{"version":3,"sources":["../webpack/bootstrap 80f084f246179088daf8","../node_modules/babylonjs/dist/preview release/babylon.max.js","../node_modules/gridbuilding/dist/gridbuilding.js","../node_modules/promise/lib/core.js","world/Brick.ts","../node_modules/react-scripts-ts/config/polyfills.js","index.tsx","../node_modules/asap/browser-raw.js","webpack:///./src/index.css?b7f4","../node_modules/object-assign/index.js","../node_modules/promise/lib/es6-extensions.js","../node_modules/promise/lib/rejection-tracking.js","config.ts","generator/index.ts","world/MaterialFactory.ts","world/Player/createCamera.ts","world/Player/index.ts","world/Player/setPlayerAction.ts","world/World/createGround.ts","world/World/createLights.ts","world/World/createScene.ts","world/World/createSkyboxMesh.ts","world/World/index.ts","../node_modules/webpack/buildin/global.js","../node_modules/whatwg-fetch/fetch.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB,sCAAsC,iBAAiB,EAAE;AAC3F,iCAAiC,uDAAuD;AACxF;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAoD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,oCAAoC,4BAA4B;AAChE,mCAAmC,4BAA4B;AAC/D,oCAAoC,4BAA4B;AAChE,oCAAoC,4BAA4B;AAChE,qCAAqC,gCAAgC;AACrE,sCAAsC,4BAA4B;AAClE,qCAAqC,4BAA4B;AACjE,mCAAmC,kCAAkC;AACrE,qCAAqC,gEAAgE;AACrG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAqE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAoD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAqE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAA8C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC,+BAA+B,SAAS;AACxC,+BAA+B,SAAS;AACxC,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAqE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iCAAiC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,8CAA8C;AACnD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,gEAAgE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAyC;AACjF;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;AACpB,wBAAwB;AACxB;AACA,0BAA0B;AAC1B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,2BAA2B;AACjE,oCAAoC,uBAAuB;AAC3D,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,mEAAmE;AACnE;AACA,wGAAwG;AACxG,mEAAmE;AACnE,4DAA4D;AAC5D;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,QAAQ;AAC5B;AACA;AACA,kCAAkC,WAAW;AAC7C,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,oBAAoB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gIAAgI;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oCAAoC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAuD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,uCAAuC;AAC5E;AACA,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA,sCAAsC,iCAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oCAAoC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gCAAgC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D,sCAAsC,eAAe;AACrD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E,+DAA+D,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oGAAoG;AACpG;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,mBAAmB,SAAS;AAC5B,mBAAmB,+BAA+B;AAClD,mBAAmB,aAAa;AAChC,mBAAmB,OAAO;AAC1B;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA,0CAA0C,uDAAuD;AACjG,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,oCAAoC,eAAe;AACnD;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA,6CAA6C;AAC7C,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2EAA2E;AAC3G;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,0CAA0C,uDAAuD;AACjG,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4CAA4C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B,0BAA0B;AAC1B,2BAA2B;AAC3B,4BAA4B;AAC5B,6BAA6B;AAC7B,4BAA4B;AAC5B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,iBAAiB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D,iEAAiE,iBAAiB;AAClF;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sCAAsC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,iDAAiD;AACjD,gDAAgD;AAChD,4CAA4C;AAC5C,wCAAwC;AACxC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,mCAAmC,EAAE;AAChG;AACA;AACA,2DAA2D,wCAAwC,EAAE;AACrG;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD,sCAAsC,cAAc;AACpD,qCAAqC,aAAa;AAClD,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH;AACpH,6GAA6G;AAC7G,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF;AACvF,uFAAuF;AACvF;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,oBAAoB;AACpB,qBAAqB;AACrB,mBAAmB;AACnB;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,6DAA6D;AACzI;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oEAAoE;AAC5G;AACA,wCAAwC,0EAA0E;AAClH;AACA,wCAAwC,iGAAiG;AACzI;AACA,wCAAwC,0EAA0E;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gDAAgD;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAyB;AAC1E,sDAAsD,iCAAiC;AACvF;AACA;AACA,wCAAwC,oFAAoF;AAC5H;AACA,wCAAwC,iFAAiF;AACzH;AACA,wCAAwC,sEAAsE;AAC9G;AACA,wCAAwC,kEAAkE;AAC1G;AACA,wCAAwC,uEAAuE;AAC/G;AACA,wCAAwC,qEAAqE;AAC7G;AACA,wCAAwC,gFAAgF;AACxH;AACA,wCAAwC,yEAAyE;AACjH;AACA,wCAAwC,yEAAyE;AACjH;AACA,wCAAwC,uFAAuF;AAC/H;AACA,wCAAwC,0FAA0F;AAClI;AACA,wCAAwC,iHAAiH;AACzJ;AACA,wCAAwC,iGAAiG;AACzI;AACA,wCAAwC,oGAAoG;AAC5I;AACA,wCAAwC,sGAAsG;AAC9I;AACA,wCAAwC,+IAA+I;AACvL;AACA,wCAAwC,+HAA+H;AACvK;AACA,wCAAwC,kIAAkI;AAC1K;AACA,wCAAwC,oIAAoI;AAC5K;AACA,wCAAwC,yEAAyE;AACjH;AACA,wCAAwC,yEAAyE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uDAAuD;AAC7H;AACA;AACA;AACA;AACA,4CAA4C,iDAAiD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,0CAA0C;AACxG,kDAAkD;AAClD;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2CAA2C;AAC9E;AACA;AACA;AACA;AACA;AACA,kEAAkE,8CAA8C;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8CAA8C;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8CAA8C;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E,oDAAoD,+BAA+B;AACnF,sDAAsD,iCAAiC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E,oDAAoD,+BAA+B;AACnF,sDAAsD,iCAAiC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAkD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2DAA2D;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kBAAkB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,wCAAwC,mBAAmB;AAC3D,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iMAAiM;AACnQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,sMAAsM,EAAE;AAC5U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,mBAAmB,mBAAmB;AACtC,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,sBAAsB;AAC1C;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,sBAAsB;AAC1C;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,oBAAoB;AACxC;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,kBAAkB;AACtC;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,mBAAmB,kBAAkB;AACrC;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,mBAAmB;AACvC;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,mBAAmB;AACvC;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,mBAAmB;AACvC;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,oBAAoB,4BAA4B;AAChD;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,sBAAsB;AAC1C;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,mBAAmB,QAAQ;AAC3B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,0BAA0B;AAC9C;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,0BAA0B;AAC9C;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,0BAA0B;AAC9C;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE,mCAAmC,0DAA0D;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+DAA+D;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0CAA0C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qDAAqD;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iCAAiC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAA6C;AAC5E;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+CAA+C;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAmD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAyC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,mCAAmC,gDAAgD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA,uBAAuB,6BAA6B;AACpD,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gCAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0CAA0C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oDAAoD,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oDAAoD,EAAE;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,6BAA6B;AAChD,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF,qCAAqC,iBAAiB;AACtD,kDAAkD,8BAA8B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,mCAAmC,cAAc;AACjD,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E,oDAAoD,+BAA+B;AACnF,sDAAsD,iCAAiC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,+BAA+B;AAC/B,iCAAiC;AACjC,2CAA2C;AAC3C;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,qCAAqC,gBAAgB;AACrD,0CAA0C,+CAA+C;AACzF,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,oCAAoC,eAAe;AACnD,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,eAAe,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+BAA+B,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,0CAA0C,+CAA+C;AACzF,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,oCAAoC,4CAA4C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kDAAkD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE,sCAAsC,kBAAkB;AACxD,qCAAqC,gBAAgB;AACrD,0CAA0C,+CAA+C;AACzF,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,oCAAoC,4CAA4C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,MAAM;AACzB,mBAAmB,KAAK;AACxB,mBAAmB,KAAK;AACxB,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,oCAAoC,eAAe;AACnD,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,KAAK;AACxB,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,oBAAoB,KAAK;AACzB;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yCAAyC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,4DAA4D;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAgD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,eAAe,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uCAAuC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E,gDAAgD,2DAA2D;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAgD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+CAA+C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+CAA+C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,yCAAyC,aAAa,WAAW;AAClI;AACA,8DAA8D,yCAAyC,aAAa,WAAW;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,+BAA+B;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,KAAK;AACxB,mBAAmB,QAAQ;AAC3B;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAA2C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAA2C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2CAA2C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iCAAiC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,4BAA4B,EAAE;AACrH;AACA,2FAA2F,4BAA4B,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA,gGAAgG,GAAG;AACnG,sDAAsD,EAAE;AACxD,qCAAqC;AACrC;AACA,kFAAkF,GAAG;AACrF;AACA;AACA;AACA;AACA;AACA,gFAAgF,GAAG;AACnF,kDAAkD,EAAE;AACpD,iCAAiC;AACjC;AACA,uEAAuE,GAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,2BAA2B;AAC9E,qDAAqD,iCAAiC;AACtF;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,6CAA6C,EAAE;AAC7G;AACA;AACA,8DAA8D,sCAAsC,EAAE;AACtG;AACA;AACA,8DAA8D,qCAAqC,EAAE;AACrG;AACA;AACA,8DAA8D,mCAAmC,EAAE;AACnG;AACA;AACA,8DAA8D,wCAAwC,EAAE;AACxG;AACA;AACA,8DAA8D,kCAAkC,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iDAAiD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,sBAAsB;AACzC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,oCAAoC;AACpC,oCAAoC;AACpC,sBAAsB;AACtB,wBAAwB;AACxB,yBAAyB;AACzB,kBAAkB;AAClB,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,uBAAuB;AACvB,+BAA+B;AAC/B,mCAAmC;AACnC,0CAA0C;AAC1C,uCAAuC;AACvC,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sCAAsC;AAC7E;AACA;AACA,2CAA2C,sCAAsC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,wDAAwD;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA,uBAAuB,kBAAkB;AACzC,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB;AAChD,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0BAA0B;AACvD,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD,6BAA6B,4BAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,oCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,iDAAiD;AACjD;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB,mBAAmB,IAAI;AACvB,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,kCAAkC;AAClC,kCAAkC;AAClC,kCAAkC;AAClC,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,oCAAoC;AACpC,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2CAA2C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gDAAgD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4CAA4C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qIAAqI;AACjM;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,8CAA8C;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+EAA+E;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mFAAmF;AAC7I;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,wLAAwL;AACtP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kHAAkH;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,0EAA0E;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iIAAiI;AAClM;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8CAA8C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qKAAqK;AACpO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS,+DAA+D;AACxE,KAAK,uDAAuD;AAC5D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qDAAqD,EAAE;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iDAAiD,EAAE;AACrH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gDAAgD,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,4CAA4C,EAAE;AAChH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iEAAiE,EAAE;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,6DAA6D,EAAE;AACjI;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kEAAkE,EAAE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8DAA8D,EAAE;AAClI;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,wBAAwB,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,wBAAwB,EAAE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sBAAsB,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,0BAA0B;AACzE,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA,0BAA0B,mEAAmE;AAC7F;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAyC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB,GAAG,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA,mCAAmC,4CAA4C;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2CAA2C;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,qCAAqC,eAAe;AACpD,2CAA2C,uBAAuB;AAClE,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,kBAAkB;AAC5D,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC,gCAAgC,QAAQ;AACxC,gCAAgC,QAAQ;AACxC,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,mCAAmC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD;AACtE,qBAAqB,2EAA2E;AAChG,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,QAAQ;AAC5B;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,QAAQ;AAC5B;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,uBAAuB,oBAAoB;AAC3C;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wDAAwD;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD;AACtE,qBAAqB,2EAA2E;AAChG,qBAAqB,iFAAiF;AACtG,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD;AACtE,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAiD;AACtE,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yCAAyC;AAC9D,qBAAqB,qCAAqC;AAC1D,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4CAA4C,uDAAuD;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAyC;AACvE,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAyC;AACvE,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E,gDAAgD,2BAA2B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C;AACA;AACA,kCAAkC;AAClC,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE,kHAAkH;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mCAAmC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yEAAyE;AAC9E;AACA;AACA;AACA;AACA,KAAK,4EAA4E;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wLAAwL,iCAAiC;AACzN;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,8EAA8E;AAC9E,8EAA8E;AAC9E,oFAAoF;AACpF,sFAAsF;AACtF,sFAAsF;AACtF;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAyD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,gEAAgE;AAChE,mDAAmD;AACnD,mDAAmD;AACnD,iDAAiD;AACjD,+DAA+D;AAC/D,mDAAmD;AACnD,8BAA8B;AAC9B,kCAAkC;AAClC,0BAA0B;AAC1B,6BAA6B;AAC7B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,6BAA6B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,iCAAiC,4BAA4B;AAC7D,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,2BAA2B;AAC3B,+BAA+B;AAC/B,0BAA0B;AAC1B,4BAA4B;AAC5B,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,iCAAiC,qBAAqB;AACtD,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,uBAAuB;AACvB;AACA;AACA;AACA,6BAA6B,qBAAqB;AAClD,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2CAA2C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uCAAuC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,kFAAkF,EAAE;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8HAA8H;AAC9H;AACA;AACA;AACA;AACA;AACA,oCAAoC,UAAU;AAC9C,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oFAAoF;AAChJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,UAAU,EAAE;AACnF,6EAA6E,UAAU,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yKAAyK;AACjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,yCAAyC,aAAa,WAAW;AAClI;AACA,8DAA8D,yCAAyC,aAAa,WAAW;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD,+DAA+D;AAC/D,yCAAyC;AACzC,wCAAwC;AACxC,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,2CAA2C;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,6LAA6L;AACpP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,8JAA8J;AAChO;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,0BAA0B,EAAE;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB,gGAAgG,EAAE;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,kBAAkB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kBAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,+DAA+D;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,oCAAoC,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD,oCAAoC,4CAA4C;AAChF,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4CAA4C,kDAAkD;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF,kCAAkC,gDAAgD;AAClF,oCAAoC,gBAAgB;AACpD,0CAA0C,uDAAuD;AACjG,iDAAiD,4BAA4B;AAC7E,mDAAmD,+BAA+B;AAClF,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wCAAwC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8CAA8C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,4BAA4B;AAC7E,oDAAoD,+BAA+B;AACnF,sDAAsD,iCAAiC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gDAAgD;AAClF,0CAA0C,sDAAsD;AAChG,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAuD;AACjG,oCAAoC,4CAA4C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,cAAc;AACjC,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,OAAO;AAC1B;AACA;AACA,6CAA6C,yBAAyB;AACtE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,qCAAqC,iBAAiB;AACtD,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,qDAAqD;AAC/F,yCAAyC,uDAAuD;AAChG,uCAAuC,2BAA2B;AAClE,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,uDAAuD;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kKAAkK,gDAAgD,EAAE;AACpN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yCAAyC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAqD;AACxF;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D,wDAAwD,sCAAsC;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wBAAwB,kCAAkC,4BAA4B,oCAAoC,mBAAmB,kCAAkC,wBAAwB,0BAA0B,4BAA4B,4BAA4B,mBAAmB;AACnW;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,+BAA+B;AAChJ;AACA;AACA,mHAAmH,qBAAqB;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,+BAA+B;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,eAAe;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,eAAe;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,eAAe;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,eAAe;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,eAAe;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,eAAe;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,eAAe;AAClG;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA,uDAAuD,iDAAiD;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yDAAyD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,eAAe,EAAE;AACpG,kFAAkF,eAAe,EAAE;AACnG,8EAA8E,eAAe,EAAE;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB,EAAE;AACzF,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,0CAA0C,EAAE;AACjI;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,WAAW,EAAE;AACrE;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,sBAAsB;AAC1G,wFAAwF,sBAAsB;AAC9G,wFAAwF,wBAAwB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,oBAAoB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,oBAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI,wCAAwC,EAAE;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qCAAqC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,mCAAmC;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oCAAoC,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oCAAoC,EAAE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,8BAA8B,EAAE;AAC9F;AACA;AACA,iEAAiE,8BAA8B,EAAE;AACjG;AACA;AACA,oEAAoE,8BAA8B,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wCAAwC,gBAAgB;AACxD,wCAAwC,gBAAgB;AACxD,yCAAyC,iBAAiB;AAC1D,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC;AAClC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sEAAsE;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gEAAgE;AACrE;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0GAA0G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uEAAuE,8DAA8D;AACrI;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,+BAA+B,+CAA+C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,8NAA8N,6HAA6H,EAAE;AAC7V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,8NAA8N,6HAA6H,EAAE;AAC7V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,mEAAmE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uKAAuK,gDAAgD,EAAE;AACzN;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC,mBAAmB,IAAI,gHAAgH;AACvI,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,wCAAwC,EAAE;AAC9K,wHAAwH,+BAA+B,EAAE;AACzJ,6HAA6H,gCAAgC,EAAE;AAC/J,6HAA6H,gCAAgC,EAAE;AAC/J,+HAA+H,sCAAsC,EAAE;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC,mBAAmB,IAAI,gHAAgH;AACvI,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,wCAAwC,EAAE;AAC9K,wHAAwH,+BAA+B,EAAE;AACzJ,6HAA6H,gCAAgC,EAAE;AAC/J,6HAA6H,gCAAgC,EAAE;AAC/J,+HAA+H,sCAAsC,EAAE;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D,uCAAuC;AAClG,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,kCAAkC;AAClC,mCAAmC;AACnC,qCAAqC;AACrC,+CAA+C,wCAAwC;AACvF,2CAA2C,2CAA2C;AACtF,qCAAqC;AACrC,mCAAmC;AACnC,sCAAsC;AACtC,iCAAiC,sDAAsD;AACvF,sCAAsC;AACtC,oCAAoC;AACpC;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC,mBAAmB,OAAO;AAC1B,mBAAmB,iBAAiB;AACpC;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qIAAqI,8CAA8C,EAAE;AACrL,iIAAiI,qCAAqC,EAAE;AACxK,8HAA8H,uCAAuC,EAAE;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,yBAAyB;AAClG,uEAAuE,oBAAoB;AAC3F,4EAA4E,4BAA4B;AACxG,oEAAoE,uBAAuB;AAC3F,oFAAoF,oCAAoC;AACxH,kFAAkF,+BAA+B;AACjH,+EAA+E,2BAA2B;AAC1G,6EAA6E,sBAAsB;AACnG,8EAA8E,4BAA4B;AAC1G,2EAA2E,wBAAwB;AACnG,yEAAyE,4BAA4B;AACrG,iFAAiF,0BAA0B;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,wBAAwB;AAC/F,wEAAwE,yBAAyB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC,mBAAmB,IAAI;AACvB,mBAAmB,oBAAoB;AACvC,mBAAmB,iBAAiB;AACpC;AACA;AACA,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qHAAqH,kCAAkC,EAAE;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,8CAA8C,EAAE;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gIAAgI,2CAA2C,EAAE;AAC7K;AACA;AACA;AACA;AACA;AACA;AACA,yIAAyI,wCAAwC,EAAE;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,kCAAkC,EAAE;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,sCAAsC,EAAE;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,oCAAoC,EAAE;AACtJ;AACA;AACA;AACA;AACA,0CAA0C,4BAA4B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,oHAAoH,cAAc,EAAE;AACpI,oHAAoH,cAAc,EAAE;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,sCAAsC,EAAE;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,yCAAyC,EAAE;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,6CAA6C,EAAE;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA,iHAAiH,4BAA4B;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,mCAAmC,EAAE;AACpJ;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA;AACA;AACA,6IAA6I,4BAA4B;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI,WAAW,EAAE;AACnJ,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG,6BAA6B,EAAE;AACrI;AACA;AACA;AACA;AACA;AACA,+GAA+G,mCAAmC,EAAE;AACpJ;AACA;AACA,sHAAsH,0CAA0C,EAAE;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,sCAAsC,EAAE;AAC1J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,oCAAoC,EAAE;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAkD;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oCAAoC;AACnE;AACA;AACA,+BAA+B,oCAAoC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0EAA0E,EAAE;AAC9I;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,cAAc;AACjC,mBAAmB,IAAI;AACvB,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,mBAAmB,EAAE;AACrI;AACA;AACA,0HAA0H,yBAAyB,EAAE;AACrJ;AACA;AACA;AACA;AACA,iHAAiH,oBAAoB,EAAE;AACvI;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iHAAiH,oBAAoB,EAAE;AACvI;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oHAAoH,uBAAuB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+HAA+H,8BAA8B,EAAE;AAC/J;AACA;AACA;AACA;AACA,gHAAgH,mBAAmB,EAAE;AACrI;AACA;AACA;AACA;AACA,sHAAsH,yBAAyB,EAAE;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,6EAA6E,EAAE;AACjJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,+FAA+F,uBAAuB,qDAAqD;AAC3P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uKAAuK,gDAAgD,EAAE;AACzN;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,IAAI;AACvB,mBAAmB,eAAe;AAClC,mBAAmB,aAAa;AAChC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B,mBAAmB,cAAc;AACjC;AACA;AACA,qCAAqC,eAAe;AACpD,0CAA0C,sDAAsD;AAChG;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,2EAA2E;AAC3K;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,mFAAmF;AACrM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8LAA8L,yCAAyC,EAAE;AACzO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,kBAAkB,cAAc;AAChC,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wFAAwF;AAC7F;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG,2CAA2C,yDAAyD;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uDAAuD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG,yCAAyC,uDAAuD;AAChG,+KAA+K,+BAA+B;AAC9M;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,+BAA+B;AAC/E,gDAAgD,uCAAuC;AACvF;AACA;AACA,gDAAgD,mCAAmC;AACnF,gDAAgD,oCAAoC;AACpF;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gBAAgB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,oDAAoD,+BAA+B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E,iDAAiD,4BAA4B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,aAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8CAA8C;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,mBAAmB,OAAO;AAC1B;AACA;AACA,8DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2CAA2C;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oCAAoC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,+CAA+C,0BAA0B;AACzE,6CAA6C,yBAAyB;AACtE,+CAA+C,2BAA2B;AAC1E,oCAAoC,eAAe;AACnD,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2CAA2C;AAC1F,uBAAuB,iBAAiB;AACxC,2BAA2B,oBAAoB;AAC/C,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB;;AAEzB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC,gCAAgC,QAAQ;AACxC,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,sBAAsB,EAAE;AACpH;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB,EAAE;AAC/E;AACA;AACA;AACA,sDAAsD,UAAU,EAAE;AAClE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,kBAAkB,EAAE;AAChF;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D,gHAAgH,QAAQ;AACxH;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sFAAsF;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0RAA0R,iDAAiD;AAC3U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,yHAAyH;AACnL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6CAA6C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,WAAW;AAC9B;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,WAAW;AAC9B;AACA;AACA,wCAAwC,gBAAgB;AACxD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,aAAa,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sDAAsD;AACxG;AACA;AACA;AACA,iEAAiE,sDAAsD;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,+CAA+C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,gBAAgB;AACnC,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B;AACjF,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAsC;AAC9E,6CAA6C,iCAAiC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,2CAA2C;AAC3C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,uBAAuB,OAAO;AAC9B,uBAAuB,QAAQ;AAC/B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,mGAAmG;AACnG,iGAAiG;AACjG,yGAAyG;AACzG,6GAA6G;AAC7G,mGAAmG;AACnG,oGAAoG;AACpG,mGAAmG;AACnG,8GAA8G;AAC9G,wGAAwG;AACxG,+GAA+G,qBAAqB;AACpI,8GAA8G;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,uFAAuF;AACvF,sCAAsC,2BAA2B;AACjE;AACA;AACA;AACA,oDAAoD;AACpD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,2DAA2D;AAC3D;AACA,kDAAkD;AAClD,kDAAkD;AAClD,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,4BAA4B,EAAE;AACnG,mEAAmE,4BAA4B,EAAE;AACjG;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,iEAAiE,4BAA4B,EAAE;AAC/F;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,sCAAsC,EAAE;AAChG;AACA;AACA,wDAAwD,sCAAsC,EAAE;AAChG;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B,EAAE;AACjF;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gCAAgC;AACzF,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,2CAA2C;AAC7H;AACA;AACA;AACA,gEAAgE,sEAAsE;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,8CAA8C;AACnD,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,8CAA8C;AACnD,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,gBAAgB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,8CAA8C;AACnD,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,UAAU;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,8CAA8C;AACnD,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+CAA+C;AAC5F,4CAA4C,6CAA6C;AACzF,6CAA6C,+CAA+C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B,EAAE;AAC9F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4BAA4B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC,+BAA+B,OAAO;AACtC,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAA4B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,gEAAgE;AAChE;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,gEAAgE;AAChE;AACA,sFAAsF;AACtF,4DAA4D;AAC5D,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,gEAAgE;AAChE;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA,mFAAmF;AACnF,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,kBAAkB,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2GAA2G;AAClL;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,+BAA+B,EAAE;AAC1H;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,oCAAoC,cAAc;AAClD;AACA,mJAAmJ;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAA8B,EAAE;AACnF;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E,6CAA6C,wDAAwD;AACrG;AACA;AACA,gEAAgE,mCAAmC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E,6CAA6C,wDAAwD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kDAAkD,6BAA6B;AAC/E,6CAA6C,wDAAwD;AACrG;AACA;AACA,gEAAgE,mCAAmC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,yCAAyC;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,yCAAyC;AACnN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,yCAAyC;AACnN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,yCAAyC;AACnN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0KAA0K,yCAAyC;AACnN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mEAAmE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,aAAa;AACb,+CAA+C,8BAA8B,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iEAAiE;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,+CAA+C,8BAA8B,EAAE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,qFAAqF;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA+I,0DAA0D,EAAE;AAC3M,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,uBAAuB,yBAAyB;AAChD,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,0DAA0D;AAC/D,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD,yCAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sCAAsC,cAAc;AACpD,0CAA0C,kBAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,6CAA6C,sBAAsB;AACnE,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAsC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8JAA8J,yCAAyC,EAAE;AACzM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD,2DAA2D,uCAAuC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA,gDAAgD,iCAAiC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sDAAsD;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uKAAuK,gBAAgB;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wLAAwL,iEAAiE,EAAE;AAC3P;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,+CAA+C,0BAA0B;AACzE,6CAA6C,yBAAyB;AACtE,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAuD;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB;AACxD,+CAA+C,0BAA0B;AACzE,6CAA6C,yBAAyB;AACtE,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAuD;AACjG,uCAAuC,mBAAmB;AAC1D,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,kFAAkF;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2CAA2C,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,2CAA2C,EAAE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,sCAAsC,EAAE;AACpH;AACA;AACA;AACA;AACA;AACA,iFAAiF,sCAAsC,EAAE;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qCAAqC;AAChE;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sCAAsC;AACjE;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC;AAClE;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA,qCAAqC,6CAA6C;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB;AAC9D,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,0BAA0B;;AAE3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,wBAAwB;AACrE,iFAAiF,+BAA+B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iEAAiE;AACjE;AACA,CAAC,0BAA0B;;AAE3B;;AAEA,6BAA6B,kFAAkF,uCAAuC,iDAAiD,wCAAwC,yCAAyC,mDAAmD,8GAA8G,gDAAgD,gFAAgF,gFAAgF,gFAAgF,mFAAmF,mFAAmF,4GAA4G,uEAAuE,oCAAoC,uCAAuC,kDAAkD,2VAA2V,6IAA6I,0DAA0D,gCAAgC,4CAA4C,sDAAsD,kIAAkI,6HAA6H,qDAAqD,4BAA4B,8EAA8E,sLAAsL,6CAA6C,4CAA4C,sCAAsC,uCAAuC,qFAAqF,kDAAkD,GAAG,SAAS,mDAAmD,GAAG,qFAAqF,kDAAkD,GAAG,SAAS,mDAAmD,GAAG,qFAAqF,kDAAkD,GAAG,SAAS,mDAAmD,GAAG,wFAAwF,oDAAoD,GAAG,SAAS,qDAAqD,GAAG,wFAAwF,oDAAoD,GAAG,SAAS,qDAAqD,GAAG,iHAAiH,oDAAoD,GAAG,SAAS,qDAAqD,GAAG,4EAA4E,4CAA4C,GAAG,SAAS,6CAA6C,GAAG,sKAAsK,iEAAiE,wQAAwQ,6BAA6B,4BAA4B,uCAAuC,kDAAkD,gDAAgD,gDAAgD,4UAA4U,2CAA2C,yKAAyK,2CAA2C,0KAA0K,2CAA2C,+KAA+K,4CAA4C,+KAA+K,4CAA4C,gGAAgG,+CAA+C,sNAAsN,4CAA4C,+HAA+H,+CAA+C,iEAAiE,4IAA4I,6RAA6R,sFAAsF,qCAAqC,sCAAsC,gCAAgC,oDAAoD,wCAAwC,uGAAuG,kFAAkF,kDAAkD,sDAAsD,yCAAyC,wDAAwD,iDAAiD,qGAAqG,mEAAmE,wCAAwC,yFAAyF,qCAAqC,8DAA8D,6CAA6C,4CAA4C,oBAAoB,wDAAwD,0BAA0B,2GAA2G,mGAAmG,0GAA0G,oFAAoF,kDAAkD,6FAA6F,GAAG,oHAAoH,2DAA2D,4CAA4C,yFAAyF,wDAAwD,+FAA+F,2EAA2E,0FAA0F,wHAAwH,kGAAkG,+CAA+C,4DAA4D,gCAAgC,+EAA+E,wJAAwJ,2KAA2K,6HAA6H,qIAAqI,wKAAwK,sHAAsH,wFAAwF,uEAAuE,mEAAmE,6CAA6C,sDAAsD,mIAAmI,mFAAmF,8CAA8C,uGAAuG,gJAAgJ,4GAA4G,8IAA8I,sGAAsG,iIAAiI,+IAA+I,6GAA6G,qFAAqF,4FAA4F,8CAA8C,wGAAwG,2KAA2K,4GAA4G,+GAA+G,kCAAkC,uJAAuJ,oEAAoE,oCAAoC,qCAAqC,GAAG,2CAA2C,yDAAyD,uCAAuC,iDAAiD,wCAAwC,yCAAyC,gDAAgD,gDAAgD,qDAAqD,2IAA2I,gFAAgF,gFAAgF,mFAAmF,mFAAmF,+FAA+F,4GAA4G,uEAAuE,oCAAoC,uCAAuC,sHAAsH,wFAAwF,2VAA2V,6IAA6I,0DAA0D,gCAAgC,2CAA2C,sDAAsD,kIAAkI,6HAA6H,qDAAqD,4BAA4B,8EAA8E,oJAAoJ,2DAA2D,8EAA8E,8LAA8L,6CAA6C,4CAA4C,sCAAsC,wCAAwC,oFAAoF,gDAAgD,GAAG,SAAS,iDAAiD,GAAG,sFAAsF,kDAAkD,GAAG,SAAS,mDAAmD,GAAG,sFAAsF,kDAAkD,GAAG,SAAS,mDAAmD,GAAG,yFAAyF,oDAAoD,GAAG,SAAS,qDAAqD,GAAG,yFAAyF,oDAAoD,GAAG,SAAS,qDAAqD,GAAG,qGAAqG,4DAA4D,GAAG,SAAS,6DAA6D,GAAG,kHAAkH,0EAA0E,GAAG,SAAS,2EAA2E,GAAG,6EAA6E,4CAA4C,GAAG,SAAS,6CAA6C,GAAG,8KAA8K,qDAAqD,uCAAuC,qSAAqS,2DAA2D,6BAA6B,4BAA4B,4BAA4B,wCAAwC,kDAAkD,iDAAiD,sHAAsH,0DAA0D,kOAAkO,0CAA0C,yKAAyK,2CAA2C,yKAAyK,2CAA2C,+KAA+K,4CAA4C,+KAA+K,4CAA4C,uMAAuM,gDAAgD,qOAAqO,gDAAgD,8IAA8I,4IAA4I,4CAA4C,mGAAmG,0IAA0I,4CAA4C,8JAA8J,4IAA4I,4CAA4C,mGAAmG,0IAA0I,4CAA4C,yEAAyE,4IAA4I,yHAAyH,6DAA6D,qYAAqY,0FAA0F,kDAAkD,0EAA0E,oDAAoD,iIAAiI,oFAAoF,0DAA0D,+BAA+B,gFAAgF,6EAA6E,0DAA0D,gCAAgC,0FAA0F,wDAAwD,6BAA6B,iCAAiC,8CAA8C,sIAAsI,kCAAkC,wEAAwE,sDAAsD,kHAAkH,6IAA6I,oGAAoG,oDAAoD,uDAAuD,8EAA8E,4GAA4G,0IAA0I,0FAA0F,+FAA+F,wDAAwD,+FAA+F,8FAA8F,oKAAoK,2CAA2C,iDAAiD,iCAAiC,2EAA2E,qHAAqH,qGAAqG,uHAAuH,2EAA2E,iDAAiD,sFAAsF,qCAAqC,uHAAuH,oJAAoJ,oCAAoC,2EAA2E,oCAAoC,6DAA6D,qDAAqD,sDAAsD,kEAAkE,gIAAgI,wDAAwD,kCAAkC,+EAA+E,kDAAkD,yDAAyD,iEAAiE,4EAA4E,2DAA2D,8FAA8F,yCAAyC,mEAAmE,oHAAoH,2DAA2D,4CAA4C,kIAAkI,yFAAyF,mIAAmI,iJAAiJ,yEAAyE,oDAAoD,mHAAmH,uGAAuG,mEAAmE,yFAAyF,yCAAyC,0JAA0J,GAAG,KAAK,6JAA6J,GAAG,iGAAiG,sDAAsD,uEAAuE,4CAA4C,8EAA8E,2DAA2D,4EAA4E,mDAAmD,wEAAwE,oDAAoD,0KAA0K,wFAAwF,mIAAmI,iJAAiJ,yEAAyE,oDAAoD,iHAAiH,uGAAuG,mEAAmE,uFAAuF,yCAAyC,sJAAsJ,GAAG,KAAK,yJAAyJ,GAAG,6FAA6F,wJAAwJ,4EAA4E,4DAA4D,4CAA4C,8CAA8C,6HAA6H,6DAA6D,0DAA0D,8DAA8D,oCAAoC,wDAAwD,mHAAmH,4BAA4B,kBAAkB,mBAAmB,kKAAkK,yEAAyE,gGAAgG,6EAA6E,qEAAqE,mFAAmF,sCAAsC,wGAAwG,sCAAsC,mKAAmK,kEAAkE,sCAAsC,mEAAmE,qCAAqC,uEAAuE,kDAAkD,yBAAyB,iCAAiC,gCAAgC,cAAc,gIAAgI,gHAAgH,qDAAqD,6BAA6B,uEAAuE,kCAAkC,kCAAkC,kCAAkC,qCAAqC,kEAAkE,qCAAqC,iEAAiE,0CAA0C,uCAAuC,qFAAqF,sEAAsE,gDAAgD,gEAAgE,0EAA0E,+BAA+B,8CAA8C,6FAA6F,qDAAqD,kCAAkC,4DAA4D,+GAA+G,yHAAyH,uIAAuI,8ZAA8Z,4GAA4G,uCAAuC,2DAA2D,2JAA2J,uDAAuD,kEAAkE,kCAAkC,yEAAyE,mDAAmD,yBAAyB,0BAA0B,uBAAuB,8BAA8B,oBAAoB,0BAA0B,qBAAqB,sBAAsB,mDAAmD,kDAAkD,kBAAkB,yBAAyB,sCAAsC,yBAAyB,+BAA+B,iDAAiD,uBAAuB,gEAAgE,gEAAgE,qBAAqB,2BAA2B,2CAA2C,kBAAkB,8EAA8E,qCAAqC,qCAAqC,WAAW,+CAA+C,sBAAsB,qBAAqB,mCAAmC,uDAAuD,2CAA2C,oBAAoB,6BAA6B,GAAG,gBAAgB,4CAA4C,GAAG,qDAAqD,uBAAuB,yBAAyB,sBAAsB,0BAA0B,qBAAqB,sBAAsB,4CAA4C,uBAAuB,8BAA8B,2BAA2B,8CAA8C,kBAAkB,uBAAuB,wBAAwB,yBAAyB,oDAAoD,uBAAuB,gEAAgE,gEAAgE,qBAAqB,2BAA2B,2CAA2C,gBAAgB,aAAa,8DAA8D,yCAAyC,WAAW,6CAA6C,sBAAsB,2BAA2B,mCAAmC,gDAAgD,2BAA2B,oDAAoD,uDAAuD,8EAA8E,GAAG,iDAAiD,2CAA2C,oEAAoE,qBAAqB,4CAA4C,2BAA2B,wBAAwB,kFAAkF,qCAAqC,WAAW,8DAA8D,4BAA4B,2BAA2B,0CAA0C,4BAA4B,WAAW,uDAAuD,qBAAqB,qBAAqB,gCAAgC,mBAAmB,kCAAkC,qCAAqC,GAAG,wCAAwC,mCAAmC,qBAAqB,6CAA6C,GAAG,qDAAqD,4FAA4F,4BAA4B,2BAA2B,6BAA6B,qCAAqC,6BAA6B,gCAAgC,yCAAyC,oCAAoC,gGAAgG,sCAAsC,8EAA8E,yEAAyE,gEAAgE,mBAAmB,kEAAkE,qEAAqE,8DAA8D,kCAAkC,yBAAyB,aAAa,GAAG,qCAAqC,qCAAqC,mCAAmC,oCAAoC,2BAA2B,oBAAoB,sEAAsE,mCAAmC,qEAAqE,6DAA6D,kCAAkC,WAAW,gDAAgD,mCAAmC,4BAA4B,oBAAoB,4BAA4B,qBAAqB,WAAW,0BAA0B,WAAW,sEAAsE,6DAA6D,GAAG,sDAAsD,2BAA2B,mBAAmB,gCAAgC,mBAAmB,sBAAsB,yBAAyB,qCAAqC,GAAG,iDAAiD,4FAA4F,2BAA2B,+DAA+D,6BAA6B,gCAAgC,yCAAyC,6CAA6C,oBAAoB,6GAA6G,+DAA+D,wGAAwG,gEAAgE,mBAAmB,yDAAyD,mCAAmC,qCAAqC,oBAAoB,sEAAsE,4EAA4E,GAAG,wDAAwD,mBAAmB,+CAA+C,iCAAiC,8BAA8B,qCAAqC,8BAA8B,uBAAuB,qBAAqB,wBAAwB,qBAAqB,kDAAkD,gCAAgC,gCAAgC,0DAA0D,0DAA0D,qCAAqC,qCAAqC,2BAA2B,qBAAqB,2BAA2B,GAAG,gBAAgB,2EAA2E,8CAA8C,gCAAgC,yCAAyC,iCAAiC,sBAAsB,WAAW,eAAe,uBAAuB,mBAAmB,eAAe,WAAW,QAAQ,kDAAkD,6CAA6C,mGAAmG,kCAAkC,gFAAgF,GAAG,qDAAqD,sCAAsC,wBAAwB,wBAAwB,wBAAwB,qBAAqB,GAAG,gEAAgE,wBAAwB,wCAAwC,gBAAgB,8BAA8B,mDAAmD,mBAAmB,sBAAsB,eAAe,WAAW,QAAQ,mFAAmF,iEAAiE,0CAA0C,wDAAwD,4DAA4D,uDAAuD,oBAAoB,GAAG,oBAAoB,gCAAgC,qBAAqB,GAAG,wDAAwD,mCAAmC,qBAAqB,oBAAoB,uBAAuB,mBAAmB,mGAAmG,oDAAoD,GAAG,gGAAgG,4CAA4C,GAAG,iGAAiG,qCAAqC,GAAG,+CAA+C,kCAAkC,iCAAiC,8BAA8B,qCAAqC,8BAA8B,qBAAqB,0BAA0B,0BAA0B,qBAAqB,2BAA2B,yBAAyB,0BAA0B,gBAAgB,gEAAgE,iDAAiD,+CAA+C,uBAAuB,0DAA0D,8EAA8E,6BAA6B,2BAA2B,aAAa,uDAAuD,uCAAuC,0CAA0C,mBAAmB,mBAAmB,qCAAqC,SAAS,GAAG,eAAe,WAAW,OAAO,4CAA4C,uDAAuD,yCAAyC,2BAA2B,uBAAuB,8BAA8B,qEAAqE,WAAW,GAAG,+DAA+D,wEAAwE,0CAA0C,yDAAyD,GAAG,uDAAuD,sCAAsC,sCAAsC,GAAG,gEAAgE,wBAAwB,wCAAwC,uEAAuE,uBAAuB,yCAAyC,yCAAyC,0CAA0C,4DAA4D,4DAA4D,4DAA4D,4DAA4D,eAAe,GAAG,wEAAwE,uBAAuB,8CAA8C,+CAA+C,8CAA8C,gDAAgD,kEAAkE,kEAAkE,mEAAmE,mEAAmE,oEAAoE,oEAAoE,eAAe,GAAG,iFAAiF,uBAAuB,8CAA8C,+CAA+C,8CAA8C,uDAAuD,oBAAoB,eAAe,uBAAuB,kCAAkC,kEAAkE,oEAAoE,oBAAoB,sDAAsD,kEAAkE,oEAAoE,oBAAoB,sDAAsD,kEAAkE,oEAAoE,oBAAoB,sDAAsD,kEAAkE,oEAAoE,oBAAoB,sDAAsD,kEAAkE,oEAAoE,oBAAoB,sDAAsD,kEAAkE,oEAAoE,oBAAoB,sDAAsD,yBAAyB,GAAG,gBAAgB,uEAAuE,8BAA8B,mBAAmB,sBAAsB,eAAe,WAAW,QAAQ,wDAAwD,0DAA0D,sCAAsC,0DAA0D,0CAA0C,6DAA6D,6EAA6E,uDAAuD,oBAAoB,GAAG,oBAAoB,gCAAgC,qBAAqB,oBAAoB,wDAAwD,8DAA8D,sCAAsC,8DAA8D,yCAAyC,qBAAqB,WAAW,uEAAuE,kCAAkC,mBAAmB,mBAAmB,+CAA+C,+CAA+C,oCAAoC,GAAG,yEAAyE,wCAAwC,6BAA6B,8BAA8B,qBAAqB,oBAAoB,qDAAqD,0GAA0G,6BAA6B,8CAA8C,iCAAiC,wCAAwC,iEAAiE,kEAAkE,8FAA8F,4FAA4F,4FAA4F,sDAAsD,sDAAsD,sDAAsD,GAAG,wBAAwB,GAAG,kEAAkE,wBAAwB,0BAA0B,6BAA6B,8BAA8B,qBAAqB,qCAAqC,uBAAuB,gEAAgE,sBAAsB,sBAAsB,mCAAmC,EAAE,QAAQ,kCAAkC,EAAE,+EAA+E,4BAA4B,kBAAkB,mBAAmB,GAAG,oBAAoB,8CAA8C,uBAAuB,qCAAqC,SAAS,GAAG,2BAA2B,4BAA4B,mBAAmB,uCAAuC,+FAA+F,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,qFAAqF,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,+EAA+E,8EAA8E,8EAA8E,+EAA+E,6EAA6E,8EAA8E,8EAA8E,6EAA6E,+EAA+E,8EAA8E,wBAAwB,uBAAuB,KAAK,wEAAwE,sCAAsC,iCAAiC,iCAAiC,+BAA+B,0BAA0B,6BAA6B,8BAA8B,2BAA2B,2BAA2B,kCAAkC,0BAA0B,uBAAuB,0BAA0B,0BAA0B,uBAAuB,oBAAoB,qBAAqB,mHAAmH,wBAAwB,gBAAgB,eAAe,yBAAyB,qEAAqE,yEAAyE,4CAA4C,GAAG,0CAA0C,0BAA0B,eAAe,EAAE,oDAAoD,iCAAiC,4CAA4C,4CAA4C,mDAAmD,kDAAkD,qBAAqB,GAAG,qFAAqF,iCAAiC,yCAAyC,gGAAgG,iDAAiD,gBAAgB,GAAG,oCAAoC,iCAAiC,GAAG,mCAAmC,sDAAsD,oBAAoB,YAAY,EAAE,0CAA0C,8BAA8B,+BAA+B,yBAAyB,qBAAqB,4DAA4D,4DAA4D,2DAA2D,6DAA6D,4DAA4D,4DAA4D,6DAA6D,2DAA2D,4DAA4D,4DAA4D,uBAAuB,2DAA2D,6DAA6D,2DAA2D,4DAA4D,4DAA4D,2DAA2D,6DAA6D,4DAA4D,4DAA4D,6DAA6D,GAAG,uBAAuB,2DAA2D,4DAA4D,4DAA4D,2DAA2D,6DAA6D,4DAA4D,4DAA4D,6DAA6D,2DAA2D,GAAG,oBAAoB,sBAAsB,+CAA+C,GAAG,qBAAqB,GAAG,oBAAoB,kDAAkD,kGAAkG,uBAAuB,2CAA2C,mEAAmE,0DAA0D,wCAAwC,4CAA4C,yFAAyF,2CAA2C,SAAS,EAAE,+BAA+B,sBAAsB,0EAA0E,GAAG,gDAAgD,6BAA6B,0DAA0D,GAAG,QAAQ,+CAA+C,qBAAqB,yFAAyF,GAAG,mBAAmB,uDAAuD,iFAAiF,8EAA8E,GAAG,GAAG,2BAA2B,+DAA+D,6DAA6D,GAAG,GAAG,4DAA4D,mBAAmB,oDAAoD,2CAA2C,qBAAqB,GAAG,kEAAkE,oBAAoB,qCAAqC,qDAAqD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,uDAAuD,uDAAuD,uDAAuD,gBAAgB,uBAAuB,GAAG,8DAA8D,gCAAgC,oBAAoB,qCAAqC,4EAA4E,6EAA6E,6EAA6E,6EAA6E,gBAAgB,sCAAsC,kCAAkC,gCAAgC,GAAG,uBAAuB,GAAG,qEAAqE,gCAAgC,yBAAyB,oBAAoB,gDAAgD,mBAAmB,6CAA6C,qDAAqD,2BAA2B,gDAAgD,mEAAmE,0BAA0B,GAAG,4GAA4G,0BAA0B,8BAA8B,4BAA4B,wBAAwB,2BAA2B,sCAAsC,gCAAgC,qCAAqC,oCAAoC,gDAAgD,+DAA+D,qHAAqH,gBAAgB,GAAG,oBAAoB,qDAAqD,oCAAoC,wCAAwC,oCAAoC,wCAAwC,sCAAsC,qCAAqC,qCAAqC,0BAA0B,eAAe,iBAAiB,QAAQ,+EAA+E,+EAA+E,oDAAoD,2DAA2D,0EAA0E,iFAAiF,6GAA6G,yBAAyB,GAAG,qBAAqB,sCAAsC,2CAA2C,GAAG,mEAAmE,oBAAoB,4EAA4E,GAAG,6DAA6D,gBAAgB,oBAAoB,uBAAuB,sBAAsB,sCAAsC,eAAe,KAAK,QAAQ,qDAAqD,wDAAwD,mEAAmE,+EAA+E,0HAA0H,8DAA8D,yCAAyC,sCAAsC,GAAG,uBAAuB,6CAA6C,GAAG,wEAAwE,kCAAkC,qDAAqD,qEAAqE,8DAA8D,kCAAkC,yBAAyB,aAAa,GAAG,wBAAwB,uBAAuB,oBAAoB,eAAe,KAAK,QAAQ,6FAA6F,mBAAmB,GAAG,eAAe,wDAAwD,oDAAoD,WAAW,kEAAkE,iCAAiC,gBAAgB,gDAAgD,4CAA4C,sBAAsB,cAAc,qBAAqB,GAAG,wFAAwF,yBAAyB,+BAA+B,0BAA0B,0BAA0B,mCAAmC,uBAAuB,mCAAmC,8CAA8C,GAAG,2BAA2B,kBAAkB,kBAAkB,yBAAyB,kIAAkI,GAAG,sBAAsB,cAAc,qBAAqB,SAAS,qBAAqB,SAAS,qBAAqB,SAAS,qBAAqB,SAAS,YAAY,WAAW,GAAG,0BAA0B,qBAAqB,oBAAoB,iCAAiC,iDAAiD,iDAAiD,iDAAiD,6BAA6B,GAAG,gCAAgC,mDAAmD,GAAG,sFAAsF,gLAAgL,GAAG,oBAAoB,yBAAyB,8CAA8C,gCAAgC,2FAA2F,wBAAwB,wBAAwB,eAAe,UAAU,QAAQ,6CAA6C,0DAA0D,8BAA8B,iGAAiG,mBAAmB,GAAG,6CAA6C,qEAAqE,8BAA8B,4GAA4G,mFAAmF,sBAAsB,GAAG,0EAA0E,oCAAoC,oCAAoC,8BAA8B,oBAAoB,6DAA6D,8CAA8C,0CAA0C,oDAAoD,kDAAkD,GAAG,sEAAsE,iCAAiC,yBAAyB,oBAAoB,yCAAyC,0CAA0C,mEAAmE,mBAAmB,6BAA6B,6CAA6C,iCAAiC,8BAA8B,gCAAgC,sCAAsC,GAAG,uEAAuE,kCAAkC,0BAA0B,4BAA4B,+BAA+B,iCAAiC,oBAAoB,gCAAgC,4CAA4C,wCAAwC,kCAAkC,oCAAoC,mBAAmB,0BAA0B,yDAAyD,yCAAyC,wDAAwD,4CAA4C,eAAe,2BAA2B,OAAO,0BAA0B,6DAA6D,4CAA4C,GAAG,sCAAsC,GAAG,0DAA0D,yBAAyB,qBAAqB,4BAA4B,4BAA4B,4BAA4B,4BAA4B,6BAA6B,6BAA6B,6BAA6B,6BAA6B,gCAAgC,mBAAmB,4BAA4B,4CAA4C,4CAA4C,6CAA6C,4CAA4C,8CAA8C,6CAA6C,8CAA8C,6CAA6C,qCAAqC,GAAG,sDAAsD,yBAAyB,mBAAmB,4BAA4B,4BAA4B,4BAA4B,4BAA4B,6BAA6B,6BAA6B,6BAA6B,6BAA6B,oCAAoC,6CAA6C,iDAAiD,0DAA0D,sEAAsE,YAAY,eAAe,eAAe,+CAA+C,8BAA8B,mEAAmE,mEAAmE,mEAAmE,mEAAmE,+BAA+B,+BAA+B,gCAAgC,gCAAgC,+BAA+B,+BAA+B,mCAAmC,mCAAmC,yDAAyD,gCAAgC,wEAAwE,+BAA+B,qBAAqB,SAAS,GAAG,qEAAqE,qEAAqE,qEAAqE,qEAAqE,2BAA2B,2BAA2B,iCAAiC,iCAAiC,sCAAsC,sCAAsC,+BAA+B,+BAA+B,wCAAwC,wCAAwC,+BAA+B,+BAA+B,sDAAsD,sDAAsD,wCAAwC,wCAAwC,0CAA0C,0CAA0C,yCAAyC,+BAA+B,mCAAmC,8CAA8C,mBAAmB,cAAc,GAAG,oBAAoB,cAAc,GAAG,mBAAmB,yBAAyB,GAAG,2CAA2C,8BAA8B,8BAA8B,2BAA2B,2BAA2B,4CAA4C,oDAAoD,eAAe,yBAAyB,GAAG,2DAA2D,YAAY,gBAAgB,gBAAgB,aAAa,0CAA0C,yCAAyC,oBAAoB,yBAAyB,GAAG,kBAAkB,yBAAyB,GAAG,YAAY,4BAA4B,4BAA4B,YAAY,4BAA4B,4BAA4B,qCAAqC,8DAA8D,gCAAgC,8DAA8D,iBAAiB,gBAAgB,GAAG,wCAAwC,gCAAgC,gCAAgC,8BAA8B,uBAAuB,uBAAuB,2CAA2C,2CAA2C,iBAAiB,sBAAsB,GAAG,iBAAiB,sBAAsB,GAAG,mCAAmC,iBAAiB,sBAAsB,GAAG,gBAAgB,sBAAsB,GAAG,gBAAgB,uEAAuE,uEAAuE,2CAA2C,2CAA2C,sCAAsC,sCAAsC,mCAAmC,mCAAmC,8BAA8B,mCAAmC,mCAAmC,GAAG,2BAA2B,2BAA2B,mBAAmB,qBAAqB,GAAG,oBAAoB,qBAAqB,GAAG,+CAA+C,+BAA+B,+CAA+C,qCAAqC,4BAA4B,2BAA2B,mDAAmD,gCAAgC,+CAA+C,0CAA0C,qDAAqD,uDAAuD,mBAAmB,uCAAuC,GAAG,kBAAkB,uCAAuC,GAAG,kDAAkD,GAAG,iEAAiE,sBAAsB,qFAAqF,iBAAiB,2DAA2D,6BAA6B,yBAAyB,kCAAkC,gDAAgD,oBAAoB,oBAAoB,oBAAoB,sCAAsC,4BAA4B,iGAAiG,+DAA+D,oBAAoB,2CAA2C,mEAAmE,wGAAwG,gEAAgE,mBAAmB,gEAAgE,sBAAsB,mBAAmB,mBAAmB,qCAAqC,wCAAwC,mCAAmC,6CAA6C,qCAAqC,sDAAsD,uBAAuB,oEAAoE,yDAAyD,uCAAuC,gDAAgD,WAAW,8CAA8C,mCAAmC,sCAAsC,2BAA2B,sBAAsB,2BAA2B,eAAe,mDAAmD,wBAAwB,2BAA2B,4DAA4D,gEAAgE,GAAG,iDAAiD,mCAAmC,uBAAuB,qBAAqB,+CAA+C,iDAAiD,0DAA0D,8DAA8D,GAAG,+CAA+C,mCAAmC,0BAA0B,0BAA0B,oBAAoB,yCAAyC,okBAAokB,0IAA0I,0BAA0B,mBAAmB,GAAG,mDAAmD,GAAG,0CAA0C,mCAAmC,4BAA4B,oBAAoB,mDAAmD,2DAA2D,sCAAsC,GAAG,2EAA2E,2CAA2C,sBAAsB,yBAAyB,uBAAuB,wBAAwB,oCAAoC,mBAAmB,mBAAmB,cAAc,kDAAkD,gDAAgD,8BAA8B,sDAAsD,cAAc,eAAe,OAAO,oBAAoB,2DAA2D,uCAAuC,oBAAoB,2BAA2B,GAAG,+CAA+C,0FAA0F,GAAG,6GAA6G,mEAAmE,4BAA4B,0EAA0E,mCAAmC,6CAA6C,GAAG,qEAAqE,gCAAgC,sBAAsB,iCAAiC,oEAAoE,4BAA4B,wCAAwC,mDAAmD,kDAAkD,2CAA2C,uDAAuD,uCAAuC,uCAAuC,oDAAoD,oDAAoD,oCAAoC,mDAAmD,gBAAgB,GAAG,oBAAoB,kDAAkD,0EAA0E,GAAG,2CAA2C,mCAAmC,sCAAsC,qDAAqD,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,qBAAqB,oCAAoC,uCAAuC,GAAG,qBAAqB,gDAAgD,qEAAqE,uCAAuC,gCAAgC,qBAAqB,gEAAgE,+BAA+B,6BAA6B,oDAAoD,gBAAgB,gEAAgE,yBAAyB,+EAA+E,6CAA6C,qDAAqD,2BAA2B,sGAAsG,4CAA4C,GAAG,+CAA+C,mCAAmC,gCAAgC,oBAAoB,0CAA0C,GAAG,8CAA8C,mCAAmC,iEAAiE,qBAAqB,yCAAyC,iBAAiB,iDAAiD,2DAA2D,IAAI,mDAAmD,mCAAmC,yHAAyH,4CAA4C,0FAA0F,8CAA8C,uEAAuE,sCAAsC,GAAG,sDAAsD,uBAAuB,8BAA8B,yFAAyF,mBAAmB,qCAAqC,kFAAkF,GAAG,8DAA8D,qBAAqB,8BAA8B,wGAAwG,qEAAqE,8DAA8D,kCAAkC,yBAAyB,aAAa,GAAG,6BAA6B,qFAAqF,8BAA8B,GAAG,4BAA4B,sCAAsC,6BAA6B,kJAAkJ,4BAA4B,WAAW,qDAAqD,gCAAgC,qBAAqB,gCAAgC,mBAAmB,0BAA0B,oDAAoD,GAAG,6CAA6C,mCAAmC,uBAAuB,mBAAmB,+CAA+C,+BAA+B,GAAG,4CAA4C,mCAAmC,gCAAgC,oBAAoB,2CAA2C,+CAA+C,+CAA+C,0CAA0C,oDAAoD,GAAG,uEAAuE,mBAAmB,gCAAgC,mCAAmC,wBAAwB,oBAAoB,eAAe,iBAAiB,iBAAiB,aAAa,aAAa,kDAAkD,8DAA8D,+CAA+C,2BAA2B,8DAA8D,+CAA+C,yBAAyB,gDAAgD,gDAAgD,GAAG,KAAK,8CAA8C,8CAA8C,GAAG,2CAA2C,GAAG,0DAA0D,mCAAmC,0BAA0B,qBAAqB,uBAAuB,4BAA4B,2BAA2B,uCAAuC,6CAA6C,2GAA2G,kCAAkC,GAAG,oBAAoB,uBAAuB,yFAAyF,OAAO,4CAA4C,GAAG,GAAG,uDAAuD,mCAAmC,4BAA4B,yBAAyB,0BAA0B,qCAAqC,+CAA+C,GAAG,oBAAoB,mBAAmB,kBAAkB,iBAAiB,iBAAiB,iBAAiB,iBAAiB,iBAAiB,kBAAkB,yDAAyD,+CAA+C,+BAA+B,mCAAmC,+BAA+B,eAAe,KAAK,QAAQ,2DAA2D,kCAAkC,gDAAgD,+CAA+C,8CAA8C,4DAA4D,yBAAyB,GAAG,yBAAyB,GAAG,4EAA4E,mCAAmC,oDAAoD,oCAAoC,6BAA6B,oBAAoB,6EAA6E,+EAA+E,4BAA4B,WAAW,6DAA6D,4FAA4F,yBAAyB,gCAAgC,yCAAyC,oDAAoD,6BAA6B,oDAAoD,8BAA8B,4BAA4B,4GAA4G,2DAA2D,gEAAgE,wBAAwB,+FAA+F,8EAA8E,yGAAyG,iFAAiF,mBAAmB,gDAAgD,mCAAmC,yBAAyB,mBAAmB,+CAA+C,sCAAsC,yBAAyB,GAAG,wDAAwD,qBAAqB,gCAAgC,mBAAmB,yBAAyB,qCAAqC,GAAG,gDAAgD,wBAAwB,qCAAqC,sBAAsB,4BAA4B,mBAAmB,2DAA2D,iEAAiE,oDAAoD,yDAAyD,+BAA+B,4BAA4B,+CAA+C,oCAAoC,uBAAuB,2BAA2B,+CAA+C,kCAAkC,GAAG,wCAAwC,mBAAmB,qBAAqB,GAAG,mDAAmD,wBAAwB,qDAAqD,8DAA8D,qCAAqC,6BAA6B,gCAAgC,yCAAyC,oCAAoC,6CAA6C,mHAAmH,yEAAyE,gEAAgE,mBAAmB,6CAA6C,qCAAqC,mCAAmC,2BAA2B,sEAAsE,6BAA6B,GAAG,iDAAiD,uBAAuB,sBAAsB,6BAA6B,qBAAqB,gCAAgC,mBAAmB,8CAA8C,kEAAkE,4CAA4C,GAAG,yCAAyC,mCAAmC,uBAAuB,mBAAmB,+CAA+C,kDAAkD,uCAAuC,GAAG;AACpvhG,qCAAqC,kFAAkF,iCAAiC,iCAAiC,kEAAkE,sCAAsC,kFAAkF,wBAAwB,wBAAwB,wBAAwB,4BAA4B,mFAAmF,uIAAuI,4FAA4F,8BAA8B,wEAAwE,iIAAiI,wFAAwF,GAAG,oDAAoD,GAAG,8DAA8D,GAAG,yGAAyG,+BAA+B,gFAAgF,EAAE,kCAAkC,EAAE,EAAE,qDAAqD,EAAE,gCAAgC,EAAE,EAAE,oEAAoE,EAAE,qCAAqC,EAAE,EAAE,yGAAyG,+BAA+B,oEAAoE,+DAA+D,4FAA4F,qGAAqG,qGAAqG,+GAA+G,+GAA+G,+GAA+G,+GAA+G,2CAA2C,0KAA0K,yEAAyE,2DAA2D,yCAAyC,8FAA8F,oEAAoE,8DAA8D,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,aAAa,EAAE,UAAU,eAAe,EAAE,sBAAsB,EAAE,SAAS,EAAE,uBAAuB,EAAE,iBAAiB,+EAA+E,sFAAsF,4EAA4E,8EAA8E,0CAA0C,iEAAiE,8DAA8D,qCAAqC,sBAAsB,sBAAsB,sBAAsB,8FAA8F,mBAAmB,GAAG,8BAA8B,yBAAyB,GAAG,mCAAmC,kDAAkD,GAAG,kCAAkC,iDAAiD,GAAG,8BAA8B,qBAAqB,GAAG,mCAAmC,uDAAuD,GAAG,2CAA2C,EAAE,0BAA0B,GAAG,6BAA6B,GAAG,mDAAmD,GAAG,6BAA6B,EAAE,UAAU,wBAAwB,EAAE,yBAAyB,EAAE,qCAAqC,GAAG,yCAAyC,GAAG,6BAA6B,GAAG,kCAAkC,GAAG,2BAA2B,GAAG,mCAAmC,GAAG,2BAA2B,GAAG,2BAA2B,EAAE,+BAA+B,GAAG,2BAA2B,EAAE,4BAA4B,GAAG,qEAAqE,eAAe,qCAAqC,kCAAkC,YAAY,mJAAmJ,sBAAsB,oBAAoB,wBAAwB,2BAA2B,0CAA0C,kDAAkD,oCAAoC,GAAG,SAAS,yCAAyC,GAAG,gDAAgD,+BAA+B,sDAAsD,4EAA4E,6CAA6C,4CAA4C,qDAAqD,wBAAwB,GAAG,2KAA2K,sBAAsB,0CAA0C,yCAAyC,wDAAwD,iEAAiE,oCAAoC,6CAA6C,wBAAwB,gDAAgD,+BAA+B,sDAAsD,4EAA4E,6CAA6C,4CAA4C,qDAAqD,wBAAwB,GAAG,0BAA0B,gDAAgD,sCAAsC,wBAAwB,GAAG,mKAAmK,sBAAsB,iDAAiD,+BAA+B,2DAA2D,6EAA6E,6CAA6C,4CAA4C,yCAAyC,wBAAwB,GAAG,wCAAwC,EAAE,gBAAgB,EAAE,GAAG,kBAAkB,qBAAqB,sBAAsB,mBAAmB,EAAE,uBAAuB,2BAA2B,EAAE,oBAAoB,2BAA2B,mBAAmB,GAAG,OAAO,GAAG,gBAAgB,EAAE,yBAAyB,EAAE,qCAAqC,GAAG,yCAAyC,GAAG,6BAA6B,GAAG,kCAAkC,GAAG,2BAA2B,GAAG,oFAAoF,oBAAoB,6CAA6C,6BAA6B,qDAAqD,6BAA6B,qDAAqD,6BAA6B,uDAAuD,8BAA8B,uDAAuD,8BAA8B,sFAAsF,8BAA8B,+CAA+C,0BAA0B,oDAAoD,qEAAqE,mDAAmD,sCAAsC,+CAA+C,qDAAqD,sDAAsD,uDAAuD,uDAAuD,+CAA+C,8HAA8H,2DAA2D,0DAA0D,qEAAqE,oCAAoC,8FAA8F,+DAA+D,iCAAiC,2DAA2D,iEAAiE,kCAAkC,6DAA6D,4KAA4K,6EAA6E,oCAAoC,+EAA+E,qBAAqB,wBAAwB,yBAAyB,oBAAoB,2BAA2B,4BAA4B,2BAA2B,4BAA4B,yBAAyB,2BAA2B,qBAAqB,qBAAqB,qBAAqB,wBAAwB,sBAAsB,sBAAsB,sBAAsB,kBAAkB,qBAAqB,qBAAqB,qBAAqB,wBAAwB,sBAAsB,sBAAsB,sBAAsB,kBAAkB,yBAAyB,wBAAwB,sBAAsB,sBAAsB,qBAAqB,kBAAkB,KAAK,iBAAiB,sBAAsB,YAAY,IAAI,8FAA8F,qFAAqF,8BAA8B,GAAG,kHAAkH,iDAAiD,uCAAuC,8CAA8C,4BAA4B,+CAA+C,yCAAyC,wFAAwF,oEAAoE,8BAA8B,kBAAkB,GAAG,aAAa,GAAG,+HAA+H,iDAAiD,uCAAuC,8CAA8C,4BAA4B,+CAA+C,yCAAyC,sBAAsB,sBAAsB,qCAAqC,qCAAqC,sCAAsC,oCAAoC,gIAAgI,yGAAyG,yGAAyG,yGAAyG,0GAA0G,mGAAmG,mGAAmG,mGAAmG,8CAA8C,GAAG,kIAAkI,iDAAiD,uCAAuC,8CAA8C,6CAA6C,+CAA+C,yCAAyC,iGAAiG,6EAA6E,wGAAwG,cAAc,GAAG,uIAAuI,iDAAiD,uCAAuC,8CAA8C,6CAA6C,+CAA+C,yCAAyC,iGAAiG,6EAA6E,oGAAoG,aAAa,GAAG,0GAA0G,6DAA6D,oCAAoC,uBAAuB,oDAAoD,aAAa,GAAG,mDAAmD,wEAAwE,oDAAoD,yCAAyC,kBAAkB,GAAG,YAAY,GAAG,+HAA+H,6DAA6D,oCAAoC,uBAAuB,oDAAoD,aAAa,GAAG,mDAAmD,sBAAsB,sBAAsB,+CAA+C,8CAA8C,gDAAgD,6CAA6C,2HAA2H,oGAAoG,oGAAoG,oGAAoG,qGAAqG,8FAA8F,8FAA8F,8FAA8F,8CAA8C,GAAG,kIAAkI,6DAA6D,oCAAoC,uBAAuB,oDAAoD,aAAa,GAAG,mDAAmD,iFAAiF,6DAA6D,wGAAwG,uBAAuB,GAAG,uIAAuI,6DAA6D,oCAAoC,uBAAuB,oDAAoD,aAAa,GAAG,mDAAmD,kFAAkF,6DAA6D,oGAAoG,uBAAuB,GAAG,sIAAsI,wEAAwE,kCAAkC,GAAG,+FAA+F,kJAAkJ,6CAA6C,2DAA2D,6EAA6E,4BAA4B,iHAAiH,6CAA6C,qCAAqC,2CAA2C,qBAAqB,sFAAsF,8DAA8D,qCAAqC,cAAc,wBAAwB,yCAAyC,8EAA8E,sDAAsD,+CAA+C,6EAA6E,2CAA2C,+CAA+C,uDAAuD,yFAAyF,2DAA2D,4DAA4D,WAAW,8EAA8E,kDAAkD,2DAA2D,iCAAiC,iCAAiC,qEAAqE,wCAAwC,yCAAyC,kEAAkE,sCAAsC,+IAA+I,yCAAyC,qGAAqG,+EAA+E,oDAAoD,uDAAuD,oDAAoD,+BAA+B,+BAA+B,oCAAoC,+BAA+B,qDAAqD,uBAAuB,+BAA+B,qDAAqD,iEAAiE,+CAA+C,8BAA8B,uBAAuB,GAAG,kDAAkD,8CAA8C,gFAAgF,gCAAgC,kFAAkF,kDAAkD,uDAAuD,6CAA6C,yGAAyG,sCAAsC,4FAA4F,kFAAkF,0DAA0D,gDAAgD,uCAAuC,wEAAwE,qBAAqB,0DAA0D,GAAG,OAAO,+DAA+D,GAAG,2HAA2H,gHAAgH,6EAA6E,oEAAoE,4EAA4E,qHAAqH,6BAA6B,qDAAqD,wBAAwB,GAAG,wKAAwK,wCAAwC,8DAA8D,+DAA+D,iCAAiC,qBAAqB,mBAAmB,qBAAqB,qBAAqB,mCAAmC,iCAAiC,6CAA6C,8CAA8C,kDAAkD,uFAAuF,qDAAqD,GAAG,oDAAoD,yCAAyC,2CAA2C,mDAAmD,sCAAsC,uCAAuC,GAAG,6CAA6C,6BAA6B,2BAA2B,gGAAgG,2DAA2D,+BAA+B,4CAA4C,2CAA2C,oFAAoF,gCAAgC,4BAA4B,6BAA6B,6BAA6B,8BAA8B,8BAA8B,eAAe,eAAe,QAAQ,iEAAiE,2CAA2C,+CAA+C,0DAA0D,qCAAqC,2DAA2D,UAAU,GAAG,SAAS,0BAA0B,0BAA0B,mCAAmC,sCAAsC,GAAG,GAAG,qBAAqB,GAAG,wDAAwD,kDAAkD,oDAAoD,yBAAyB,GAAG,gGAAgG,+LAA+L,yBAAyB,4BAA4B,0BAA0B,qBAAqB,6BAA6B,2BAA2B,+BAA+B,yCAAyC,uCAAuC,kDAAkD,GAAG,yCAAyC,6CAA6C,GAAG,0CAA0C,oEAAoE,GAAG,iCAAiC,GAAG,0EAA0E,UAAU,GAAG,sDAAsD,+HAA+H,wBAAwB,yCAAyC,iEAAiE,0EAA0E,kEAAkE,mHAAmH,qEAAqE,2EAA2E,wCAAwC,EAAE,oDAAoD,EAAE,gCAAgC,EAAE,yCAAyC,EAAE,wDAAwD,EAAE,kBAAkB,EAAE,uBAAuB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,qFAAqF,2BAA2B,EAAE,+DAA+D,EAAE,kBAAkB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,kFAAkF,iCAAiC,EAAE,sBAAsB,EAAE,qDAAqD,EAAE,kBAAkB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,qFAAqF,kCAAkC,EAAE,wDAAwD,EAAE,kBAAkB,EAAE,uBAAuB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,6BAA6B,2BAA2B,EAAE,+DAA+D,EAAE,kBAAkB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,0BAA0B,iCAAiC,EAAE,sBAAsB,EAAE,qDAAqD,EAAE,kBAAkB,EAAE,yBAAyB,EAAE,sBAAsB,EAAE,6BAA6B,wCAAwC,EAAE,wBAAwB,EAAE,yBAAyB,EAAE,8CAA8C,EAAE,8BAA8B,EAAE,OAAO,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,cAAc,6DAA6D,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,qBAAqB,EAAE,gBAAgB,kCAAkC,EAAE,yBAAyB,EAAE,yCAAyC,EAAE,8BAA8B,EAAE,OAAO,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,cAAc,wDAAwD,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,qBAAqB,EAAE,gBAAgB,mCAAmC,EAAE,yBAAyB,EAAE,yCAAyC,EAAE,8BAA8B,EAAE,OAAO,EAAE,qBAAqB,EAAE,qBAAqB,EAAE,cAAc,wDAAwD,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,qBAAqB,EAAE,gBAAgB,wCAAwC,EAAE,kCAAkC,EAAE,8BAA8B,EAAE,OAAO,EAAE,qBAAqB,EAAE,cAAc,iDAAiD,EAAE,cAAc,EAAE,eAAe,EAAE,OAAO,EAAE,gBAAgB,mDAAmD,wGAAwG,6FAA6F,8DAA8D,EAAE,qCAAqC,kDAAkD,EAAE,mDAAmD,0DAA0D,0DAA0D,yIAAyI,+DAA+D,8CAA8C,oDAAoD,8BAA8B,2CAA2C,4BAA4B,qDAAqD,6BAA6B,qDAAqD,6BAA6B,uDAAuD,8BAA8B,uDAAuD,8BAA8B,gEAAgE,kCAAkC,yEAAyE,yCAAyC,+CAA+C,0BAA0B,oDAAoD,6DAA6D,gCAAgC,4CAA4C,6DAA6D,gCAAgC,4CAA4C,oEAAoE,4BAA4B,oCAAoC,kCAAkC,8BAA8B,6CAA6C,qDAAqD,+CAA+C,sDAAsD,uDAAuD,uDAAuD,+DAA+D,yEAAyE,gIAAgI,6DAA6D,gCAAgC,4CAA4C,6DAA6D,gCAAgC,4CAA4C,mEAAmE,qBAAqB,4BAA4B,6BAA6B,6BAA6B,8BAA8B,8BAA8B,kCAAkC,yCAAyC,gCAAgC,gCAAgC,0BAA0B,4BAA4B,6BAA6B,6BAA6B,8BAA8B,8BAA8B,kCAAkC,yCAAyC,0BAA0B,gCAAgC,gCAAgC,gCAAgC,4BAA4B,kCAAkC,4CAA4C,4CAA4C,kCAAkC,8BAA8B,0BAA0B,IAAI,iBAAiB,sBAAsB,YAAY,IAAI,uIAAuI,iDAAiD,0DAA0D,wCAAwC,kDAAkD,gBAAgB,GAAG,yEAAyE,2CAA2C,sDAAsD,GAAG,2FAA2F,+GAA+G,GAAG,sFAAsF,gCAAgC,mCAAmC,qBAAqB,GAAG,6EAA6E,mFAAmF,GAAG,yGAAyG,8DAA8D,0FAA0F,GAAG,qIAAqI,yDAAyD,iFAAiF,kFAAkF,gCAAgC,wDAAwD,mEAAmE,0BAA0B,GAAG,kFAAkF,mEAAmE,+DAA+D,uDAAuD,kHAAkH,0BAA0B,GAAG,oGAAoG,mFAAmF,+DAA+D,wBAAwB,0BAA0B,WAAW,gFAAgF,8DAA8D,8DAA8D,qDAAqD,2EAA2E,sBAAsB,GAAG,2DAA2D,uDAAuD,uBAAuB,GAAG,0HAA0H,wCAAwC,yDAAyD,uFAAuF,iDAAiD,aAAa,GAAG,mFAAmF,iDAAiD,0DAA0D,GAAG,kEAAkE,8DAA8D,sBAAsB,GAAG,uFAAuF,2BAA2B,2BAA2B,+BAA+B,+BAA+B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,6DAA6D,wBAAwB,aAAa,0BAA0B,GAAG,iDAAiD,sCAAsC,oBAAoB,oBAAoB,2BAA2B,0BAA0B,0BAA0B,0BAA0B,kCAAkC,kCAAkC,4BAA4B,4BAA4B,4BAA4B,uBAAuB,oBAAoB,oBAAoB,oBAAoB,uBAAuB,mBAAmB,mBAAmB,mBAAmB,YAAY,GAAG,uDAAuD,eAAe,qCAAqC,YAAY,+FAA+F,iGAAiG,0EAA0E,sCAAsC,GAAG,2HAA2H,oBAAoB,yEAAyE,8DAA8D,2FAA2F,+FAA+F,8EAA8E,4FAA4F,8BAA8B,yCAAyC,GAAG,yBAAyB,GAAG,yNAAyN,sBAAsB,sBAAsB,wBAAwB,sBAAsB,6BAA6B,4CAA4C,0DAA0D,wFAAwF,2CAA2C,wCAAwC,GAAG,WAAW,uCAAuC,2CAA2C,GAAG,sFAAsF,oDAAoD,6DAA6D,mDAAmD,oEAAoE,sDAAsD,8EAA8E,kGAAkG,oDAAoD,wBAAwB,GAAG,iPAAiP,sBAAsB,4CAA4C,sDAAsD,4DAA4D,8FAA8F,yIAAyI,sCAAsC,mDAAmD,oFAAoF,6DAA6D,uEAAuE,mDAAmD,oEAAoE,sDAAsD,8EAA8E,kGAAkG,oDAAoD,wBAAwB,GAAG,mOAAmO,sBAAsB,iDAAiD,qDAAqD,oEAAoE,gDAAgD,uDAAuD,wCAAwC,mDAAmD,kGAAkG,wCAAwC,wBAAwB,GAAG,uFAAuF,0BAA0B,0BAA0B,2DAA2D,+BAA+B,8EAA8E,iBAAiB,iBAAiB,iBAAiB,4BAA4B,uGAAuG,EAAE,iBAAiB,GAAG,qDAAqD,EAAE,gBAAgB,GAAG,iIAAiI,EAAE,qBAAqB,GAAG,8EAA8E,EAAE,oBAAoB,GAAG,mEAAmE,GAAG,kCAAkC,EAAE,kCAAkC,GAAG;AACpx3C;AACA;AACA;;;;;;;ACtolEA,iBAAiB,6BAA6B,EAAE,uCAAuC;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,wBAAwB,uBAAuB;AAC/C,4BAA4B,0BAA0B;AACtD,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;;AAGA,OAAO;AACP;AACA;;AAEA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,wC;;;;;;;AC1fA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,cAAc;AACnE;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;ACpNqC;AAIrC;IAGI,eACY,MAAY,EACZ,aAAoB,EACpB,mBAAoD,EACpD,KAAqB,EACrB,SAAyB,EACzB,SAAkD,EAClD,eAAwD,EACxD,gBAAyD;QAFzD,wCAA4B,kDAAe,CAAC,IAAI,EAAE;QAClD,oDAAkC,kDAAe,CAAC,IAAI,EAAE;QACxD,sDAAmC,kDAAe,CAAC,IAAI,EAAE;QAPzD,WAAM,GAAN,MAAM,CAAM;QACZ,kBAAa,GAAb,aAAa,CAAO;QACpB,wBAAmB,GAAnB,mBAAmB,CAAiC;QACpD,UAAK,GAAL,KAAK,CAAgB;QACrB,cAAS,GAAT,SAAS,CAAgB;QACzB,cAAS,GAAT,SAAS,CAAyC;QAClD,oBAAe,GAAf,eAAe,CAAyC;QACxD,qBAAgB,GAAhB,gBAAgB,CAAyC;QAGjE,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;QACpC,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;QACpC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAClE,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IACxE,CAAC;IAGD,sBAAI,2BAAQ;aAAZ;YACI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC;QAC1B,CAAC;;;OAAA;IAED,sBAAI,2BAAQ;aAAZ;YACI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;QACxD,CAAC;;;OAAA;IAED,sBAAI,iCAAc;aAAlB;YACI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,EAAE,CAAC;QACzD,CAAC;aAMD,UAAmB,cAA8B;YAC7C,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,cAAc,CAAC,CAAC;QAChE,CAAC;;;OARA;IAED,sBAAI,kCAAe;aAAnB;YACI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,EAAE,CAAC;QAC1D,CAAC;aAMD,UAAoB,eAA+B;YAC/C,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;QAClE,CAAC;;;OARA;IAUD,iCAAiB,GAAjB;QACI,IAAM,WAAW,GAAG,EAAE,CAAC;QACvB,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3B,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC5B,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAC3B,IAAM,MAAM,GAAG;YACX,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,MAAM,GAAG,WAAW,CAAC;YACpE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,MAAM,GAAG,WAAW,CAAC;YAEpE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,GAAG,WAAW,EAAE,KAAK,GAAG,WAAW,CAAC;YACpE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,GAAG,WAAW,EAAE,KAAK,GAAG,WAAW,CAAC;YAEpE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,KAAK,GAAG,WAAW,CAAC;YACnE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,GAAG,WAAW,EAAE,KAAK,GAAG,WAAW,CAAC;SACtE,CAAC;QACF,IAAM,WAAW,GAAG,EAAC,KAAK,SAAE,MAAM,UAAE,KAAK,SAAE,MAAM,UAAC,CAAC;QACnD,IAAI,CAAC,IAAI,GAAG,sDAAmB,CAAC,SAAS,CAAC,UAAU,EAAE,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEtF,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QACjF,IAAI,CAAC,IAAI,CAAC,eAAe,GAAG,IAAI,0DAAuB,CACnD,IAAI,CAAC,IAAI,EACT,0DAAuB,CAAC,WAAW,EACnC,IAAI,CAAC,mBAAmB,EACxB,IAAI,CAAC,MAAM,CAAC,KAAK,CACpB,CAAC;IACN,CAAC;IACL,YAAC;AAAD,CAAC;;;;;;;;;AC7ED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACzBkC;AACb;AAErB,IAAM,aAAa,GAAG,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAsB,CAAC;AAE5E,IAAM,KAAK,GAAG,IAAI,6DAAK,CAAC,aAAa,CAAC,CAAC;AACvC,KAAK,CAAC,GAAG,EAAE,CAAC;AACZ,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;;;;;;;;8CCPnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9NA,yC;;;;;;;ACAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACzFA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;;;;;;;AC1GA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;AChHO,IAAM,MAAM,GAAG;IAClB,SAAS,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IACnB,UAAU,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IACpB,MAAM,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IAChB,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IACjB,MAAM,EAAE,CAAC,EAAE,CAAC;CACf,CAAC;AAEK,IAAM,MAAM,GAAG;IACpB,KAAK,EAAE;QACH,QAAQ,EAAC,EAAE;QACX,OAAO,EAAC,EAAE;QACV,QAAQ,EAAC,CAAC;QACV,IAAI,EAAC,CAAC;QACN,GAAG,EAAC,CAAC;QACL,IAAI,EAAC,EAAE;KACV;CACF,CAAC;;;;;;;;;;;;;ACjBmC;AACQ;AAEV;AAEnC;IACI,wBACY,KAAW;QAAX,UAAK,GAAL,KAAK,CAAM;IACrB,CAAC;IAEH,sCAAa,GAAb;QAAA,iBAuCC;QAnCG,IAAM,MAAM,GAAG,IAAI,kDAAe,CAC9B,CAAC,EACD,CAAC,EACD,EAAE,CACL,CAAC;QAEF,IAAM,KAAK,GAAG,kEAMrB,CAAC;QAEM,IAAM,QAAQ,GAAG,sDAAqB,CAAC,gBAAgB,CAAC;YACpD,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;YACL,KAAK;SACR,CAAC,CAAC;QAEH,QAAQ,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,UAAC,KAAK;YAE/B,IAAI,6DAAK,CACL,KAAI,CAAC,KAAK,EACV,aAAa,EACb,EAAC,IAAI,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAC,EAC7B,IAAI,kDAAe,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAC7D,IAAI,kDAAe,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAClF,CAAC;QACN,CAAC,CAAC,CAAC;IAEP,CAAC;IACL,qBAAC;AAAD,CAAC;;;;;;;;;;;AClDoC;AAErC;IAII,yBACY,MAAoB;QAApB,WAAM,GAAN,MAAM,CAAc;QAE5B,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;IAC9B,CAAC;IAED,qCAAW,GAAX,UACI,YAAmB;QAGnB,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAC,QAAQ,IAAG,eAAQ,CAAC,IAAI,KAAK,YAAY,EAA9B,CAA8B,CAAC,IAAE,IAAI,CAAC;QAEnG,EAAE,EAAC,cAAc,CAAC,EAAC;YACf,MAAM,CAAC,cAAc,CAAC;QAC1B,CAAC;QAAA,IAAI,CAAC,CAAC;YAEH,IAAI,YAAY,GAAC,CAAC,CAAC;YACnB,EAAE,EAAC,YAAY,KAAG,OAAO,CAAC,EAAC;gBACvB,YAAY,GAAC,GAAG,CAAC;YACrB,CAAC;YAED,IAAM,QAAQ,GAAG,IAAI,2DAAwB,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YACzE,QAAQ,CAAC,eAAe,GAAG,KAAK,CAAC;YACjC,IAAM,OAAO,GAAG,IAAI,kDAAe,CAAC,gBAAsB,IAAE,sBAAoB,YAAY,SAAM,GAAE,IAAI,CAAC,MAAM,CAAC,CAAC;YACjH,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;YAC9B,OAAO,CAAC,MAAM,GAAG,YAAY,CAAC;YAC9B,QAAQ,CAAC,cAAc,GAAG,OAAO,CAAC;YAClC,QAAQ,CAAC,aAAa,GAAG,iDAAc,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;YACjE,QAAQ,CAAC,eAAe,GAAG,OAAO,CAAC;YACnC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACpC,MAAM,CAAC,QAAQ,CAAC;QACpB,CAAC;IACL,CAAC;IACL,sBAAC;AAAD,CAAC;;;;;;;;;;;;ACvCoC;AAEvB,sBAAuB,KAAmB;IACpD,IAAM,MAAM,GAAG,IAAI,qDAAkB,CAAC,YAAY,EAAE,kDAAe,CAAC,IAAI,EAAE,EAAG,KAAK,CAAC,CAAC;IACpF,MAAM,CAAC,GAAG,GAAG,GAAG,CAAC;IACjB,MAAM,CAAC,MAAM,CAAC;AAClB,CAAC;;;;;;;;;;;;;ACNoC;AAEK;AAC1C,wDAAwD;AACxD,sDAAsD;AACN;AACZ;AAEpC;IAKI,gBAAmB,KAAY;QAA/B,iBA6BC;QA7BkB,UAAK,GAAL,KAAK,CAAO;QAE3B,IAAI,CAAC,MAAM,GAAG,qFAAY,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,GAAG,+CAAY,CAAC,YAAY,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;QACpE,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAClD,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACjD,IAAI,CAAC,IAAI,CAAC,eAAe,GAAG,IAAI,0DAAuB,CACnD,IAAI,CAAC,IAAI,EACT,0DAAuB,CAAC,cAAc,EACtC;YACI,IAAI,EAAE,CAAC;YACP,WAAW,EAAE,IAAI;YACjB,QAAQ,EAAE,GAAG;SAChB,EACD,KAAK,CAAC,KAAK,CACd,CAAC;QAGF,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,wBAAwB,CAAC;YAC/C,KAAI,CAAC,MAAM,CAAC,QAAQ,GAAG,KAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YAC1C,KAAI,CAAC,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,kDAAe,CAAC,IAAI,EAAE,CAAC,CAAC;QACzE,CAAC,CAAC,CAAC;QAGH,4DAA4D;QAC5D,0BAA0B;QAC1B,wFAAe,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAED,sBAAI,6BAAS;aAAb;YAAA,iBAKC;YAJG,IAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC;YAClC,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,UAAC,IAAI,IAAK,WAAI,KAAK,KAAI,CAAC,KAAK,CAAC,UAAU,EAA9B,CAA8B,CAAC,CAAC,WAAW,CAAC;YAEpK,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACnC,CAAC;;;OAAA;IAED,sBAAI,8BAAU;aAAd;YACI,IAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC;YACvC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,CAAC;QAC/D,CAAC;;;OAAA;IAED,sBAAI,6BAAS;aAAb;YACI,IAAM,eAAe,GAAG,IAAI,CAAC,SAAS,CAAC;YACvC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC,EAAE,eAAe,CAAC,CAAC,CAAC,CAAC;QAC5D,CAAC;;;OAAA;IAED,4BAAW,GAAX,UAAY,MAAuB;QAE/B,IAAM,eAAe,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,EAAE,CAAC;QACtE,IAAM,QAAQ,GAAG,IAAI,CAAC;QAEtB,IAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC1E,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;QAGjE,IAAM,aAAa,GAAG,IAAI,kDAAe,CACrC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,QAAQ,EAC7B,QAAQ,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,EACvB,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,GAAG,QAAQ,CAChC,CAAC;QAEF,IAAM,gBAAgB,GAAG,eAAe,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;QAC5D,IAAM,YAAY,GAAG,IAAI,kDAAe,CAAC,CAAC,EAAE,gBAAgB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACnE,IAAM,eAAe,GAAG,IAAI,kDAAe,CAAC,gBAAgB,CAAC,CAAC,EAAE,CAAC,EAAE,gBAAgB,CAAC,CAAC,CAAC,CAAC;QAEvF,IAAM,qBAAqB,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC;QACvD,EAAE,CAAC,CAAC,qBAAqB,GAAG,uDAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;YAChD,eAAe,CAAC,YAAY,CAAC,uDAAM,CAAC,KAAK,CAAC,QAAQ,GAAG,qBAAqB,CAAC,CAAC;QAChF,CAAC;QAED,IAAM,0BAA0B,GAAG,eAAe,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;QAErE,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,iBAAiB,CAAC,0BAA0B,CAAC,CAAC;IAE5E,CAAC;IACL,aAAC;AAAD,CAAC;;;;;;;;;;;;;;;AC1FoC;AACA;AAEC;AAGtC,oBAAuB,KAAU,EAAE,OAAe;IAE9C,mBAAmB;IAEnB,IAAM,CAAC,GAAG,KAAK,CAAC,MAAM,GAAG,OAAO,GAAG,CAAC,CAAC;IACrC,mBAAmB;IAEnB,IAAM,MAAM,GAAG,EAAE;IACjB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QACzB,IAAM,KAAK,GAAG,EAAE;QAChB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,EAAE,CAAC,EAAE,EAAE,CAAC;YAC/B,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAC7B,CAAC;QACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;IAED,MAAM,CAAC,MAAM,CAAC;AAElB,CAAC;AAGa,yBAA0B,MAAc;IAGlD,IAAI,WAAW,GAAY,KAAK,CAAC;IACjC,IAAI,IAAe,CAAC;IAGpB,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,gBAAgB,CACvC,aAAa,EACb,UAAC,KAAK;QAEF,WAAW,GAAG,IAAI,CAAC;QACnB,IAAI,GAAG,EAAE,CAAC;QACV,gBAAgB;QAChB,IAAI,CAAC,IAAI,CAAC,IAAI,qDAAO,CACjB,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,WAAW,EACpD,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,YAAY,CACxD,CAAC,CAAC;IAGP,CAAC,CAAC,CAAC;IAGP,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,gBAAgB,CACvC,aAAa,EACb,UAAC,KAAK;QACF,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACd,IAAI,CAAC,IAAI,CAAC,IAAI,qDAAO,CACjB,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,WAAW,EACpD,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC,eAAe,CAAC,YAAY,CACxD,CAAC,CAAC;QACP,CAAC;IACL,CAAC,CAAC,CAAC;IAGP,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC,gBAAgB,CACvC,WAAW,EACX,UAAC,KAAK;QAGF,sEAAsE;QACtE,uEAAuE;QAGvE,IAAM,MAAM,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,UAAC,GAAG,EAAE,YAAY,IAAK,UAAG,GAAG,YAAY,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,EAA7C,CAA6C,EAAE,CAAC,CAAC,CAAC;QACnH,IAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;QAEtD,sBAAsB;QAGtB,IAAI,6DAAK,CACL,MAAM,CAAC,KAAK,EACZ,aAAa,EACb,EAAC,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE,GAAG,EAAC,EAC9B,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAC5B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,EAC3C,kDAAe,CAAC,IAAI,EAAE,EACtB,MAAM,CAAC,UAAU,CAAC,KAAK,CAAC,MAAM,GAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,kDAAe,CACvD,GAAG,GAAG,KAAK,CAAC,CAAC,EACb,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EACd,CAAC,CACJ,CAAC,EACF,IAAI,kDAAe,CACf,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EACnC,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,EACnC,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,CACtC,CACJ,CAAC;IAGN,CAAC,CAAC,CAAC;AAGX,CAAC;;;;;;;;;;;ACpGoC;AAGvB,0BACV,KAAmB,EACnB,eAA+B;IAG/B,IAAM,UAAU,GAAG,+CAAY,CAAC,YAAY,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC;IAC7E,UAAU,CAAC,QAAQ,GAAG,eAAe,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;IAC3D,UAAU,CAAC,eAAe,GAAG,IAAI,0DAAuB,CACpD,UAAU,EACV,0DAAuB,CAAC,WAAW,EACnC,EAAE,IAAI,EAAE,CAAC,EAAE,WAAW,EAAE,GAAG,EAAC,EAC5B,KAAK,CACR,CAAC;IACF,MAAM,CAAC,UAAU,CAAC;AACtB,CAAC;;;;;;;;;;;ACjBoC;AAEvB,sBAAuB,KAAmB;IACpD,IAAM,MAAM,GAAG,IAAI,2DAAwB,CAAC,OAAO,EAAE,IAAI,kDAAe,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IAC3F,MAAM,CAAC,QAAQ,GAAG,IAAI,kDAAe,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;IACjD,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC;IACvB,MAAM,CAAC,CAAC,MAAM,CAAC;AACnB,CAAC;;;;;;;;;;;ACPoC;AAEvB,qBAAsB,MAAqB;IACrD,IAAM,KAAK,GAAG,IAAI,gDAAa,CAAC,MAAM,CAAC,CAAC;IACxC,KAAK,CAAC,UAAU,GAAG,IAAI,iDAAc,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAClD,IAAM,aAAa,GAAG,IAAI,kDAAe,CAAC,CAAC,EAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IACrD,IAAM,aAAa,GAAG,IAAI,uDAAoB,EAAE,CAAC;IACjD,KAAK,CAAC,aAAa,CAAC,aAAa,EAAE,aAAa,CAAC,CAAC;IAClD,MAAM,CAAC,KAAK,CAAC;AACjB,CAAC;;;;;;;;;;;ACToC;AAEvB,0BAA2B,KAAmB;IACxD,IAAM,UAAU,GAAG,+CAAY,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACjE,IAAM,cAAc,GAAG,IAAI,2DAAwB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;IACrE,cAAc,CAAC,eAAe,GAAG,KAAK,CAAC;IACvC,cAAc,CAAC,iBAAiB,GAAG,IAAI,sDAAmB,CAAC,gBAAsB,GAAE,oDAAoD,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;IACpN,cAAc,CAAC,iBAAiB,CAAC,eAAe,GAAG,kDAAe,CAAC,WAAW,CAAC;IAC/E,cAAc,CAAC,YAAY,GAAG,IAAI,iDAAc,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1D,cAAc,CAAC,aAAa,GAAG,IAAI,iDAAc,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC3D,cAAc,CAAC,eAAe,GAAG,IAAI,CAAC;IACtC,UAAU,CAAC,QAAQ,GAAG,cAAc,CAAC;IACrC,MAAM,CAAC,UAAU,CAAC;AACtB,CAAC;;;;;;;;;;;;;;;;;ACboC;AACY;AACJ;AACd;AAES;AACE;AACI;AACI;AAElD;IAWI,eACW,aAAgC;QAAhC,kBAAa,GAAb,aAAa,CAAmB;IAE3C,CAAC;IAED,mBAAG,GAAH;QAAA,iBAqBC;QApBG,IAAI,CAAC,MAAM,GAAC,EAAE,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,IAAI,iDAAc,CAAC,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;QAE3D,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC;YACtB,KAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE;YAC9B,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,KAAK,GAAG,oFAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtC,IAAI,CAAC,MAAM,GAAG,qFAAY,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,iEAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACvD,IAAI,CAAC,MAAM,GAAG,IAAI,wDAAM,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,UAAU,GAAG,yFAAgB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC/C,IAAI,CAAC,UAAU,GAAG,qFAAgB,CAAC,IAAI,CAAC,KAAK,EAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QAEpE,IAAI,CAAC,cAAc,GAAG,IAAI,2DAAc,CAAC,IAAI,CAAC,CAAC;QAC/C,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,CAAC;IACxC,CAAC;IAED,oBAAI,GAAJ,UAAK,IAAc,EAAC,GAAa;QAAjC,iBAIC;QAJI,gCAAc;QAAC,8BAAa;QAC7B,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,GAAG,IAAI,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,GAAG,EAAE,UAAC,IAAI;YAC1F,MAAM,CAAC,IAAI,KAAK,KAAI,CAAC,MAAM,CAAC,IAAI,IAAI,iBAAiB,IAAI,IAAI,CAAC;QAClE,CAAC,CAAC,CAAC;IACP,CAAC;IACL,YAAC;AAAD,CAAC;;;;;;;;ACtDD;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;;AAEA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;;AAEA;AACA;AACA,wCAAwC,4BAA4B;AACpE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,SAAS;AACT;AACA,SAAS;AACT,8EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,uBAAuB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B,eAAe;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA,CAAC","file":"static/js/main.0920c3a9.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/collapse-game/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 80f084f246179088daf8","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\nvar c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\nif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\nelse for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\nreturn c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __extends = (this && this.__extends) || (function () {\n            var extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var BABYLON;\n(function (BABYLON) {\n    BABYLON.ToGammaSpace = 1 / 2.2;\n    BABYLON.ToLinearSpace = 2.2;\n    BABYLON.Epsilon = 0.001;\n    var MathTools = (function () {\n        function MathTools() {\n        }\n        /**\n         * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n         */\n        MathTools.WithinEpsilon = function (a, b, epsilon) {\n            if (epsilon === void 0) { epsilon = 1.401298E-45; }\n            var num = a - b;\n            return -epsilon <= num && num <= epsilon;\n        };\n        /**\n         * Returns a string : the upper case translation of the number i to hexadecimal.\n         */\n        MathTools.ToHex = function (i) {\n            var str = i.toString(16);\n            if (i <= 15) {\n                return (\"0\" + str).toUpperCase();\n            }\n            return str.toUpperCase();\n        };\n        /**\n         * Returns -1 if value is negative and +1 is value is positive.\n         * Returns the value itself if it's equal to zero.\n         */\n        MathTools.Sign = function (value) {\n            value = +value; // convert to a number\n            if (value === 0 || isNaN(value))\n                return value;\n            return value > 0 ? 1 : -1;\n        };\n        /**\n         * Returns the value itself if it's between min and max.\n         * Returns min if the value is lower than min.\n         * Returns max if the value is greater than max.\n         */\n        MathTools.Clamp = function (value, min, max) {\n            if (min === void 0) { min = 0; }\n            if (max === void 0) { max = 1; }\n            return Math.min(max, Math.max(min, value));\n        };\n        /**\n         * Returns the log2 of value.\n         */\n        MathTools.Log2 = function (value) {\n            return Math.log(value) * Math.LOG2E;\n        };\n        return MathTools;\n    }());\n    BABYLON.MathTools = MathTools;\n    var Scalar = (function () {\n        function Scalar() {\n        }\n        /**\n         * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n         */\n        Scalar.Lerp = function (start, end, amount) {\n            return start + ((end - start) * amount);\n        };\n        /**\n         * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n         */\n        Scalar.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            return (((value1 * part1) + (value2 * part2)) + (tangent1 * part3)) + (tangent2 * part4);\n        };\n        return Scalar;\n    }());\n    BABYLON.Scalar = Scalar;\n    var Color3 = (function () {\n        /**\n         * Creates a new Color3 object from red, green, blue values, all between 0 and 1.\n         */\n        function Color3(r, g, b) {\n            if (r === void 0) { r = 0; }\n            if (g === void 0) { g = 0; }\n            if (b === void 0) { b = 0; }\n            this.r = r;\n            this.g = g;\n            this.b = b;\n        }\n        /**\n         * Returns a string with the Color3 current values.\n         */\n        Color3.prototype.toString = function () {\n            return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \"}\";\n        };\n        /**\n         * Returns the string \"Color3\".\n         */\n        Color3.prototype.getClassName = function () {\n            return \"Color3\";\n        };\n        /**\n         * Returns the Color3 hash code.\n         */\n        Color3.prototype.getHashCode = function () {\n            var hash = this.r || 0;\n            hash = (hash * 397) ^ (this.g || 0);\n            hash = (hash * 397) ^ (this.b || 0);\n            return hash;\n        };\n        // Operators\n        /**\n         * Stores in the passed array from the passed starting index the red, green, blue values as successive elements.\n         * Returns the Color3.\n         */\n        Color3.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.r;\n            array[index + 1] = this.g;\n            array[index + 2] = this.b;\n            return this;\n        };\n        /**\n         * Returns a new Color4 object from the current Color3 and the passed alpha.\n         */\n        Color3.prototype.toColor4 = function (alpha) {\n            if (alpha === void 0) { alpha = 1; }\n            return new Color4(this.r, this.g, this.b, alpha);\n        };\n        /**\n         * Returns a new array populated with 3 numeric elements : red, green and blue values.\n         */\n        Color3.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        /**\n         * Returns the luminance value (float).\n         */\n        Color3.prototype.toLuminance = function () {\n            return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n        };\n        /**\n         * Multiply each Color3 rgb values by the passed Color3 rgb values in a new Color3 object.\n         * Returns this new object.\n         */\n        Color3.prototype.multiply = function (otherColor) {\n            return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n        };\n        /**\n         * Multiply the rgb values of the Color3 and the passed Color3 and stores the result in the object \"result\".\n         * Returns the current Color3.\n         */\n        Color3.prototype.multiplyToRef = function (otherColor, result) {\n            result.r = this.r * otherColor.r;\n            result.g = this.g * otherColor.g;\n            result.b = this.b * otherColor.b;\n            return this;\n        };\n        /**\n         * Boolean : True if the rgb values are equal to the passed ones.\n         */\n        Color3.prototype.equals = function (otherColor) {\n            return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;\n        };\n        /**\n         * Boolean : True if the rgb values are equal to the passed ones.\n         */\n        Color3.prototype.equalsFloats = function (r, g, b) {\n            return this.r === r && this.g === g && this.b === b;\n        };\n        /**\n         * Multiplies in place each rgb value by scale.\n         * Returns the updated Color3.\n         */\n        Color3.prototype.scale = function (scale) {\n            return new Color3(this.r * scale, this.g * scale, this.b * scale);\n        };\n        /**\n         * Multiplies the rgb values by scale and stores the result into \"result\".\n         * Returns the unmodified current Color3.\n         */\n        Color3.prototype.scaleToRef = function (scale, result) {\n            result.r = this.r * scale;\n            result.g = this.g * scale;\n            result.b = this.b * scale;\n            return this;\n        };\n        /**\n         * Returns a new Color3 set with the added values of the current Color3 and of the passed one.\n         */\n        Color3.prototype.add = function (otherColor) {\n            return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n        };\n        /**\n         * Stores the result of the addition of the current Color3 and passed one rgb values into \"result\".\n         * Returns the unmodified current Color3.\n         */\n        Color3.prototype.addToRef = function (otherColor, result) {\n            result.r = this.r + otherColor.r;\n            result.g = this.g + otherColor.g;\n            result.b = this.b + otherColor.b;\n            return this;\n        };\n        /**\n         * Returns a new Color3 set with the subtracted values of the passed one from the current Color3 .\n         */\n        Color3.prototype.subtract = function (otherColor) {\n            return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n        };\n        /**\n         * Stores the result of the subtraction of passed one from the current Color3 rgb values into \"result\".\n         * Returns the unmodified current Color3.\n         */\n        Color3.prototype.subtractToRef = function (otherColor, result) {\n            result.r = this.r - otherColor.r;\n            result.g = this.g - otherColor.g;\n            result.b = this.b - otherColor.b;\n            return this;\n        };\n        /**\n         * Returns a new Color3 copied the current one.\n         */\n        Color3.prototype.clone = function () {\n            return new Color3(this.r, this.g, this.b);\n        };\n        /**\n         * Copies the rgb values from the source in the current Color3.\n         * Returns the updated Color3.\n         */\n        Color3.prototype.copyFrom = function (source) {\n            this.r = source.r;\n            this.g = source.g;\n            this.b = source.b;\n            return this;\n        };\n        /**\n         * Updates the Color3 rgb values from the passed floats.\n         * Returns the Color3.\n         */\n        Color3.prototype.copyFromFloats = function (r, g, b) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            return this;\n        };\n        /**\n         * Updates the Color3 rgb values from the passed floats.\n         * Returns the Color3.\n         */\n        Color3.prototype.set = function (r, g, b) {\n            return this.copyFromFloats(r, g, b);\n        };\n        /**\n         * Returns the Color3 hexadecimal code as a string.\n         */\n        Color3.prototype.toHexString = function () {\n            var intR = (this.r * 255) | 0;\n            var intG = (this.g * 255) | 0;\n            var intB = (this.b * 255) | 0;\n            return \"#\" + MathTools.ToHex(intR) + MathTools.ToHex(intG) + MathTools.ToHex(intB);\n        };\n        /**\n         * Returns a new Color3 converted to linear space.\n         */\n        Color3.prototype.toLinearSpace = function () {\n            var convertedColor = new Color3();\n            this.toLinearSpaceToRef(convertedColor);\n            return convertedColor;\n        };\n        /**\n         * Converts the Color3 values to linear space and stores the result in \"convertedColor\".\n         * Returns the unmodified Color3.\n         */\n        Color3.prototype.toLinearSpaceToRef = function (convertedColor) {\n            convertedColor.r = Math.pow(this.r, BABYLON.ToLinearSpace);\n            convertedColor.g = Math.pow(this.g, BABYLON.ToLinearSpace);\n            convertedColor.b = Math.pow(this.b, BABYLON.ToLinearSpace);\n            return this;\n        };\n        /**\n         * Returns a new Color3 converted to gamma space.\n         */\n        Color3.prototype.toGammaSpace = function () {\n            var convertedColor = new Color3();\n            this.toGammaSpaceToRef(convertedColor);\n            return convertedColor;\n        };\n        /**\n         * Converts the Color3 values to gamma space and stores the result in \"convertedColor\".\n         * Returns the unmodified Color3.\n         */\n        Color3.prototype.toGammaSpaceToRef = function (convertedColor) {\n            convertedColor.r = Math.pow(this.r, BABYLON.ToGammaSpace);\n            convertedColor.g = Math.pow(this.g, BABYLON.ToGammaSpace);\n            convertedColor.b = Math.pow(this.b, BABYLON.ToGammaSpace);\n            return this;\n        };\n        // Statics\n        /**\n         * Creates a new Color3 from the string containing valid hexadecimal values.\n         */\n        Color3.FromHexString = function (hex) {\n            if (hex.substring(0, 1) !== \"#\" || hex.length !== 7) {\n                //Tools.Warn(\"Color3.FromHexString must be called with a string like #FFFFFF\");\n                return new Color3(0, 0, 0);\n            }\n            var r = parseInt(hex.substring(1, 3), 16);\n            var g = parseInt(hex.substring(3, 5), 16);\n            var b = parseInt(hex.substring(5, 7), 16);\n            return Color3.FromInts(r, g, b);\n        };\n        /**\n         * Creates a new Vector3 from the startind index of the passed array.\n         */\n        Color3.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n        };\n        /**\n         * Creates a new Color3 from integer values ( < 256).\n         */\n        Color3.FromInts = function (r, g, b) {\n            return new Color3(r / 255.0, g / 255.0, b / 255.0);\n        };\n        /**\n         * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3.\n         */\n        Color3.Lerp = function (start, end, amount) {\n            var r = start.r + ((end.r - start.r) * amount);\n            var g = start.g + ((end.g - start.g) * amount);\n            var b = start.b + ((end.b - start.b) * amount);\n            return new Color3(r, g, b);\n        };\n        Color3.Red = function () { return new Color3(1, 0, 0); };\n        Color3.Green = function () { return new Color3(0, 1, 0); };\n        Color3.Blue = function () { return new Color3(0, 0, 1); };\n        Color3.Black = function () { return new Color3(0, 0, 0); };\n        Color3.White = function () { return new Color3(1, 1, 1); };\n        Color3.Purple = function () { return new Color3(0.5, 0, 0.5); };\n        Color3.Magenta = function () { return new Color3(1, 0, 1); };\n        Color3.Yellow = function () { return new Color3(1, 1, 0); };\n        Color3.Gray = function () { return new Color3(0.5, 0.5, 0.5); };\n        Color3.Random = function () { return new Color3(Math.random(), Math.random(), Math.random()); };\n        return Color3;\n    }());\n    BABYLON.Color3 = Color3;\n    var Color4 = (function () {\n        /**\n         * Creates a new Color4 object from the passed float values ( < 1) : red, green, blue, alpha.\n         */\n        function Color4(r, g, b, a) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n        }\n        // Operators\n        /**\n         * Adds in place the passed Color4 values to the current Color4.\n         * Returns the updated Color4.\n         */\n        Color4.prototype.addInPlace = function (right) {\n            this.r += right.r;\n            this.g += right.g;\n            this.b += right.b;\n            this.a += right.a;\n            return this;\n        };\n        /**\n         * Returns a new array populated with 4 numeric elements : red, green, blue, alpha values.\n         */\n        Color4.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        /**\n         * Stores from the starting index in the passed array the Color4 successive values.\n         * Returns the Color4.\n         */\n        Color4.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.r;\n            array[index + 1] = this.g;\n            array[index + 2] = this.b;\n            array[index + 3] = this.a;\n            return this;\n        };\n        /**\n         * Returns a new Color4 set with the added values of the current Color4 and of the passed one.\n         */\n        Color4.prototype.add = function (right) {\n            return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n        };\n        /**\n         * Returns a new Color4 set with the subtracted values of the passed one from the current Color4.\n         */\n        Color4.prototype.subtract = function (right) {\n            return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n        };\n        /**\n         * Subtracts the passed ones from the current Color4 values and stores the results in \"result\".\n         * Returns the Color4.\n         */\n        Color4.prototype.subtractToRef = function (right, result) {\n            result.r = this.r - right.r;\n            result.g = this.g - right.g;\n            result.b = this.b - right.b;\n            result.a = this.a - right.a;\n            return this;\n        };\n        /**\n         * Creates a new Color4 with the current Color4 values multiplied by scale.\n         */\n        Color4.prototype.scale = function (scale) {\n            return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n        };\n        /**\n         * Multiplies the current Color4 values by scale and stores the result in \"result\".\n         * Returns the Color4.\n         */\n        Color4.prototype.scaleToRef = function (scale, result) {\n            result.r = this.r * scale;\n            result.g = this.g * scale;\n            result.b = this.b * scale;\n            result.a = this.a * scale;\n            return this;\n        };\n        /**\n          * Multipy an RGBA Color4 value by another and return a new Color4 object\n          * @param color The Color4 (RGBA) value to multiply by\n          * @returns A new Color4.\n          */\n        Color4.prototype.multiply = function (color) {\n            return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n        };\n        /**\n         * Multipy an RGBA Color4 value by another and push the result in a reference value\n         * @param color The Color4 (RGBA) value to multiply by\n         * @param result The Color4 (RGBA) to fill the result in\n         * @returns the result Color4.\n         */\n        Color4.prototype.multiplyToRef = function (color, result) {\n            result.r = this.r * color.r;\n            result.g = this.g * color.g;\n            result.b = this.b * color.b;\n            result.a = this.a * color.a;\n            return result;\n        };\n        /**\n         * Returns a string with the Color4 values.\n         */\n        Color4.prototype.toString = function () {\n            return \"{R: \" + this.r + \" G:\" + this.g + \" B:\" + this.b + \" A:\" + this.a + \"}\";\n        };\n        /**\n         * Returns the string \"Color4\"\n         */\n        Color4.prototype.getClassName = function () {\n            return \"Color4\";\n        };\n        /**\n         * Return the Color4 hash code as a number.\n         */\n        Color4.prototype.getHashCode = function () {\n            var hash = this.r || 0;\n            hash = (hash * 397) ^ (this.g || 0);\n            hash = (hash * 397) ^ (this.b || 0);\n            hash = (hash * 397) ^ (this.a || 0);\n            return hash;\n        };\n        /**\n         * Creates a new Color4 copied from the current one.\n         */\n        Color4.prototype.clone = function () {\n            return new Color4(this.r, this.g, this.b, this.a);\n        };\n        /**\n         * Copies the passed Color4 values into the current one.\n         * Returns the updated Color4.\n         */\n        Color4.prototype.copyFrom = function (source) {\n            this.r = source.r;\n            this.g = source.g;\n            this.b = source.b;\n            this.a = source.a;\n            return this;\n        };\n        /**\n         * Copies the passed float values into the current one.\n         * Returns the updated Color4.\n         */\n        Color4.prototype.copyFromFloats = function (r, g, b, a) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n            return this;\n        };\n        /**\n         * Copies the passed float values into the current one.\n         * Returns the updated Color4.\n         */\n        Color4.prototype.set = function (r, g, b, a) {\n            return this.copyFromFloats(r, g, b, a);\n        };\n        /**\n         * Returns a string containing the hexadecimal Color4 code.\n         */\n        Color4.prototype.toHexString = function () {\n            var intR = (this.r * 255) | 0;\n            var intG = (this.g * 255) | 0;\n            var intB = (this.b * 255) | 0;\n            var intA = (this.a * 255) | 0;\n            return \"#\" + MathTools.ToHex(intR) + MathTools.ToHex(intG) + MathTools.ToHex(intB) + MathTools.ToHex(intA);\n        };\n        // Statics\n        /**\n         * Creates a new Color4 from the valid hexadecimal value contained in the passed string.\n         */\n        Color4.FromHexString = function (hex) {\n            if (hex.substring(0, 1) !== \"#\" || hex.length !== 9) {\n                //Tools.Warn(\"Color4.FromHexString must be called with a string like #FFFFFFFF\");\n                return new Color4(0.0, 0.0, 0.0, 0.0);\n            }\n            var r = parseInt(hex.substring(1, 3), 16);\n            var g = parseInt(hex.substring(3, 5), 16);\n            var b = parseInt(hex.substring(5, 7), 16);\n            var a = parseInt(hex.substring(7, 9), 16);\n            return Color4.FromInts(r, g, b, a);\n        };\n        /**\n         * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 and the right Color4.\n         */\n        Color4.Lerp = function (left, right, amount) {\n            var result = new Color4(0.0, 0.0, 0.0, 0.0);\n            Color4.LerpToRef(left, right, amount, result);\n            return result;\n        };\n        /**\n         * Set the passed \"result\" with the linearly interpolated values of \"amount\" between the left Color4 and the right Color4.\n         */\n        Color4.LerpToRef = function (left, right, amount, result) {\n            result.r = left.r + (right.r - left.r) * amount;\n            result.g = left.g + (right.g - left.g) * amount;\n            result.b = left.b + (right.b - left.b) * amount;\n            result.a = left.a + (right.a - left.a) * amount;\n        };\n        /**\n         * Creates a new Color4 from the starting index element of the passed array.\n         */\n        Color4.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        /**\n         * Creates a new Color4 from the passed integers ( < 256 ).\n         */\n        Color4.FromInts = function (r, g, b, a) {\n            return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n        };\n        Color4.CheckColors4 = function (colors, count) {\n            // Check if color3 was used\n            if (colors.length === count * 3) {\n                var colors4 = [];\n                for (var index = 0; index < colors.length; index += 3) {\n                    var newIndex = (index / 3) * 4;\n                    colors4[newIndex] = colors[index];\n                    colors4[newIndex + 1] = colors[index + 1];\n                    colors4[newIndex + 2] = colors[index + 2];\n                    colors4[newIndex + 3] = 1.0;\n                }\n                return colors4;\n            }\n            return colors;\n        };\n        return Color4;\n    }());\n    BABYLON.Color4 = Color4;\n    var Vector2 = (function () {\n        /**\n         * Creates a new Vector2 from the passed x and y coordinates.\n         */\n        function Vector2(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        /**\n         * Returns a string with the Vector2 coordinates.\n         */\n        Vector2.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \"}\";\n        };\n        /**\n         * Returns the string \"Vector2\"\n         */\n        Vector2.prototype.getClassName = function () {\n            return \"Vector2\";\n        };\n        /**\n         * Returns the Vector2 hash code as a number.\n         */\n        Vector2.prototype.getHashCode = function () {\n            var hash = this.x || 0;\n            hash = (hash * 397) ^ (this.y || 0);\n            return hash;\n        };\n        // Operators\n        /**\n         * Sets the Vector2 coordinates in the passed array or Float32Array from the passed index.\n         * Returns the Vector2.\n         */\n        Vector2.prototype.toArray = function (array, index) {\n            if (index === void 0) { index = 0; }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            return this;\n        };\n        /**\n         * Returns a new array with 2 elements : the Vector2 coordinates.\n         */\n        Vector2.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        /**\n         *  Sets the Vector2 coordinates with the passed Vector2 coordinates.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            return this;\n        };\n        /**\n         * Sets the Vector2 coordinates with the passed floats.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.copyFromFloats = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        /**\n         * Sets the Vector2 coordinates with the passed floats.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.set = function (x, y) {\n            return this.copyFromFloats(x, y);\n        };\n        /**\n         * Returns a new Vector2 set with the addition of the current Vector2 and the passed one coordinates.\n         */\n        Vector2.prototype.add = function (otherVector) {\n            return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n        };\n        /**\n         * Sets the \"result\" coordinates with the addition of the current Vector2 and the passed one coordinates.\n         * Returns the Vector2.\n         */\n        Vector2.prototype.addToRef = function (otherVector, result) {\n            result.x = this.x + otherVector.x;\n            result.y = this.y + otherVector.y;\n            return this;\n        };\n        /**\n         * Set the Vector2 coordinates by adding the passed Vector2 coordinates.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.addInPlace = function (otherVector) {\n            this.x += otherVector.x;\n            this.y += otherVector.y;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 by adding the current Vector2 coordinates to the passed Vector3 x, y coordinates.\n         */\n        Vector2.prototype.addVector3 = function (otherVector) {\n            return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n        };\n        /**\n         * Returns a new Vector2 set with the subtracted coordinates of the passed one from the current Vector2.\n         */\n        Vector2.prototype.subtract = function (otherVector) {\n            return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n        };\n        /**\n         * Sets the \"result\" coordinates with the subtraction of the passed one from the current Vector2 coordinates.\n         * Returns the Vector2.\n         */\n        Vector2.prototype.subtractToRef = function (otherVector, result) {\n            result.x = this.x - otherVector.x;\n            result.y = this.y - otherVector.y;\n            return this;\n        };\n        /**\n         * Sets the current Vector2 coordinates by subtracting from it the passed one coordinates.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            return this;\n        };\n        /**\n         * Multiplies in place the current Vector2 coordinates by the passed ones.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 set with the multiplication of the current Vector2 and the passed one coordinates.\n         */\n        Vector2.prototype.multiply = function (otherVector) {\n            return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n        };\n        /**\n         * Sets \"result\" coordinates with the multiplication of the current Vector2 and the passed one coordinates.\n         * Returns the Vector2.\n         */\n        Vector2.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 set with the Vector2 coordinates multiplied by the passed floats.\n         */\n        Vector2.prototype.multiplyByFloats = function (x, y) {\n            return new Vector2(this.x * x, this.y * y);\n        };\n        /**\n         * Returns a new Vector2 set with the Vector2 coordinates divided by the passed one coordinates.\n         */\n        Vector2.prototype.divide = function (otherVector) {\n            return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n        };\n        /**\n         * Sets the \"result\" coordinates with the Vector2 divided by the passed one coordinates.\n         * Returns the Vector2.\n         */\n        Vector2.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x / otherVector.x;\n            result.y = this.y / otherVector.y;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 with current Vector2 negated coordinates.\n         */\n        Vector2.prototype.negate = function () {\n            return new Vector2(-this.x, -this.y);\n        };\n        /**\n         * Multiply the Vector2 coordinates by scale.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 scaled by \"scale\" from the current Vector2.\n         */\n        Vector2.prototype.scale = function (scale) {\n            return new Vector2(this.x * scale, this.y * scale);\n        };\n        /**\n         * Boolean : True if the passed vector coordinates strictly equal the current Vector2 ones.\n         */\n        Vector2.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n        };\n        /**\n         * Boolean : True if the passed vector coordinates are close to the current ones by a distance of epsilon.\n         */\n        Vector2.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n            if (epsilon === void 0) { epsilon = BABYLON.Epsilon; }\n            return otherVector && MathTools.WithinEpsilon(this.x, otherVector.x, epsilon) && MathTools.WithinEpsilon(this.y, otherVector.y, epsilon);\n        };\n        // Properties\n        /**\n         * Returns the vector length (float).\n         */\n        Vector2.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        /**\n         * Returns the vector squared length (float);\n         */\n        Vector2.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y);\n        };\n        // Methods\n        /**\n         * Normalize the vector.\n         * Returns the updated Vector2.\n         */\n        Vector2.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0)\n                return this;\n            var num = 1.0 / len;\n            this.x *= num;\n            this.y *= num;\n            return this;\n        };\n        /**\n         * Returns a new Vector2 copied from the Vector2.\n         */\n        Vector2.prototype.clone = function () {\n            return new Vector2(this.x, this.y);\n        };\n        // Statics\n        /**\n         * Returns a new Vector2(0, 0)\n         */\n        Vector2.Zero = function () {\n            return new Vector2(0, 0);\n        };\n        /**\n         * Returns a new Vector2(1, 1)\n         */\n        Vector2.One = function () {\n            return new Vector2(1, 1);\n        };\n        /**\n         * Returns a new Vector2 set from the passed index element of the passed array.\n         */\n        Vector2.FromArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            return new Vector2(array[offset], array[offset + 1]);\n        };\n        /**\n         * Sets \"result\" from the passed index element of the passed array.\n         */\n        Vector2.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n        };\n        /**\n         * Retuns a new Vector2 located for \"amount\" (float) on the CatmullRom  spline defined by the passed four Vector2.\n         */\n        Vector2.CatmullRom = function (value1, value2, value3, value4, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) +\n                (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) +\n                ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\n            var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) +\n                (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) +\n                ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n         * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n         * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate.\n         */\n        Vector2.Clamp = function (value, min, max) {\n            var x = value.x;\n            x = (x > max.x) ? max.x : x;\n            x = (x < min.x) ? min.x : x;\n            var y = value.y;\n            y = (y > max.y) ? max.y : y;\n            y = (y < min.y) ? min.y : y;\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n         */\n        Vector2.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\n            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n         */\n        Vector2.Lerp = function (start, end, amount) {\n            var x = start.x + ((end.x - start.x) * amount);\n            var y = start.y + ((end.y - start.y) * amount);\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns the dot product (float) of the vector \"left\" and the vector \"right\".\n         */\n        Vector2.Dot = function (left, right) {\n            return left.x * right.x + left.y * right.y;\n        };\n        /**\n         * Returns a new Vector2 equal to the normalized passed vector.\n         */\n        Vector2.Normalize = function (vector) {\n            var newVector = vector.clone();\n            newVector.normalize();\n            return newVector;\n        };\n        /**\n         * Returns a new Vecto2 set with the minimal coordinate values from the \"left\" and \"right\" vectors.\n         */\n        Vector2.Minimize = function (left, right) {\n            var x = (left.x < right.x) ? left.x : right.x;\n            var y = (left.y < right.y) ? left.y : right.y;\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors.\n         */\n        Vector2.Maximize = function (left, right) {\n            var x = (left.x > right.x) ? left.x : right.x;\n            var y = (left.y > right.y) ? left.y : right.y;\n            return new Vector2(x, y);\n        };\n        /**\n         * Returns a new Vecto2 set with the transformed coordinates of the passed vector by the passed transformation matrix.\n         */\n        Vector2.Transform = function (vector, transformation) {\n            var r = Vector2.Zero();\n            Vector2.TransformToRef(vector, transformation, r);\n            return r;\n        };\n        /**\n         * Transforms the passed vector coordinates by the passed transformation matrix and stores the result in the vector \"result\" coordinates.\n         */\n        Vector2.TransformToRef = function (vector, transformation, result) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + transformation.m[12];\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + transformation.m[13];\n            result.x = x;\n            result.y = y;\n        };\n        /**\n         * Boolean : True if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\n         */\n        Vector2.PointInTriangle = function (p, p0, p1, p2) {\n            var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);\n            var sign = a < 0 ? -1 : 1;\n            var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;\n            var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;\n            return s > 0 && t > 0 && (s + t) < 2 * a * sign;\n        };\n        /**\n         * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector2.Distance = function (value1, value2) {\n            return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n        };\n        /**\n         * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector2.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            return (x * x) + (y * y);\n        };\n        /**\n         * Returns a new Vecto2 located at the center of the vectors \"value1\" and \"value2\".\n         */\n        Vector2.Center = function (value1, value2) {\n            var center = value1.add(value2);\n            center.scaleInPlace(0.5);\n            return center;\n        };\n        /**\n         * Returns the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n         */\n        Vector2.DistanceOfPointFromSegment = function (p, segA, segB) {\n            var l2 = Vector2.DistanceSquared(segA, segB);\n            if (l2 === 0.0) {\n                return Vector2.Distance(p, segA);\n            }\n            var v = segB.subtract(segA);\n            var t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n            var proj = segA.add(v.multiplyByFloats(t, t));\n            return Vector2.Distance(p, proj);\n        };\n        return Vector2;\n    }());\n    BABYLON.Vector2 = Vector2;\n    var Vector3 = (function () {\n        /**\n         * Creates a new Vector3 object from the passed x, y, z (floats) coordinates.\n         * A Vector3 is the main object used in 3D geometry.\n         * It can represent etiher the coordinates of a point the space, either a direction.\n         */\n        function Vector3(x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n        /**\n         * Returns a string with the Vector3 coordinates.\n         */\n        Vector3.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \"}\";\n        };\n        /**\n         * Returns the string \"Vector3\"\n         */\n        Vector3.prototype.getClassName = function () {\n            return \"Vector3\";\n        };\n        /**\n         * Returns the Vector hash code.\n         */\n        Vector3.prototype.getHashCode = function () {\n            var hash = this.x || 0;\n            hash = (hash * 397) ^ (this.y || 0);\n            hash = (hash * 397) ^ (this.z || 0);\n            return hash;\n        };\n        // Operators\n        /**\n         * Returns a new array with three elements : the coordinates the Vector3.\n         */\n        Vector3.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        /**\n         * Populates the passed array or Float32Array from the passed index with the successive coordinates of the Vector3.\n         * Returns the Vector3.\n         */\n        Vector3.prototype.toArray = function (array, index) {\n            if (index === void 0) { index = 0; }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            array[index + 2] = this.z;\n            return this;\n        };\n        /**\n         * Returns a new Quaternion object, computed from the Vector3 coordinates.\n         */\n        Vector3.prototype.toQuaternion = function () {\n            var result = new Quaternion(0.0, 0.0, 0.0, 1.0);\n            var cosxPlusz = Math.cos((this.x + this.z) * 0.5);\n            var sinxPlusz = Math.sin((this.x + this.z) * 0.5);\n            var coszMinusx = Math.cos((this.z - this.x) * 0.5);\n            var sinzMinusx = Math.sin((this.z - this.x) * 0.5);\n            var cosy = Math.cos(this.y * 0.5);\n            var siny = Math.sin(this.y * 0.5);\n            result.x = coszMinusx * siny;\n            result.y = -sinzMinusx * siny;\n            result.z = sinxPlusz * cosy;\n            result.w = cosxPlusz * cosy;\n            return result;\n        };\n        /**\n         * Adds the passed vector to the current Vector3.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.addInPlace = function (otherVector) {\n            this.x += otherVector.x;\n            this.y += otherVector.y;\n            this.z += otherVector.z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3, result of the addition the current Vector3 and the passed vector.\n         */\n        Vector3.prototype.add = function (otherVector) {\n            return new Vector3(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n        };\n        /**\n         * Adds the current Vector3 to the passed one and stores the result in the vector \"result\".\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.addToRef = function (otherVector, result) {\n            result.x = this.x + otherVector.x;\n            result.y = this.y + otherVector.y;\n            result.z = this.z + otherVector.z;\n            return this;\n        };\n        /**\n         * Subtract the passed vector from the current Vector3.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            this.z -= otherVector.z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3, result of the subtraction of the passed vector from the current Vector3.\n         */\n        Vector3.prototype.subtract = function (otherVector) {\n            return new Vector3(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z);\n        };\n        /**\n         * Subtracts the passed vector from the current Vector3 and stores the result in the vector \"result\".\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.subtractToRef = function (otherVector, result) {\n            result.x = this.x - otherVector.x;\n            result.y = this.y - otherVector.y;\n            result.z = this.z - otherVector.z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the subtraction of the passed floats from the current Vector3 coordinates.\n         */\n        Vector3.prototype.subtractFromFloats = function (x, y, z) {\n            return new Vector3(this.x - x, this.y - y, this.z - z);\n        };\n        /**\n         * Subtracts the passed floats from the current Vector3 coordinates and set the passed vector \"result\" with this result.\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.subtractFromFloatsToRef = function (x, y, z, result) {\n            result.x = this.x - x;\n            result.y = this.y - y;\n            result.z = this.z - z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the current Vector3 negated coordinates.\n         */\n        Vector3.prototype.negate = function () {\n            return new Vector3(-this.x, -this.y, -this.z);\n        };\n        /**\n         * Multiplies the Vector3 coordinates by the float \"scale\".\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            this.z *= scale;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\".\n         */\n        Vector3.prototype.scale = function (scale) {\n            return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n        };\n        /**\n         * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the passed vector \"result\" coordinates.\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.scaleToRef = function (scale, result) {\n            result.x = this.x * scale;\n            result.y = this.y * scale;\n            result.z = this.z * scale;\n            return this;\n        };\n        /**\n         * Boolean : True if the current Vector3 and the passed vector coordinates are strictly equal.\n         */\n        Vector3.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z;\n        };\n        /**\n         * Boolean : True if the current Vector3 and the passed vector coordinates are distant less than epsilon.\n         */\n        Vector3.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n            if (epsilon === void 0) { epsilon = BABYLON.Epsilon; }\n            return otherVector && MathTools.WithinEpsilon(this.x, otherVector.x, epsilon) && MathTools.WithinEpsilon(this.y, otherVector.y, epsilon) && MathTools.WithinEpsilon(this.z, otherVector.z, epsilon);\n        };\n        /**\n         * Boolean : True if the current Vector3 coordinate equal the passed floats.\n         */\n        Vector3.prototype.equalsToFloats = function (x, y, z) {\n            return this.x === x && this.y === y && this.z === z;\n        };\n        /**\n         * Muliplies the current Vector3 coordinates by the passed ones.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            this.z *= otherVector.z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3, result of the multiplication of the current Vector3 by the passed vector.\n         */\n        Vector3.prototype.multiply = function (otherVector) {\n            return new Vector3(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z);\n        };\n        /**\n         * Multiplies the current Vector3 by the passed one and stores the result in the passed vector \"result\".\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            result.z = this.z * otherVector.z;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set witth the result of the mulliplication of the current Vector3 coordinates by the passed floats.\n         */\n        Vector3.prototype.multiplyByFloats = function (x, y, z) {\n            return new Vector3(this.x * x, this.y * y, this.z * z);\n        };\n        /**\n         * Returns a new Vector3 set witth the result of the division of the current Vector3 coordinates by the passed ones.\n         */\n        Vector3.prototype.divide = function (otherVector) {\n            return new Vector3(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\n        };\n        /**\n         * Divides the current Vector3 coordinates by the passed ones and stores the result in the passed vector \"result\".\n         * Returns the current Vector3.\n         */\n        Vector3.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x / otherVector.x;\n            result.y = this.y / otherVector.y;\n            result.z = this.z / otherVector.z;\n            return this;\n        };\n        /**\n         * Updates the current Vector3 with the minimal coordinate values between its and the passed vector ones.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.MinimizeInPlace = function (other) {\n            if (other.x < this.x)\n                this.x = other.x;\n            if (other.y < this.y)\n                this.y = other.y;\n            if (other.z < this.z)\n                this.z = other.z;\n            return this;\n        };\n        /**\n         * Updates the current Vector3 with the maximal coordinate values between its and the passed vector ones.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.MaximizeInPlace = function (other) {\n            if (other.x > this.x)\n                this.x = other.x;\n            if (other.y > this.y)\n                this.y = other.y;\n            if (other.z > this.z)\n                this.z = other.z;\n            return this;\n        };\n        // Properties\n        /**\n         * Returns the length of the Vector3 (float).\n         */\n        Vector3.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        };\n        /**\n         * Returns the squared length of the Vector3 (float).\n         */\n        Vector3.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y + this.z * this.z);\n        };\n        // Methods\n        /**\n         * Normalize the current Vector3.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0 || len === 1.0)\n                return this;\n            var num = 1.0 / len;\n            this.x *= num;\n            this.y *= num;\n            this.z *= num;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 copied from the current Vector3.\n         */\n        Vector3.prototype.clone = function () {\n            return new Vector3(this.x, this.y, this.z);\n        };\n        /**\n         * Copies the passed vector coordinates to the current Vector3 ones.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            this.z = source.z;\n            return this;\n        };\n        /**\n         * Copies the passed floats to the current Vector3 coordinates.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.copyFromFloats = function (x, y, z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            return this;\n        };\n        /**\n         * Copies the passed floats to the current Vector3 coordinates.\n         * Returns the updated Vector3.\n         */\n        Vector3.prototype.set = function (x, y, z) {\n            return this.copyFromFloats(x, y, z);\n        };\n        // Statics\n        /**\n         *\n         */\n        Vector3.GetClipFactor = function (vector0, vector1, axis, size) {\n            var d0 = Vector3.Dot(vector0, axis) - size;\n            var d1 = Vector3.Dot(vector1, axis) - size;\n            var s = d0 / (d0 - d1);\n            return s;\n        };\n        /**\n         * Returns a new Vector3 set from the index \"offset\" of the passed array.\n         */\n        Vector3.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n        };\n        /**\n         * Returns a new Vector3 set from the index \"offset\" of the passed Float32Array.\n         * This function is deprecated.  Use FromArray instead.\n         */\n        Vector3.FromFloatArray = function (array, offset) {\n            return Vector3.FromArray(array, offset);\n        };\n        /**\n         * Sets the passed vector \"result\" with the element values from the index \"offset\" of the passed array.\n         */\n        Vector3.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n        };\n        /**\n         * Sets the passed vector \"result\" with the element values from the index \"offset\" of the passed Float32Array.\n         * This function is deprecated.  Use FromArrayToRef instead.\n         */\n        Vector3.FromFloatArrayToRef = function (array, offset, result) {\n            return Vector3.FromArrayToRef(array, offset, result);\n        };\n        /**\n         * Sets the passed vector \"result\" with the passed floats.\n         */\n        Vector3.FromFloatsToRef = function (x, y, z, result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n        };\n        /**\n         * Returns a new Vector3 set to (0.0, 0.0, 0.0).\n         */\n        Vector3.Zero = function () {\n            return new Vector3(0.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new Vector3 set to (1.0, 1.0, 1.0).\n         */\n        Vector3.One = function () {\n            return new Vector3(1.0, 1.0, 1.0);\n        };\n        /**\n         * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n         */\n        Vector3.Up = function () {\n            return new Vector3(0.0, 1.0, 0.0);\n        };\n        /**\n         * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n         */\n        Vector3.Forward = function () {\n            return new Vector3(0.0, 0.0, 1.0);\n        };\n        /**\n         * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n         */\n        Vector3.Right = function () {\n            return new Vector3(1.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n         */\n        Vector3.Left = function () {\n            return new Vector3(-1.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new Vector3 set with the result of the transformation by the passed matrix of the passed vector.\n         * This method computes tranformed coordinates only, not transformed direction vectors.\n         */\n        Vector3.TransformCoordinates = function (vector, transformation) {\n            var result = Vector3.Zero();\n            Vector3.TransformCoordinatesToRef(vector, transformation, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" coordinates with the result of the transformation by the passed matrix of the passed vector.\n         * This method computes tranformed coordinates only, not transformed direction vectors.\n         */\n        Vector3.TransformCoordinatesToRef = function (vector, transformation, result) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]) + transformation.m[12];\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]) + transformation.m[13];\n            var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]) + transformation.m[14];\n            var w = (vector.x * transformation.m[3]) + (vector.y * transformation.m[7]) + (vector.z * transformation.m[11]) + transformation.m[15];\n            result.x = x / w;\n            result.y = y / w;\n            result.z = z / w;\n        };\n        /**\n         * Sets the passed vector \"result\" coordinates with the result of the transformation by the passed matrix of the passed floats (x, y, z).\n         * This method computes tranformed coordinates only, not transformed direction vectors.\n         */\n        Vector3.TransformCoordinatesFromFloatsToRef = function (x, y, z, transformation, result) {\n            var rx = (x * transformation.m[0]) + (y * transformation.m[4]) + (z * transformation.m[8]) + transformation.m[12];\n            var ry = (x * transformation.m[1]) + (y * transformation.m[5]) + (z * transformation.m[9]) + transformation.m[13];\n            var rz = (x * transformation.m[2]) + (y * transformation.m[6]) + (z * transformation.m[10]) + transformation.m[14];\n            var rw = (x * transformation.m[3]) + (y * transformation.m[7]) + (z * transformation.m[11]) + transformation.m[15];\n            result.x = rx / rw;\n            result.y = ry / rw;\n            result.z = rz / rw;\n        };\n        /**\n         * Returns a new Vector3 set with the result of the normal transformation by the passed matrix of the passed vector.\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector3.TransformNormal = function (vector, transformation) {\n            var result = Vector3.Zero();\n            Vector3.TransformNormalToRef(vector, transformation, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the normal transformation by the passed matrix of the passed vector.\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector3.TransformNormalToRef = function (vector, transformation, result) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]);\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]);\n            var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]);\n            result.x = x;\n            result.y = y;\n            result.z = z;\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the normal transformation by the passed matrix of the passed floats (x, y, z).\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector3.TransformNormalFromFloatsToRef = function (x, y, z, transformation, result) {\n            result.x = (x * transformation.m[0]) + (y * transformation.m[4]) + (z * transformation.m[8]);\n            result.y = (x * transformation.m[1]) + (y * transformation.m[5]) + (z * transformation.m[9]);\n            result.z = (x * transformation.m[2]) + (y * transformation.m[6]) + (z * transformation.m[10]);\n        };\n        /**\n         * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\".\n         */\n        Vector3.CatmullRom = function (value1, value2, value3, value4, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var x = 0.5 * ((((2.0 * value2.x) + ((-value1.x + value3.x) * amount)) +\n                (((((2.0 * value1.x) - (5.0 * value2.x)) + (4.0 * value3.x)) - value4.x) * squared)) +\n                ((((-value1.x + (3.0 * value2.x)) - (3.0 * value3.x)) + value4.x) * cubed));\n            var y = 0.5 * ((((2.0 * value2.y) + ((-value1.y + value3.y) * amount)) +\n                (((((2.0 * value1.y) - (5.0 * value2.y)) + (4.0 * value3.y)) - value4.y) * squared)) +\n                ((((-value1.y + (3.0 * value2.y)) - (3.0 * value3.y)) + value4.y) * cubed));\n            var z = 0.5 * ((((2.0 * value2.z) + ((-value1.z + value3.z) * amount)) +\n                (((((2.0 * value1.z) - (5.0 * value2.z)) + (4.0 * value3.z)) - value4.z) * squared)) +\n                ((((-value1.z + (3.0 * value2.z)) - (3.0 * value3.z)) + value4.z) * cubed));\n            return new Vector3(x, y, z);\n        };\n        /**\n         * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\".\n         * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one.\n         * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one.\n         */\n        Vector3.Clamp = function (value, min, max) {\n            var x = value.x;\n            x = (x > max.x) ? max.x : x;\n            x = (x < min.x) ? min.x : x;\n            var y = value.y;\n            y = (y > max.y) ? max.y : y;\n            y = (y < min.y) ? min.y : y;\n            var z = value.z;\n            z = (z > max.z) ? max.z : z;\n            z = (z < min.z) ? min.z : z;\n            return new Vector3(x, y, z);\n        };\n        /**\n         * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\".\n         */\n        Vector3.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\n            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\n            var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);\n            return new Vector3(x, y, z);\n        };\n        /**\n         * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\".\n         */\n        Vector3.Lerp = function (start, end, amount) {\n            var result = new Vector3(0, 0, 0);\n            Vector3.LerpToRef(start, end, amount, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\".\n         */\n        Vector3.LerpToRef = function (start, end, amount, result) {\n            result.x = start.x + ((end.x - start.x) * amount);\n            result.y = start.y + ((end.y - start.y) * amount);\n            result.z = start.z + ((end.z - start.z) * amount);\n        };\n        /**\n         * Returns the dot product (float) between the vectors \"left\" and \"right\".\n         */\n        Vector3.Dot = function (left, right) {\n            return (left.x * right.x + left.y * right.y + left.z * right.z);\n        };\n        /**\n         * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\".\n         * The cross product is then orthogonal to both \"left\" and \"right\".\n         */\n        Vector3.Cross = function (left, right) {\n            var result = Vector3.Zero();\n            Vector3.CrossToRef(left, right, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" with the cross product of \"left\" and \"right\".\n         * The cross product is then orthogonal to both \"left\" and \"right\".\n         */\n        Vector3.CrossToRef = function (left, right, result) {\n            MathTmp.Vector3[0].x = left.y * right.z - left.z * right.y;\n            MathTmp.Vector3[0].y = left.z * right.x - left.x * right.z;\n            MathTmp.Vector3[0].z = left.x * right.y - left.y * right.x;\n            result.copyFrom(MathTmp.Vector3[0]);\n        };\n        /**\n         * Returns a new Vector3 as the normalization of the passed vector.\n         */\n        Vector3.Normalize = function (vector) {\n            var result = Vector3.Zero();\n            Vector3.NormalizeToRef(vector, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" with the normalization of the passed first vector.\n         */\n        Vector3.NormalizeToRef = function (vector, result) {\n            result.copyFrom(vector);\n            result.normalize();\n        };\n        Vector3.Project = function (vector, world, transform, viewport) {\n            var cw = viewport.width;\n            var ch = viewport.height;\n            var cx = viewport.x;\n            var cy = viewport.y;\n            var viewportMatrix = Vector3._viewportMatrixCache ? Vector3._viewportMatrixCache : (Vector3._viewportMatrixCache = new Matrix());\n            Matrix.FromValuesToRef(cw / 2.0, 0, 0, 0, 0, -ch / 2.0, 0, 0, 0, 0, 0.5, 0, cx + cw / 2.0, ch / 2.0 + cy, 0.5, 1, viewportMatrix);\n            var matrix = Vector3._matrixCache ? Vector3._matrixCache : (Vector3._matrixCache = new Matrix());\n            world.multiplyToRef(transform, matrix);\n            matrix.multiplyToRef(viewportMatrix, matrix);\n            return Vector3.TransformCoordinates(vector, matrix);\n        };\n        Vector3.UnprojectFromTransform = function (source, viewportWidth, viewportHeight, world, transform) {\n            var matrix = Vector3._matrixCache ? Vector3._matrixCache : (Vector3._matrixCache = new Matrix());\n            world.multiplyToRef(transform, matrix);\n            matrix.invert();\n            source.x = source.x / viewportWidth * 2 - 1;\n            source.y = -(source.y / viewportHeight * 2 - 1);\n            var vector = Vector3.TransformCoordinates(source, matrix);\n            var num = source.x * matrix.m[3] + source.y * matrix.m[7] + source.z * matrix.m[11] + matrix.m[15];\n            if (MathTools.WithinEpsilon(num, 1.0)) {\n                vector = vector.scale(1.0 / num);\n            }\n            return vector;\n        };\n        Vector3.Unproject = function (source, viewportWidth, viewportHeight, world, view, projection) {\n            var matrix = Vector3._matrixCache ? Vector3._matrixCache : (Vector3._matrixCache = new Matrix());\n            world.multiplyToRef(view, matrix);\n            matrix.multiplyToRef(projection, matrix);\n            matrix.invert();\n            var screenSource = new Vector3(source.x / viewportWidth * 2 - 1, -(source.y / viewportHeight * 2 - 1), 2 * source.z - 1.0);\n            var vector = Vector3.TransformCoordinates(screenSource, matrix);\n            var num = screenSource.x * matrix.m[3] + screenSource.y * matrix.m[7] + screenSource.z * matrix.m[11] + matrix.m[15];\n            if (MathTools.WithinEpsilon(num, 1.0)) {\n                vector = vector.scale(1.0 / num);\n            }\n            return vector;\n        };\n        Vector3.Minimize = function (left, right) {\n            var min = left.clone();\n            min.MinimizeInPlace(right);\n            return min;\n        };\n        Vector3.Maximize = function (left, right) {\n            var max = left.clone();\n            max.MaximizeInPlace(right);\n            return max;\n        };\n        /**\n         * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector3.Distance = function (value1, value2) {\n            return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n        };\n        /**\n         * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector3.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            var z = value1.z - value2.z;\n            return (x * x) + (y * y) + (z * z);\n        };\n        /**\n         * Returns a new Vector3 located at the center between \"value1\" and \"value2\".\n         */\n        Vector3.Center = function (value1, value2) {\n            var center = value1.add(value2);\n            center.scaleInPlace(0.5);\n            return center;\n        };\n        /**\n         * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n         * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n         * to something in order to rotate it from its local system to the given target system.\n         * Note : axis1, axis2 and axis3 are normalized during this operation.\n         * Returns a new Vector3.\n         */\n        Vector3.RotationFromAxis = function (axis1, axis2, axis3) {\n            var rotation = Vector3.Zero();\n            Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n            return rotation;\n        };\n        /**\n         * The same than RotationFromAxis but updates the passed ref Vector3 parameter instead of returning a new Vector3.\n         */\n        Vector3.RotationFromAxisToRef = function (axis1, axis2, axis3, ref) {\n            var quat = MathTmp.Quaternion[0];\n            Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n            quat.toEulerAnglesToRef(ref);\n        };\n        return Vector3;\n    }());\n    BABYLON.Vector3 = Vector3;\n    //Vector4 class created for EulerAngle class conversion to Quaternion\n    var Vector4 = (function () {\n        /**\n         * Creates a Vector4 object from the passed floats.\n         */\n        function Vector4(x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n        }\n        /**\n         * Returns the string with the Vector4 coordinates.\n         */\n        Vector4.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n        };\n        /**\n         * Returns the string \"Vector4\".\n         */\n        Vector4.prototype.getClassName = function () {\n            return \"Vector4\";\n        };\n        /**\n         * Returns the Vector4 hash code.\n         */\n        Vector4.prototype.getHashCode = function () {\n            var hash = this.x || 0;\n            hash = (hash * 397) ^ (this.y || 0);\n            hash = (hash * 397) ^ (this.z || 0);\n            hash = (hash * 397) ^ (this.w || 0);\n            return hash;\n        };\n        // Operators\n        /**\n         * Returns a new array populated with 4 elements : the Vector4 coordinates.\n         */\n        Vector4.prototype.asArray = function () {\n            var result = [];\n            this.toArray(result, 0);\n            return result;\n        };\n        /**\n         * Populates the passed array from the passed index with the Vector4 coordinates.\n         * Returns the Vector4.\n         */\n        Vector4.prototype.toArray = function (array, index) {\n            if (index === undefined) {\n                index = 0;\n            }\n            array[index] = this.x;\n            array[index + 1] = this.y;\n            array[index + 2] = this.z;\n            array[index + 3] = this.w;\n            return this;\n        };\n        /**\n         * Adds the passed vector to the current Vector4.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.addInPlace = function (otherVector) {\n            this.x += otherVector.x;\n            this.y += otherVector.y;\n            this.z += otherVector.z;\n            this.w += otherVector.w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 as the result of the addition of the current Vector4 and the passed one.\n         */\n        Vector4.prototype.add = function (otherVector) {\n            return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n        };\n        /**\n         * Updates the passed vector \"result\" with the result of the addition of the current Vector4 and the passed one.\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.addToRef = function (otherVector, result) {\n            result.x = this.x + otherVector.x;\n            result.y = this.y + otherVector.y;\n            result.z = this.z + otherVector.z;\n            result.w = this.w + otherVector.w;\n            return this;\n        };\n        /**\n         * Subtract in place the passed vector from the current Vector4.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.subtractInPlace = function (otherVector) {\n            this.x -= otherVector.x;\n            this.y -= otherVector.y;\n            this.z -= otherVector.z;\n            this.w -= otherVector.w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 with the result of the subtraction of the passed vector from the current Vector4.\n         */\n        Vector4.prototype.subtract = function (otherVector) {\n            return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the subtraction of the passed vector from the current Vector4.\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.subtractToRef = function (otherVector, result) {\n            result.x = this.x - otherVector.x;\n            result.y = this.y - otherVector.y;\n            result.z = this.z - otherVector.z;\n            result.w = this.w - otherVector.w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 set with the result of the subtraction of the passed floats from the current Vector4 coordinates.\n         */\n        Vector4.prototype.subtractFromFloats = function (x, y, z, w) {\n            return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n        };\n        /**\n         * Sets the passed vector \"result\" set with the result of the subtraction of the passed floats from the current Vector4 coordinates.\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.subtractFromFloatsToRef = function (x, y, z, w, result) {\n            result.x = this.x - x;\n            result.y = this.y - y;\n            result.z = this.z - z;\n            result.w = this.w - w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 set with the current Vector4 negated coordinates.\n         */\n        Vector4.prototype.negate = function () {\n            return new Vector4(-this.x, -this.y, -this.z, -this.w);\n        };\n        /**\n         * Multiplies the current Vector4 coordinates by scale (float).\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.scaleInPlace = function (scale) {\n            this.x *= scale;\n            this.y *= scale;\n            this.z *= scale;\n            this.w *= scale;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n         */\n        Vector4.prototype.scale = function (scale) {\n            return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n        };\n        /**\n         * Sets the passed vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.scaleToRef = function (scale, result) {\n            result.x = this.x * scale;\n            result.y = this.y * scale;\n            result.z = this.z * scale;\n            result.w = this.w * scale;\n            return this;\n        };\n        /**\n         * Boolean : True if the current Vector4 coordinates are stricly equal to the passed ones.\n         */\n        Vector4.prototype.equals = function (otherVector) {\n            return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;\n        };\n        /**\n         * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the passed vector ones.\n         */\n        Vector4.prototype.equalsWithEpsilon = function (otherVector, epsilon) {\n            if (epsilon === void 0) { epsilon = BABYLON.Epsilon; }\n            return otherVector\n                && MathTools.WithinEpsilon(this.x, otherVector.x, epsilon)\n                && MathTools.WithinEpsilon(this.y, otherVector.y, epsilon)\n                && MathTools.WithinEpsilon(this.z, otherVector.z, epsilon)\n                && MathTools.WithinEpsilon(this.w, otherVector.w, epsilon);\n        };\n        /**\n         * Boolean : True if the passed floats are strictly equal to the current Vector4 coordinates.\n         */\n        Vector4.prototype.equalsToFloats = function (x, y, z, w) {\n            return this.x === x && this.y === y && this.z === z && this.w === w;\n        };\n        /**\n         * Multiplies in place the current Vector4 by the passed one.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.multiplyInPlace = function (otherVector) {\n            this.x *= otherVector.x;\n            this.y *= otherVector.y;\n            this.z *= otherVector.z;\n            this.w *= otherVector.w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 set with the multiplication result of the current Vector4 and the passed one.\n         */\n        Vector4.prototype.multiply = function (otherVector) {\n            return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n        };\n        /**\n         * Updates the passed vector \"result\" with the multiplication result of the current Vector4 and the passed one.\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.multiplyToRef = function (otherVector, result) {\n            result.x = this.x * otherVector.x;\n            result.y = this.y * otherVector.y;\n            result.z = this.z * otherVector.z;\n            result.w = this.w * otherVector.w;\n            return this;\n        };\n        /**\n         * Returns a new Vector4 set with the multiplication result of the passed floats and the current Vector4 coordinates.\n         */\n        Vector4.prototype.multiplyByFloats = function (x, y, z, w) {\n            return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n        };\n        /**\n         * Returns a new Vector4 set with the division result of the current Vector4 by the passed one.\n         */\n        Vector4.prototype.divide = function (otherVector) {\n            return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n        };\n        /**\n         * Updates the passed vector \"result\" with the division result of the current Vector4 by the passed one.\n         * Returns the current Vector4.\n         */\n        Vector4.prototype.divideToRef = function (otherVector, result) {\n            result.x = this.x / otherVector.x;\n            result.y = this.y / otherVector.y;\n            result.z = this.z / otherVector.z;\n            result.w = this.w / otherVector.w;\n            return this;\n        };\n        /**\n         * Updates the Vector4 coordinates with the minimum values between its own and the passed vector ones.\n         */\n        Vector4.prototype.MinimizeInPlace = function (other) {\n            if (other.x < this.x)\n                this.x = other.x;\n            if (other.y < this.y)\n                this.y = other.y;\n            if (other.z < this.z)\n                this.z = other.z;\n            if (other.w < this.w)\n                this.w = other.w;\n            return this;\n        };\n        /**\n         * Updates the Vector4 coordinates with the maximum values between its own and the passed vector ones.\n         */\n        Vector4.prototype.MaximizeInPlace = function (other) {\n            if (other.x > this.x)\n                this.x = other.x;\n            if (other.y > this.y)\n                this.y = other.y;\n            if (other.z > this.z)\n                this.z = other.z;\n            if (other.w > this.w)\n                this.w = other.w;\n            return this;\n        };\n        // Properties\n        /**\n         * Returns the Vector4 length (float).\n         */\n        Vector4.prototype.length = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n        };\n        /**\n         * Returns the Vector4 squared length (float).\n         */\n        Vector4.prototype.lengthSquared = function () {\n            return (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n        };\n        // Methods\n        /**\n         * Normalizes in place the Vector4.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.normalize = function () {\n            var len = this.length();\n            if (len === 0)\n                return this;\n            var num = 1.0 / len;\n            this.x *= num;\n            this.y *= num;\n            this.z *= num;\n            this.w *= num;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n         */\n        Vector4.prototype.toVector3 = function () {\n            return new Vector3(this.x, this.y, this.z);\n        };\n        /**\n         * Returns a new Vector4 copied from the current one.\n         */\n        Vector4.prototype.clone = function () {\n            return new Vector4(this.x, this.y, this.z, this.w);\n        };\n        /**\n         * Updates the current Vector4 with the passed one coordinates.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.copyFrom = function (source) {\n            this.x = source.x;\n            this.y = source.y;\n            this.z = source.z;\n            this.w = source.w;\n            return this;\n        };\n        /**\n         * Updates the current Vector4 coordinates with the passed floats.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.copyFromFloats = function (x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n            return this;\n        };\n        /**\n         * Updates the current Vector4 coordinates with the passed floats.\n         * Returns the updated Vector4.\n         */\n        Vector4.prototype.set = function (x, y, z, w) {\n            return this.copyFromFloats(x, y, z, w);\n        };\n        // Statics\n        /**\n         * Returns a new Vector4 set from the starting index of the passed array.\n         */\n        Vector4.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        /**\n         * Updates the passed vector \"result\" from the starting index of the passed array.\n         */\n        Vector4.FromArrayToRef = function (array, offset, result) {\n            result.x = array[offset];\n            result.y = array[offset + 1];\n            result.z = array[offset + 2];\n            result.w = array[offset + 3];\n        };\n        /**\n         * Updates the passed vector \"result\" from the starting index of the passed Float32Array.\n         */\n        Vector4.FromFloatArrayToRef = function (array, offset, result) {\n            Vector4.FromArrayToRef(array, offset, result);\n        };\n        /**\n         * Updates the passed vector \"result\" coordinates from the passed floats.\n         */\n        Vector4.FromFloatsToRef = function (x, y, z, w, result) {\n            result.x = x;\n            result.y = y;\n            result.z = z;\n            result.w = w;\n        };\n        /**\n         * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n         */\n        Vector4.Zero = function () {\n            return new Vector4(0.0, 0.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n         */\n        Vector4.One = function () {\n            return new Vector4(1.0, 1.0, 1.0, 1.0);\n        };\n        /**\n         * Returns a new normalized Vector4 from the passed one.\n         */\n        Vector4.Normalize = function (vector) {\n            var result = Vector4.Zero();\n            Vector4.NormalizeToRef(vector, result);\n            return result;\n        };\n        /**\n         * Updates the passed vector \"result\" from the normalization of the passed one.\n         */\n        Vector4.NormalizeToRef = function (vector, result) {\n            result.copyFrom(vector);\n            result.normalize();\n        };\n        Vector4.Minimize = function (left, right) {\n            var min = left.clone();\n            min.MinimizeInPlace(right);\n            return min;\n        };\n        Vector4.Maximize = function (left, right) {\n            var max = left.clone();\n            max.MaximizeInPlace(right);\n            return max;\n        };\n        /**\n         * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector4.Distance = function (value1, value2) {\n            return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n        };\n        /**\n         * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n         */\n        Vector4.DistanceSquared = function (value1, value2) {\n            var x = value1.x - value2.x;\n            var y = value1.y - value2.y;\n            var z = value1.z - value2.z;\n            var w = value1.w - value2.w;\n            return (x * x) + (y * y) + (z * z) + (w * w);\n        };\n        /**\n         * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n         */\n        Vector4.Center = function (value1, value2) {\n            var center = value1.add(value2);\n            center.scaleInPlace(0.5);\n            return center;\n        };\n        /**\n         * Returns a new Vector4 set with the result of the normal transformation by the passed matrix of the passed vector.\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector4.TransformNormal = function (vector, transformation) {\n            var result = Vector4.Zero();\n            Vector4.TransformNormalToRef(vector, transformation, result);\n            return result;\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the normal transformation by the passed matrix of the passed vector.\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector4.TransformNormalToRef = function (vector, transformation, result) {\n            var x = (vector.x * transformation.m[0]) + (vector.y * transformation.m[4]) + (vector.z * transformation.m[8]);\n            var y = (vector.x * transformation.m[1]) + (vector.y * transformation.m[5]) + (vector.z * transformation.m[9]);\n            var z = (vector.x * transformation.m[2]) + (vector.y * transformation.m[6]) + (vector.z * transformation.m[10]);\n            result.x = x;\n            result.y = y;\n            result.z = z;\n            result.w = vector.w;\n        };\n        /**\n         * Sets the passed vector \"result\" with the result of the normal transformation by the passed matrix of the passed floats (x, y, z, w).\n         * This methods computes transformed normalized direction vectors only.\n         */\n        Vector4.TransformNormalFromFloatsToRef = function (x, y, z, w, transformation, result) {\n            result.x = (x * transformation.m[0]) + (y * transformation.m[4]) + (z * transformation.m[8]);\n            result.y = (x * transformation.m[1]) + (y * transformation.m[5]) + (z * transformation.m[9]);\n            result.z = (x * transformation.m[2]) + (y * transformation.m[6]) + (z * transformation.m[10]);\n            result.w = w;\n        };\n        return Vector4;\n    }());\n    BABYLON.Vector4 = Vector4;\n    var Size = (function () {\n        /**\n         * Creates a Size object from the passed width and height (floats).\n         */\n        function Size(width, height) {\n            this.width = width;\n            this.height = height;\n        }\n        // Returns a string with the Size width and height.  \n        Size.prototype.toString = function () {\n            return \"{W: \" + this.width + \", H: \" + this.height + \"}\";\n        };\n        /**\n         * Returns the string \"Size\"\n         */\n        Size.prototype.getClassName = function () {\n            return \"Size\";\n        };\n        /**\n         * Returns the Size hash code.\n         */\n        Size.prototype.getHashCode = function () {\n            var hash = this.width || 0;\n            hash = (hash * 397) ^ (this.height || 0);\n            return hash;\n        };\n        /**\n         * Updates the current size from the passed one.\n         * Returns the updated Size.\n         */\n        Size.prototype.copyFrom = function (src) {\n            this.width = src.width;\n            this.height = src.height;\n        };\n        /**\n         * Updates in place the current Size from the passed floats.\n         * Returns the updated Size.\n         */\n        Size.prototype.copyFromFloats = function (width, height) {\n            this.width = width;\n            this.height = height;\n            return this;\n        };\n        /**\n         * Updates in place the current Size from the passed floats.\n         * Returns the updated Size.\n         */\n        Size.prototype.set = function (width, height) {\n            return this.copyFromFloats(width, height);\n        };\n        /**\n         * Returns a new Size set with the multiplication result of the current Size and the passed floats.\n         */\n        Size.prototype.multiplyByFloats = function (w, h) {\n            return new Size(this.width * w, this.height * h);\n        };\n        /**\n         * Returns a new Size copied from the passed one.\n         */\n        Size.prototype.clone = function () {\n            return new Size(this.width, this.height);\n        };\n        /**\n         * Boolean : True if the current Size and the passed one width and height are strictly equal.\n         */\n        Size.prototype.equals = function (other) {\n            if (!other) {\n                return false;\n            }\n            return (this.width === other.width) && (this.height === other.height);\n        };\n        Object.defineProperty(Size.prototype, \"surface\", {\n            /**\n             * Returns the surface of the Size : width * height (float).\n             */\n            get: function () {\n                return this.width * this.height;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns a new Size set to (0.0, 0.0)\n         */\n        Size.Zero = function () {\n            return new Size(0.0, 0.0);\n        };\n        /**\n         * Returns a new Size set as the addition result of the current Size and the passed one.\n         */\n        Size.prototype.add = function (otherSize) {\n            var r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n            return r;\n        };\n        /**\n         * Returns a new Size set as the subtraction result of  the passed one from the current Size.\n         */\n        Size.prototype.subtract = function (otherSize) {\n            var r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n            return r;\n        };\n        /**\n         * Returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\".\n         */\n        Size.Lerp = function (start, end, amount) {\n            var w = start.width + ((end.width - start.width) * amount);\n            var h = start.height + ((end.height - start.height) * amount);\n            return new Size(w, h);\n        };\n        return Size;\n    }());\n    BABYLON.Size = Size;\n    var Quaternion = (function () {\n        /**\n         * Creates a new Quaternion from the passed floats.\n         */\n        function Quaternion(x, y, z, w) {\n            if (x === void 0) { x = 0.0; }\n            if (y === void 0) { y = 0.0; }\n            if (z === void 0) { z = 0.0; }\n            if (w === void 0) { w = 1.0; }\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n        }\n        /**\n         * Returns a string with the Quaternion coordinates.\n         */\n        Quaternion.prototype.toString = function () {\n            return \"{X: \" + this.x + \" Y:\" + this.y + \" Z:\" + this.z + \" W:\" + this.w + \"}\";\n        };\n        /**\n         * Returns the string \"Quaternion\".\n         */\n        Quaternion.prototype.getClassName = function () {\n            return \"Quaternion\";\n        };\n        /**\n         * Returns the Quaternion hash code.\n         */\n        Quaternion.prototype.getHashCode = function () {\n            var hash = this.x || 0;\n            hash = (hash * 397) ^ (this.y || 0);\n            hash = (hash * 397) ^ (this.z || 0);\n            hash = (hash * 397) ^ (this.w || 0);\n            return hash;\n        };\n        /**\n         * Returns a new array populated with 4 elements : the Quaternion coordinates.\n         */\n        Quaternion.prototype.asArray = function () {\n            return [this.x, this.y, this.z, this.w];\n        };\n        /**\n         * Boolean : True if the current Quaterion and the passed one coordinates are strictly equal.\n         */\n        Quaternion.prototype.equals = function (otherQuaternion) {\n            return otherQuaternion && this.x === otherQuaternion.x && this.y === otherQuaternion.y && this.z === otherQuaternion.z && this.w === otherQuaternion.w;\n        };\n        /**\n         * Returns a new Quaternion copied from the current one.\n         */\n        Quaternion.prototype.clone = function () {\n            return new Quaternion(this.x, this.y, this.z, this.w);\n        };\n        /**\n         * Updates the current Quaternion from the passed one coordinates.\n         * Returns the updated Quaterion.\n         */\n        Quaternion.prototype.copyFrom = function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.z = other.z;\n            this.w = other.w;\n            return this;\n        };\n        /**\n         * Updates the current Quaternion from the passed float coordinates.\n         * Returns the updated Quaterion.\n         */\n        Quaternion.prototype.copyFromFloats = function (x, y, z, w) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.w = w;\n            return this;\n        };\n        /**\n         * Updates the current Quaternion from the passed float coordinates.\n         * Returns the updated Quaterion.\n         */\n        Quaternion.prototype.set = function (x, y, z, w) {\n            return this.copyFromFloats(x, y, z, w);\n        };\n        /**\n         * Returns a new Quaternion as the addition result of the passed one and the current Quaternion.\n         */\n        Quaternion.prototype.add = function (other) {\n            return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);\n        };\n        /**\n         * Returns a new Quaternion as the subtraction result of the passed one from the current Quaternion.\n         */\n        Quaternion.prototype.subtract = function (other) {\n            return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);\n        };\n        /**\n         * Returns a new Quaternion set by multiplying the current Quaterion coordinates by the float \"scale\".\n         */\n        Quaternion.prototype.scale = function (value) {\n            return new Quaternion(this.x * value, this.y * value, this.z * value, this.w * value);\n        };\n        /**\n         * Returns a new Quaternion set as the quaternion mulplication result of the current one with the passed one \"q1\".\n         */\n        Quaternion.prototype.multiply = function (q1) {\n            var result = new Quaternion(0, 0, 0, 1.0);\n            this.multiplyToRef(q1, result);\n            return result;\n        };\n        /**\n         * Sets the passed \"result\" as the quaternion mulplication result of the current one with the passed one \"q1\".\n         * Returns the current Quaternion.\n         */\n        Quaternion.prototype.multiplyToRef = function (q1, result) {\n            var x = this.x * q1.w + this.y * q1.z - this.z * q1.y + this.w * q1.x;\n            var y = -this.x * q1.z + this.y * q1.w + this.z * q1.x + this.w * q1.y;\n            var z = this.x * q1.y - this.y * q1.x + this.z * q1.w + this.w * q1.z;\n            var w = -this.x * q1.x - this.y * q1.y - this.z * q1.z + this.w * q1.w;\n            result.copyFromFloats(x, y, z, w);\n            return this;\n        };\n        /**\n         * Updates the current Quaternion with the quaternion mulplication result of itself with the passed one \"q1\".\n         * Returns the updated Quaternion.\n         */\n        Quaternion.prototype.multiplyInPlace = function (q1) {\n            this.multiplyToRef(q1, this);\n            return this;\n        };\n        /**\n         * Sets the passed \"ref\" with the conjugation of the current Quaternion.\n         * Returns the current Quaternion.\n         */\n        Quaternion.prototype.conjugateToRef = function (ref) {\n            ref.copyFromFloats(-this.x, -this.y, -this.z, this.w);\n            return this;\n        };\n        /**\n         * Conjugates in place the current Quaternion.\n         * Returns the updated Quaternion.\n         */\n        Quaternion.prototype.conjugateInPlace = function () {\n            this.x *= -1;\n            this.y *= -1;\n            this.z *= -1;\n            return this;\n        };\n        /**\n         * Returns a new Quaternion as the conjugate of the current Quaternion.\n         */\n        Quaternion.prototype.conjugate = function () {\n            var result = new Quaternion(-this.x, -this.y, -this.z, this.w);\n            return result;\n        };\n        /**\n         * Returns the Quaternion length (float).\n         */\n        Quaternion.prototype.length = function () {\n            return Math.sqrt((this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w));\n        };\n        /**\n         * Normalize in place the current Quaternion.\n         * Returns the updated Quaternion.\n         */\n        Quaternion.prototype.normalize = function () {\n            var length = 1.0 / this.length();\n            this.x *= length;\n            this.y *= length;\n            this.z *= length;\n            this.w *= length;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the Euler angles translated from the current Quaternion.\n         */\n        Quaternion.prototype.toEulerAngles = function (order) {\n            if (order === void 0) { order = \"YZX\"; }\n            var result = Vector3.Zero();\n            this.toEulerAnglesToRef(result, order);\n            return result;\n        };\n        /**\n         * Sets the passed vector3 \"result\" with the Euler angles translated from the current Quaternion.\n         * Returns the current Quaternion.\n         */\n        Quaternion.prototype.toEulerAnglesToRef = function (result, order) {\n            if (order === void 0) { order = \"YZX\"; }\n            var qz = this.z;\n            var qx = this.x;\n            var qy = this.y;\n            var qw = this.w;\n            var sqw = qw * qw;\n            var sqz = qz * qz;\n            var sqx = qx * qx;\n            var sqy = qy * qy;\n            var zAxisY = qy * qz - qx * qw;\n            var limit = .4999999;\n            if (zAxisY < -limit) {\n                result.y = 2 * Math.atan2(qy, qw);\n                result.x = Math.PI / 2;\n                result.z = 0;\n            }\n            else if (zAxisY > limit) {\n                result.y = 2 * Math.atan2(qy, qw);\n                result.x = -Math.PI / 2;\n                result.z = 0;\n            }\n            else {\n                result.z = Math.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw));\n                result.x = Math.asin(-2.0 * (qz * qy - qx * qw));\n                result.y = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));\n            }\n            return this;\n        };\n        /**\n         * Updates the passed rotation matrix with the current Quaternion values.\n         * Returns the current Quaternion.\n         */\n        Quaternion.prototype.toRotationMatrix = function (result) {\n            var xx = this.x * this.x;\n            var yy = this.y * this.y;\n            var zz = this.z * this.z;\n            var xy = this.x * this.y;\n            var zw = this.z * this.w;\n            var zx = this.z * this.x;\n            var yw = this.y * this.w;\n            var yz = this.y * this.z;\n            var xw = this.x * this.w;\n            result.m[0] = 1.0 - (2.0 * (yy + zz));\n            result.m[1] = 2.0 * (xy + zw);\n            result.m[2] = 2.0 * (zx - yw);\n            result.m[3] = 0;\n            result.m[4] = 2.0 * (xy - zw);\n            result.m[5] = 1.0 - (2.0 * (zz + xx));\n            result.m[6] = 2.0 * (yz + xw);\n            result.m[7] = 0;\n            result.m[8] = 2.0 * (zx + yw);\n            result.m[9] = 2.0 * (yz - xw);\n            result.m[10] = 1.0 - (2.0 * (yy + xx));\n            result.m[11] = 0;\n            result.m[12] = 0;\n            result.m[13] = 0;\n            result.m[14] = 0;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n            return this;\n        };\n        /**\n         * Updates the current Quaternion from the passed rotation matrix values.\n         * Returns the updated Quaternion.\n         */\n        Quaternion.prototype.fromRotationMatrix = function (matrix) {\n            Quaternion.FromRotationMatrixToRef(matrix, this);\n            return this;\n        };\n        // Statics\n        /**\n         * Returns a new Quaternion set from the passed rotation matrix values.\n         */\n        Quaternion.FromRotationMatrix = function (matrix) {\n            var result = new Quaternion();\n            Quaternion.FromRotationMatrixToRef(matrix, result);\n            return result;\n        };\n        /**\n         * Updates the passed quaternion \"result\" with the passed rotation matrix values.\n         */\n        Quaternion.FromRotationMatrixToRef = function (matrix, result) {\n            var data = matrix.m;\n            var m11 = data[0], m12 = data[4], m13 = data[8];\n            var m21 = data[1], m22 = data[5], m23 = data[9];\n            var m31 = data[2], m32 = data[6], m33 = data[10];\n            var trace = m11 + m22 + m33;\n            var s;\n            if (trace > 0) {\n                s = 0.5 / Math.sqrt(trace + 1.0);\n                result.w = 0.25 / s;\n                result.x = (m32 - m23) * s;\n                result.y = (m13 - m31) * s;\n                result.z = (m21 - m12) * s;\n            }\n            else if (m11 > m22 && m11 > m33) {\n                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n                result.w = (m32 - m23) / s;\n                result.x = 0.25 * s;\n                result.y = (m12 + m21) / s;\n                result.z = (m13 + m31) / s;\n            }\n            else if (m22 > m33) {\n                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n                result.w = (m13 - m31) / s;\n                result.x = (m12 + m21) / s;\n                result.y = 0.25 * s;\n                result.z = (m23 + m32) / s;\n            }\n            else {\n                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n                result.w = (m21 - m12) / s;\n                result.x = (m13 + m31) / s;\n                result.y = (m23 + m32) / s;\n                result.z = 0.25 * s;\n            }\n        };\n        /**\n         * Returns a new Quaternion set to (0.0, 0.0, 0.0).\n         */\n        Quaternion.Zero = function () {\n            return new Quaternion(0.0, 0.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new Quaternion as the inverted current Quaternion.\n         */\n        Quaternion.Inverse = function (q) {\n            return new Quaternion(-q.x, -q.y, -q.z, q.w);\n        };\n        /**\n         * Returns the identity Quaternion.\n         */\n        Quaternion.Identity = function () {\n            return new Quaternion(0.0, 0.0, 0.0, 1.0);\n        };\n        Quaternion.IsIdentity = function (quaternion) {\n            return quaternion && quaternion.x === 0 && quaternion.y === 0 && quaternion.z === 0 && quaternion.w === 1;\n        };\n        /**\n         * Returns a new Quaternion set from the passed axis (Vector3) and angle in radians (float).\n         */\n        Quaternion.RotationAxis = function (axis, angle) {\n            return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());\n        };\n        /**\n         * Sets the passed quaternion \"result\" from the passed axis (Vector3) and angle in radians (float).\n         */\n        Quaternion.RotationAxisToRef = function (axis, angle, result) {\n            var sin = Math.sin(angle / 2);\n            axis.normalize();\n            result.w = Math.cos(angle / 2);\n            result.x = axis.x * sin;\n            result.y = axis.y * sin;\n            result.z = axis.z * sin;\n            return result;\n        };\n        /**\n         * Retuns a new Quaternion set from the starting index of the passed array.\n         */\n        Quaternion.FromArray = function (array, offset) {\n            if (!offset) {\n                offset = 0;\n            }\n            return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n        };\n        /**\n         * Returns a new Quaternion set from the passed Euler float angles (y, x, z).\n         */\n        Quaternion.RotationYawPitchRoll = function (yaw, pitch, roll) {\n            var q = new Quaternion();\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n            return q;\n        };\n        /**\n         * Sets the passed quaternion \"result\" from the passed float Euler angles (y, x, z).\n         */\n        Quaternion.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n            // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)\n            var halfRoll = roll * 0.5;\n            var halfPitch = pitch * 0.5;\n            var halfYaw = yaw * 0.5;\n            var sinRoll = Math.sin(halfRoll);\n            var cosRoll = Math.cos(halfRoll);\n            var sinPitch = Math.sin(halfPitch);\n            var cosPitch = Math.cos(halfPitch);\n            var sinYaw = Math.sin(halfYaw);\n            var cosYaw = Math.cos(halfYaw);\n            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n        };\n        /**\n         * Returns a new Quaternion from the passed float Euler angles expressed in z-x-z orientation\n         */\n        Quaternion.RotationAlphaBetaGamma = function (alpha, beta, gamma) {\n            var result = new Quaternion();\n            Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n            return result;\n        };\n        /**\n         * Sets the passed quaternion \"result\" from the passed float Euler angles expressed in z-x-z orientation\n         */\n        Quaternion.RotationAlphaBetaGammaToRef = function (alpha, beta, gamma, result) {\n            // Produces a quaternion from Euler angles in the z-x-z orientation\n            var halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n            var halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n            var halfBeta = beta * 0.5;\n            result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n            result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n            result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n            result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        };\n        /**\n         * Returns a new Quaternion as the quaternion rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system.\n         * cf to Vector3.RotationFromAxis() documentation.\n         * Note : axis1, axis2 and axis3 are normalized during this operation.\n         */\n        Quaternion.RotationQuaternionFromAxis = function (axis1, axis2, axis3, ref) {\n            var quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n            Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n            return quat;\n        };\n        /**\n         * Sets the passed quaternion \"ref\" with the quaternion rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system.\n         * cf to Vector3.RotationFromAxis() documentation.\n         * Note : axis1, axis2 and axis3 are normalized during this operation.\n         */\n        Quaternion.RotationQuaternionFromAxisToRef = function (axis1, axis2, axis3, ref) {\n            var rotMat = MathTmp.Matrix[0];\n            BABYLON.Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n            BABYLON.Quaternion.FromRotationMatrixToRef(rotMat, ref);\n        };\n        Quaternion.Slerp = function (left, right, amount) {\n            var result = Quaternion.Identity();\n            Quaternion.SlerpToRef(left, right, amount, result);\n            return result;\n        };\n        Quaternion.SlerpToRef = function (left, right, amount, result) {\n            var num2;\n            var num3;\n            var num = amount;\n            var num4 = (((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w);\n            var flag = false;\n            if (num4 < 0) {\n                flag = true;\n                num4 = -num4;\n            }\n            if (num4 > 0.999999) {\n                num3 = 1 - num;\n                num2 = flag ? -num : num;\n            }\n            else {\n                var num5 = Math.acos(num4);\n                var num6 = (1.0 / Math.sin(num5));\n                num3 = (Math.sin((1.0 - num) * num5)) * num6;\n                num2 = flag ? ((-Math.sin(num * num5)) * num6) : ((Math.sin(num * num5)) * num6);\n            }\n            result.x = (num3 * left.x) + (num2 * right.x);\n            result.y = (num3 * left.y) + (num2 * right.y);\n            result.z = (num3 * left.z) + (num2 * right.z);\n            result.w = (num3 * left.w) + (num2 * right.w);\n        };\n        /**\n         * Returns a new Quaternion located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\".\n         */\n        Quaternion.Hermite = function (value1, tangent1, value2, tangent2, amount) {\n            var squared = amount * amount;\n            var cubed = amount * squared;\n            var part1 = ((2.0 * cubed) - (3.0 * squared)) + 1.0;\n            var part2 = (-2.0 * cubed) + (3.0 * squared);\n            var part3 = (cubed - (2.0 * squared)) + amount;\n            var part4 = cubed - squared;\n            var x = (((value1.x * part1) + (value2.x * part2)) + (tangent1.x * part3)) + (tangent2.x * part4);\n            var y = (((value1.y * part1) + (value2.y * part2)) + (tangent1.y * part3)) + (tangent2.y * part4);\n            var z = (((value1.z * part1) + (value2.z * part2)) + (tangent1.z * part3)) + (tangent2.z * part4);\n            var w = (((value1.w * part1) + (value2.w * part2)) + (tangent1.w * part3)) + (tangent2.w * part4);\n            return new Quaternion(x, y, z, w);\n        };\n        return Quaternion;\n    }());\n    BABYLON.Quaternion = Quaternion;\n    var Matrix = (function () {\n        function Matrix() {\n            this._isIdentity = false;\n            this._isIdentityDirty = true;\n            this.m = new Float32Array(16);\n            this._markAsUpdated();\n        }\n        Matrix.prototype._markAsUpdated = function () {\n            this.updateFlag = Matrix._updateFlagSeed++;\n            this._isIdentityDirty = true;\n        };\n        // Properties\n        /**\n         * Boolean : True is the matrix is the identity matrix\n         */\n        Matrix.prototype.isIdentity = function (considerAsTextureMatrix) {\n            if (considerAsTextureMatrix === void 0) { considerAsTextureMatrix = false; }\n            if (this._isIdentityDirty) {\n                this._isIdentityDirty = false;\n                if (this.m[0] !== 1.0 || this.m[5] !== 1.0 || this.m[15] !== 1.0) {\n                    this._isIdentity = false;\n                }\n                else if (this.m[1] !== 0.0 || this.m[2] !== 0.0 || this.m[3] !== 0.0 ||\n                    this.m[4] !== 0.0 || this.m[6] !== 0.0 || this.m[7] !== 0.0 ||\n                    this.m[8] !== 0.0 || this.m[9] !== 0.0 || this.m[11] !== 0.0 ||\n                    this.m[12] !== 0.0 || this.m[13] !== 0.0 || this.m[14] !== 0.0) {\n                    this._isIdentity = false;\n                }\n                else {\n                    this._isIdentity = true;\n                }\n                if (!considerAsTextureMatrix && this.m[10] !== 1.0) {\n                    this._isIdentity = false;\n                }\n            }\n            return this._isIdentity;\n        };\n        /**\n         * Returns the matrix determinant (float).\n         */\n        Matrix.prototype.determinant = function () {\n            var temp1 = (this.m[10] * this.m[15]) - (this.m[11] * this.m[14]);\n            var temp2 = (this.m[9] * this.m[15]) - (this.m[11] * this.m[13]);\n            var temp3 = (this.m[9] * this.m[14]) - (this.m[10] * this.m[13]);\n            var temp4 = (this.m[8] * this.m[15]) - (this.m[11] * this.m[12]);\n            var temp5 = (this.m[8] * this.m[14]) - (this.m[10] * this.m[12]);\n            var temp6 = (this.m[8] * this.m[13]) - (this.m[9] * this.m[12]);\n            return ((((this.m[0] * (((this.m[5] * temp1) - (this.m[6] * temp2)) + (this.m[7] * temp3))) - (this.m[1] * (((this.m[4] * temp1) -\n                (this.m[6] * temp4)) + (this.m[7] * temp5)))) + (this.m[2] * (((this.m[4] * temp2) - (this.m[5] * temp4)) + (this.m[7] * temp6)))) -\n                (this.m[3] * (((this.m[4] * temp3) - (this.m[5] * temp5)) + (this.m[6] * temp6))));\n        };\n        // Methods\n        /**\n         * Returns the matrix underlying array.\n         */\n        Matrix.prototype.toArray = function () {\n            return this.m;\n        };\n        /**\n        * Returns the matrix underlying array.\n        */\n        Matrix.prototype.asArray = function () {\n            return this.toArray();\n        };\n        /**\n         * Inverts in place the Matrix.\n         * Returns the Matrix inverted.\n         */\n        Matrix.prototype.invert = function () {\n            this.invertToRef(this);\n            return this;\n        };\n        /**\n         * Sets all the matrix elements to zero.\n         * Returns the Matrix.\n         */\n        Matrix.prototype.reset = function () {\n            for (var index = 0; index < 16; index++) {\n                this.m[index] = 0.0;\n            }\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Returns a new Matrix as the addition result of the current Matrix and the passed one.\n         */\n        Matrix.prototype.add = function (other) {\n            var result = new Matrix();\n            this.addToRef(other, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" with the ddition result of the current Matrix and the passed one.\n         * Returns the Matrix.\n         */\n        Matrix.prototype.addToRef = function (other, result) {\n            for (var index = 0; index < 16; index++) {\n                result.m[index] = this.m[index] + other.m[index];\n            }\n            result._markAsUpdated();\n            return this;\n        };\n        /**\n         * Adds in place the passed matrix to the current Matrix.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.addToSelf = function (other) {\n            for (var index = 0; index < 16; index++) {\n                this.m[index] += other.m[index];\n            }\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Sets the passed matrix with the current inverted Matrix.\n         * Returns the unmodified current Matrix.\n         */\n        Matrix.prototype.invertToRef = function (other) {\n            var l1 = this.m[0];\n            var l2 = this.m[1];\n            var l3 = this.m[2];\n            var l4 = this.m[3];\n            var l5 = this.m[4];\n            var l6 = this.m[5];\n            var l7 = this.m[6];\n            var l8 = this.m[7];\n            var l9 = this.m[8];\n            var l10 = this.m[9];\n            var l11 = this.m[10];\n            var l12 = this.m[11];\n            var l13 = this.m[12];\n            var l14 = this.m[13];\n            var l15 = this.m[14];\n            var l16 = this.m[15];\n            var l17 = (l11 * l16) - (l12 * l15);\n            var l18 = (l10 * l16) - (l12 * l14);\n            var l19 = (l10 * l15) - (l11 * l14);\n            var l20 = (l9 * l16) - (l12 * l13);\n            var l21 = (l9 * l15) - (l11 * l13);\n            var l22 = (l9 * l14) - (l10 * l13);\n            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);\n            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));\n            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);\n            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));\n            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));\n            var l28 = (l7 * l16) - (l8 * l15);\n            var l29 = (l6 * l16) - (l8 * l14);\n            var l30 = (l6 * l15) - (l7 * l14);\n            var l31 = (l5 * l16) - (l8 * l13);\n            var l32 = (l5 * l15) - (l7 * l13);\n            var l33 = (l5 * l14) - (l6 * l13);\n            var l34 = (l7 * l12) - (l8 * l11);\n            var l35 = (l6 * l12) - (l8 * l10);\n            var l36 = (l6 * l11) - (l7 * l10);\n            var l37 = (l5 * l12) - (l8 * l9);\n            var l38 = (l5 * l11) - (l7 * l9);\n            var l39 = (l5 * l10) - (l6 * l9);\n            other.m[0] = l23 * l27;\n            other.m[4] = l24 * l27;\n            other.m[8] = l25 * l27;\n            other.m[12] = l26 * l27;\n            other.m[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;\n            other.m[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;\n            other.m[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;\n            other.m[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;\n            other.m[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;\n            other.m[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;\n            other.m[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;\n            other.m[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;\n            other.m[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;\n            other.m[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;\n            other.m[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;\n            other.m[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;\n            other._markAsUpdated();\n            return this;\n        };\n        /**\n         * Inserts the translation vector (using 3 x floats) in the current Matrix.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.setTranslationFromFloats = function (x, y, z) {\n            this.m[12] = x;\n            this.m[13] = y;\n            this.m[14] = z;\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n * Inserts the translation vector in the current Matrix.\n * Returns the updated Matrix.\n */\n        Matrix.prototype.setTranslation = function (vector3) {\n            this.m[12] = vector3.x;\n            this.m[13] = vector3.y;\n            this.m[14] = vector3.z;\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Returns a new Vector3 as the extracted translation from the Matrix.\n         */\n        Matrix.prototype.getTranslation = function () {\n            return new Vector3(this.m[12], this.m[13], this.m[14]);\n        };\n        /**\n         * Fill a Vector3 with the extracted translation from the Matrix.\n         */\n        Matrix.prototype.getTranslationToRef = function (result) {\n            result.x = this.m[12];\n            result.y = this.m[13];\n            result.z = this.m[14];\n            return this;\n        };\n        /**\n         * Remove rotation and scaling part from the Matrix.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.removeRotationAndScaling = function () {\n            this.setRowFromFloats(0, 1, 0, 0, 0);\n            this.setRowFromFloats(1, 0, 1, 0, 0);\n            this.setRowFromFloats(2, 0, 0, 1, 0);\n            return this;\n        };\n        /**\n         * Returns a new Matrix set with the multiplication result of the current Matrix and the passed one.\n         */\n        Matrix.prototype.multiply = function (other) {\n            var result = new Matrix();\n            this.multiplyToRef(other, result);\n            return result;\n        };\n        /**\n         * Updates the current Matrix from the passed one values.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.copyFrom = function (other) {\n            for (var index = 0; index < 16; index++) {\n                this.m[index] = other.m[index];\n            }\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Populates the passed array from the starting index with the Matrix values.\n         * Returns the Matrix.\n         */\n        Matrix.prototype.copyToArray = function (array, offset) {\n            if (offset === void 0) { offset = 0; }\n            for (var index = 0; index < 16; index++) {\n                array[offset + index] = this.m[index];\n            }\n            return this;\n        };\n        /**\n         * Sets the passed matrix \"result\" with the multiplication result of the current Matrix and the passed one.\n         */\n        Matrix.prototype.multiplyToRef = function (other, result) {\n            this.multiplyToArray(other, result.m, 0);\n            result._markAsUpdated();\n            return this;\n        };\n        /**\n         * Sets the Float32Array \"result\" from the passed index \"offset\" with the multiplication result of the current Matrix and the passed one.\n         */\n        Matrix.prototype.multiplyToArray = function (other, result, offset) {\n            var tm0 = this.m[0];\n            var tm1 = this.m[1];\n            var tm2 = this.m[2];\n            var tm3 = this.m[3];\n            var tm4 = this.m[4];\n            var tm5 = this.m[5];\n            var tm6 = this.m[6];\n            var tm7 = this.m[7];\n            var tm8 = this.m[8];\n            var tm9 = this.m[9];\n            var tm10 = this.m[10];\n            var tm11 = this.m[11];\n            var tm12 = this.m[12];\n            var tm13 = this.m[13];\n            var tm14 = this.m[14];\n            var tm15 = this.m[15];\n            var om0 = other.m[0];\n            var om1 = other.m[1];\n            var om2 = other.m[2];\n            var om3 = other.m[3];\n            var om4 = other.m[4];\n            var om5 = other.m[5];\n            var om6 = other.m[6];\n            var om7 = other.m[7];\n            var om8 = other.m[8];\n            var om9 = other.m[9];\n            var om10 = other.m[10];\n            var om11 = other.m[11];\n            var om12 = other.m[12];\n            var om13 = other.m[13];\n            var om14 = other.m[14];\n            var om15 = other.m[15];\n            result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n            result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n            result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n            result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n            result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n            result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n            result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n            result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n            result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n            result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n            result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n            result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n            result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n            result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n            result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n            result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n            return this;\n        };\n        /**\n         * Boolean : True is the current Matrix and the passed one values are strictly equal.\n         */\n        Matrix.prototype.equals = function (value) {\n            return value &&\n                (this.m[0] === value.m[0] && this.m[1] === value.m[1] && this.m[2] === value.m[2] && this.m[3] === value.m[3] &&\n                    this.m[4] === value.m[4] && this.m[5] === value.m[5] && this.m[6] === value.m[6] && this.m[7] === value.m[7] &&\n                    this.m[8] === value.m[8] && this.m[9] === value.m[9] && this.m[10] === value.m[10] && this.m[11] === value.m[11] &&\n                    this.m[12] === value.m[12] && this.m[13] === value.m[13] && this.m[14] === value.m[14] && this.m[15] === value.m[15]);\n        };\n        /**\n         * Returns a new Matrix from the current Matrix.\n         */\n        Matrix.prototype.clone = function () {\n            return Matrix.FromValues(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5], this.m[6], this.m[7], this.m[8], this.m[9], this.m[10], this.m[11], this.m[12], this.m[13], this.m[14], this.m[15]);\n        };\n        /**\n         * Returns the string \"Matrix\"\n         */\n        Matrix.prototype.getClassName = function () {\n            return \"Matrix\";\n        };\n        /**\n         * Returns the Matrix hash code.\n         */\n        Matrix.prototype.getHashCode = function () {\n            var hash = this.m[0] || 0;\n            for (var i = 1; i < 16; i++) {\n                hash = (hash * 397) ^ (this.m[i] || 0);\n            }\n            return hash;\n        };\n        /**\n         * Decomposes the current Matrix into :\n         * - a scale vector3 passed as a reference to update,\n         * - a rotation quaternion passed as a reference to update,\n         * - a translation vector3 passed as a reference to update.\n         * Returns the boolean `true`.\n         */\n        Matrix.prototype.decompose = function (scale, rotation, translation) {\n            translation.x = this.m[12];\n            translation.y = this.m[13];\n            translation.z = this.m[14];\n            scale.x = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1] + this.m[2] * this.m[2]);\n            scale.y = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5] + this.m[6] * this.m[6]);\n            scale.z = Math.sqrt(this.m[8] * this.m[8] + this.m[9] * this.m[9] + this.m[10] * this.m[10]);\n            if (this.determinant() <= 0) {\n                scale.y *= -1;\n            }\n            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {\n                rotation.x = 0;\n                rotation.y = 0;\n                rotation.z = 0;\n                rotation.w = 1;\n                return false;\n            }\n            Matrix.FromValuesToRef(this.m[0] / scale.x, this.m[1] / scale.x, this.m[2] / scale.x, 0, this.m[4] / scale.y, this.m[5] / scale.y, this.m[6] / scale.y, 0, this.m[8] / scale.z, this.m[9] / scale.z, this.m[10] / scale.z, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);\n            Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);\n            return true;\n        };\n        /**\n         * Returns a new Matrix as the extracted rotation matrix from the current one.\n         */\n        Matrix.prototype.getRotationMatrix = function () {\n            var result = Matrix.Identity();\n            this.getRotationMatrixToRef(result);\n            return result;\n        };\n        /**\n         * Extracts the rotation matrix from the current one and sets it as the passed \"result\".\n         * Returns the current Matrix.\n         */\n        Matrix.prototype.getRotationMatrixToRef = function (result) {\n            var m = this.m;\n            var xs = m[0] * m[1] * m[2] * m[3] < 0 ? -1 : 1;\n            var ys = m[4] * m[5] * m[6] * m[7] < 0 ? -1 : 1;\n            var zs = m[8] * m[9] * m[10] * m[11] < 0 ? -1 : 1;\n            var sx = xs * Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n            var sy = ys * Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n            var sz = zs * Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n            Matrix.FromValuesToRef(m[0] / sx, m[1] / sx, m[2] / sx, 0, m[4] / sy, m[5] / sy, m[6] / sy, 0, m[8] / sz, m[9] / sz, m[10] / sz, 0, 0, 0, 0, 1, result);\n            return this;\n        };\n        // Statics\n        /**\n         * Returns a new Matrix set from the starting index of the passed array.\n         */\n        Matrix.FromArray = function (array, offset) {\n            var result = new Matrix();\n            if (!offset) {\n                offset = 0;\n            }\n            Matrix.FromArrayToRef(array, offset, result);\n            return result;\n        };\n        /**\n         * Sets the passed \"result\" matrix from the starting index of the passed array.\n         */\n        Matrix.FromArrayToRef = function (array, offset, result) {\n            for (var index = 0; index < 16; index++) {\n                result.m[index] = array[index + offset];\n            }\n            result._markAsUpdated();\n        };\n        /**\n         * Sets the passed \"result\" matrix from the starting index of the passed Float32Array by multiplying each element by the float \"scale\".\n         */\n        Matrix.FromFloat32ArrayToRefScaled = function (array, offset, scale, result) {\n            for (var index = 0; index < 16; index++) {\n                result.m[index] = array[index + offset] * scale;\n            }\n            result._markAsUpdated();\n        };\n        /**\n         * Sets the passed matrix \"result\" with the 16 passed floats.\n         */\n        Matrix.FromValuesToRef = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n            result.m[0] = initialM11;\n            result.m[1] = initialM12;\n            result.m[2] = initialM13;\n            result.m[3] = initialM14;\n            result.m[4] = initialM21;\n            result.m[5] = initialM22;\n            result.m[6] = initialM23;\n            result.m[7] = initialM24;\n            result.m[8] = initialM31;\n            result.m[9] = initialM32;\n            result.m[10] = initialM33;\n            result.m[11] = initialM34;\n            result.m[12] = initialM41;\n            result.m[13] = initialM42;\n            result.m[14] = initialM43;\n            result.m[15] = initialM44;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns the index-th row of the current matrix as a new Vector4.\n         */\n        Matrix.prototype.getRow = function (index) {\n            if (index < 0 || index > 3) {\n                return null;\n            }\n            var i = index * 4;\n            return new Vector4(this.m[i + 0], this.m[i + 1], this.m[i + 2], this.m[i + 3]);\n        };\n        /**\n         * Sets the index-th row of the current matrix with the passed Vector4 values.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.setRow = function (index, row) {\n            if (index < 0 || index > 3) {\n                return this;\n            }\n            var i = index * 4;\n            this.m[i + 0] = row.x;\n            this.m[i + 1] = row.y;\n            this.m[i + 2] = row.z;\n            this.m[i + 3] = row.w;\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Sets the index-th row of the current matrix with the passed 4 x float values.\n         * Returns the updated Matrix.\n         */\n        Matrix.prototype.setRowFromFloats = function (index, x, y, z, w) {\n            if (index < 0 || index > 3) {\n                return this;\n            }\n            var i = index * 4;\n            this.m[i + 0] = x;\n            this.m[i + 1] = y;\n            this.m[i + 2] = z;\n            this.m[i + 3] = w;\n            this._markAsUpdated();\n            return this;\n        };\n        /**\n         * Returns a new Matrix set from the 16 passed floats.\n         */\n        Matrix.FromValues = function (initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n            var result = new Matrix();\n            result.m[0] = initialM11;\n            result.m[1] = initialM12;\n            result.m[2] = initialM13;\n            result.m[3] = initialM14;\n            result.m[4] = initialM21;\n            result.m[5] = initialM22;\n            result.m[6] = initialM23;\n            result.m[7] = initialM24;\n            result.m[8] = initialM31;\n            result.m[9] = initialM32;\n            result.m[10] = initialM33;\n            result.m[11] = initialM34;\n            result.m[12] = initialM41;\n            result.m[13] = initialM42;\n            result.m[14] = initialM43;\n            result.m[15] = initialM44;\n            return result;\n        };\n        /**\n         * Returns a new Matrix composed by the passed scale (vector3), rotation (quaternion) and translation (vector3).\n         */\n        Matrix.Compose = function (scale, rotation, translation) {\n            var result = Matrix.Identity();\n            Matrix.ComposeToRef(scale, rotation, translation, result);\n            return result;\n        };\n        /**\n       * Update a Matrix with values composed by the passed scale (vector3), rotation (quaternion) and translation (vector3).\n       */\n        Matrix.ComposeToRef = function (scale, rotation, translation, result) {\n            Matrix.FromValuesToRef(scale.x, 0, 0, 0, 0, scale.y, 0, 0, 0, 0, scale.z, 0, 0, 0, 0, 1, MathTmp.Matrix[1]);\n            rotation.toRotationMatrix(MathTmp.Matrix[0]);\n            MathTmp.Matrix[1].multiplyToRef(MathTmp.Matrix[0], result);\n            result.setTranslation(translation);\n        };\n        /**\n         * Returns a new indentity Matrix.\n         */\n        Matrix.Identity = function () {\n            return Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n        };\n        /**\n         * Sets the passed \"result\" as an identity matrix.\n         */\n        Matrix.IdentityToRef = function (result) {\n            Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        };\n        /**\n         * Returns a new zero Matrix.\n         */\n        Matrix.Zero = function () {\n            return Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        };\n        /**\n         * Returns a new rotation matrix for \"angle\" radians around the X axis.\n         */\n        Matrix.RotationX = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationXToRef(angle, result);\n            return result;\n        };\n        /**\n         * Returns a new Matrix as the passed inverted one.\n         */\n        Matrix.Invert = function (source) {\n            var result = new Matrix();\n            source.invertToRef(result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix for \"angle\" radians around the X axis.\n         */\n        Matrix.RotationXToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[0] = 1.0;\n            result.m[15] = 1.0;\n            result.m[5] = c;\n            result.m[10] = c;\n            result.m[9] = -s;\n            result.m[6] = s;\n            result.m[1] = 0.0;\n            result.m[2] = 0.0;\n            result.m[3] = 0.0;\n            result.m[4] = 0.0;\n            result.m[7] = 0.0;\n            result.m[8] = 0.0;\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns a new rotation matrix for \"angle\" radians around the Y axis.\n         */\n        Matrix.RotationY = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationYToRef(angle, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix for \"angle\" radians around the Y axis.\n         */\n        Matrix.RotationYToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[5] = 1.0;\n            result.m[15] = 1.0;\n            result.m[0] = c;\n            result.m[2] = -s;\n            result.m[8] = s;\n            result.m[10] = c;\n            result.m[1] = 0.0;\n            result.m[3] = 0.0;\n            result.m[4] = 0.0;\n            result.m[6] = 0.0;\n            result.m[7] = 0.0;\n            result.m[9] = 0.0;\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns a new rotation matrix for \"angle\" radians around the Z axis.\n         */\n        Matrix.RotationZ = function (angle) {\n            var result = new Matrix();\n            Matrix.RotationZToRef(angle, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix for \"angle\" radians around the Z axis.\n         */\n        Matrix.RotationZToRef = function (angle, result) {\n            var s = Math.sin(angle);\n            var c = Math.cos(angle);\n            result.m[10] = 1.0;\n            result.m[15] = 1.0;\n            result.m[0] = c;\n            result.m[1] = s;\n            result.m[4] = -s;\n            result.m[5] = c;\n            result.m[2] = 0.0;\n            result.m[3] = 0.0;\n            result.m[6] = 0.0;\n            result.m[7] = 0.0;\n            result.m[8] = 0.0;\n            result.m[9] = 0.0;\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns a new rotation matrix for \"angle\" radians around the passed axis.\n         */\n        Matrix.RotationAxis = function (axis, angle) {\n            var result = Matrix.Zero();\n            Matrix.RotationAxisToRef(axis, angle, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix for \"angle\" radians around the passed axis.\n         */\n        Matrix.RotationAxisToRef = function (axis, angle, result) {\n            var s = Math.sin(-angle);\n            var c = Math.cos(-angle);\n            var c1 = 1 - c;\n            axis.normalize();\n            result.m[0] = (axis.x * axis.x) * c1 + c;\n            result.m[1] = (axis.x * axis.y) * c1 - (axis.z * s);\n            result.m[2] = (axis.x * axis.z) * c1 + (axis.y * s);\n            result.m[3] = 0.0;\n            result.m[4] = (axis.y * axis.x) * c1 + (axis.z * s);\n            result.m[5] = (axis.y * axis.y) * c1 + c;\n            result.m[6] = (axis.y * axis.z) * c1 - (axis.x * s);\n            result.m[7] = 0.0;\n            result.m[8] = (axis.z * axis.x) * c1 - (axis.y * s);\n            result.m[9] = (axis.z * axis.y) * c1 + (axis.x * s);\n            result.m[10] = (axis.z * axis.z) * c1 + c;\n            result.m[11] = 0.0;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns a new Matrix as a rotation matrix from the Euler angles (y, x, z).\n         */\n        Matrix.RotationYawPitchRoll = function (yaw, pitch, roll) {\n            var result = new Matrix();\n            Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix from the Euler angles (y, x, z).\n         */\n        Matrix.RotationYawPitchRollToRef = function (yaw, pitch, roll, result) {\n            Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, this._tempQuaternion);\n            this._tempQuaternion.toRotationMatrix(result);\n        };\n        /**\n         * Returns a new Matrix as a scaling matrix from the passed floats (x, y, z).\n         */\n        Matrix.Scaling = function (x, y, z) {\n            var result = Matrix.Zero();\n            Matrix.ScalingToRef(x, y, z, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a scaling matrix from the passed floats (x, y, z).\n         */\n        Matrix.ScalingToRef = function (x, y, z, result) {\n            result.m[0] = x;\n            result.m[1] = 0.0;\n            result.m[2] = 0.0;\n            result.m[3] = 0.0;\n            result.m[4] = 0.0;\n            result.m[5] = y;\n            result.m[6] = 0.0;\n            result.m[7] = 0.0;\n            result.m[8] = 0.0;\n            result.m[9] = 0.0;\n            result.m[10] = z;\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Returns a new Matrix as a translation matrix from the passed floats (x, y, z).\n         */\n        Matrix.Translation = function (x, y, z) {\n            var result = Matrix.Identity();\n            Matrix.TranslationToRef(x, y, z, result);\n            return result;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a translation matrix from the passed floats (x, y, z).\n         */\n        Matrix.TranslationToRef = function (x, y, z, result) {\n            Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n        };\n        /**\n         * Returns a new Matrix whose values are the interpolated values for \"gradien\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n         */\n        Matrix.Lerp = function (startValue, endValue, gradient) {\n            var result = Matrix.Zero();\n            for (var index = 0; index < 16; index++) {\n                result.m[index] = startValue.m[index] * (1.0 - gradient) + endValue.m[index] * gradient;\n            }\n            result._markAsUpdated();\n            return result;\n        };\n        /**\n         * Returns a new Matrix whose values are computed by :\n         * - decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices,\n         * - interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end,\n         * - recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices.\n         */\n        Matrix.DecomposeLerp = function (startValue, endValue, gradient) {\n            var startScale = new Vector3(0, 0, 0);\n            var startRotation = new Quaternion();\n            var startTranslation = new Vector3(0, 0, 0);\n            startValue.decompose(startScale, startRotation, startTranslation);\n            var endScale = new Vector3(0, 0, 0);\n            var endRotation = new Quaternion();\n            var endTranslation = new Vector3(0, 0, 0);\n            endValue.decompose(endScale, endRotation, endTranslation);\n            var resultScale = Vector3.Lerp(startScale, endScale, gradient);\n            var resultRotation = Quaternion.Slerp(startRotation, endRotation, gradient);\n            var resultTranslation = Vector3.Lerp(startTranslation, endTranslation, gradient);\n            return Matrix.Compose(resultScale, resultRotation, resultTranslation);\n        };\n        /**\n         * Returns a new rotation Matrix used to rotate a mesh so as it looks at the target Vector3, from the eye Vector3, the UP vector3 being orientated like \"up\".\n         * This methods works for a Left-Handed system.\n         */\n        Matrix.LookAtLH = function (eye, target, up) {\n            var result = Matrix.Zero();\n            Matrix.LookAtLHToRef(eye, target, up, result);\n            return result;\n        };\n        /**\n         * Sets the passed \"result\" Matrix as a rotation matrix used to rotate a mesh so as it looks at the target Vector3, from the eye Vector3, the UP vector3 being orientated like \"up\".\n         * This methods works for a Left-Handed system.\n         */\n        Matrix.LookAtLHToRef = function (eye, target, up, result) {\n            // Z axis\n            target.subtractToRef(eye, this._zAxis);\n            this._zAxis.normalize();\n            // X axis\n            Vector3.CrossToRef(up, this._zAxis, this._xAxis);\n            if (this._xAxis.lengthSquared() === 0) {\n                this._xAxis.x = 1.0;\n            }\n            else {\n                this._xAxis.normalize();\n            }\n            // Y axis\n            Vector3.CrossToRef(this._zAxis, this._xAxis, this._yAxis);\n            this._yAxis.normalize();\n            // Eye angles\n            var ex = -Vector3.Dot(this._xAxis, eye);\n            var ey = -Vector3.Dot(this._yAxis, eye);\n            var ez = -Vector3.Dot(this._zAxis, eye);\n            return Matrix.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, ex, ey, ez, 1, result);\n        };\n        /**\n         * Returns a new rotation Matrix used to rotate a mesh so as it looks at the target Vector3, from the eye Vector3, the UP vector3 being orientated like \"up\".\n         * This methods works for a Right-Handed system.\n         */\n        Matrix.LookAtRH = function (eye, target, up) {\n            var result = Matrix.Zero();\n            Matrix.LookAtRHToRef(eye, target, up, result);\n            return result;\n        };\n        /**\n         * Sets the passed \"result\" Matrix as a rotation matrix used to rotate a mesh so as it looks at the target Vector3, from the eye Vector3, the UP vector3 being orientated like \"up\".\n         * This methods works for a Left-Handed system.\n         */\n        Matrix.LookAtRHToRef = function (eye, target, up, result) {\n            // Z axis\n            eye.subtractToRef(target, this._zAxis);\n            this._zAxis.normalize();\n            // X axis\n            Vector3.CrossToRef(up, this._zAxis, this._xAxis);\n            if (this._xAxis.lengthSquared() === 0) {\n                this._xAxis.x = 1.0;\n            }\n            else {\n                this._xAxis.normalize();\n            }\n            // Y axis\n            Vector3.CrossToRef(this._zAxis, this._xAxis, this._yAxis);\n            this._yAxis.normalize();\n            // Eye angles\n            var ex = -Vector3.Dot(this._xAxis, eye);\n            var ey = -Vector3.Dot(this._yAxis, eye);\n            var ez = -Vector3.Dot(this._zAxis, eye);\n            return Matrix.FromValuesToRef(this._xAxis.x, this._yAxis.x, this._zAxis.x, 0, this._xAxis.y, this._yAxis.y, this._zAxis.y, 0, this._xAxis.z, this._yAxis.z, this._zAxis.z, 0, ex, ey, ez, 1, result);\n        };\n        /**\n         * Returns a new Matrix as a left-handed orthographic projection matrix computed from the passed floats : width and height of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoLH = function (width, height, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a left-handed orthographic projection matrix computed from the passed floats : width and height of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoLHToRef = function (width, height, znear, zfar, result) {\n            var n = znear;\n            var f = zfar;\n            var a = 2.0 / width;\n            var b = 2.0 / height;\n            var c = 2.0 / (f - n);\n            var d = -(f + n) / (f - n);\n            BABYLON.Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n        };\n        /**\n         * Returns a new Matrix as a left-handed orthographic projection matrix computed from the passed floats : left, right, top and bottom being the coordinates of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoOffCenterLH = function (left, right, bottom, top, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a left-handed orthographic projection matrix computed from the passed floats : left, right, top and bottom being the coordinates of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoOffCenterLHToRef = function (left, right, bottom, top, znear, zfar, result) {\n            var n = znear;\n            var f = zfar;\n            var a = 2.0 / (right - left);\n            var b = 2.0 / (top - bottom);\n            var c = 2.0 / (f - n);\n            var d = -(f + n) / (f - n);\n            var i0 = (left + right) / (left - right);\n            var i1 = (top + bottom) / (bottom - top);\n            BABYLON.Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n        };\n        /**\n         * Returns a new Matrix as a right-handed orthographic projection matrix computed from the passed floats : left, right, top and bottom being the coordinates of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoOffCenterRH = function (left, right, bottom, top, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a right-handed orthographic projection matrix computed from the passed floats : left, right, top and bottom being the coordinates of the projection plane, z near and far limits.\n         */\n        Matrix.OrthoOffCenterRHToRef = function (left, right, bottom, top, znear, zfar, result) {\n            Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\n            result.m[10] *= -1.0;\n        };\n        /**\n         * Returns a new Matrix as a left-handed perspective projection matrix computed from the passed floats : width and height of the projection plane, z near and far limits.\n         */\n        Matrix.PerspectiveLH = function (width, height, znear, zfar) {\n            var matrix = Matrix.Zero();\n            var n = znear;\n            var f = zfar;\n            var a = 2.0 * n / width;\n            var b = 2.0 * n / height;\n            var c = (f + n) / (f - n);\n            var d = -2.0 * f * n / (f - n);\n            BABYLON.Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n            return matrix;\n        };\n        /**\n         * Returns a new Matrix as a left-handed perspective projection matrix computed from the passed floats : vertical angle of view (fov), width/height ratio (aspect), z near and far limits.\n         */\n        Matrix.PerspectiveFovLH = function (fov, aspect, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a left-handed perspective projection matrix computed from the passed floats : vertical angle of view (fov), width/height ratio (aspect), z near and far limits.\n         */\n        Matrix.PerspectiveFovLHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n            if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n            var n = znear;\n            var f = zfar;\n            var t = 1.0 / (Math.tan(fov * 0.5));\n            var a = isVerticalFovFixed ? (t / aspect) : t;\n            var b = isVerticalFovFixed ? t : (t * aspect);\n            var c = (f + n) / (f - n);\n            var d = -2.0 * f * n / (f - n);\n            BABYLON.Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n        };\n        /**\n         * Returns a new Matrix as a right-handed perspective projection matrix computed from the passed floats : vertical angle of view (fov), width/height ratio (aspect), z near and far limits.\n         */\n        Matrix.PerspectiveFovRH = function (fov, aspect, znear, zfar) {\n            var matrix = Matrix.Zero();\n            Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as a right-handed perspective projection matrix computed from the passed floats : vertical angle of view (fov), width/height ratio (aspect), z near and far limits.\n         */\n        Matrix.PerspectiveFovRHToRef = function (fov, aspect, znear, zfar, result, isVerticalFovFixed) {\n            //alternatively this could be expressed as:\n            //    m = PerspectiveFovLHToRef\n            //    m[10] *= -1.0;\n            //    m[11] *= -1.0;\n            if (isVerticalFovFixed === void 0) { isVerticalFovFixed = true; }\n            var n = znear;\n            var f = zfar;\n            var t = 1.0 / (Math.tan(fov * 0.5));\n            var a = isVerticalFovFixed ? (t / aspect) : t;\n            var b = isVerticalFovFixed ? t : (t * aspect);\n            var c = -(f + n) / (f - n);\n            var d = -2 * f * n / (f - n);\n            BABYLON.Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n        };\n        /**\n         * Sets the passed matrix \"result\" as a left-handed perspective projection matrix  for WebVR computed from the passed floats : vertical angle of view (fov), width/height ratio (aspect), z near and far limits.\n         */\n        Matrix.PerspectiveFovWebVRToRef = function (fov, znear, zfar, result, rightHanded) {\n            if (rightHanded === void 0) { rightHanded = false; }\n            var rightHandedFactor = rightHanded ? -1 : 1;\n            var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\n            var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\n            var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\n            var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\n            var xScale = 2.0 / (leftTan + rightTan);\n            var yScale = 2.0 / (upTan + downTan);\n            result.m[0] = xScale;\n            result.m[1] = result.m[2] = result.m[3] = result.m[4] = 0.0;\n            result.m[5] = yScale;\n            result.m[6] = result.m[7] = 0.0;\n            result.m[8] = ((leftTan - rightTan) * xScale * 0.5); // * rightHandedFactor;\n            result.m[9] = -((upTan - downTan) * yScale * 0.5); // * rightHandedFactor;\n            //result.m[10] = -(znear + zfar) / (zfar - znear) * rightHandedFactor;\n            result.m[10] = -zfar / (znear - zfar);\n            result.m[11] = 1.0 * rightHandedFactor;\n            result.m[12] = result.m[13] = result.m[15] = 0.0;\n            result.m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n            // result.m[14] = (znear * zfar) / (znear - zfar);\n            result._markAsUpdated();\n        };\n        /**\n         * Returns the final transformation matrix : world * view * projection * viewport\n         */\n        Matrix.GetFinalMatrix = function (viewport, world, view, projection, zmin, zmax) {\n            var cw = viewport.width;\n            var ch = viewport.height;\n            var cx = viewport.x;\n            var cy = viewport.y;\n            var viewportMatrix = Matrix.FromValues(cw / 2.0, 0.0, 0.0, 0.0, 0.0, -ch / 2.0, 0.0, 0.0, 0.0, 0.0, zmax - zmin, 0.0, cx + cw / 2.0, ch / 2.0 + cy, zmin, 1);\n            return world.multiply(view).multiply(projection).multiply(viewportMatrix);\n        };\n        /**\n         * Returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the passed Matrix.\n         */\n        Matrix.GetAsMatrix2x2 = function (matrix) {\n            return new Float32Array([\n                matrix.m[0], matrix.m[1],\n                matrix.m[4], matrix.m[5]\n            ]);\n        };\n        /**\n         * Returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the passed Matrix.\n         */\n        Matrix.GetAsMatrix3x3 = function (matrix) {\n            return new Float32Array([\n                matrix.m[0], matrix.m[1], matrix.m[2],\n                matrix.m[4], matrix.m[5], matrix.m[6],\n                matrix.m[8], matrix.m[9], matrix.m[10]\n            ]);\n        };\n        /**\n         * Compute the transpose of the passed Matrix.\n         * Returns a new Matrix.\n         */\n        Matrix.Transpose = function (matrix) {\n            var result = new Matrix();\n            result.m[0] = matrix.m[0];\n            result.m[1] = matrix.m[4];\n            result.m[2] = matrix.m[8];\n            result.m[3] = matrix.m[12];\n            result.m[4] = matrix.m[1];\n            result.m[5] = matrix.m[5];\n            result.m[6] = matrix.m[9];\n            result.m[7] = matrix.m[13];\n            result.m[8] = matrix.m[2];\n            result.m[9] = matrix.m[6];\n            result.m[10] = matrix.m[10];\n            result.m[11] = matrix.m[14];\n            result.m[12] = matrix.m[3];\n            result.m[13] = matrix.m[7];\n            result.m[14] = matrix.m[11];\n            result.m[15] = matrix.m[15];\n            return result;\n        };\n        /**\n         * Returns a new Matrix as the reflection  matrix across the passed plane.\n         */\n        Matrix.Reflection = function (plane) {\n            var matrix = new Matrix();\n            Matrix.ReflectionToRef(plane, matrix);\n            return matrix;\n        };\n        /**\n         * Sets the passed matrix \"result\" as the reflection matrix across the passed plane.\n         */\n        Matrix.ReflectionToRef = function (plane, result) {\n            plane.normalize();\n            var x = plane.normal.x;\n            var y = plane.normal.y;\n            var z = plane.normal.z;\n            var temp = -2 * x;\n            var temp2 = -2 * y;\n            var temp3 = -2 * z;\n            result.m[0] = (temp * x) + 1;\n            result.m[1] = temp2 * x;\n            result.m[2] = temp3 * x;\n            result.m[3] = 0.0;\n            result.m[4] = temp * y;\n            result.m[5] = (temp2 * y) + 1;\n            result.m[6] = temp3 * y;\n            result.m[7] = 0.0;\n            result.m[8] = temp * z;\n            result.m[9] = temp2 * z;\n            result.m[10] = (temp3 * z) + 1;\n            result.m[11] = 0.0;\n            result.m[12] = temp * plane.d;\n            result.m[13] = temp2 * plane.d;\n            result.m[14] = temp3 * plane.d;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Sets the passed matrix \"mat\" as a rotation matrix composed from the 3 passed  left handed axis.\n         */\n        Matrix.FromXYZAxesToRef = function (xaxis, yaxis, zaxis, result) {\n            result.m[0] = xaxis.x;\n            result.m[1] = xaxis.y;\n            result.m[2] = xaxis.z;\n            result.m[3] = 0.0;\n            result.m[4] = yaxis.x;\n            result.m[5] = yaxis.y;\n            result.m[6] = yaxis.z;\n            result.m[7] = 0.0;\n            result.m[8] = zaxis.x;\n            result.m[9] = zaxis.y;\n            result.m[10] = zaxis.z;\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n        };\n        /**\n         * Sets the passed matrix \"result\" as a rotation matrix according to the passed quaternion.\n         */\n        Matrix.FromQuaternionToRef = function (quat, result) {\n            var xx = quat.x * quat.x;\n            var yy = quat.y * quat.y;\n            var zz = quat.z * quat.z;\n            var xy = quat.x * quat.y;\n            var zw = quat.z * quat.w;\n            var zx = quat.z * quat.x;\n            var yw = quat.y * quat.w;\n            var yz = quat.y * quat.z;\n            var xw = quat.x * quat.w;\n            result.m[0] = 1.0 - (2.0 * (yy + zz));\n            result.m[1] = 2.0 * (xy + zw);\n            result.m[2] = 2.0 * (zx - yw);\n            result.m[3] = 0.0;\n            result.m[4] = 2.0 * (xy - zw);\n            result.m[5] = 1.0 - (2.0 * (zz + xx));\n            result.m[6] = 2.0 * (yz + xw);\n            result.m[7] = 0.0;\n            result.m[8] = 2.0 * (zx + yw);\n            result.m[9] = 2.0 * (yz - xw);\n            result.m[10] = 1.0 - (2.0 * (yy + xx));\n            result.m[11] = 0.0;\n            result.m[12] = 0.0;\n            result.m[13] = 0.0;\n            result.m[14] = 0.0;\n            result.m[15] = 1.0;\n            result._markAsUpdated();\n        };\n        return Matrix;\n    }());\n    Matrix._tempQuaternion = new Quaternion();\n    Matrix._xAxis = Vector3.Zero();\n    Matrix._yAxis = Vector3.Zero();\n    Matrix._zAxis = Vector3.Zero();\n    Matrix._updateFlagSeed = 0;\n    BABYLON.Matrix = Matrix;\n    var Plane = (function () {\n        /**\n         * Creates a Plane object according to the passed floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n         */\n        function Plane(a, b, c, d) {\n            this.normal = new Vector3(a, b, c);\n            this.d = d;\n        }\n        /**\n         * Returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n         */\n        Plane.prototype.asArray = function () {\n            return [this.normal.x, this.normal.y, this.normal.z, this.d];\n        };\n        // Methods\n        /**\n         * Returns a new plane copied from the current Plane.\n         */\n        Plane.prototype.clone = function () {\n            return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n        };\n        /**\n         * Returns the string \"Plane\".\n         */\n        Plane.prototype.getClassName = function () {\n            return \"Plane\";\n        };\n        /**\n         * Returns the Plane hash code.\n         */\n        Plane.prototype.getHashCode = function () {\n            var hash = this.normal.getHashCode();\n            hash = (hash * 397) ^ (this.d || 0);\n            return hash;\n        };\n        /**\n         * Normalize the current Plane in place.\n         * Returns the updated Plane.\n         */\n        Plane.prototype.normalize = function () {\n            var norm = (Math.sqrt((this.normal.x * this.normal.x) + (this.normal.y * this.normal.y) + (this.normal.z * this.normal.z)));\n            var magnitude = 0.0;\n            if (norm !== 0) {\n                magnitude = 1.0 / norm;\n            }\n            this.normal.x *= magnitude;\n            this.normal.y *= magnitude;\n            this.normal.z *= magnitude;\n            this.d *= magnitude;\n            return this;\n        };\n        /**\n         * Returns a new Plane as the result of the transformation of the current Plane by the passed matrix.\n         */\n        Plane.prototype.transform = function (transformation) {\n            var transposedMatrix = Matrix.Transpose(transformation);\n            var x = this.normal.x;\n            var y = this.normal.y;\n            var z = this.normal.z;\n            var d = this.d;\n            var normalX = (((x * transposedMatrix.m[0]) + (y * transposedMatrix.m[1])) + (z * transposedMatrix.m[2])) + (d * transposedMatrix.m[3]);\n            var normalY = (((x * transposedMatrix.m[4]) + (y * transposedMatrix.m[5])) + (z * transposedMatrix.m[6])) + (d * transposedMatrix.m[7]);\n            var normalZ = (((x * transposedMatrix.m[8]) + (y * transposedMatrix.m[9])) + (z * transposedMatrix.m[10])) + (d * transposedMatrix.m[11]);\n            var finalD = (((x * transposedMatrix.m[12]) + (y * transposedMatrix.m[13])) + (z * transposedMatrix.m[14])) + (d * transposedMatrix.m[15]);\n            return new Plane(normalX, normalY, normalZ, finalD);\n        };\n        /**\n         * Returns the dot product (float) of the point coordinates and the plane normal.\n         */\n        Plane.prototype.dotCoordinate = function (point) {\n            return ((((this.normal.x * point.x) + (this.normal.y * point.y)) + (this.normal.z * point.z)) + this.d);\n        };\n        /**\n         * Updates the current Plane from the plane defined by the three passed points.\n         * Returns the updated Plane.\n         */\n        Plane.prototype.copyFromPoints = function (point1, point2, point3) {\n            var x1 = point2.x - point1.x;\n            var y1 = point2.y - point1.y;\n            var z1 = point2.z - point1.z;\n            var x2 = point3.x - point1.x;\n            var y2 = point3.y - point1.y;\n            var z2 = point3.z - point1.z;\n            var yz = (y1 * z2) - (z1 * y2);\n            var xz = (z1 * x2) - (x1 * z2);\n            var xy = (x1 * y2) - (y1 * x2);\n            var pyth = (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\n            var invPyth;\n            if (pyth !== 0) {\n                invPyth = 1.0 / pyth;\n            }\n            else {\n                invPyth = 0.0;\n            }\n            this.normal.x = yz * invPyth;\n            this.normal.y = xz * invPyth;\n            this.normal.z = xy * invPyth;\n            this.d = -((this.normal.x * point1.x) + (this.normal.y * point1.y) + (this.normal.z * point1.z));\n            return this;\n        };\n        /**\n         * Boolean : True is the vector \"direction\"  is the same side than the plane normal.\n         */\n        Plane.prototype.isFrontFacingTo = function (direction, epsilon) {\n            var dot = Vector3.Dot(this.normal, direction);\n            return (dot <= epsilon);\n        };\n        /**\n         * Returns the signed distance (float) from the passed point to the Plane.\n         */\n        Plane.prototype.signedDistanceTo = function (point) {\n            return Vector3.Dot(point, this.normal) + this.d;\n        };\n        // Statics\n        /**\n         * Returns a new Plane from the passed array.\n         */\n        Plane.FromArray = function (array) {\n            return new Plane(array[0], array[1], array[2], array[3]);\n        };\n        /**\n         * Returns a new Plane defined by the three passed points.\n         */\n        Plane.FromPoints = function (point1, point2, point3) {\n            var result = new Plane(0.0, 0.0, 0.0, 0.0);\n            result.copyFromPoints(point1, point2, point3);\n            return result;\n        };\n        /**\n         * Returns a new Plane the normal vector to this plane at the passed origin point.\n         * Note : the vector \"normal\" is updated because normalized.\n         */\n        Plane.FromPositionAndNormal = function (origin, normal) {\n            var result = new Plane(0.0, 0.0, 0.0, 0.0);\n            normal.normalize();\n            result.normal = normal;\n            result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n            return result;\n        };\n        /**\n         * Returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the passed other point.\n         */\n        Plane.SignedDistanceToPlaneFromPositionAndNormal = function (origin, normal, point) {\n            var d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n            return Vector3.Dot(point, normal) + d;\n        };\n        return Plane;\n    }());\n    BABYLON.Plane = Plane;\n    var Viewport = (function () {\n        /**\n         * Creates a Viewport object located at (x, y) and sized (width, height).\n         */\n        function Viewport(x, y, width, height) {\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n        }\n        Viewport.prototype.toGlobal = function (renderWidthOrEngine, renderHeight) {\n            if (renderWidthOrEngine._gl) {\n                var engine = renderWidthOrEngine;\n                return this.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n            }\n            var renderWidth = renderWidthOrEngine;\n            return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);\n        };\n        /**\n         * Returns a new Viewport copied from the current one.\n         */\n        Viewport.prototype.clone = function () {\n            return new Viewport(this.x, this.y, this.width, this.height);\n        };\n        return Viewport;\n    }());\n    BABYLON.Viewport = Viewport;\n    var Frustum = (function () {\n        function Frustum() {\n        }\n        /**\n         * Returns a new array of 6 Frustum planes computed by the passed transformation matrix.\n         */\n        Frustum.GetPlanes = function (transform) {\n            var frustumPlanes = [];\n            for (var index = 0; index < 6; index++) {\n                frustumPlanes.push(new Plane(0.0, 0.0, 0.0, 0.0));\n            }\n            Frustum.GetPlanesToRef(transform, frustumPlanes);\n            return frustumPlanes;\n        };\n        /**\n         * Sets the passed array \"frustumPlanes\" with the 6 Frustum planes computed by the passed transformation matrix.\n         */\n        Frustum.GetPlanesToRef = function (transform, frustumPlanes) {\n            // Near\n            frustumPlanes[0].normal.x = transform.m[3] + transform.m[2];\n            frustumPlanes[0].normal.y = transform.m[7] + transform.m[6];\n            frustumPlanes[0].normal.z = transform.m[11] + transform.m[10];\n            frustumPlanes[0].d = transform.m[15] + transform.m[14];\n            frustumPlanes[0].normalize();\n            // Far\n            frustumPlanes[1].normal.x = transform.m[3] - transform.m[2];\n            frustumPlanes[1].normal.y = transform.m[7] - transform.m[6];\n            frustumPlanes[1].normal.z = transform.m[11] - transform.m[10];\n            frustumPlanes[1].d = transform.m[15] - transform.m[14];\n            frustumPlanes[1].normalize();\n            // Left\n            frustumPlanes[2].normal.x = transform.m[3] + transform.m[0];\n            frustumPlanes[2].normal.y = transform.m[7] + transform.m[4];\n            frustumPlanes[2].normal.z = transform.m[11] + transform.m[8];\n            frustumPlanes[2].d = transform.m[15] + transform.m[12];\n            frustumPlanes[2].normalize();\n            // Right\n            frustumPlanes[3].normal.x = transform.m[3] - transform.m[0];\n            frustumPlanes[3].normal.y = transform.m[7] - transform.m[4];\n            frustumPlanes[3].normal.z = transform.m[11] - transform.m[8];\n            frustumPlanes[3].d = transform.m[15] - transform.m[12];\n            frustumPlanes[3].normalize();\n            // Top\n            frustumPlanes[4].normal.x = transform.m[3] - transform.m[1];\n            frustumPlanes[4].normal.y = transform.m[7] - transform.m[5];\n            frustumPlanes[4].normal.z = transform.m[11] - transform.m[9];\n            frustumPlanes[4].d = transform.m[15] - transform.m[13];\n            frustumPlanes[4].normalize();\n            // Bottom\n            frustumPlanes[5].normal.x = transform.m[3] + transform.m[1];\n            frustumPlanes[5].normal.y = transform.m[7] + transform.m[5];\n            frustumPlanes[5].normal.z = transform.m[11] + transform.m[9];\n            frustumPlanes[5].d = transform.m[15] + transform.m[13];\n            frustumPlanes[5].normalize();\n        };\n        return Frustum;\n    }());\n    BABYLON.Frustum = Frustum;\n    var Space;\n    (function (Space) {\n        Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n        Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n        Space[Space[\"BONE\"] = 2] = \"BONE\";\n    })(Space = BABYLON.Space || (BABYLON.Space = {}));\n    var Axis = (function () {\n        function Axis() {\n        }\n        return Axis;\n    }());\n    Axis.X = new Vector3(1.0, 0.0, 0.0);\n    Axis.Y = new Vector3(0.0, 1.0, 0.0);\n    Axis.Z = new Vector3(0.0, 0.0, 1.0);\n    BABYLON.Axis = Axis;\n    ;\n    var BezierCurve = (function () {\n        function BezierCurve() {\n        }\n        /**\n         * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the passed x1, y1, x2, y2 floats.\n         */\n        BezierCurve.interpolate = function (t, x1, y1, x2, y2) {\n            // Extract X (which is equal to time here)\n            var f0 = 1 - 3 * x2 + 3 * x1;\n            var f1 = 3 * x2 - 6 * x1;\n            var f2 = 3 * x1;\n            var refinedT = t;\n            for (var i = 0; i < 5; i++) {\n                var refinedT2 = refinedT * refinedT;\n                var refinedT3 = refinedT2 * refinedT;\n                var x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n                var slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n                refinedT -= (x - t) * slope;\n                refinedT = Math.min(1, Math.max(0, refinedT));\n            }\n            // Resolve cubic bezier for the given x\n            return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 +\n                3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 +\n                Math.pow(refinedT, 3);\n        };\n        return BezierCurve;\n    }());\n    BABYLON.BezierCurve = BezierCurve;\n    var Orientation;\n    (function (Orientation) {\n        Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n        Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n    })(Orientation = BABYLON.Orientation || (BABYLON.Orientation = {}));\n    var Angle = (function () {\n        /**\n         * Creates an Angle object of \"radians\" radians (float).\n         */\n        function Angle(radians) {\n            var _this = this;\n            /**\n             * Returns the Angle value in degrees (float).\n             */\n            this.degrees = function () { return _this._radians * 180.0 / Math.PI; };\n            /**\n             * Returns the Angle value in radians (float).\n             */\n            this.radians = function () { return _this._radians; };\n            this._radians = radians;\n            if (this._radians < 0.0)\n                this._radians += (2.0 * Math.PI);\n        }\n        /**\n         * Returns a new Angle object valued with the angle value in radians between the two passed vectors.\n         */\n        Angle.BetweenTwoPoints = function (a, b) {\n            var delta = b.subtract(a);\n            var theta = Math.atan2(delta.y, delta.x);\n            return new Angle(theta);\n        };\n        /**\n         * Returns a new Angle object from the passed float in radians.\n         */\n        Angle.FromRadians = function (radians) {\n            return new Angle(radians);\n        };\n        /**\n         * Returns a new Angle object from the passed float in degrees.\n         */\n        Angle.FromDegrees = function (degrees) {\n            return new Angle(degrees * Math.PI / 180.0);\n        };\n        return Angle;\n    }());\n    BABYLON.Angle = Angle;\n    var Arc2 = (function () {\n        /**\n         * Creates an Arc object from the three passed points : start, middle and end.\n         */\n        function Arc2(startPoint, midPoint, endPoint) {\n            this.startPoint = startPoint;\n            this.midPoint = midPoint;\n            this.endPoint = endPoint;\n            var temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n            var startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2.;\n            var midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2.;\n            var det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n            this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);\n            this.radius = this.centerPoint.subtract(this.startPoint).length();\n            this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n            var a1 = this.startAngle.degrees();\n            var a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n            var a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n            // angles correction\n            if (a2 - a1 > +180.0)\n                a2 -= 360.0;\n            if (a2 - a1 < -180.0)\n                a2 += 360.0;\n            if (a3 - a2 > +180.0)\n                a3 -= 360.0;\n            if (a3 - a2 < -180.0)\n                a3 += 360.0;\n            this.orientation = (a2 - a1) < 0 ? Orientation.CW : Orientation.CCW;\n            this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);\n        }\n        return Arc2;\n    }());\n    BABYLON.Arc2 = Arc2;\n    var Path2 = (function () {\n        /**\n         * Creates a Path2 object from the starting 2D coordinates x and y.\n         */\n        function Path2(x, y) {\n            this._points = new Array();\n            this._length = 0.0;\n            this.closed = false;\n            this._points.push(new Vector2(x, y));\n        }\n        /**\n         * Adds a new segment until the passed coordinates (x, y) to the current Path2.\n         * Returns the updated Path2.\n         */\n        Path2.prototype.addLineTo = function (x, y) {\n            if (closed) {\n                //Tools.Error(\"cannot add lines to closed paths\");\n                return this;\n            }\n            var newPoint = new Vector2(x, y);\n            var previousPoint = this._points[this._points.length - 1];\n            this._points.push(newPoint);\n            this._length += newPoint.subtract(previousPoint).length();\n            return this;\n        };\n        /**\n         * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n         * Returns the updated Path2.\n         */\n        Path2.prototype.addArcTo = function (midX, midY, endX, endY, numberOfSegments) {\n            if (numberOfSegments === void 0) { numberOfSegments = 36; }\n            if (closed) {\n                //Tools.Error(\"cannot add arcs to closed paths\");\n                return this;\n            }\n            var startPoint = this._points[this._points.length - 1];\n            var midPoint = new Vector2(midX, midY);\n            var endPoint = new Vector2(endX, endY);\n            var arc = new Arc2(startPoint, midPoint, endPoint);\n            var increment = arc.angle.radians() / numberOfSegments;\n            if (arc.orientation === Orientation.CW)\n                increment *= -1;\n            var currentAngle = arc.startAngle.radians() + increment;\n            for (var i = 0; i < numberOfSegments; i++) {\n                var x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n                var y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n                this.addLineTo(x, y);\n                currentAngle += increment;\n            }\n            return this;\n        };\n        /**\n         * Closes the Path2.\n         * Returns the Path2.\n         */\n        Path2.prototype.close = function () {\n            this.closed = true;\n            return this;\n        };\n        /**\n         * Returns the Path2 total length (float).\n         */\n        Path2.prototype.length = function () {\n            var result = this._length;\n            if (!this.closed) {\n                var lastPoint = this._points[this._points.length - 1];\n                var firstPoint = this._points[0];\n                result += (firstPoint.subtract(lastPoint).length());\n            }\n            return result;\n        };\n        /**\n         * Returns the Path2 internal array of points.\n         */\n        Path2.prototype.getPoints = function () {\n            return this._points;\n        };\n        /**\n         * Returns a new Vector2 located at a percentage of the Path2 total length on this path.\n         */\n        Path2.prototype.getPointAtLengthPosition = function (normalizedLengthPosition) {\n            if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n                //Tools.Error(\"normalized length position should be between 0 and 1.\");\n                return Vector2.Zero();\n            }\n            var lengthPosition = normalizedLengthPosition * this.length();\n            var previousOffset = 0;\n            for (var i = 0; i < this._points.length; i++) {\n                var j = (i + 1) % this._points.length;\n                var a = this._points[i];\n                var b = this._points[j];\n                var bToA = b.subtract(a);\n                var nextOffset = (bToA.length() + previousOffset);\n                if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                    var dir = bToA.normalize();\n                    var localOffset = lengthPosition - previousOffset;\n                    return new Vector2(a.x + (dir.x * localOffset), a.y + (dir.y * localOffset));\n                }\n                previousOffset = nextOffset;\n            }\n            //Tools.Error(\"internal error\");\n            return Vector2.Zero();\n        };\n        /**\n         * Returns a new Path2 starting at the coordinates (x, y).\n         */\n        Path2.StartingAt = function (x, y) {\n            return new Path2(x, y);\n        };\n        return Path2;\n    }());\n    BABYLON.Path2 = Path2;\n    var Path3D = (function () {\n        /**\n        * new Path3D(path, normal, raw)\n        * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n        * please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D\n        * path : an array of Vector3, the curve axis of the Path3D\n        * normal (optional) : Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n        * raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n        */\n        function Path3D(path, firstNormal, raw) {\n            this.path = path;\n            this._curve = new Array();\n            this._distances = new Array();\n            this._tangents = new Array();\n            this._normals = new Array();\n            this._binormals = new Array();\n            for (var p = 0; p < path.length; p++) {\n                this._curve[p] = path[p].clone(); // hard copy\n            }\n            this._raw = raw || false;\n            this._compute(firstNormal);\n        }\n        /**\n         * Returns the Path3D array of successive Vector3 designing its curve.\n         */\n        Path3D.prototype.getCurve = function () {\n            return this._curve;\n        };\n        /**\n         * Returns an array populated with tangent vectors on each Path3D curve point.\n         */\n        Path3D.prototype.getTangents = function () {\n            return this._tangents;\n        };\n        /**\n         * Returns an array populated with normal vectors on each Path3D curve point.\n         */\n        Path3D.prototype.getNormals = function () {\n            return this._normals;\n        };\n        /**\n         * Returns an array populated with binormal vectors on each Path3D curve point.\n         */\n        Path3D.prototype.getBinormals = function () {\n            return this._binormals;\n        };\n        /**\n         * Returns an array populated with distances (float) of the i-th point from the first curve point.\n         */\n        Path3D.prototype.getDistances = function () {\n            return this._distances;\n        };\n        /**\n         * Forces the Path3D tangent, normal, binormal and distance recomputation.\n         * Returns the same object updated.\n         */\n        Path3D.prototype.update = function (path, firstNormal) {\n            for (var p = 0; p < path.length; p++) {\n                this._curve[p].x = path[p].x;\n                this._curve[p].y = path[p].y;\n                this._curve[p].z = path[p].z;\n            }\n            this._compute(firstNormal);\n            return this;\n        };\n        // private function compute() : computes tangents, normals and binormals\n        Path3D.prototype._compute = function (firstNormal) {\n            var l = this._curve.length;\n            // first and last tangents\n            this._tangents[0] = this._getFirstNonNullVector(0);\n            if (!this._raw) {\n                this._tangents[0].normalize();\n            }\n            this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n            if (!this._raw) {\n                this._tangents[l - 1].normalize();\n            }\n            // normals and binormals at first point : arbitrary vector with _normalVector()\n            var tg0 = this._tangents[0];\n            var pp0 = this._normalVector(this._curve[0], tg0, firstNormal);\n            this._normals[0] = pp0;\n            if (!this._raw) {\n                this._normals[0].normalize();\n            }\n            this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);\n            if (!this._raw) {\n                this._binormals[0].normalize();\n            }\n            this._distances[0] = 0.0;\n            // normals and binormals : next points\n            var prev; // previous vector (segment)\n            var cur; // current vector (segment)\n            var curTang; // current tangent\n            // previous normal\n            var prevBinor; // previous binormal\n            for (var i = 1; i < l; i++) {\n                // tangents\n                prev = this._getLastNonNullVector(i);\n                if (i < l - 1) {\n                    cur = this._getFirstNonNullVector(i);\n                    this._tangents[i] = prev.add(cur);\n                    this._tangents[i].normalize();\n                }\n                this._distances[i] = this._distances[i - 1] + prev.length();\n                // normals and binormals\n                // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n                curTang = this._tangents[i];\n                prevBinor = this._binormals[i - 1];\n                this._normals[i] = Vector3.Cross(prevBinor, curTang);\n                if (!this._raw) {\n                    this._normals[i].normalize();\n                }\n                this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);\n                if (!this._raw) {\n                    this._binormals[i].normalize();\n                }\n            }\n        };\n        // private function getFirstNonNullVector(index)\n        // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n        Path3D.prototype._getFirstNonNullVector = function (index) {\n            var i = 1;\n            var nNVector = this._curve[index + i].subtract(this._curve[index]);\n            while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n                i++;\n                nNVector = this._curve[index + i].subtract(this._curve[index]);\n            }\n            return nNVector;\n        };\n        // private function getLastNonNullVector(index)\n        // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n        Path3D.prototype._getLastNonNullVector = function (index) {\n            var i = 1;\n            var nLVector = this._curve[index].subtract(this._curve[index - i]);\n            while (nLVector.length() === 0 && index > i + 1) {\n                i++;\n                nLVector = this._curve[index].subtract(this._curve[index - i]);\n            }\n            return nLVector;\n        };\n        // private function normalVector(v0, vt, va) :\n        // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n        // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n        Path3D.prototype._normalVector = function (v0, vt, va) {\n            var normal0;\n            var tgl = vt.length();\n            if (tgl === 0.0) {\n                tgl = 1.0;\n            }\n            if (va === undefined || va === null) {\n                var point;\n                if (!MathTools.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, BABYLON.Epsilon)) {\n                    point = new Vector3(0.0, -1.0, 0.0);\n                }\n                else if (!MathTools.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, BABYLON.Epsilon)) {\n                    point = new Vector3(1.0, 0.0, 0.0);\n                }\n                else if (!MathTools.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, BABYLON.Epsilon)) {\n                    point = new Vector3(0.0, 0.0, 1.0);\n                }\n                normal0 = Vector3.Cross(vt, point);\n            }\n            else {\n                normal0 = Vector3.Cross(vt, va);\n                Vector3.CrossToRef(normal0, vt, normal0);\n            }\n            normal0.normalize();\n            return normal0;\n        };\n        return Path3D;\n    }());\n    BABYLON.Path3D = Path3D;\n    var Curve3 = (function () {\n        /**\n         * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n         * A Curve3 is designed from a series of successive Vector3.\n         * Tuto : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object\n         */\n        function Curve3(points) {\n            this._length = 0.0;\n            this._points = points;\n            this._length = this._computeLength(points);\n        }\n        /**\n         * Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve\n         * @param v0 (Vector3) the origin point of the Quadratic Bezier\n         * @param v1 (Vector3) the control point\n         * @param v2 (Vector3) the end point of the Quadratic Bezier\n         * @param nbPoints (integer) the wanted number of points in the curve\n         */\n        Curve3.CreateQuadraticBezier = function (v0, v1, v2, nbPoints) {\n            nbPoints = nbPoints > 2 ? nbPoints : 3;\n            var bez = new Array();\n            var equation = function (t, val0, val1, val2) {\n                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n                return res;\n            };\n            for (var i = 0; i <= nbPoints; i++) {\n                bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n            }\n            return new Curve3(bez);\n        };\n        /**\n         * Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve\n         * @param v0 (Vector3) the origin point of the Cubic Bezier\n         * @param v1 (Vector3) the first control point\n         * @param v2 (Vector3) the second control point\n         * @param v3 (Vector3) the end point of the Cubic Bezier\n         * @param nbPoints (integer) the wanted number of points in the curve\n         */\n        Curve3.CreateCubicBezier = function (v0, v1, v2, v3, nbPoints) {\n            nbPoints = nbPoints > 3 ? nbPoints : 4;\n            var bez = new Array();\n            var equation = function (t, val0, val1, val2, val3) {\n                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;\n                return res;\n            };\n            for (var i = 0; i <= nbPoints; i++) {\n                bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n            }\n            return new Curve3(bez);\n        };\n        /**\n         * Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline\n         * @param p1 (Vector3) the origin point of the Hermite Spline\n         * @param t1 (Vector3) the tangent vector at the origin point\n         * @param p2 (Vector3) the end point of the Hermite Spline\n         * @param t2 (Vector3) the tangent vector at the end point\n         * @param nbPoints (integer) the wanted number of points in the curve\n         */\n        Curve3.CreateHermiteSpline = function (p1, t1, p2, t2, nbPoints) {\n            var hermite = new Array();\n            var step = 1.0 / nbPoints;\n            for (var i = 0; i <= nbPoints; i++) {\n                hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));\n            }\n            return new Curve3(hermite);\n        };\n        /**\n         * Returns a Curve3 object along a CatmullRom Spline curve :\n         * @param points (array of Vector3) the points the spline must pass through. At least, four points required.\n         * @param nbPoints (integer) the wanted number of points between each curve control points.\n         */\n        Curve3.CreateCatmullRomSpline = function (points, nbPoints) {\n            var totalPoints = new Array();\n            totalPoints.push(points[0].clone());\n            Array.prototype.push.apply(totalPoints, points);\n            totalPoints.push(points[points.length - 1].clone());\n            var catmullRom = new Array();\n            var step = 1.0 / nbPoints;\n            for (var i = 0; i < totalPoints.length - 3; i++) {\n                var amount = 0.0;\n                for (var c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n                    amount += step;\n                }\n            }\n            i--;\n            catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n            return new Curve3(catmullRom);\n        };\n        /**\n         * Returns the Curve3 stored array of successive Vector3\n         */\n        Curve3.prototype.getPoints = function () {\n            return this._points;\n        };\n        /**\n         * Returns the computed length (float) of the curve.\n         */\n        Curve3.prototype.length = function () {\n            return this._length;\n        };\n        /**\n         * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n         * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n         * curveA and curveB keep unchanged.\n         */\n        Curve3.prototype.continue = function (curve) {\n            var lastPoint = this._points[this._points.length - 1];\n            var continuedPoints = this._points.slice();\n            var curvePoints = curve.getPoints();\n            for (var i = 1; i < curvePoints.length; i++) {\n                continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n            }\n            var continuedCurve = new Curve3(continuedPoints);\n            return continuedCurve;\n        };\n        Curve3.prototype._computeLength = function (path) {\n            var l = 0;\n            for (var i = 1; i < path.length; i++) {\n                l += (path[i].subtract(path[i - 1])).length();\n            }\n            return l;\n        };\n        return Curve3;\n    }());\n    BABYLON.Curve3 = Curve3;\n    // Vertex formats\n    var PositionNormalVertex = (function () {\n        function PositionNormalVertex(position, normal) {\n            if (position === void 0) { position = Vector3.Zero(); }\n            if (normal === void 0) { normal = Vector3.Up(); }\n            this.position = position;\n            this.normal = normal;\n        }\n        PositionNormalVertex.prototype.clone = function () {\n            return new PositionNormalVertex(this.position.clone(), this.normal.clone());\n        };\n        return PositionNormalVertex;\n    }());\n    BABYLON.PositionNormalVertex = PositionNormalVertex;\n    var PositionNormalTextureVertex = (function () {\n        function PositionNormalTextureVertex(position, normal, uv) {\n            if (position === void 0) { position = Vector3.Zero(); }\n            if (normal === void 0) { normal = Vector3.Up(); }\n            if (uv === void 0) { uv = Vector2.Zero(); }\n            this.position = position;\n            this.normal = normal;\n            this.uv = uv;\n        }\n        PositionNormalTextureVertex.prototype.clone = function () {\n            return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());\n        };\n        return PositionNormalTextureVertex;\n    }());\n    BABYLON.PositionNormalTextureVertex = PositionNormalTextureVertex;\n    // Temporary pre-allocated objects for engine internal use\n    // usage in any internal function :\n    // var tmp = Tmp.Vector3[0];   <= gets access to the first pre-created Vector3\n    // There's a Tmp array per object type : int, float, Vector2, Vector3, Vector4, Quaternion, Matrix\n    var Tmp = (function () {\n        function Tmp() {\n        }\n        return Tmp;\n    }());\n    Tmp.Color3 = [Color3.Black(), Color3.Black(), Color3.Black()];\n    Tmp.Vector2 = [Vector2.Zero(), Vector2.Zero(), Vector2.Zero()]; // 3 temp Vector2 at once should be enough\n    Tmp.Vector3 = [Vector3.Zero(), Vector3.Zero(), Vector3.Zero(),\n        Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero(), Vector3.Zero()]; // 9 temp Vector3 at once should be enough\n    Tmp.Vector4 = [Vector4.Zero(), Vector4.Zero(), Vector4.Zero()]; // 3 temp Vector4 at once should be enough\n    Tmp.Quaternion = [Quaternion.Zero(), Quaternion.Zero()]; // 2 temp Quaternion at once should be enough\n    Tmp.Matrix = [Matrix.Zero(), Matrix.Zero(),\n        Matrix.Zero(), Matrix.Zero(),\n        Matrix.Zero(), Matrix.Zero(),\n        Matrix.Zero(), Matrix.Zero()]; // 6 temp Matrices at once should be enough\n    BABYLON.Tmp = Tmp;\n    // Same as Tmp but not exported to keep it onyl for math functions to avoid conflicts\n    var MathTmp = (function () {\n        function MathTmp() {\n        }\n        return MathTmp;\n    }());\n    MathTmp.Vector3 = [Vector3.Zero()];\n    MathTmp.Matrix = [Matrix.Zero(), Matrix.Zero()];\n    MathTmp.Quaternion = [Quaternion.Zero()];\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.math.js.map\n\n\n\n//# sourceMappingURL=babylon.mixins.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    function generateSerializableMember(type, sourceName) {\n        return function (target, propertyKey) {\n            if (!target.__serializableMembers) {\n                target.__serializableMembers = {};\n            }\n            if (!target.__serializableMembers[propertyKey]) {\n                target.__serializableMembers[propertyKey] = { type: type, sourceName: sourceName };\n            }\n        };\n    }\n    function generateExpandMember(setCallback, targetKey) {\n        return function (target, propertyKey) {\n            var key = targetKey || (\"_\" + propertyKey);\n            Object.defineProperty(target, propertyKey, {\n                get: function () {\n                    return this[key];\n                },\n                set: function (value) {\n                    if (this[key] === value) {\n                        return;\n                    }\n                    this[key] = value;\n                    target[setCallback].apply(this);\n                },\n                enumerable: true,\n                configurable: true\n            });\n        };\n    }\n    function expandToProperty(callback, targetKey) {\n        return generateExpandMember(callback, targetKey);\n    }\n    BABYLON.expandToProperty = expandToProperty;\n    function serialize(sourceName) {\n        return generateSerializableMember(0, sourceName); // value member\n    }\n    BABYLON.serialize = serialize;\n    function serializeAsTexture(sourceName) {\n        return generateSerializableMember(1, sourceName); // texture member\n    }\n    BABYLON.serializeAsTexture = serializeAsTexture;\n    function serializeAsColor3(sourceName) {\n        return generateSerializableMember(2, sourceName); // color3 member\n    }\n    BABYLON.serializeAsColor3 = serializeAsColor3;\n    function serializeAsFresnelParameters(sourceName) {\n        return generateSerializableMember(3, sourceName); // fresnel parameters member\n    }\n    BABYLON.serializeAsFresnelParameters = serializeAsFresnelParameters;\n    function serializeAsVector2(sourceName) {\n        return generateSerializableMember(4, sourceName); // vector2 member\n    }\n    BABYLON.serializeAsVector2 = serializeAsVector2;\n    function serializeAsVector3(sourceName) {\n        return generateSerializableMember(5, sourceName); // vector3 member\n    }\n    BABYLON.serializeAsVector3 = serializeAsVector3;\n    function serializeAsMeshReference(sourceName) {\n        return generateSerializableMember(6, sourceName); // mesh reference member\n    }\n    BABYLON.serializeAsMeshReference = serializeAsMeshReference;\n    function serializeAsColorCurves(sourceName) {\n        return generateSerializableMember(7, sourceName); // color curves\n    }\n    BABYLON.serializeAsColorCurves = serializeAsColorCurves;\n    function serializeAsColor4(sourceName) {\n        return generateSerializableMember(8, sourceName); // color 4\n    }\n    BABYLON.serializeAsColor4 = serializeAsColor4;\n    function serializeAsImageProcessingConfiguration(sourceName) {\n        return generateSerializableMember(9, sourceName); // image processing\n    }\n    BABYLON.serializeAsImageProcessingConfiguration = serializeAsImageProcessingConfiguration;\n    var SerializationHelper = (function () {\n        function SerializationHelper() {\n        }\n        SerializationHelper.Serialize = function (entity, serializationObject) {\n            if (!serializationObject) {\n                serializationObject = {};\n            }\n            // Tags\n            if (BABYLON.Tags) {\n                serializationObject.tags = BABYLON.Tags.GetTags(entity);\n            }\n            // Properties\n            for (var property in entity.__serializableMembers) {\n                var propertyDescriptor = entity.__serializableMembers[property];\n                var targetPropertyName = propertyDescriptor.sourceName || property;\n                var propertyType = propertyDescriptor.type;\n                var sourceProperty = entity[property];\n                if (sourceProperty !== undefined && sourceProperty !== null) {\n                    switch (propertyType) {\n                        case 0:\n                            serializationObject[targetPropertyName] = sourceProperty;\n                            break;\n                        case 1:\n                            serializationObject[targetPropertyName] = sourceProperty.serialize();\n                            break;\n                        case 2:\n                            serializationObject[targetPropertyName] = sourceProperty.asArray();\n                            break;\n                        case 3:\n                            serializationObject[targetPropertyName] = sourceProperty.serialize();\n                            break;\n                        case 4:\n                            serializationObject[targetPropertyName] = sourceProperty.asArray();\n                            break;\n                        case 5:\n                            serializationObject[targetPropertyName] = sourceProperty.asArray();\n                            break;\n                        case 6:\n                            serializationObject[targetPropertyName] = sourceProperty.id;\n                            break;\n                        case 7:\n                            serializationObject[targetPropertyName] = sourceProperty.serialize();\n                            break;\n                        case 8:\n                            serializationObject[targetPropertyName] = sourceProperty.asArray();\n                            break;\n                        case 9:\n                            serializationObject[targetPropertyName] = sourceProperty.serialize();\n                            break;\n                    }\n                }\n            }\n            return serializationObject;\n        };\n        SerializationHelper.Parse = function (creationFunction, source, scene, rootUrl) {\n            var destination = creationFunction();\n            // Tags\n            if (BABYLON.Tags) {\n                BABYLON.Tags.AddTagsTo(destination, source.tags);\n            }\n            // Properties\n            for (var property in destination.__serializableMembers) {\n                var propertyDescriptor = destination.__serializableMembers[property];\n                var sourceProperty = source[propertyDescriptor.sourceName || property];\n                var propertyType = propertyDescriptor.type;\n                if (sourceProperty !== undefined && sourceProperty !== null) {\n                    switch (propertyType) {\n                        case 0:\n                            destination[property] = sourceProperty;\n                            break;\n                        case 1:\n                            destination[property] = BABYLON.Texture.Parse(sourceProperty, scene, rootUrl);\n                            break;\n                        case 2:\n                            destination[property] = BABYLON.Color3.FromArray(sourceProperty);\n                            break;\n                        case 3:\n                            destination[property] = BABYLON.FresnelParameters.Parse(sourceProperty);\n                            break;\n                        case 4:\n                            destination[property] = BABYLON.Vector2.FromArray(sourceProperty);\n                            break;\n                        case 5:\n                            destination[property] = BABYLON.Vector3.FromArray(sourceProperty);\n                            break;\n                        case 6:\n                            destination[property] = scene.getLastMeshByID(sourceProperty);\n                            break;\n                        case 7:\n                            destination[property] = BABYLON.ColorCurves.Parse(sourceProperty);\n                            break;\n                        case 8:\n                            destination[property] = BABYLON.Color4.FromArray(sourceProperty);\n                            break;\n                        case 9:\n                            destination[property] = BABYLON.ImageProcessingConfiguration.Parse(sourceProperty);\n                            break;\n                    }\n                }\n            }\n            return destination;\n        };\n        SerializationHelper.Clone = function (creationFunction, source) {\n            var destination = creationFunction();\n            // Tags\n            if (BABYLON.Tags) {\n                BABYLON.Tags.AddTagsTo(destination, source.tags);\n            }\n            // Properties\n            for (var property in destination.__serializableMembers) {\n                var propertyDescriptor = destination.__serializableMembers[property];\n                var sourceProperty = source[property];\n                var propertyType = propertyDescriptor.type;\n                if (sourceProperty !== undefined && sourceProperty !== null) {\n                    switch (propertyType) {\n                        case 0: // Value\n                        case 6:\n                            destination[property] = sourceProperty;\n                            break;\n                        case 1: // Texture\n                        case 2: // Color3\n                        case 3: // FresnelParameters\n                        case 4: // Vector2\n                        case 5: // Vector3\n                        case 7:\n                            destination[property] = sourceProperty.clone();\n                            break;\n                    }\n                }\n            }\n            return destination;\n        };\n        return SerializationHelper;\n    }());\n    BABYLON.SerializationHelper = SerializationHelper;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.decorators.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * A class serves as a medium between the observable and its observers\n     */\n    var EventState = (function () {\n        /**\n        * If the callback of a given Observer set skipNextObservers to true the following observers will be ignored\n        */\n        function EventState(mask, skipNextObservers) {\n            if (skipNextObservers === void 0) { skipNextObservers = false; }\n            this.initalize(mask, skipNextObservers);\n        }\n        EventState.prototype.initalize = function (mask, skipNextObservers) {\n            if (skipNextObservers === void 0) { skipNextObservers = false; }\n            this.mask = mask;\n            this.skipNextObservers = skipNextObservers;\n            return this;\n        };\n        return EventState;\n    }());\n    BABYLON.EventState = EventState;\n    /**\n     * Represent an Observer registered to a given Observable object.\n     */\n    var Observer = (function () {\n        function Observer(callback, mask) {\n            this.callback = callback;\n            this.mask = mask;\n        }\n        return Observer;\n    }());\n    BABYLON.Observer = Observer;\n    /**\n     * The Observable class is a simple implementation of the Observable pattern.\n     * There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.\n     * This enable a more fine grained execution without having to rely on multiple different Observable objects.\n     * For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).\n     * A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.\n     */\n    var Observable = (function () {\n        function Observable() {\n            this._observers = new Array();\n            this._eventState = new EventState(0);\n        }\n        /**\n         * Create a new Observer with the specified callback\n         * @param callback the callback that will be executed for that Observer\n         * @param mask the mask used to filter observers\n         * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.\n         */\n        Observable.prototype.add = function (callback, mask, insertFirst) {\n            if (mask === void 0) { mask = -1; }\n            if (insertFirst === void 0) { insertFirst = false; }\n            if (!callback) {\n                return null;\n            }\n            var observer = new Observer(callback, mask);\n            if (insertFirst) {\n                this._observers.unshift(observer);\n            }\n            else {\n                this._observers.push(observer);\n            }\n            return observer;\n        };\n        /**\n         * Remove an Observer from the Observable object\n         * @param observer the instance of the Observer to remove. If it doesn't belong to this Observable, false will be returned.\n         */\n        Observable.prototype.remove = function (observer) {\n            var index = this._observers.indexOf(observer);\n            if (index !== -1) {\n                this._observers.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Remove a callback from the Observable object\n         * @param callback the callback to remove. If it doesn't belong to this Observable, false will be returned.\n        */\n        Observable.prototype.removeCallback = function (callback) {\n            for (var index = 0; index < this._observers.length; index++) {\n                if (this._observers[index].callback === callback) {\n                    this._observers.splice(index, 1);\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * Notify all Observers by calling their respective callback with the given data\n         * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute\n         * @param eventData\n         * @param mask\n         */\n        Observable.prototype.notifyObservers = function (eventData, mask) {\n            if (mask === void 0) { mask = -1; }\n            var state = this._eventState;\n            state.mask = mask;\n            state.skipNextObservers = false;\n            for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {\n                var obs = _a[_i];\n                if (obs.mask & mask) {\n                    obs.callback(eventData, state);\n                }\n                if (state.skipNextObservers) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        /**\n         * return true is the Observable has at least one Observer registered\n         */\n        Observable.prototype.hasObservers = function () {\n            return this._observers.length > 0;\n        };\n        /**\n        * Clear the list of observers\n        */\n        Observable.prototype.clear = function () {\n            this._observers = new Array();\n        };\n        /**\n        * Clone the current observable\n        */\n        Observable.prototype.clone = function () {\n            var result = new Observable();\n            result._observers = this._observers.slice(0);\n            return result;\n        };\n        /**\n         * Does this observable handles observer registered with a given mask\n         * @param {number} trigger - the mask to be tested\n         * @return {boolean} whether or not one observer registered with the given mask is handeled\n        **/\n        Observable.prototype.hasSpecificMask = function (mask) {\n            if (mask === void 0) { mask = -1; }\n            for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {\n                var obs = _a[_i];\n                if (obs.mask & mask && obs.mask === mask) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        return Observable;\n    }());\n    BABYLON.Observable = Observable;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.observable.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SmartArray = (function () {\n        function SmartArray(capacity) {\n            this.length = 0;\n            this._duplicateId = 0;\n            this.data = new Array(capacity);\n            this._id = SmartArray._GlobalId++;\n        }\n        SmartArray.prototype.push = function (value) {\n            this.data[this.length++] = value;\n            if (this.length > this.data.length) {\n                this.data.length *= 2;\n            }\n            if (!value.__smartArrayFlags) {\n                value.__smartArrayFlags = {};\n            }\n            value.__smartArrayFlags[this._id] = this._duplicateId;\n        };\n        SmartArray.prototype.forEach = function (func) {\n            for (var index = 0; index < this.length; index++) {\n                func(this.data[index]);\n            }\n        };\n        SmartArray.prototype.pushNoDuplicate = function (value) {\n            if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {\n                return false;\n            }\n            this.push(value);\n            return true;\n        };\n        SmartArray.prototype.sort = function (compareFn) {\n            this.data.sort(compareFn);\n        };\n        SmartArray.prototype.reset = function () {\n            this.length = 0;\n            this._duplicateId++;\n        };\n        SmartArray.prototype.dispose = function () {\n            this.reset();\n            this.data.length = 0;\n        };\n        SmartArray.prototype.concat = function (array) {\n            if (array.length === 0) {\n                return;\n            }\n            if (this.length + array.length > this.data.length) {\n                this.data.length = (this.length + array.length) * 2;\n            }\n            for (var index = 0; index < array.length; index++) {\n                this.data[this.length++] = (array.data || array)[index];\n            }\n        };\n        SmartArray.prototype.concatWithNoDuplicate = function (array) {\n            if (array.length === 0) {\n                return;\n            }\n            if (this.length + array.length > this.data.length) {\n                this.data.length = (this.length + array.length) * 2;\n            }\n            for (var index = 0; index < array.length; index++) {\n                var item = (array.data || array)[index];\n                this.pushNoDuplicate(item);\n            }\n        };\n        SmartArray.prototype.indexOf = function (value) {\n            var position = this.data.indexOf(value);\n            if (position >= this.length) {\n                return -1;\n            }\n            return position;\n        };\n        SmartArray.prototype.contains = function (value) {\n            return this.data.indexOf(value) !== -1;\n        };\n        return SmartArray;\n    }());\n    // Statics\n    SmartArray._GlobalId = 0;\n    BABYLON.SmartArray = SmartArray;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.smartArray.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    // Screenshots\n    var screenshotCanvas;\n    var cloneValue = function (source, destinationObject) {\n        if (!source)\n            return null;\n        if (source instanceof BABYLON.Mesh) {\n            return null;\n        }\n        if (source instanceof BABYLON.SubMesh) {\n            return source.clone(destinationObject);\n        }\n        else if (source.clone) {\n            return source.clone();\n        }\n        return null;\n    };\n    var Tools = (function () {\n        function Tools() {\n        }\n        ;\n        /**\n         * Interpolates between a and b via alpha\n         * @param a The lower value (returned when alpha = 0)\n         * @param b The upper value (returned when alpha = 1)\n         * @param alpha The interpolation-factor\n         * @return The mixed value\n         */\n        Tools.Mix = function (a, b, alpha) {\n            return a * (1 - alpha) + b * alpha;\n        };\n        Tools.Instantiate = function (className) {\n            var arr = className.split(\".\");\n            var fn = (window || this);\n            for (var i = 0, len = arr.length; i < len; i++) {\n                fn = fn[arr[i]];\n            }\n            if (typeof fn !== \"function\") {\n                return null;\n            }\n            return fn;\n        };\n        Tools.SetImmediate = function (action) {\n            if (window.setImmediate) {\n                window.setImmediate(action);\n            }\n            else {\n                setTimeout(action, 1);\n            }\n        };\n        Tools.IsExponentOfTwo = function (value) {\n            var count = 1;\n            do {\n                count *= 2;\n            } while (count < value);\n            return count === value;\n        };\n        /**\n         * Find the next highest power of two.\n         * @param x Number to start search from.\n         * @return Next highest power of two.\n         */\n        Tools.CeilingPOT = function (x) {\n            x--;\n            x |= x >> 1;\n            x |= x >> 2;\n            x |= x >> 4;\n            x |= x >> 8;\n            x |= x >> 16;\n            x++;\n            return x;\n        };\n        /**\n         * Find the next lowest power of two.\n         * @param x Number to start search from.\n         * @return Next lowest power of two.\n         */\n        Tools.FloorPOT = function (x) {\n            x = x | (x >> 1);\n            x = x | (x >> 2);\n            x = x | (x >> 4);\n            x = x | (x >> 8);\n            x = x | (x >> 16);\n            return x - (x >> 1);\n        };\n        /**\n         * Find the nearest power of two.\n         * @param x Number to start search from.\n         * @return Next nearest power of two.\n         */\n        Tools.NearestPOT = function (x) {\n            var c = Tools.CeilingPOT(x);\n            var f = Tools.FloorPOT(x);\n            return (c - x) > (x - f) ? f : c;\n        };\n        Tools.GetExponentOfTwo = function (value, max, mode) {\n            if (mode === void 0) { mode = BABYLON.Engine.SCALEMODE_NEAREST; }\n            var pot;\n            switch (mode) {\n                case BABYLON.Engine.SCALEMODE_FLOOR:\n                    pot = Tools.FloorPOT(value);\n                    break;\n                case BABYLON.Engine.SCALEMODE_NEAREST:\n                    pot = Tools.NearestPOT(value);\n                    break;\n                case BABYLON.Engine.SCALEMODE_CEILING:\n                    pot = Tools.CeilingPOT(value);\n                    break;\n            }\n            return Math.min(pot, max);\n        };\n        Tools.GetFilename = function (path) {\n            var index = path.lastIndexOf(\"/\");\n            if (index < 0)\n                return path;\n            return path.substring(index + 1);\n        };\n        Tools.GetDOMTextContent = function (element) {\n            var result = \"\";\n            var child = element.firstChild;\n            while (child) {\n                if (child.nodeType === 3) {\n                    result += child.textContent;\n                }\n                child = child.nextSibling;\n            }\n            return result;\n        };\n        Tools.ToDegrees = function (angle) {\n            return angle * 180 / Math.PI;\n        };\n        Tools.ToRadians = function (angle) {\n            return angle * Math.PI / 180;\n        };\n        Tools.EncodeArrayBufferTobase64 = function (buffer) {\n            var keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n            var output = \"\";\n            var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n            var i = 0;\n            var bytes = new Uint8Array(buffer);\n            while (i < bytes.length) {\n                chr1 = bytes[i++];\n                chr2 = i < bytes.length ? bytes[i++] : Number.NaN; // Not sure if the index \n                chr3 = i < bytes.length ? bytes[i++] : Number.NaN; // checks are needed here\n                enc1 = chr1 >> 2;\n                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n                enc4 = chr3 & 63;\n                if (isNaN(chr2)) {\n                    enc3 = enc4 = 64;\n                }\n                else if (isNaN(chr3)) {\n                    enc4 = 64;\n                }\n                output += keyStr.charAt(enc1) + keyStr.charAt(enc2) +\n                    keyStr.charAt(enc3) + keyStr.charAt(enc4);\n            }\n            return \"data:image/png;base64,\" + output;\n        };\n        Tools.ExtractMinAndMaxIndexed = function (positions, indices, indexStart, indexCount, bias) {\n            if (bias === void 0) { bias = null; }\n            var minimum = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            var maximum = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n            for (var index = indexStart; index < indexStart + indexCount; index++) {\n                var current = new BABYLON.Vector3(positions[indices[index] * 3], positions[indices[index] * 3 + 1], positions[indices[index] * 3 + 2]);\n                minimum = BABYLON.Vector3.Minimize(current, minimum);\n                maximum = BABYLON.Vector3.Maximize(current, maximum);\n            }\n            if (bias) {\n                minimum.x -= minimum.x * bias.x + bias.y;\n                minimum.y -= minimum.y * bias.x + bias.y;\n                minimum.z -= minimum.z * bias.x + bias.y;\n                maximum.x += maximum.x * bias.x + bias.y;\n                maximum.y += maximum.y * bias.x + bias.y;\n                maximum.z += maximum.z * bias.x + bias.y;\n            }\n            return {\n                minimum: minimum,\n                maximum: maximum\n            };\n        };\n        Tools.ExtractMinAndMax = function (positions, start, count, bias, stride) {\n            if (bias === void 0) { bias = null; }\n            var minimum = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            var maximum = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n            if (!stride) {\n                stride = 3;\n            }\n            for (var index = start; index < start + count; index++) {\n                var current = new BABYLON.Vector3(positions[index * stride], positions[index * stride + 1], positions[index * stride + 2]);\n                minimum = BABYLON.Vector3.Minimize(current, minimum);\n                maximum = BABYLON.Vector3.Maximize(current, maximum);\n            }\n            if (bias) {\n                minimum.x -= minimum.x * bias.x + bias.y;\n                minimum.y -= minimum.y * bias.x + bias.y;\n                minimum.z -= minimum.z * bias.x + bias.y;\n                maximum.x += maximum.x * bias.x + bias.y;\n                maximum.y += maximum.y * bias.x + bias.y;\n                maximum.z += maximum.z * bias.x + bias.y;\n            }\n            return {\n                minimum: minimum,\n                maximum: maximum\n            };\n        };\n        Tools.Vector2ArrayFeeder = function (array) {\n            return function (index) {\n                var isFloatArray = (array.BYTES_PER_ELEMENT !== undefined);\n                var length = isFloatArray ? array.length / 2 : array.length;\n                if (index >= length) {\n                    return null;\n                }\n                if (isFloatArray) {\n                    var fa = array;\n                    return new BABYLON.Vector2(fa[index * 2 + 0], fa[index * 2 + 1]);\n                }\n                var a = array;\n                return a[index];\n            };\n        };\n        Tools.ExtractMinAndMaxVector2 = function (feeder, bias) {\n            if (bias === void 0) { bias = null; }\n            var minimum = new BABYLON.Vector2(Number.MAX_VALUE, Number.MAX_VALUE);\n            var maximum = new BABYLON.Vector2(-Number.MAX_VALUE, -Number.MAX_VALUE);\n            var i = 0;\n            var cur = feeder(i++);\n            while (cur) {\n                minimum = BABYLON.Vector2.Minimize(cur, minimum);\n                maximum = BABYLON.Vector2.Maximize(cur, maximum);\n                cur = feeder(i++);\n            }\n            if (bias) {\n                minimum.x -= minimum.x * bias.x + bias.y;\n                minimum.y -= minimum.y * bias.x + bias.y;\n                maximum.x += maximum.x * bias.x + bias.y;\n                maximum.y += maximum.y * bias.x + bias.y;\n            }\n            return {\n                minimum: minimum,\n                maximum: maximum\n            };\n        };\n        Tools.MakeArray = function (obj, allowsNullUndefined) {\n            if (allowsNullUndefined !== true && (obj === undefined || obj == null))\n                return undefined;\n            return Array.isArray(obj) ? obj : [obj];\n        };\n        // Misc.\n        Tools.GetPointerPrefix = function () {\n            var eventPrefix = \"pointer\";\n            // Check if pointer events are supported\n            if (!window.PointerEvent && !navigator.pointerEnabled) {\n                eventPrefix = \"mouse\";\n            }\n            return eventPrefix;\n        };\n        /**\n         * @param func - the function to be called\n         * @param requester - the object that will request the next frame. Falls back to window.\n         */\n        Tools.QueueNewFrame = function (func, requester) {\n            if (requester === void 0) { requester = window; }\n            //if WebVR is enabled AND presenting, requestAnimationFrame is triggered when enabled.\n            /*if(requester.isPresenting) {\n                return;\n            } else*/ if (requester.requestAnimationFrame)\n                requester.requestAnimationFrame(func);\n            else if (requester.msRequestAnimationFrame)\n                requester.msRequestAnimationFrame(func);\n            else if (requester.webkitRequestAnimationFrame)\n                requester.webkitRequestAnimationFrame(func);\n            else if (requester.mozRequestAnimationFrame)\n                requester.mozRequestAnimationFrame(func);\n            else if (requester.oRequestAnimationFrame)\n                requester.oRequestAnimationFrame(func);\n            else {\n                window.setTimeout(func, 16);\n            }\n        };\n        Tools.RequestFullscreen = function (element) {\n            var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;\n            if (!requestFunction)\n                return;\n            requestFunction.call(element);\n        };\n        Tools.ExitFullscreen = function () {\n            if (document.exitFullscreen) {\n                document.exitFullscreen();\n            }\n            else if (document.mozCancelFullScreen) {\n                document.mozCancelFullScreen();\n            }\n            else if (document.webkitCancelFullScreen) {\n                document.webkitCancelFullScreen();\n            }\n            else if (document.msCancelFullScreen) {\n                document.msCancelFullScreen();\n            }\n        };\n        Tools.SetCorsBehavior = function (url, img) {\n            if (Tools.CorsBehavior) {\n                switch (typeof (Tools.CorsBehavior)) {\n                    case \"function\":\n                        var result = Tools.CorsBehavior(url);\n                        if (result) {\n                            img.crossOrigin = result;\n                        }\n                        break;\n                    case \"string\":\n                    default:\n                        img.crossOrigin = Tools.CorsBehavior;\n                        break;\n                }\n            }\n        };\n        // External files\n        Tools.CleanUrl = function (url) {\n            url = url.replace(/#/mg, \"%23\");\n            return url;\n        };\n        Tools.LoadImage = function (url, onload, onerror, database) {\n            if (url instanceof ArrayBuffer) {\n                url = Tools.EncodeArrayBufferTobase64(url);\n            }\n            url = Tools.CleanUrl(url);\n            var img = new Image();\n            if (url.substr(0, 5) !== \"data:\") {\n                Tools.SetCorsBehavior(url, img);\n            }\n            img.onload = function () {\n                onload(img);\n            };\n            img.onerror = function (err) {\n                Tools.Error(\"Error while trying to load image: \" + url);\n                if (Tools.UseFallbackTexture) {\n                    img.src = Tools.fallbackTexture;\n                    onload(img);\n                }\n                else {\n                    onerror();\n                }\n            };\n            var noIndexedDB = function () {\n                img.src = url;\n            };\n            var loadFromIndexedDB = function () {\n                database.loadImageFromDB(url, img);\n            };\n            //ANY database to do!\n            if (url.substr(0, 5) !== \"data:\" && database && database.enableTexturesOffline && BABYLON.Database.IsUASupportingBlobStorage) {\n                database.openAsync(loadFromIndexedDB, noIndexedDB);\n            }\n            else {\n                if (url.indexOf(\"file:\") !== 0) {\n                    noIndexedDB();\n                }\n                else {\n                    var textureName = url.substring(5).toLowerCase();\n                    if (BABYLON.FilesInput.FilesToLoad[textureName]) {\n                        try {\n                            var blobURL;\n                            try {\n                                blobURL = URL.createObjectURL(BABYLON.FilesInput.FilesToLoad[textureName], { oneTimeOnly: true });\n                            }\n                            catch (ex) {\n                                // Chrome doesn't support oneTimeOnly parameter\n                                blobURL = URL.createObjectURL(BABYLON.FilesInput.FilesToLoad[textureName]);\n                            }\n                            img.src = blobURL;\n                        }\n                        catch (e) {\n                            img.src = null;\n                        }\n                    }\n                    else {\n                        Tools.Error(\"Image: \" + textureName + \" not found. Did you forget to provide it?\");\n                        img.src = Tools.fallbackTexture;\n                    }\n                }\n            }\n            return img;\n        };\n        //ANY\n        Tools.LoadFile = function (url, callback, progressCallBack, database, useArrayBuffer, onError) {\n            url = Tools.CleanUrl(url);\n            var noIndexedDB = function () {\n                var request = new XMLHttpRequest();\n                var loadUrl = Tools.BaseUrl + url;\n                request.open('GET', loadUrl, true);\n                if (useArrayBuffer) {\n                    request.responseType = \"arraybuffer\";\n                }\n                request.onprogress = progressCallBack;\n                request.onreadystatechange = function () {\n                    // In case of undefined state in some browsers.\n                    if (request.readyState === (XMLHttpRequest.DONE || 4)) {\n                        request.onreadystatechange = null; //some browsers have issues where onreadystatechange can be called multiple times with the same value\n                        if (request.status >= 200 && request.status < 300 || (navigator.isCocoonJS && (request.status === 0))) {\n                            callback(!useArrayBuffer ? request.responseText : request.response);\n                        }\n                        else {\n                            if (onError) {\n                                onError(request);\n                            }\n                            else {\n                                throw new Error(\"Error status: \" + request.status + \" - Unable to load \" + loadUrl);\n                            }\n                        }\n                    }\n                };\n                request.send(null);\n            };\n            var loadFromIndexedDB = function () {\n                database.loadFileFromDB(url, callback, progressCallBack, noIndexedDB, useArrayBuffer);\n            };\n            if (url.indexOf(\"file:\") !== -1) {\n                var fileName = url.substring(5).toLowerCase();\n                if (BABYLON.FilesInput.FilesToLoad[fileName]) {\n                    Tools.ReadFile(BABYLON.FilesInput.FilesToLoad[fileName], callback, progressCallBack, useArrayBuffer);\n                }\n                else {\n                    Tools.Error(\"File: \" + fileName + \" not found. Did you forget to provide it?\");\n                }\n            }\n            else {\n                // Caching all files\n                if (database && database.enableSceneOffline) {\n                    database.openAsync(loadFromIndexedDB, noIndexedDB);\n                }\n                else {\n                    noIndexedDB();\n                }\n            }\n        };\n        /**\n         * Load a script (identified by an url). When the url returns, the\n         * content of this file is added into a new script element, attached to the DOM (body element)\n         */\n        Tools.LoadScript = function (scriptUrl, onSuccess, onError) {\n            var head = document.getElementsByTagName('head')[0];\n            var script = document.createElement('script');\n            script.type = 'text/javascript';\n            script.src = scriptUrl;\n            var self = this;\n            script.onload = function () {\n                if (onSuccess) {\n                    onSuccess();\n                }\n            };\n            script.onerror = function () {\n                if (onError) {\n                    onError();\n                }\n            };\n            head.appendChild(script);\n        };\n        Tools.ReadFileAsDataURL = function (fileToLoad, callback, progressCallback) {\n            var reader = new FileReader();\n            reader.onload = function (e) {\n                //target doesn't have result from ts 1.3\n                callback(e.target['result']);\n            };\n            reader.onprogress = progressCallback;\n            reader.readAsDataURL(fileToLoad);\n        };\n        Tools.ReadFile = function (fileToLoad, callback, progressCallBack, useArrayBuffer) {\n            var reader = new FileReader();\n            reader.onerror = function (e) {\n                Tools.Log(\"Error while reading file: \" + fileToLoad.name);\n                callback(JSON.stringify({ autoClear: true, clearColor: [1, 0, 0], ambientColor: [0, 0, 0], gravity: [0, -9.807, 0], meshes: [], cameras: [], lights: [] }));\n            };\n            reader.onload = function (e) {\n                //target doesn't have result from ts 1.3\n                callback(e.target['result']);\n            };\n            reader.onprogress = progressCallBack;\n            if (!useArrayBuffer) {\n                // Asynchronous read\n                reader.readAsText(fileToLoad);\n            }\n            else {\n                reader.readAsArrayBuffer(fileToLoad);\n            }\n        };\n        //returns a downloadable url to a file content.\n        Tools.FileAsURL = function (content) {\n            var fileBlob = new Blob([content]);\n            var url = window.URL || window.webkitURL;\n            var link = url.createObjectURL(fileBlob);\n            return link;\n        };\n        // Misc.\n        Tools.Format = function (value, decimals) {\n            if (decimals === void 0) { decimals = 2; }\n            return value.toFixed(decimals);\n        };\n        Tools.CheckExtends = function (v, min, max) {\n            if (v.x < min.x)\n                min.x = v.x;\n            if (v.y < min.y)\n                min.y = v.y;\n            if (v.z < min.z)\n                min.z = v.z;\n            if (v.x > max.x)\n                max.x = v.x;\n            if (v.y > max.y)\n                max.y = v.y;\n            if (v.z > max.z)\n                max.z = v.z;\n        };\n        Tools.DeepCopy = function (source, destination, doNotCopyList, mustCopyList) {\n            for (var prop in source) {\n                if (prop[0] === \"_\" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {\n                    continue;\n                }\n                if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {\n                    continue;\n                }\n                var sourceValue = source[prop];\n                var typeOfSourceValue = typeof sourceValue;\n                if (typeOfSourceValue === \"function\") {\n                    continue;\n                }\n                if (typeOfSourceValue === \"object\") {\n                    if (sourceValue instanceof Array) {\n                        destination[prop] = [];\n                        if (sourceValue.length > 0) {\n                            if (typeof sourceValue[0] == \"object\") {\n                                for (var index = 0; index < sourceValue.length; index++) {\n                                    var clonedValue = cloneValue(sourceValue[index], destination);\n                                    if (destination[prop].indexOf(clonedValue) === -1) {\n                                        destination[prop].push(clonedValue);\n                                    }\n                                }\n                            }\n                            else {\n                                destination[prop] = sourceValue.slice(0);\n                            }\n                        }\n                    }\n                    else {\n                        destination[prop] = cloneValue(sourceValue, destination);\n                    }\n                }\n                else {\n                    destination[prop] = sourceValue;\n                }\n            }\n        };\n        Tools.IsEmpty = function (obj) {\n            for (var i in obj) {\n                return false;\n            }\n            return true;\n        };\n        Tools.RegisterTopRootEvents = function (events) {\n            for (var index = 0; index < events.length; index++) {\n                var event = events[index];\n                window.addEventListener(event.name, event.handler, false);\n                try {\n                    if (window.parent) {\n                        window.parent.addEventListener(event.name, event.handler, false);\n                    }\n                }\n                catch (e) {\n                    // Silently fails...\n                }\n            }\n        };\n        Tools.UnregisterTopRootEvents = function (events) {\n            for (var index = 0; index < events.length; index++) {\n                var event = events[index];\n                window.removeEventListener(event.name, event.handler);\n                try {\n                    if (window.parent) {\n                        window.parent.removeEventListener(event.name, event.handler);\n                    }\n                }\n                catch (e) {\n                    // Silently fails...\n                }\n            }\n        };\n        Tools.DumpFramebuffer = function (width, height, engine, successCallback, mimeType) {\n            if (mimeType === void 0) { mimeType = \"image/png\"; }\n            // Read the contents of the framebuffer\n            var numberOfChannelsByLine = width * 4;\n            var halfHeight = height / 2;\n            //Reading datas from WebGL\n            var data = engine.readPixels(0, 0, width, height);\n            //To flip image on Y axis.\n            for (var i = 0; i < halfHeight; i++) {\n                for (var j = 0; j < numberOfChannelsByLine; j++) {\n                    var currentCell = j + i * numberOfChannelsByLine;\n                    var targetLine = height - i - 1;\n                    var targetCell = j + targetLine * numberOfChannelsByLine;\n                    var temp = data[currentCell];\n                    data[currentCell] = data[targetCell];\n                    data[targetCell] = temp;\n                }\n            }\n            // Create a 2D canvas to store the result\n            if (!screenshotCanvas) {\n                screenshotCanvas = document.createElement('canvas');\n            }\n            screenshotCanvas.width = width;\n            screenshotCanvas.height = height;\n            var context = screenshotCanvas.getContext('2d');\n            // Copy the pixels to a 2D canvas\n            var imageData = context.createImageData(width, height);\n            var castData = (imageData.data);\n            castData.set(data);\n            context.putImageData(imageData, 0, 0);\n            Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\n        };\n        Tools.EncodeScreenshotCanvasData = function (successCallback, mimeType) {\n            if (mimeType === void 0) { mimeType = \"image/png\"; }\n            var base64Image = screenshotCanvas.toDataURL(mimeType);\n            if (successCallback) {\n                successCallback(base64Image);\n            }\n            else {\n                //Creating a link if the browser have the download attribute on the a tag, to automatically start download generated image.\n                if ((\"download\" in document.createElement(\"a\"))) {\n                    var a = window.document.createElement(\"a\");\n                    a.href = base64Image;\n                    var date = new Date();\n                    var stringDate = (date.getFullYear() + \"-\" + (date.getMonth() + 1)).slice(-2) + \"-\" + date.getDate() + \"_\" + date.getHours() + \"-\" + ('0' + date.getMinutes()).slice(-2);\n                    a.setAttribute(\"download\", \"screenshot_\" + stringDate + \".png\");\n                    window.document.body.appendChild(a);\n                    a.addEventListener(\"click\", function () {\n                        a.parentElement.removeChild(a);\n                    });\n                    a.click();\n                    //Or opening a new tab with the image if it is not possible to automatically start download.\n                }\n                else {\n                    var newWindow = window.open(\"\");\n                    var img = newWindow.document.createElement(\"img\");\n                    img.src = base64Image;\n                    newWindow.document.body.appendChild(img);\n                }\n            }\n        };\n        Tools.CreateScreenshot = function (engine, camera, size, successCallback, mimeType) {\n            if (mimeType === void 0) { mimeType = \"image/png\"; }\n            var width;\n            var height;\n            // If a precision value is specified\n            if (size.precision) {\n                width = Math.round(engine.getRenderWidth() * size.precision);\n                height = Math.round(width / engine.getAspectRatio(camera));\n            }\n            else if (size.width && size.height) {\n                width = size.width;\n                height = size.height;\n            }\n            else if (size.width && !size.height) {\n                width = size.width;\n                height = Math.round(width / engine.getAspectRatio(camera));\n            }\n            else if (size.height && !size.width) {\n                height = size.height;\n                width = Math.round(height * engine.getAspectRatio(camera));\n            }\n            else if (!isNaN(size)) {\n                height = size;\n                width = size;\n            }\n            else {\n                Tools.Error(\"Invalid 'size' parameter !\");\n                return;\n            }\n            if (!screenshotCanvas) {\n                screenshotCanvas = document.createElement('canvas');\n            }\n            screenshotCanvas.width = width;\n            screenshotCanvas.height = height;\n            var renderContext = screenshotCanvas.getContext(\"2d\");\n            var ratio = engine.getRenderWidth() / engine.getRenderHeight();\n            var newWidth = width;\n            var newHeight = newWidth / ratio;\n            if (newHeight > height) {\n                newHeight = height;\n                newWidth = newHeight * ratio;\n            }\n            var offsetX = Math.max(0, width - newWidth) / 2;\n            var offsetY = Math.max(0, height - newHeight) / 2;\n            renderContext.drawImage(engine.getRenderingCanvas(), offsetX, offsetY, newWidth, newHeight);\n            Tools.EncodeScreenshotCanvasData(successCallback, mimeType);\n        };\n        Tools.CreateScreenshotUsingRenderTarget = function (engine, camera, size, successCallback, mimeType, samples) {\n            if (mimeType === void 0) { mimeType = \"image/png\"; }\n            if (samples === void 0) { samples = 1; }\n            var width;\n            var height;\n            //If a precision value is specified\n            if (size.precision) {\n                width = Math.round(engine.getRenderWidth() * size.precision);\n                height = Math.round(width / engine.getAspectRatio(camera));\n                size = { width: width, height: height };\n            }\n            else if (size.width && size.height) {\n                width = size.width;\n                height = size.height;\n            }\n            else if (size.width && !size.height) {\n                width = size.width;\n                height = Math.round(width / engine.getAspectRatio(camera));\n                size = { width: width, height: height };\n            }\n            else if (size.height && !size.width) {\n                height = size.height;\n                width = Math.round(height * engine.getAspectRatio(camera));\n                size = { width: width, height: height };\n            }\n            else if (!isNaN(size)) {\n                height = size;\n                width = size;\n            }\n            else {\n                Tools.Error(\"Invalid 'size' parameter !\");\n                return;\n            }\n            var scene = camera.getScene();\n            var previousCamera = null;\n            if (scene.activeCamera !== camera) {\n                previousCamera = scene.activeCamera;\n                scene.activeCamera = camera;\n            }\n            //At this point size can be a number, or an object (according to engine.prototype.createRenderTargetTexture method)\n            var texture = new BABYLON.RenderTargetTexture(\"screenShot\", size, scene, false, false, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT, false, BABYLON.Texture.NEAREST_SAMPLINGMODE);\n            texture.renderList = scene.meshes;\n            texture.samples = samples;\n            texture.onAfterRenderObservable.add(function () {\n                Tools.DumpFramebuffer(width, height, engine, successCallback, mimeType);\n            });\n            scene.incrementRenderId();\n            scene.resetCachedMaterial();\n            texture.render(true);\n            texture.dispose();\n            if (previousCamera) {\n                scene.activeCamera = previousCamera;\n            }\n            camera.getProjectionMatrix(true); // Force cache refresh;\n        };\n        // XHR response validator for local file scenario\n        Tools.ValidateXHRData = function (xhr, dataType) {\n            // 1 for text (.babylon, manifest and shaders), 2 for TGA, 4 for DDS, 7 for all\n            if (dataType === void 0) { dataType = 7; }\n            try {\n                if (dataType & 1) {\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        return true;\n                    }\n                    else if (dataType === 1) {\n                        return false;\n                    }\n                }\n                if (dataType & 2) {\n                    // Check header width and height since there is no \"TGA\" magic number\n                    var tgaHeader = BABYLON.Internals.TGATools.GetTGAHeader(xhr.response);\n                    if (tgaHeader.width && tgaHeader.height && tgaHeader.width > 0 && tgaHeader.height > 0) {\n                        return true;\n                    }\n                    else if (dataType === 2) {\n                        return false;\n                    }\n                }\n                if (dataType & 4) {\n                    // Check for the \"DDS\" magic number\n                    var ddsHeader = new Uint8Array(xhr.response, 0, 3);\n                    if (ddsHeader[0] === 68 && ddsHeader[1] === 68 && ddsHeader[2] === 83) {\n                        return true;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n            catch (e) {\n                // Global protection\n            }\n            return false;\n        };\n        /**\n         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n         * Be aware Math.random() could cause collisions, but:\n         * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n         */\n        Tools.RandomId = function () {\n            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n        };\n        Object.defineProperty(Tools, \"NoneLogLevel\", {\n            get: function () {\n                return Tools._NoneLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"MessageLogLevel\", {\n            get: function () {\n                return Tools._MessageLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"WarningLogLevel\", {\n            get: function () {\n                return Tools._WarningLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"ErrorLogLevel\", {\n            get: function () {\n                return Tools._ErrorLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"AllLogLevel\", {\n            get: function () {\n                return Tools._MessageLogLevel | Tools._WarningLogLevel | Tools._ErrorLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Tools._AddLogEntry = function (entry) {\n            Tools._LogCache = entry + Tools._LogCache;\n            if (Tools.OnNewCacheEntry) {\n                Tools.OnNewCacheEntry(entry);\n            }\n        };\n        Tools._FormatMessage = function (message) {\n            var padStr = function (i) { return (i < 10) ? \"0\" + i : \"\" + i; };\n            var date = new Date();\n            return \"[\" + padStr(date.getHours()) + \":\" + padStr(date.getMinutes()) + \":\" + padStr(date.getSeconds()) + \"]: \" + message;\n        };\n        Tools._LogDisabled = function (message) {\n            // nothing to do\n        };\n        Tools._LogEnabled = function (message) {\n            var formattedMessage = Tools._FormatMessage(message);\n            console.log(\"BJS - \" + formattedMessage);\n            var entry = \"<div style='color:white'>\" + formattedMessage + \"</div><br>\";\n            Tools._AddLogEntry(entry);\n        };\n        Tools._WarnDisabled = function (message) {\n            // nothing to do\n        };\n        Tools._WarnEnabled = function (message) {\n            var formattedMessage = Tools._FormatMessage(message);\n            console.warn(\"BJS - \" + formattedMessage);\n            var entry = \"<div style='color:orange'>\" + formattedMessage + \"</div><br>\";\n            Tools._AddLogEntry(entry);\n        };\n        Tools._ErrorDisabled = function (message) {\n            // nothing to do\n        };\n        Tools._ErrorEnabled = function (message) {\n            Tools.errorsCount++;\n            var formattedMessage = Tools._FormatMessage(message);\n            console.error(\"BJS - \" + formattedMessage);\n            var entry = \"<div style='color:red'>\" + formattedMessage + \"</div><br>\";\n            Tools._AddLogEntry(entry);\n        };\n        Object.defineProperty(Tools, \"LogCache\", {\n            get: function () {\n                return Tools._LogCache;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Tools.ClearLogCache = function () {\n            Tools._LogCache = \"\";\n            Tools.errorsCount = 0;\n        };\n        Object.defineProperty(Tools, \"LogLevels\", {\n            set: function (level) {\n                if ((level & Tools.MessageLogLevel) === Tools.MessageLogLevel) {\n                    Tools.Log = Tools._LogEnabled;\n                }\n                else {\n                    Tools.Log = Tools._LogDisabled;\n                }\n                if ((level & Tools.WarningLogLevel) === Tools.WarningLogLevel) {\n                    Tools.Warn = Tools._WarnEnabled;\n                }\n                else {\n                    Tools.Warn = Tools._WarnDisabled;\n                }\n                if ((level & Tools.ErrorLogLevel) === Tools.ErrorLogLevel) {\n                    Tools.Error = Tools._ErrorEnabled;\n                }\n                else {\n                    Tools.Error = Tools._ErrorDisabled;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"PerformanceNoneLogLevel\", {\n            get: function () {\n                return Tools._PerformanceNoneLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"PerformanceUserMarkLogLevel\", {\n            get: function () {\n                return Tools._PerformanceUserMarkLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"PerformanceConsoleLogLevel\", {\n            get: function () {\n                return Tools._PerformanceConsoleLogLevel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Tools, \"PerformanceLogLevel\", {\n            set: function (level) {\n                if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {\n                    Tools.StartPerformanceCounter = Tools._StartUserMark;\n                    Tools.EndPerformanceCounter = Tools._EndUserMark;\n                    return;\n                }\n                if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {\n                    Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;\n                    Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;\n                    return;\n                }\n                Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n                Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Tools._StartPerformanceCounterDisabled = function (counterName, condition) {\n        };\n        Tools._EndPerformanceCounterDisabled = function (counterName, condition) {\n        };\n        Tools._StartUserMark = function (counterName, condition) {\n            if (condition === void 0) { condition = true; }\n            if (!condition || !Tools._performance.mark) {\n                return;\n            }\n            Tools._performance.mark(counterName + \"-Begin\");\n        };\n        Tools._EndUserMark = function (counterName, condition) {\n            if (condition === void 0) { condition = true; }\n            if (!condition || !Tools._performance.mark) {\n                return;\n            }\n            Tools._performance.mark(counterName + \"-End\");\n            Tools._performance.measure(counterName, counterName + \"-Begin\", counterName + \"-End\");\n        };\n        Tools._StartPerformanceConsole = function (counterName, condition) {\n            if (condition === void 0) { condition = true; }\n            if (!condition) {\n                return;\n            }\n            Tools._StartUserMark(counterName, condition);\n            if (console.time) {\n                console.time(counterName);\n            }\n        };\n        Tools._EndPerformanceConsole = function (counterName, condition) {\n            if (condition === void 0) { condition = true; }\n            if (!condition) {\n                return;\n            }\n            Tools._EndUserMark(counterName, condition);\n            if (console.time) {\n                console.timeEnd(counterName);\n            }\n        };\n        Object.defineProperty(Tools, \"Now\", {\n            get: function () {\n                if (window.performance && window.performance.now) {\n                    return window.performance.now();\n                }\n                return new Date().getTime();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * This method will return the name of the class used to create the instance of the given object.\n         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.\n         * @param object the object to get the class name from\n         * @return the name of the class, will be \"object\" for a custom data type not using the @className decorator\n         */\n        Tools.getClassName = function (object, isType) {\n            if (isType === void 0) { isType = false; }\n            var name = null;\n            if (!isType && object.getClassName) {\n                name = object.getClassName();\n            }\n            else {\n                if (object instanceof Object) {\n                    var classObj = isType ? object : Object.getPrototypeOf(object);\n                    name = classObj.constructor[\"__bjsclassName__\"];\n                }\n                if (!name) {\n                    name = typeof object;\n                }\n            }\n            return name;\n        };\n        Tools.first = function (array, predicate) {\n            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n                var el = array_1[_i];\n                if (predicate(el)) {\n                    return el;\n                }\n            }\n        };\n        /**\n         * This method will return the name of the full name of the class, including its owning module (if any).\n         * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).\n         * @param object the object to get the class name from\n         * @return a string that can have two forms: \"moduleName.className\" if module was specified when the class' Name was registered or \"className\" if there was not module specified.\n         */\n        Tools.getFullClassName = function (object, isType) {\n            if (isType === void 0) { isType = false; }\n            var className = null;\n            var moduleName = null;\n            if (!isType && object.getClassName) {\n                className = object.getClassName();\n            }\n            else {\n                if (object instanceof Object) {\n                    var classObj = isType ? object : Object.getPrototypeOf(object);\n                    className = classObj.constructor[\"__bjsclassName__\"];\n                    moduleName = classObj.constructor[\"__bjsmoduleName__\"];\n                }\n                if (!className) {\n                    className = typeof object;\n                }\n            }\n            if (!className) {\n                return null;\n            }\n            return ((moduleName != null) ? (moduleName + \".\") : \"\") + className;\n        };\n        /**\n         * This method can be used with hashCodeFromStream when your input is an array of values that are either: number, string, boolean or custom type implementing the getHashCode():number method.\n         * @param array\n         */\n        Tools.arrayOrStringFeeder = function (array) {\n            return function (index) {\n                if (index >= array.length) {\n                    return null;\n                }\n                var val = array.charCodeAt ? array.charCodeAt(index) : array[index];\n                if (val && val.getHashCode) {\n                    val = val.getHashCode();\n                }\n                if (typeof val === \"string\") {\n                    return Tools.hashCodeFromStream(Tools.arrayOrStringFeeder(val));\n                }\n                return val;\n            };\n        };\n        /**\n         * Compute the hashCode of a stream of number\n         * To compute the HashCode on a string or an Array of data types implementing the getHashCode() method, use the arrayOrStringFeeder method.\n         * @param feeder a callback that will be called until it returns null, each valid returned values will be used to compute the hash code.\n         * @return the hash code computed\n         */\n        Tools.hashCodeFromStream = function (feeder) {\n            // Based from here: http://stackoverflow.com/a/7616484/802124\n            var hash = 0;\n            var index = 0;\n            var chr = feeder(index++);\n            while (chr != null) {\n                hash = ((hash << 5) - hash) + chr;\n                hash |= 0; // Convert to 32bit integer\n                chr = feeder(index++);\n            }\n            return hash;\n        };\n        return Tools;\n    }());\n    Tools.BaseUrl = \"\";\n    Tools.CorsBehavior = \"anonymous\";\n    Tools.UseFallbackTexture = true;\n    // Used in case of a texture loading problem \n    Tools.fallbackTexture = \"data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z\";\n    // Logs\n    Tools._NoneLogLevel = 0;\n    Tools._MessageLogLevel = 1;\n    Tools._WarningLogLevel = 2;\n    Tools._ErrorLogLevel = 4;\n    Tools._LogCache = \"\";\n    Tools.errorsCount = 0;\n    Tools.Log = Tools._LogEnabled;\n    Tools.Warn = Tools._WarnEnabled;\n    Tools.Error = Tools._ErrorEnabled;\n    // Performances\n    Tools._PerformanceNoneLogLevel = 0;\n    Tools._PerformanceUserMarkLogLevel = 1;\n    Tools._PerformanceConsoleLogLevel = 2;\n    Tools._performance = window.performance;\n    Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;\n    Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;\n    BABYLON.Tools = Tools;\n    /**\n     * This class is used to track a performance counter which is number based.\n     * The user has access to many properties which give statistics of different nature\n     *\n     * The implementer can track two kinds of Performance Counter: time and count\n     * For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.\n     * For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.\n     */\n    var PerfCounter = (function () {\n        function PerfCounter() {\n            this._startMonitoringTime = 0;\n            this._min = 0;\n            this._max = 0;\n            this._average = 0;\n            this._lastSecAverage = 0;\n            this._current = 0;\n            this._totalValueCount = 0;\n            this._totalAccumulated = 0;\n            this._lastSecAccumulated = 0;\n            this._lastSecTime = 0;\n            this._lastSecValueCount = 0;\n        }\n        Object.defineProperty(PerfCounter.prototype, \"min\", {\n            /**\n             * Returns the smallest value ever\n             */\n            get: function () {\n                return this._min;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PerfCounter.prototype, \"max\", {\n            /**\n             * Returns the biggest value ever\n             */\n            get: function () {\n                return this._max;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PerfCounter.prototype, \"average\", {\n            /**\n             * Returns the average value since the performance counter is running\n             */\n            get: function () {\n                return this._average;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PerfCounter.prototype, \"lastSecAverage\", {\n            /**\n             * Returns the average value of the last second the counter was monitored\n             */\n            get: function () {\n                return this._lastSecAverage;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PerfCounter.prototype, \"current\", {\n            /**\n             * Returns the current value\n             */\n            get: function () {\n                return this._current;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PerfCounter.prototype, \"total\", {\n            get: function () {\n                return this._totalAccumulated;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Call this method to start monitoring a new frame.\n         * This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.\n         */\n        PerfCounter.prototype.fetchNewFrame = function () {\n            this._totalValueCount++;\n            this._current = 0;\n            this._lastSecValueCount++;\n        };\n        /**\n         * Call this method to monitor a count of something (e.g. mesh drawn in viewport count)\n         * @param newCount the count value to add to the monitored count\n         * @param fetchResult true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.\n         */\n        PerfCounter.prototype.addCount = function (newCount, fetchResult) {\n            if (!PerfCounter.Enabled) {\n                return;\n            }\n            this._current += newCount;\n            if (fetchResult) {\n                this._fetchResult();\n            }\n        };\n        /**\n         * Start monitoring this performance counter\n         */\n        PerfCounter.prototype.beginMonitoring = function () {\n            if (!PerfCounter.Enabled) {\n                return;\n            }\n            this._startMonitoringTime = Tools.Now;\n        };\n        /**\n         * Compute the time lapsed since the previous beginMonitoring() call.\n         * @param newFrame true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter\n         */\n        PerfCounter.prototype.endMonitoring = function (newFrame) {\n            if (newFrame === void 0) { newFrame = true; }\n            if (!PerfCounter.Enabled) {\n                return;\n            }\n            if (newFrame) {\n                this.fetchNewFrame();\n            }\n            var currentTime = Tools.Now;\n            this._current = currentTime - this._startMonitoringTime;\n            if (newFrame) {\n                this._fetchResult();\n            }\n        };\n        PerfCounter.prototype._fetchResult = function () {\n            this._totalAccumulated += this._current;\n            this._lastSecAccumulated += this._current;\n            // Min/Max update\n            this._min = Math.min(this._min, this._current);\n            this._max = Math.max(this._max, this._current);\n            this._average = this._totalAccumulated / this._totalValueCount;\n            // Reset last sec?\n            var now = Tools.Now;\n            if ((now - this._lastSecTime) > 1000) {\n                this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;\n                this._lastSecTime = now;\n                this._lastSecAccumulated = 0;\n                this._lastSecValueCount = 0;\n            }\n        };\n        return PerfCounter;\n    }());\n    PerfCounter.Enabled = true;\n    BABYLON.PerfCounter = PerfCounter;\n    /**\n     * Use this className as a decorator on a given class definition to add it a name and optionally its module.\n     * You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.\n     * This method is the only way to get it done in all cases, even if the .js file declaring the class is minified\n     * @param name The name of the class, case should be preserved\n     * @param module The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.\n     */\n    function className(name, module) {\n        return function (target) {\n            target[\"__bjsclassName__\"] = name;\n            target[\"__bjsmoduleName__\"] = (module != null) ? module : null;\n        };\n    }\n    BABYLON.className = className;\n    /**\n    * An implementation of a loop for asynchronous functions.\n    */\n    var AsyncLoop = (function () {\n        /**\n         * Constroctor.\n         * @param iterations the number of iterations.\n         * @param _fn the function to run each iteration\n         * @param _successCallback the callback that will be called upon succesful execution\n         * @param offset starting offset.\n         */\n        function AsyncLoop(iterations, _fn, _successCallback, offset) {\n            if (offset === void 0) { offset = 0; }\n            this.iterations = iterations;\n            this._fn = _fn;\n            this._successCallback = _successCallback;\n            this.index = offset - 1;\n            this._done = false;\n        }\n        /**\n         * Execute the next iteration. Must be called after the last iteration was finished.\n         */\n        AsyncLoop.prototype.executeNext = function () {\n            if (!this._done) {\n                if (this.index + 1 < this.iterations) {\n                    ++this.index;\n                    this._fn(this);\n                }\n                else {\n                    this.breakLoop();\n                }\n            }\n        };\n        /**\n         * Break the loop and run the success callback.\n         */\n        AsyncLoop.prototype.breakLoop = function () {\n            this._done = true;\n            this._successCallback();\n        };\n        /**\n         * Helper function\n         */\n        AsyncLoop.Run = function (iterations, _fn, _successCallback, offset) {\n            if (offset === void 0) { offset = 0; }\n            var loop = new AsyncLoop(iterations, _fn, _successCallback, offset);\n            loop.executeNext();\n            return loop;\n        };\n        /**\n         * A for-loop that will run a given number of iterations synchronous and the rest async.\n         * @param iterations total number of iterations\n         * @param syncedIterations number of synchronous iterations in each async iteration.\n         * @param fn the function to call each iteration.\n         * @param callback a success call back that will be called when iterating stops.\n         * @param breakFunction a break condition (optional)\n         * @param timeout timeout settings for the setTimeout function. default - 0.\n         * @constructor\n         */\n        AsyncLoop.SyncAsyncForLoop = function (iterations, syncedIterations, fn, callback, breakFunction, timeout) {\n            if (timeout === void 0) { timeout = 0; }\n            AsyncLoop.Run(Math.ceil(iterations / syncedIterations), function (loop) {\n                if (breakFunction && breakFunction())\n                    loop.breakLoop();\n                else {\n                    setTimeout(function () {\n                        for (var i = 0; i < syncedIterations; ++i) {\n                            var iteration = (loop.index * syncedIterations) + i;\n                            if (iteration >= iterations)\n                                break;\n                            fn(iteration);\n                            if (breakFunction && breakFunction()) {\n                                loop.breakLoop();\n                                break;\n                            }\n                        }\n                        loop.executeNext();\n                    }, timeout);\n                }\n            }, callback);\n        };\n        return AsyncLoop;\n    }());\n    BABYLON.AsyncLoop = AsyncLoop;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.tools.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var _AlphaState = (function () {\n            /**\n             * Initializes the state.\n             */\n            function _AlphaState() {\n                this._isAlphaBlendDirty = false;\n                this._isBlendFunctionParametersDirty = false;\n                this._isBlendEquationParametersDirty = false;\n                this._isBlendConstantsDirty = false;\n                this._alphaBlend = false;\n                this._blendFunctionParameters = new Array(4);\n                this._blendEquationParameters = new Array(2);\n                this._blendConstants = new Array(4);\n                this.reset();\n            }\n            Object.defineProperty(_AlphaState.prototype, \"isDirty\", {\n                get: function () {\n                    return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_AlphaState.prototype, \"alphaBlend\", {\n                get: function () {\n                    return this._alphaBlend;\n                },\n                set: function (value) {\n                    if (this._alphaBlend === value) {\n                        return;\n                    }\n                    this._alphaBlend = value;\n                    this._isAlphaBlendDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            _AlphaState.prototype.setAlphaBlendConstants = function (r, g, b, a) {\n                if (this._blendConstants[0] === r &&\n                    this._blendConstants[1] === g &&\n                    this._blendConstants[2] === b &&\n                    this._blendConstants[3] === a) {\n                    return;\n                }\n                this._blendConstants[0] = r;\n                this._blendConstants[1] = g;\n                this._blendConstants[2] = b;\n                this._blendConstants[3] = a;\n                this._isBlendConstantsDirty = true;\n            };\n            _AlphaState.prototype.setAlphaBlendFunctionParameters = function (value0, value1, value2, value3) {\n                if (this._blendFunctionParameters[0] === value0 &&\n                    this._blendFunctionParameters[1] === value1 &&\n                    this._blendFunctionParameters[2] === value2 &&\n                    this._blendFunctionParameters[3] === value3) {\n                    return;\n                }\n                this._blendFunctionParameters[0] = value0;\n                this._blendFunctionParameters[1] = value1;\n                this._blendFunctionParameters[2] = value2;\n                this._blendFunctionParameters[3] = value3;\n                this._isBlendFunctionParametersDirty = true;\n            };\n            _AlphaState.prototype.setAlphaEquationParameters = function (rgb, alpha) {\n                if (this._blendEquationParameters[0] === rgb &&\n                    this._blendEquationParameters[1] === alpha) {\n                    return;\n                }\n                this._blendEquationParameters[0] = rgb;\n                this._blendEquationParameters[1] = alpha;\n                this._isBlendEquationParametersDirty = true;\n            };\n            _AlphaState.prototype.reset = function () {\n                this._alphaBlend = false;\n                this._blendFunctionParameters[0] = null;\n                this._blendFunctionParameters[1] = null;\n                this._blendFunctionParameters[2] = null;\n                this._blendFunctionParameters[3] = null;\n                this._blendEquationParameters[0] = null;\n                this._blendEquationParameters[1] = null;\n                this._blendConstants[0] = null;\n                this._blendConstants[1] = null;\n                this._blendConstants[2] = null;\n                this._blendConstants[3] = null;\n                this._isAlphaBlendDirty = true;\n                this._isBlendFunctionParametersDirty = false;\n                this._isBlendEquationParametersDirty = false;\n                this._isBlendConstantsDirty = false;\n            };\n            _AlphaState.prototype.apply = function (gl) {\n                if (!this.isDirty) {\n                    return;\n                }\n                // Alpha blend\n                if (this._isAlphaBlendDirty) {\n                    if (this._alphaBlend) {\n                        gl.enable(gl.BLEND);\n                    }\n                    else {\n                        gl.disable(gl.BLEND);\n                    }\n                    this._isAlphaBlendDirty = false;\n                }\n                // Alpha function\n                if (this._isBlendFunctionParametersDirty) {\n                    gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);\n                    this._isBlendFunctionParametersDirty = false;\n                }\n                // Alpha equation\n                if (this._isBlendEquationParametersDirty) {\n                    gl.blendEquationSeparate(this._isBlendEquationParametersDirty[0], this._isBlendEquationParametersDirty[1]);\n                    this._isBlendEquationParametersDirty = false;\n                }\n                // Constants\n                if (this._isBlendConstantsDirty) {\n                    gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);\n                    this._isBlendConstantsDirty = false;\n                }\n            };\n            return _AlphaState;\n        }());\n        Internals._AlphaState = _AlphaState;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.alphaCullingState.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var _DepthCullingState = (function () {\n            /**\n             * Initializes the state.\n             */\n            function _DepthCullingState() {\n                this._isDepthTestDirty = false;\n                this._isDepthMaskDirty = false;\n                this._isDepthFuncDirty = false;\n                this._isCullFaceDirty = false;\n                this._isCullDirty = false;\n                this._isZOffsetDirty = false;\n                this.reset();\n            }\n            Object.defineProperty(_DepthCullingState.prototype, \"isDirty\", {\n                get: function () {\n                    return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"zOffset\", {\n                get: function () {\n                    return this._zOffset;\n                },\n                set: function (value) {\n                    if (this._zOffset === value) {\n                        return;\n                    }\n                    this._zOffset = value;\n                    this._isZOffsetDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"cullFace\", {\n                get: function () {\n                    return this._cullFace;\n                },\n                set: function (value) {\n                    if (this._cullFace === value) {\n                        return;\n                    }\n                    this._cullFace = value;\n                    this._isCullFaceDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"cull\", {\n                get: function () {\n                    return this._cull;\n                },\n                set: function (value) {\n                    if (this._cull === value) {\n                        return;\n                    }\n                    this._cull = value;\n                    this._isCullDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"depthFunc\", {\n                get: function () {\n                    return this._depthFunc;\n                },\n                set: function (value) {\n                    if (this._depthFunc === value) {\n                        return;\n                    }\n                    this._depthFunc = value;\n                    this._isDepthFuncDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"depthMask\", {\n                get: function () {\n                    return this._depthMask;\n                },\n                set: function (value) {\n                    if (this._depthMask === value) {\n                        return;\n                    }\n                    this._depthMask = value;\n                    this._isDepthMaskDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_DepthCullingState.prototype, \"depthTest\", {\n                get: function () {\n                    return this._depthTest;\n                },\n                set: function (value) {\n                    if (this._depthTest === value) {\n                        return;\n                    }\n                    this._depthTest = value;\n                    this._isDepthTestDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            _DepthCullingState.prototype.reset = function () {\n                this._depthMask = true;\n                this._depthTest = true;\n                this._depthFunc = null;\n                this._cullFace = null;\n                this._cull = null;\n                this._zOffset = 0;\n                this._isDepthTestDirty = true;\n                this._isDepthMaskDirty = true;\n                this._isDepthFuncDirty = false;\n                this._isCullFaceDirty = false;\n                this._isCullDirty = false;\n                this._isZOffsetDirty = false;\n            };\n            _DepthCullingState.prototype.apply = function (gl) {\n                if (!this.isDirty) {\n                    return;\n                }\n                // Cull\n                if (this._isCullDirty) {\n                    if (this.cull) {\n                        gl.enable(gl.CULL_FACE);\n                    }\n                    else {\n                        gl.disable(gl.CULL_FACE);\n                    }\n                    this._isCullDirty = false;\n                }\n                // Cull face\n                if (this._isCullFaceDirty) {\n                    gl.cullFace(this.cullFace);\n                    this._isCullFaceDirty = false;\n                }\n                // Depth mask\n                if (this._isDepthMaskDirty) {\n                    gl.depthMask(this.depthMask);\n                    this._isDepthMaskDirty = false;\n                }\n                // Depth test\n                if (this._isDepthTestDirty) {\n                    if (this.depthTest) {\n                        gl.enable(gl.DEPTH_TEST);\n                    }\n                    else {\n                        gl.disable(gl.DEPTH_TEST);\n                    }\n                    this._isDepthTestDirty = false;\n                }\n                // Depth func\n                if (this._isDepthFuncDirty) {\n                    gl.depthFunc(this.depthFunc);\n                    this._isDepthFuncDirty = false;\n                }\n                // zOffset\n                if (this._isZOffsetDirty) {\n                    if (this.zOffset) {\n                        gl.enable(gl.POLYGON_OFFSET_FILL);\n                        gl.polygonOffset(this.zOffset, 0);\n                    }\n                    else {\n                        gl.disable(gl.POLYGON_OFFSET_FILL);\n                    }\n                    this._isZOffsetDirty = false;\n                }\n            };\n            return _DepthCullingState;\n        }());\n        Internals._DepthCullingState = _DepthCullingState;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.depthCullingState.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var _StencilState = (function () {\n            function _StencilState() {\n                this._isStencilTestDirty = false;\n                this._isStencilMaskDirty = false;\n                this._isStencilFuncDirty = false;\n                this._isStencilOpDirty = false;\n                this.reset();\n            }\n            Object.defineProperty(_StencilState.prototype, \"isDirty\", {\n                get: function () {\n                    return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilFunc\", {\n                get: function () {\n                    return this._stencilFunc;\n                },\n                set: function (value) {\n                    if (this._stencilFunc === value) {\n                        return;\n                    }\n                    this._stencilFunc = value;\n                    this._isStencilFuncDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilFuncRef\", {\n                get: function () {\n                    return this._stencilFuncRef;\n                },\n                set: function (value) {\n                    if (this._stencilFuncRef === value) {\n                        return;\n                    }\n                    this._stencilFuncRef = value;\n                    this._isStencilFuncDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilFuncMask\", {\n                get: function () {\n                    return this._stencilFuncMask;\n                },\n                set: function (value) {\n                    if (this._stencilFuncMask === value) {\n                        return;\n                    }\n                    this._stencilFuncMask = value;\n                    this._isStencilFuncDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilOpStencilFail\", {\n                get: function () {\n                    return this._stencilOpStencilFail;\n                },\n                set: function (value) {\n                    if (this._stencilOpStencilFail === value) {\n                        return;\n                    }\n                    this._stencilOpStencilFail = value;\n                    this._isStencilOpDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilOpDepthFail\", {\n                get: function () {\n                    return this._stencilOpDepthFail;\n                },\n                set: function (value) {\n                    if (this._stencilOpDepthFail === value) {\n                        return;\n                    }\n                    this._stencilOpDepthFail = value;\n                    this._isStencilOpDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilOpStencilDepthPass\", {\n                get: function () {\n                    return this._stencilOpStencilDepthPass;\n                },\n                set: function (value) {\n                    if (this._stencilOpStencilDepthPass === value) {\n                        return;\n                    }\n                    this._stencilOpStencilDepthPass = value;\n                    this._isStencilOpDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilMask\", {\n                get: function () {\n                    return this._stencilMask;\n                },\n                set: function (value) {\n                    if (this._stencilMask === value) {\n                        return;\n                    }\n                    this._stencilMask = value;\n                    this._isStencilMaskDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(_StencilState.prototype, \"stencilTest\", {\n                get: function () {\n                    return this._stencilTest;\n                },\n                set: function (value) {\n                    if (this._stencilTest === value) {\n                        return;\n                    }\n                    this._stencilTest = value;\n                    this._isStencilTestDirty = true;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            _StencilState.prototype.reset = function () {\n                this._stencilTest = false;\n                this._stencilMask = 0xFF;\n                this._stencilFunc = BABYLON.Engine.ALWAYS;\n                this._stencilFuncRef = 1;\n                this._stencilFuncMask = 0xFF;\n                this._stencilOpStencilFail = BABYLON.Engine.KEEP;\n                this._stencilOpDepthFail = BABYLON.Engine.KEEP;\n                this._stencilOpStencilDepthPass = BABYLON.Engine.REPLACE;\n                this._isStencilTestDirty = true;\n                this._isStencilMaskDirty = true;\n                this._isStencilFuncDirty = true;\n                this._isStencilOpDirty = true;\n            };\n            _StencilState.prototype.apply = function (gl) {\n                if (!this.isDirty) {\n                    return;\n                }\n                // Stencil test\n                if (this._isStencilTestDirty) {\n                    if (this.stencilTest) {\n                        gl.enable(gl.STENCIL_TEST);\n                    }\n                    else {\n                        gl.disable(gl.STENCIL_TEST);\n                    }\n                    this._isStencilTestDirty = false;\n                }\n                // Stencil mask\n                if (this._isStencilMaskDirty) {\n                    gl.stencilMask(this.stencilMask);\n                    this._isStencilMaskDirty = false;\n                }\n                // Stencil func\n                if (this._isStencilFuncDirty) {\n                    gl.stencilFunc(this.stencilFunc, this.stencilFuncRef, this.stencilFuncMask);\n                    this._isStencilFuncDirty = false;\n                }\n                // Stencil op\n                if (this._isStencilOpDirty) {\n                    gl.stencilOp(this.stencilOpStencilFail, this.stencilOpDepthFail, this.stencilOpStencilDepthPass);\n                    this._isStencilOpDirty = false;\n                }\n            };\n            return _StencilState;\n        }());\n        Internals._StencilState = _StencilState;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.stencilState.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var compileShader = function (gl, source, type, defines, shaderVersion) {\n        var shader = gl.createShader(type === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n        gl.shaderSource(shader, shaderVersion + (defines ? defines + \"\\n\" : \"\") + source);\n        gl.compileShader(shader);\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            throw new Error(gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    };\n    var getSamplingParameters = function (samplingMode, generateMipMaps, gl) {\n        var magFilter = gl.NEAREST;\n        var minFilter = gl.NEAREST;\n        if (samplingMode === BABYLON.Texture.BILINEAR_SAMPLINGMODE) {\n            magFilter = gl.LINEAR;\n            if (generateMipMaps) {\n                minFilter = gl.LINEAR_MIPMAP_NEAREST;\n            }\n            else {\n                minFilter = gl.LINEAR;\n            }\n        }\n        else if (samplingMode === BABYLON.Texture.TRILINEAR_SAMPLINGMODE) {\n            magFilter = gl.LINEAR;\n            if (generateMipMaps) {\n                minFilter = gl.LINEAR_MIPMAP_LINEAR;\n            }\n            else {\n                minFilter = gl.LINEAR;\n            }\n        }\n        else if (samplingMode === BABYLON.Texture.NEAREST_SAMPLINGMODE) {\n            magFilter = gl.NEAREST;\n            if (generateMipMaps) {\n                minFilter = gl.NEAREST_MIPMAP_LINEAR;\n            }\n            else {\n                minFilter = gl.NEAREST;\n            }\n        }\n        return {\n            min: minFilter,\n            mag: magFilter\n        };\n    };\n    var prepareWebGLTexture = function (texture, gl, scene, width, height, invertY, noMipmap, isCompressed, processFunction, samplingMode) {\n        if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n        var engine = scene.getEngine();\n        if (!engine) {\n            return;\n        }\n        var potWidth = BABYLON.Tools.GetExponentOfTwo(width, engine.getCaps().maxTextureSize);\n        var potHeight = BABYLON.Tools.GetExponentOfTwo(height, engine.getCaps().maxTextureSize);\n        engine._bindTextureDirectly(gl.TEXTURE_2D, texture);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY === undefined ? 1 : (invertY ? 1 : 0));\n        texture._baseWidth = width;\n        texture._baseHeight = height;\n        texture._width = potWidth;\n        texture._height = potHeight;\n        texture.isReady = true;\n        processFunction(potWidth, potHeight);\n        var filters = getSamplingParameters(samplingMode, !noMipmap, gl);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n        if (!noMipmap && !isCompressed) {\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n        engine._bindTextureDirectly(gl.TEXTURE_2D, null);\n        engine.resetTextureCache();\n        scene._removePendingData(texture);\n        texture.onLoadedCallbacks.forEach(function (callback) {\n            callback();\n        });\n        texture.onLoadedCallbacks = [];\n    };\n    var partialLoad = function (url, index, loadedImages, scene, onfinish, onErrorCallBack) {\n        if (onErrorCallBack === void 0) { onErrorCallBack = null; }\n        var img;\n        var onload = function () {\n            loadedImages[index] = img;\n            loadedImages._internalCount++;\n            scene._removePendingData(img);\n            if (loadedImages._internalCount === 6) {\n                onfinish(loadedImages);\n            }\n        };\n        var onerror = function () {\n            scene._removePendingData(img);\n            if (onErrorCallBack) {\n                onErrorCallBack();\n            }\n        };\n        img = BABYLON.Tools.LoadImage(url, onload, onerror, scene.database);\n        scene._addPendingData(img);\n    };\n    var cascadeLoad = function (rootUrl, scene, onfinish, files, onError) {\n        if (onError === void 0) { onError = null; }\n        var loadedImages = [];\n        loadedImages._internalCount = 0;\n        for (var index = 0; index < 6; index++) {\n            partialLoad(files[index], index, loadedImages, scene, onfinish, onError);\n        }\n    };\n    var InstancingAttributeInfo = (function () {\n        function InstancingAttributeInfo() {\n        }\n        return InstancingAttributeInfo;\n    }());\n    BABYLON.InstancingAttributeInfo = InstancingAttributeInfo;\n    var EngineCapabilities = (function () {\n        function EngineCapabilities() {\n        }\n        return EngineCapabilities;\n    }());\n    BABYLON.EngineCapabilities = EngineCapabilities;\n    /**\n     * The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio.\n     */\n    var Engine = (function () {\n        /**\n         * @constructor\n         * @param {HTMLCanvasElement} canvas - the canvas to be used for rendering\n         * @param {boolean} [antialias] - enable antialias\n         * @param options - further options to be sent to the getContext function\n         */\n        function Engine(canvas, antialias, options, adaptToDeviceRatio) {\n            if (adaptToDeviceRatio === void 0) { adaptToDeviceRatio = false; }\n            var _this = this;\n            // Public members\n            this.isFullscreen = false;\n            this.isPointerLock = false;\n            this.cullBackFaces = true;\n            this.renderEvenInBackground = true;\n            this.preventCacheWipeBetweenFrames = false;\n            // To enable/disable IDB support and avoid XHR on .manifest\n            this.enableOfflineSupport = BABYLON.Database;\n            this.scenes = new Array();\n            // Observables\n            /**\n             * Observable event triggered each time the rendering canvas is resized\n             */\n            this.onResizeObservable = new BABYLON.Observable();\n            /**\n             * Observable event triggered each time the canvas lost focus\n             */\n            this.onCanvasBlurObservable = new BABYLON.Observable();\n            this._windowIsBackground = false;\n            this._webGLVersion = 1.0;\n            this._badOS = false;\n            this._badDesktopOS = false;\n            this._drawCalls = new BABYLON.PerfCounter();\n            this._renderingQueueLaunched = false;\n            this._activeRenderLoops = [];\n            // FPS\n            this.fpsRange = 60;\n            this.previousFramesDuration = [];\n            this.fps = 60;\n            this.deltaTime = 0;\n            // States\n            this._depthCullingState = new BABYLON.Internals._DepthCullingState();\n            this._stencilState = new BABYLON.Internals._StencilState();\n            this._alphaState = new BABYLON.Internals._AlphaState();\n            this._alphaMode = Engine.ALPHA_DISABLE;\n            // Cache\n            this._loadedTexturesCache = new Array();\n            this._maxTextureChannels = 16;\n            this._activeTexturesCache = new Array(this._maxTextureChannels);\n            this._compiledEffects = {};\n            this._vertexAttribArraysEnabled = [];\n            this._uintIndicesCurrentlySet = false;\n            this._currentBoundBuffer = new Array();\n            this._currentBufferPointers = [];\n            this._currentInstanceLocations = new Array();\n            this._currentInstanceBuffers = new Array();\n            this._vaoRecordInProgress = false;\n            this._mustWipeVertexAttributes = false;\n            // Hardware supported Compressed Textures\n            this._texturesSupported = new Array();\n            this._onVRFullScreenTriggered = function () {\n                if (_this._vrDisplayEnabled && _this._vrDisplayEnabled.isPresenting) {\n                    //get the old size before we change\n                    _this._oldSize = new BABYLON.Size(_this.getRenderWidth(), _this.getRenderHeight());\n                    _this._oldHardwareScaleFactor = _this.getHardwareScalingLevel();\n                    //get the width and height, change the render size\n                    var leftEye = _this._vrDisplayEnabled.getEyeParameters('left');\n                    var width, height;\n                    _this.setHardwareScalingLevel(1);\n                    _this.setSize(leftEye.renderWidth * 2, leftEye.renderHeight);\n                }\n                else {\n                    //When the specs are implemented, need to uncomment this.\n                    //this._vrDisplayEnabled.cancelAnimationFrame(this._vrAnimationFrameHandler);\n                    _this.setHardwareScalingLevel(_this._oldHardwareScaleFactor);\n                    _this.setSize(_this._oldSize.width, _this._oldSize.height);\n                    _this._vrDisplayEnabled = undefined;\n                }\n            };\n            this._renderingCanvas = canvas;\n            Engine.Instances.push(this);\n            options = options || {};\n            if (antialias != null) {\n                options.antialias = antialias;\n            }\n            if (options.preserveDrawingBuffer === undefined) {\n                options.preserveDrawingBuffer = false;\n            }\n            if (options.audioEngine === undefined) {\n                options.audioEngine = true;\n            }\n            if (options.stencil === undefined) {\n                options.stencil = true;\n            }\n            // GL\n            if (!options.disableWebGL2Support) {\n                try {\n                    this._gl = (canvas.getContext(\"webgl2\", options) || canvas.getContext(\"experimental-webgl2\", options));\n                    if (this._gl) {\n                        this._webGLVersion = 2.0;\n                    }\n                }\n                catch (e) {\n                    // Do nothing\n                }\n            }\n            if (!this._gl) {\n                if (!canvas) {\n                    throw new Error(\"The provided canvas is null or undefined.\");\n                }\n                try {\n                    this._gl = (canvas.getContext(\"webgl\", options) || canvas.getContext(\"experimental-webgl\", options));\n                }\n                catch (e) {\n                    throw new Error(\"WebGL not supported\");\n                }\n            }\n            if (!this._gl) {\n                throw new Error(\"WebGL not supported\");\n            }\n            this._onBlur = function () {\n                _this._windowIsBackground = true;\n            };\n            this._onFocus = function () {\n                _this._windowIsBackground = false;\n            };\n            this._onCanvasBlur = function () {\n                _this.onCanvasBlurObservable.notifyObservers(_this);\n            };\n            window.addEventListener(\"blur\", this._onBlur);\n            window.addEventListener(\"focus\", this._onFocus);\n            canvas.addEventListener(\"pointerout\", this._onCanvasBlur);\n            // Viewport\n            var limitDeviceRatio = options.limitDeviceRatio || window.devicePixelRatio || 1.0;\n            this._hardwareScalingLevel = adaptToDeviceRatio ? 1.0 / Math.min(limitDeviceRatio, window.devicePixelRatio || 1.0) : 1.0;\n            this.resize();\n            // Caps\n            this._isStencilEnable = options.stencil;\n            this._caps = new EngineCapabilities();\n            this._caps.maxTexturesImageUnits = this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS);\n            this._caps.maxVertexTextureImageUnits = this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n            this._caps.maxTextureSize = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n            this._caps.maxCubemapTextureSize = this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n            this._caps.maxRenderTextureSize = this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE);\n            this._caps.maxVertexAttribs = this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS);\n            this._caps.maxVaryingVectors = this._gl.getParameter(this._gl.MAX_VARYING_VECTORS);\n            this._caps.maxFragmentUniformVectors = this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n            this._caps.maxVertexUniformVectors = this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS);\n            // Infos\n            this._glVersion = this._gl.getParameter(this._gl.VERSION);\n            var rendererInfo = this._gl.getExtension(\"WEBGL_debug_renderer_info\");\n            if (rendererInfo != null) {\n                this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);\n                this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);\n            }\n            if (!this._glVendor) {\n                this._glVendor = \"Unknown vendor\";\n            }\n            if (!this._glRenderer) {\n                this._glRenderer = \"Unknown renderer\";\n            }\n            // Constants\n            this._gl.HALF_FLOAT_OES = 0x8D61; // Half floating-point type (16-bit).\n            this._gl.RGBA16F = 0x881A; // RGBA 16-bit floating-point color-renderable internal sized format.\n            this._gl.RGBA32F = 0x8814; // RGBA 32-bit floating-point color-renderable internal sized format.         \n            this._gl.DEPTH24_STENCIL8 = 35056;\n            // Extensions\n            this._caps.standardDerivatives = this._webGLVersion > 1 || (this._gl.getExtension('OES_standard_derivatives') !== null);\n            this._caps.astc = this._gl.getExtension('WEBGL_compressed_texture_astc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_astc');\n            this._caps.s3tc = this._gl.getExtension('WEBGL_compressed_texture_s3tc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n            this._caps.pvrtc = this._gl.getExtension('WEBGL_compressed_texture_pvrtc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n            this._caps.etc1 = this._gl.getExtension('WEBGL_compressed_texture_etc1') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');\n            this._caps.etc2 = this._gl.getExtension('WEBGL_compressed_texture_etc') || this._gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc') ||\n                this._gl.getExtension('WEBGL_compressed_texture_es3_0'); // also a requirement of OpenGL ES 3\n            this._caps.textureAnisotropicFilterExtension = this._gl.getExtension('EXT_texture_filter_anisotropic') || this._gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || this._gl.getExtension('MOZ_EXT_texture_filter_anisotropic');\n            this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;\n            this._caps.uintIndices = this._webGLVersion > 1 || this._gl.getExtension('OES_element_index_uint') !== null;\n            this._caps.fragmentDepthSupported = this._webGLVersion > 1 || this._gl.getExtension('EXT_frag_depth') !== null;\n            this._caps.highPrecisionShaderSupported = true;\n            this._caps.drawBuffersExtension = this._webGLVersion > 1 || this._gl.getExtension('WEBGL_draw_buffers');\n            // Checks if some of the format renders first to allow the use of webgl inspector.\n            this._caps.colorBufferFloat = this._webGLVersion > 1 && this._gl.getExtension('EXT_color_buffer_float');\n            this._caps.textureFloat = this._webGLVersion > 1 || this._gl.getExtension('OES_texture_float');\n            this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension('OES_texture_float_linear');\n            this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer();\n            this._caps.textureHalfFloat = this._webGLVersion > 1 || this._gl.getExtension('OES_texture_half_float');\n            this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || (this._caps.textureHalfFloat && this._gl.getExtension('OES_texture_half_float_linear'));\n            if (this._webGLVersion > 1) {\n                this._gl.HALF_FLOAT_OES = 0x140B;\n            }\n            this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();\n            this._caps.textureLOD = this._webGLVersion > 1 || this._gl.getExtension('EXT_shader_texture_lod');\n            // Vertex array object \n            if (this._webGLVersion > 1) {\n                this._caps.vertexArrayObject = true;\n            }\n            else {\n                var vertexArrayObjectExtension = this._gl.getExtension('OES_vertex_array_object');\n                if (vertexArrayObjectExtension != null) {\n                    this._caps.vertexArrayObject = true;\n                    this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);\n                    this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);\n                    this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);\n                }\n                else {\n                    this._caps.vertexArrayObject = false;\n                }\n            }\n            // Instances count            \n            if (this._webGLVersion > 1) {\n                this._caps.instancedArrays = true;\n            }\n            else {\n                var instanceExtension = this._gl.getExtension('ANGLE_instanced_arrays');\n                if (instanceExtension != null) {\n                    this._caps.instancedArrays = true;\n                    this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);\n                    this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);\n                    this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);\n                }\n                else {\n                    this._caps.instancedArrays = false;\n                }\n            }\n            // Intelligently add supported compressed formats in order to check for.\n            // Check for ASTC support first as it is most powerful and to be very cross platform.\n            // Next PVRTC & DXT, which are probably superior to ETC1/2.  \n            // Likely no hardware which supports both PVR & DXT, so order matters little.\n            // ETC2 is newer and handles ETC1 (no alpha capability), so check for first.\n            if (this._caps.astc)\n                this.texturesSupported.push('-astc.ktx');\n            if (this._caps.s3tc)\n                this.texturesSupported.push('-dxt.ktx');\n            if (this._caps.pvrtc)\n                this.texturesSupported.push('-pvrtc.ktx');\n            if (this._caps.etc2)\n                this.texturesSupported.push('-etc2.ktx');\n            if (this._caps.etc1)\n                this.texturesSupported.push('-etc1.ktx');\n            if (this._gl.getShaderPrecisionFormat) {\n                var highp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);\n                this._caps.highPrecisionShaderSupported = highp.precision !== 0;\n            }\n            // Depth buffer\n            this.setDepthBuffer(true);\n            this.setDepthFunctionToLessOrEqual();\n            this.setDepthWrite(true);\n            // Fullscreen\n            this._onFullscreenChange = function () {\n                if (document.fullscreen !== undefined) {\n                    _this.isFullscreen = document.fullscreen;\n                }\n                else if (document.mozFullScreen !== undefined) {\n                    _this.isFullscreen = document.mozFullScreen;\n                }\n                else if (document.webkitIsFullScreen !== undefined) {\n                    _this.isFullscreen = document.webkitIsFullScreen;\n                }\n                else if (document.msIsFullScreen !== undefined) {\n                    _this.isFullscreen = document.msIsFullScreen;\n                }\n                // Pointer lock\n                if (_this.isFullscreen && _this._pointerLockRequested) {\n                    canvas.requestPointerLock = canvas.requestPointerLock ||\n                        canvas.msRequestPointerLock ||\n                        canvas.mozRequestPointerLock ||\n                        canvas.webkitRequestPointerLock;\n                    if (canvas.requestPointerLock) {\n                        canvas.requestPointerLock();\n                    }\n                }\n            };\n            document.addEventListener(\"fullscreenchange\", this._onFullscreenChange, false);\n            document.addEventListener(\"mozfullscreenchange\", this._onFullscreenChange, false);\n            document.addEventListener(\"webkitfullscreenchange\", this._onFullscreenChange, false);\n            document.addEventListener(\"msfullscreenchange\", this._onFullscreenChange, false);\n            // Pointer lock\n            this._onPointerLockChange = function () {\n                _this.isPointerLock = (document.mozPointerLockElement === canvas ||\n                    document.webkitPointerLockElement === canvas ||\n                    document.msPointerLockElement === canvas ||\n                    document.pointerLockElement === canvas);\n            };\n            document.addEventListener(\"pointerlockchange\", this._onPointerLockChange, false);\n            document.addEventListener(\"mspointerlockchange\", this._onPointerLockChange, false);\n            document.addEventListener(\"mozpointerlockchange\", this._onPointerLockChange, false);\n            document.addEventListener(\"webkitpointerlockchange\", this._onPointerLockChange, false);\n            if (options.audioEngine && BABYLON.AudioEngine && !Engine.audioEngine) {\n                Engine.audioEngine = new BABYLON.AudioEngine();\n            }\n            //Load WebVR Devices\n            if (options.autoEnableWebVR) {\n                this.initWebVR();\n            }\n            //Detect if we are running on a faulty buggy OS.\n            this._badOS = /AppleWebKit.*10.[\\d] Mobile/.test(navigator.userAgent);\n            //Detect if we are running on a faulty buggy desktop OS.\n            this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n            BABYLON.Tools.Log(\"Babylon.js engine (v\" + Engine.Version + \") launched\");\n        }\n        Object.defineProperty(Engine, \"LastCreatedEngine\", {\n            get: function () {\n                if (Engine.Instances.length === 0) {\n                    return null;\n                }\n                return Engine.Instances[Engine.Instances.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"LastCreatedScene\", {\n            get: function () {\n                var lastCreatedEngine = Engine.LastCreatedEngine;\n                if (!lastCreatedEngine) {\n                    return null;\n                }\n                if (lastCreatedEngine.scenes.length === 0) {\n                    return null;\n                }\n                return lastCreatedEngine.scenes[lastCreatedEngine.scenes.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation\n         */\n        Engine.MarkAllMaterialsAsDirty = function (flag, predicate) {\n            for (var engineIndex = 0; engineIndex < Engine.Instances.length; engineIndex++) {\n                var engine = Engine.Instances[engineIndex];\n                for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {\n                    engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);\n                }\n            }\n        };\n        Object.defineProperty(Engine, \"NEVER\", {\n            get: function () {\n                return Engine._NEVER;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALWAYS\", {\n            get: function () {\n                return Engine._ALWAYS;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"LESS\", {\n            get: function () {\n                return Engine._LESS;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"EQUAL\", {\n            get: function () {\n                return Engine._EQUAL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"LEQUAL\", {\n            get: function () {\n                return Engine._LEQUAL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"GREATER\", {\n            get: function () {\n                return Engine._GREATER;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"GEQUAL\", {\n            get: function () {\n                return Engine._GEQUAL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"NOTEQUAL\", {\n            get: function () {\n                return Engine._NOTEQUAL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"KEEP\", {\n            get: function () {\n                return Engine._KEEP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"REPLACE\", {\n            get: function () {\n                return Engine._REPLACE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"INCR\", {\n            get: function () {\n                return Engine._INCR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DECR\", {\n            get: function () {\n                return Engine._DECR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"INVERT\", {\n            get: function () {\n                return Engine._INVERT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"INCR_WRAP\", {\n            get: function () {\n                return Engine._INCR_WRAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DECR_WRAP\", {\n            get: function () {\n                return Engine._DECR_WRAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_DISABLE\", {\n            get: function () {\n                return Engine._ALPHA_DISABLE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_ONEONE\", {\n            get: function () {\n                return Engine._ALPHA_ONEONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_ADD\", {\n            get: function () {\n                return Engine._ALPHA_ADD;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_COMBINE\", {\n            get: function () {\n                return Engine._ALPHA_COMBINE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_SUBTRACT\", {\n            get: function () {\n                return Engine._ALPHA_SUBTRACT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_MULTIPLY\", {\n            get: function () {\n                return Engine._ALPHA_MULTIPLY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_MAXIMIZED\", {\n            get: function () {\n                return Engine._ALPHA_MAXIMIZED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_PREMULTIPLIED\", {\n            get: function () {\n                return Engine._ALPHA_PREMULTIPLIED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_PREMULTIPLIED_PORTERDUFF\", {\n            get: function () {\n                return Engine._ALPHA_PREMULTIPLIED_PORTERDUFF;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_INTERPOLATE\", {\n            get: function () {\n                return Engine._ALPHA_INTERPOLATE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"ALPHA_SCREENMODE\", {\n            get: function () {\n                return Engine._ALPHA_SCREENMODE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DELAYLOADSTATE_NONE\", {\n            get: function () {\n                return Engine._DELAYLOADSTATE_NONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DELAYLOADSTATE_LOADED\", {\n            get: function () {\n                return Engine._DELAYLOADSTATE_LOADED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DELAYLOADSTATE_LOADING\", {\n            get: function () {\n                return Engine._DELAYLOADSTATE_LOADING;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"DELAYLOADSTATE_NOTLOADED\", {\n            get: function () {\n                return Engine._DELAYLOADSTATE_NOTLOADED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTUREFORMAT_ALPHA\", {\n            get: function () {\n                return Engine._TEXTUREFORMAT_ALPHA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTUREFORMAT_LUMINANCE\", {\n            get: function () {\n                return Engine._TEXTUREFORMAT_LUMINANCE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTUREFORMAT_LUMINANCE_ALPHA\", {\n            get: function () {\n                return Engine._TEXTUREFORMAT_LUMINANCE_ALPHA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTUREFORMAT_RGB\", {\n            get: function () {\n                return Engine._TEXTUREFORMAT_RGB;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTUREFORMAT_RGBA\", {\n            get: function () {\n                return Engine._TEXTUREFORMAT_RGBA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTURETYPE_UNSIGNED_INT\", {\n            get: function () {\n                return Engine._TEXTURETYPE_UNSIGNED_INT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTURETYPE_FLOAT\", {\n            get: function () {\n                return Engine._TEXTURETYPE_FLOAT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"TEXTURETYPE_HALF_FLOAT\", {\n            get: function () {\n                return Engine._TEXTURETYPE_HALF_FLOAT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"SCALEMODE_FLOOR\", {\n            get: function () {\n                return Engine._SCALEMODE_FLOOR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"SCALEMODE_NEAREST\", {\n            get: function () {\n                return Engine._SCALEMODE_NEAREST;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"SCALEMODE_CEILING\", {\n            get: function () {\n                return Engine._SCALEMODE_CEILING;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine, \"Version\", {\n            get: function () {\n                return \"3.0\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"badOS\", {\n            get: function () {\n                return this._badOS;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"badDesktopOS\", {\n            get: function () {\n                return this._badDesktopOS;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"texturesSupported\", {\n            get: function () {\n                return this._texturesSupported;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"textureFormatInUse\", {\n            get: function () {\n                return this._textureFormatInUse;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"emptyTexture\", {\n            // Empty texture\n            get: function () {\n                if (!this._emptyTexture) {\n                    this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, BABYLON.Engine.TEXTUREFORMAT_RGBA, false, false, BABYLON.Texture.NEAREST_SAMPLINGMODE);\n                }\n                return this._emptyTexture;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"emptyCubeTexture\", {\n            get: function () {\n                if (!this._emptyCubeTexture) {\n                    var faceData = new Uint8Array(4);\n                    var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];\n                    this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, BABYLON.Engine.TEXTUREFORMAT_RGBA, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT, false, false, BABYLON.Texture.NEAREST_SAMPLINGMODE);\n                }\n                return this._emptyCubeTexture;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"webGLVersion\", {\n            get: function () {\n                return this._webGLVersion;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"isStencilEnable\", {\n            /**\n             * Returns true if the stencil buffer has been enabled through the creation option of the context.\n             */\n            get: function () {\n                return this._isStencilEnable;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Engine.prototype._prepareWorkingCanvas = function () {\n            if (this._workingCanvas) {\n                return;\n            }\n            this._workingCanvas = document.createElement(\"canvas\");\n            this._workingContext = this._workingCanvas.getContext(\"2d\");\n        };\n        Engine.prototype.resetTextureCache = function () {\n            for (var index = 0; index < this._maxTextureChannels; index++) {\n                this._activeTexturesCache[index] = null;\n            }\n        };\n        Engine.prototype.getGlInfo = function () {\n            return {\n                vendor: this._glVendor,\n                renderer: this._glRenderer,\n                version: this._glVersion\n            };\n        };\n        Engine.prototype.getAspectRatio = function (camera, useScreen) {\n            if (useScreen === void 0) { useScreen = false; }\n            var viewport = camera.viewport;\n            return (this.getRenderWidth(useScreen) * viewport.width) / (this.getRenderHeight(useScreen) * viewport.height);\n        };\n        Engine.prototype.getRenderWidth = function (useScreen) {\n            if (useScreen === void 0) { useScreen = false; }\n            if (!useScreen && this._currentRenderTarget) {\n                return this._currentRenderTarget._width;\n            }\n            return this._renderingCanvas.width;\n        };\n        Engine.prototype.getRenderHeight = function (useScreen) {\n            if (useScreen === void 0) { useScreen = false; }\n            if (!useScreen && this._currentRenderTarget) {\n                return this._currentRenderTarget._height;\n            }\n            return this._renderingCanvas.height;\n        };\n        Engine.prototype.getRenderingCanvas = function () {\n            return this._renderingCanvas;\n        };\n        Engine.prototype.getRenderingCanvasClientRect = function () {\n            return this._renderingCanvas.getBoundingClientRect();\n        };\n        Engine.prototype.setHardwareScalingLevel = function (level) {\n            this._hardwareScalingLevel = level;\n            this.resize();\n        };\n        Engine.prototype.getHardwareScalingLevel = function () {\n            return this._hardwareScalingLevel;\n        };\n        Engine.prototype.getLoadedTexturesCache = function () {\n            return this._loadedTexturesCache;\n        };\n        Engine.prototype.getCaps = function () {\n            return this._caps;\n        };\n        Object.defineProperty(Engine.prototype, \"drawCalls\", {\n            get: function () {\n                return this._drawCalls.current;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"drawCallsPerfCounter\", {\n            get: function () {\n                return this._drawCalls;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Engine.prototype.getDepthFunction = function () {\n            return this._depthCullingState.depthFunc;\n        };\n        Engine.prototype.setDepthFunction = function (depthFunc) {\n            this._depthCullingState.depthFunc = depthFunc;\n        };\n        Engine.prototype.setDepthFunctionToGreater = function () {\n            this._depthCullingState.depthFunc = this._gl.GREATER;\n        };\n        Engine.prototype.setDepthFunctionToGreaterOrEqual = function () {\n            this._depthCullingState.depthFunc = this._gl.GEQUAL;\n        };\n        Engine.prototype.setDepthFunctionToLess = function () {\n            this._depthCullingState.depthFunc = this._gl.LESS;\n        };\n        Engine.prototype.setDepthFunctionToLessOrEqual = function () {\n            this._depthCullingState.depthFunc = this._gl.LEQUAL;\n        };\n        Engine.prototype.getStencilBuffer = function () {\n            return this._stencilState.stencilTest;\n        };\n        Engine.prototype.setStencilBuffer = function (enable) {\n            this._stencilState.stencilTest = enable;\n        };\n        Engine.prototype.getStencilMask = function () {\n            return this._stencilState.stencilMask;\n        };\n        Engine.prototype.setStencilMask = function (mask) {\n            this._stencilState.stencilMask = mask;\n        };\n        Engine.prototype.getStencilFunction = function () {\n            return this._stencilState.stencilFunc;\n        };\n        Engine.prototype.getStencilFunctionReference = function () {\n            return this._stencilState.stencilFuncRef;\n        };\n        Engine.prototype.getStencilFunctionMask = function () {\n            return this._stencilState.stencilFuncMask;\n        };\n        Engine.prototype.setStencilFunction = function (stencilFunc) {\n            this._stencilState.stencilFunc = stencilFunc;\n        };\n        Engine.prototype.setStencilFunctionReference = function (reference) {\n            this._stencilState.stencilFuncRef = reference;\n        };\n        Engine.prototype.setStencilFunctionMask = function (mask) {\n            this._stencilState.stencilFuncMask = mask;\n        };\n        Engine.prototype.getStencilOperationFail = function () {\n            return this._stencilState.stencilOpStencilFail;\n        };\n        Engine.prototype.getStencilOperationDepthFail = function () {\n            return this._stencilState.stencilOpDepthFail;\n        };\n        Engine.prototype.getStencilOperationPass = function () {\n            return this._stencilState.stencilOpStencilDepthPass;\n        };\n        Engine.prototype.setStencilOperationFail = function (operation) {\n            this._stencilState.stencilOpStencilFail = operation;\n        };\n        Engine.prototype.setStencilOperationDepthFail = function (operation) {\n            this._stencilState.stencilOpDepthFail = operation;\n        };\n        Engine.prototype.setStencilOperationPass = function (operation) {\n            this._stencilState.stencilOpStencilDepthPass = operation;\n        };\n        Engine.prototype.setDitheringState = function (value) {\n            if (value) {\n                this._gl.enable(this._gl.DITHER);\n            }\n            else {\n                this._gl.disable(this._gl.DITHER);\n            }\n        };\n        /**\n         * stop executing a render loop function and remove it from the execution array\n         * @param {Function} [renderFunction] the function to be removed. If not provided all functions will be removed.\n         */\n        Engine.prototype.stopRenderLoop = function (renderFunction) {\n            if (!renderFunction) {\n                this._activeRenderLoops = [];\n                return;\n            }\n            var index = this._activeRenderLoops.indexOf(renderFunction);\n            if (index >= 0) {\n                this._activeRenderLoops.splice(index, 1);\n            }\n        };\n        Engine.prototype._renderLoop = function () {\n            var shouldRender = true;\n            if (!this.renderEvenInBackground && this._windowIsBackground) {\n                shouldRender = false;\n            }\n            if (shouldRender) {\n                // Start new frame\n                this.beginFrame();\n                for (var index = 0; index < this._activeRenderLoops.length; index++) {\n                    var renderFunction = this._activeRenderLoops[index];\n                    renderFunction();\n                }\n                // Present\n                this.endFrame();\n            }\n            if (this._activeRenderLoops.length > 0) {\n                // Register new frame\n                BABYLON.Tools.QueueNewFrame(this._bindedRenderFunction, this._vrDisplayEnabled);\n            }\n            else {\n                this._renderingQueueLaunched = false;\n            }\n        };\n        /**\n         * Register and execute a render loop. The engine can have more than one render function.\n         * @param {Function} renderFunction - the function to continuously execute starting the next render loop.\n         * @example\n         * engine.runRenderLoop(function () {\n         *      scene.render()\n         * })\n         */\n        Engine.prototype.runRenderLoop = function (renderFunction) {\n            if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {\n                return;\n            }\n            this._activeRenderLoops.push(renderFunction);\n            if (!this._renderingQueueLaunched) {\n                this._renderingQueueLaunched = true;\n                this._bindedRenderFunction = this._renderLoop.bind(this);\n                BABYLON.Tools.QueueNewFrame(this._bindedRenderFunction);\n            }\n        };\n        /**\n         * Toggle full screen mode.\n         * @param {boolean} requestPointerLock - should a pointer lock be requested from the user\n         * @param {any} options - an options object to be sent to the requestFullscreen function\n         */\n        Engine.prototype.switchFullscreen = function (requestPointerLock) {\n            if (this.isFullscreen) {\n                BABYLON.Tools.ExitFullscreen();\n            }\n            else {\n                this._pointerLockRequested = requestPointerLock;\n                BABYLON.Tools.RequestFullscreen(this._renderingCanvas);\n            }\n        };\n        Engine.prototype.clear = function (color, backBuffer, depth, stencil) {\n            if (stencil === void 0) { stencil = false; }\n            this.applyStates();\n            var mode = 0;\n            if (backBuffer && color) {\n                this._gl.clearColor(color.r, color.g, color.b, color.a !== undefined ? color.a : 1.0);\n                mode |= this._gl.COLOR_BUFFER_BIT;\n            }\n            if (depth) {\n                this._gl.clearDepth(1.0);\n                mode |= this._gl.DEPTH_BUFFER_BIT;\n            }\n            if (stencil) {\n                this._gl.clearStencil(0);\n                mode |= this._gl.STENCIL_BUFFER_BIT;\n            }\n            this._gl.clear(mode);\n        };\n        Engine.prototype.scissorClear = function (x, y, width, height, clearColor) {\n            var gl = this._gl;\n            // Save state\n            var curScissor = gl.getParameter(gl.SCISSOR_TEST);\n            var curScissorBox = gl.getParameter(gl.SCISSOR_BOX);\n            // Change state\n            gl.enable(gl.SCISSOR_TEST);\n            gl.scissor(x, y, width, height);\n            // Clear\n            this.clear(clearColor, true, true, true);\n            // Restore state\n            gl.scissor(curScissorBox[0], curScissorBox[1], curScissorBox[2], curScissorBox[3]);\n            if (curScissor === true) {\n                gl.enable(gl.SCISSOR_TEST);\n            }\n            else {\n                gl.disable(gl.SCISSOR_TEST);\n            }\n        };\n        /**\n         * Set the WebGL's viewport\n         * @param {BABYLON.Viewport} viewport - the viewport element to be used.\n         * @param {number} [requiredWidth] - the width required for rendering. If not provided the rendering canvas' width is used.\n         * @param {number} [requiredHeight] - the height required for rendering. If not provided the rendering canvas' height is used.\n         */\n        Engine.prototype.setViewport = function (viewport, requiredWidth, requiredHeight) {\n            var width = requiredWidth || (navigator.isCocoonJS ? window.innerWidth : this.getRenderWidth());\n            var height = requiredHeight || (navigator.isCocoonJS ? window.innerHeight : this.getRenderHeight());\n            var x = viewport.x || 0;\n            var y = viewport.y || 0;\n            this._cachedViewport = viewport;\n            this._gl.viewport(x * width, y * height, width * viewport.width, height * viewport.height);\n        };\n        /**\n         * Directly set the WebGL Viewport\n         * The x, y, width & height are directly passed to the WebGL call\n         * @return the current viewport Object (if any) that is being replaced by this call. You can restore this viewport later on to go back to the original state.\n         */\n        Engine.prototype.setDirectViewport = function (x, y, width, height) {\n            var currentViewport = this._cachedViewport;\n            this._cachedViewport = null;\n            this._gl.viewport(x, y, width, height);\n            return currentViewport;\n        };\n        Engine.prototype.beginFrame = function () {\n            this._measureFps();\n        };\n        Engine.prototype.endFrame = function () {\n            //force a flush in case we are using a bad OS.\n            if (this._badOS) {\n                this.flushFramebuffer();\n            }\n            //submit frame to the vr device, if enabled\n            if (this._vrDisplayEnabled && this._vrDisplayEnabled.isPresenting) {\n                this._vrDisplayEnabled.submitFrame();\n            }\n        };\n        /**\n         * resize the view according to the canvas' size.\n         * @example\n         *   window.addEventListener(\"resize\", function () {\n         *      engine.resize();\n         *   });\n         */\n        Engine.prototype.resize = function () {\n            // We're not resizing the size of the canvas while in VR mode & presenting\n            if (!(this._vrDisplayEnabled && this._vrDisplayEnabled.isPresenting)) {\n                var width = navigator.isCocoonJS ? window.innerWidth : this._renderingCanvas.clientWidth;\n                var height = navigator.isCocoonJS ? window.innerHeight : this._renderingCanvas.clientHeight;\n                this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel);\n            }\n        };\n        /**\n         * force a specific size of the canvas\n         * @param {number} width - the new canvas' width\n         * @param {number} height - the new canvas' height\n         */\n        Engine.prototype.setSize = function (width, height) {\n            if (this._renderingCanvas.width === width && this._renderingCanvas.height === height) {\n                return;\n            }\n            this._renderingCanvas.width = width;\n            this._renderingCanvas.height = height;\n            for (var index = 0; index < this.scenes.length; index++) {\n                var scene = this.scenes[index];\n                for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {\n                    var cam = scene.cameras[camIndex];\n                    cam._currentRenderId = 0;\n                }\n            }\n            if (this.onResizeObservable.hasObservers) {\n                this.onResizeObservable.notifyObservers(this);\n            }\n        };\n        //WebVR functions\n        Engine.prototype.isVRDevicePresent = function (callback) {\n            this.getVRDevice(null, function (device) {\n                callback(device !== null);\n            });\n        };\n        Engine.prototype.getVRDevice = function (name, callback) {\n            if (!this.vrDisplaysPromise) {\n                callback(null);\n                return;\n            }\n            this.vrDisplaysPromise.then(function (devices) {\n                if (devices.length > 0) {\n                    if (name) {\n                        var found = devices.some(function (device) {\n                            if (device.displayName === name) {\n                                callback(device);\n                                return true;\n                            }\n                            else {\n                                return false;\n                            }\n                        });\n                        if (!found) {\n                            BABYLON.Tools.Warn(\"Display \" + name + \" was not found. Using \" + devices[0].displayName);\n                            callback(devices[0]);\n                        }\n                    }\n                    else {\n                        //choose the first one\n                        callback(devices[0]);\n                    }\n                }\n                else {\n                    BABYLON.Tools.Error(\"No WebVR devices found!\");\n                    callback(null);\n                }\n            });\n        };\n        Engine.prototype.initWebVR = function () {\n            if (!this.vrDisplaysPromise) {\n                this._getVRDisplays();\n            }\n        };\n        Engine.prototype.enableVR = function (vrDevice) {\n            this._vrDisplayEnabled = vrDevice;\n            this._vrDisplayEnabled.requestPresent([{ source: this.getRenderingCanvas() }]).then(this._onVRFullScreenTriggered);\n        };\n        Engine.prototype.disableVR = function () {\n            if (this._vrDisplayEnabled) {\n                this._vrDisplayEnabled.exitPresent().then(this._onVRFullScreenTriggered);\n            }\n        };\n        Engine.prototype._getVRDisplays = function () {\n            var _this = this;\n            var getWebVRDevices = function (devices) {\n                var size = devices.length;\n                var i = 0;\n                _this._vrDisplays = devices.filter(function (device) {\n                    return devices[i] instanceof VRDisplay;\n                });\n                return _this._vrDisplays;\n            };\n            //using a key due to typescript\n            if (navigator.getVRDisplays) {\n                this.vrDisplaysPromise = navigator.getVRDisplays().then(getWebVRDevices);\n            }\n        };\n        Engine.prototype.bindFramebuffer = function (texture, faceIndex, requiredWidth, requiredHeight) {\n            if (this._currentRenderTarget) {\n                this.unBindFramebuffer(this._currentRenderTarget);\n            }\n            this._currentRenderTarget = texture;\n            this.bindUnboundFramebuffer(texture._MSAAFramebuffer ? texture._MSAAFramebuffer : texture._framebuffer);\n            var gl = this._gl;\n            if (texture.isCube) {\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture, 0);\n            }\n            gl.viewport(0, 0, requiredWidth || texture._width, requiredHeight || texture._height);\n            this.wipeCaches();\n        };\n        Engine.prototype.bindUnboundFramebuffer = function (framebuffer) {\n            if (this._currentFramebuffer !== framebuffer) {\n                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);\n                this._currentFramebuffer = framebuffer;\n            }\n        };\n        Engine.prototype.unBindFramebuffer = function (texture, disableGenerateMipMaps, onBeforeUnbind) {\n            if (disableGenerateMipMaps === void 0) { disableGenerateMipMaps = false; }\n            this._currentRenderTarget = null;\n            // If MSAA, we need to bitblt back to main texture\n            var gl = this._gl;\n            if (texture._MSAAFramebuffer) {\n                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, texture._MSAAFramebuffer);\n                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, texture._framebuffer);\n                gl.blitFramebuffer(0, 0, texture._width, texture._height, 0, 0, texture._width, texture._height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n            }\n            if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n                this._bindTextureDirectly(gl.TEXTURE_2D, texture);\n                gl.generateMipmap(gl.TEXTURE_2D);\n                this._bindTextureDirectly(gl.TEXTURE_2D, null);\n            }\n            if (onBeforeUnbind) {\n                if (texture._MSAAFramebuffer) {\n                    // Bind the correct framebuffer\n                    this.bindUnboundFramebuffer(texture._framebuffer);\n                }\n                onBeforeUnbind();\n            }\n            this.bindUnboundFramebuffer(null);\n        };\n        Engine.prototype.generateMipMapsForCubemap = function (texture) {\n            if (texture.generateMipMaps) {\n                var gl = this._gl;\n                this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n                this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n            }\n        };\n        Engine.prototype.flushFramebuffer = function () {\n            this._gl.flush();\n        };\n        Engine.prototype.restoreDefaultFramebuffer = function () {\n            if (this._currentRenderTarget) {\n                this.unBindFramebuffer(this._currentRenderTarget);\n            }\n            else {\n                this.bindUnboundFramebuffer(null);\n            }\n            if (this._cachedViewport) {\n                this.setViewport(this._cachedViewport);\n            }\n            this.wipeCaches();\n        };\n        // UBOs\n        Engine.prototype.createUniformBuffer = function (elements) {\n            var ubo = this._gl.createBuffer();\n            this.bindUniformBuffer(ubo);\n            if (elements instanceof Float32Array) {\n                this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);\n            }\n            else {\n                this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);\n            }\n            this.bindUniformBuffer(null);\n            ubo.references = 1;\n            return ubo;\n        };\n        Engine.prototype.createDynamicUniformBuffer = function (elements) {\n            var ubo = this._gl.createBuffer();\n            this.bindUniformBuffer(ubo);\n            if (elements instanceof Float32Array) {\n                this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);\n            }\n            else {\n                this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);\n            }\n            this.bindUniformBuffer(null);\n            ubo.references = 1;\n            return ubo;\n        };\n        Engine.prototype.updateUniformBuffer = function (uniformBuffer, elements, offset, count) {\n            this.bindUniformBuffer(uniformBuffer);\n            if (offset === undefined) {\n                offset = 0;\n            }\n            if (count === undefined) {\n                if (elements instanceof Float32Array) {\n                    this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);\n                }\n                else {\n                    this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));\n                }\n            }\n            else {\n                if (elements instanceof Float32Array) {\n                    this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));\n                }\n                else {\n                    this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));\n                }\n            }\n            this.bindUniformBuffer(null);\n        };\n        // VBOs\n        Engine.prototype._resetVertexBufferBinding = function () {\n            this.bindArrayBuffer(null);\n            this._cachedVertexBuffers = null;\n        };\n        Engine.prototype.createVertexBuffer = function (vertices) {\n            var vbo = this._gl.createBuffer();\n            this.bindArrayBuffer(vbo);\n            if (vertices instanceof Float32Array) {\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, vertices, this._gl.STATIC_DRAW);\n            }\n            else {\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);\n            }\n            this._resetVertexBufferBinding();\n            vbo.references = 1;\n            return vbo;\n        };\n        Engine.prototype.createDynamicVertexBuffer = function (vertices) {\n            var vbo = this._gl.createBuffer();\n            this.bindArrayBuffer(vbo);\n            if (vertices instanceof Float32Array) {\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, vertices, this._gl.DYNAMIC_DRAW);\n            }\n            else {\n                this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.DYNAMIC_DRAW);\n            }\n            this._resetVertexBufferBinding();\n            vbo.references = 1;\n            return vbo;\n        };\n        Engine.prototype.updateDynamicVertexBuffer = function (vertexBuffer, vertices, offset, count) {\n            this.bindArrayBuffer(vertexBuffer);\n            if (offset === undefined) {\n                offset = 0;\n            }\n            if (count === undefined) {\n                if (vertices instanceof Float32Array) {\n                    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, offset, vertices);\n                }\n                else {\n                    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, offset, new Float32Array(vertices));\n                }\n            }\n            else {\n                if (vertices instanceof Float32Array) {\n                    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, vertices.subarray(offset, offset + count));\n                }\n                else {\n                    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(vertices).subarray(offset, offset + count));\n                }\n            }\n            this._resetVertexBufferBinding();\n        };\n        Engine.prototype._resetIndexBufferBinding = function () {\n            this.bindIndexBuffer(null);\n            this._cachedIndexBuffer = null;\n        };\n        Engine.prototype.createIndexBuffer = function (indices) {\n            var vbo = this._gl.createBuffer();\n            this.bindIndexBuffer(vbo);\n            // Check for 32 bits indices\n            var arrayBuffer;\n            var need32Bits = false;\n            if (indices instanceof Uint16Array) {\n                arrayBuffer = indices;\n            }\n            else {\n                //check 32 bit support\n                if (this._caps.uintIndices) {\n                    if (indices instanceof Uint32Array) {\n                        arrayBuffer = indices;\n                        need32Bits = true;\n                    }\n                    else {\n                        //number[] or Int32Array, check if 32 bit is necessary\n                        for (var index = 0; index < indices.length; index++) {\n                            if (indices[index] > 65535) {\n                                need32Bits = true;\n                                break;\n                            }\n                        }\n                        arrayBuffer = need32Bits ? new Uint32Array(indices) : new Uint16Array(indices);\n                    }\n                }\n                else {\n                    //no 32 bit support, force conversion to 16 bit (values greater 16 bit are lost)\n                    arrayBuffer = new Uint16Array(indices);\n                }\n            }\n            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, arrayBuffer, this._gl.STATIC_DRAW);\n            this._resetIndexBufferBinding();\n            vbo.references = 1;\n            vbo.is32Bits = need32Bits;\n            return vbo;\n        };\n        Engine.prototype.bindArrayBuffer = function (buffer) {\n            if (!this._vaoRecordInProgress) {\n                this._unBindVertexArrayObject();\n            }\n            this.bindBuffer(buffer, this._gl.ARRAY_BUFFER);\n        };\n        Engine.prototype.bindUniformBuffer = function (buffer) {\n            this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer);\n        };\n        Engine.prototype.bindUniformBufferBase = function (buffer, location) {\n            this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location, buffer);\n        };\n        Engine.prototype.bindUniformBlock = function (shaderProgram, blockName, index) {\n            var uniformLocation = this._gl.getUniformBlockIndex(shaderProgram, blockName);\n            this._gl.uniformBlockBinding(shaderProgram, uniformLocation, index);\n        };\n        ;\n        Engine.prototype.bindIndexBuffer = function (buffer) {\n            if (!this._vaoRecordInProgress) {\n                this._unBindVertexArrayObject();\n            }\n            this.bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);\n        };\n        Engine.prototype.bindBuffer = function (buffer, target) {\n            if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {\n                this._gl.bindBuffer(target, buffer);\n                this._currentBoundBuffer[target] = buffer;\n            }\n        };\n        Engine.prototype.updateArrayBuffer = function (data) {\n            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\n        };\n        Engine.prototype.vertexAttribPointer = function (buffer, indx, size, type, normalized, stride, offset) {\n            var pointer = this._currentBufferPointers[indx];\n            var changed = false;\n            if (!pointer) {\n                changed = true;\n                this._currentBufferPointers[indx] = { indx: indx, size: size, type: type, normalized: normalized, stride: stride, offset: offset, buffer: buffer };\n            }\n            else {\n                if (pointer.buffer !== buffer) {\n                    pointer.buffer = buffer;\n                    changed = true;\n                }\n                if (pointer.size !== size) {\n                    pointer.size = size;\n                    changed = true;\n                }\n                if (pointer.type !== type) {\n                    pointer.type = type;\n                    changed = true;\n                }\n                if (pointer.normalized !== normalized) {\n                    pointer.normalized = normalized;\n                    changed = true;\n                }\n                if (pointer.stride !== stride) {\n                    pointer.stride = stride;\n                    changed = true;\n                }\n                if (pointer.offset !== offset) {\n                    pointer.offset = offset;\n                    changed = true;\n                }\n            }\n            if (changed || this._vaoRecordInProgress) {\n                this.bindArrayBuffer(buffer);\n                this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);\n            }\n        };\n        Engine.prototype._bindIndexBufferWithCache = function (indexBuffer) {\n            if (indexBuffer == null) {\n                return;\n            }\n            if (this._cachedIndexBuffer !== indexBuffer) {\n                this._cachedIndexBuffer = indexBuffer;\n                this.bindIndexBuffer(indexBuffer);\n                this._uintIndicesCurrentlySet = indexBuffer.is32Bits;\n            }\n        };\n        Engine.prototype._bindVertexBuffersAttributes = function (vertexBuffers, effect) {\n            var attributes = effect.getAttributesNames();\n            if (!this._vaoRecordInProgress) {\n                this._unBindVertexArrayObject();\n            }\n            this.unbindAllAttributes();\n            for (var index = 0; index < attributes.length; index++) {\n                var order = effect.getAttributeLocation(index);\n                if (order >= 0) {\n                    var vertexBuffer = vertexBuffers[attributes[index]];\n                    if (!vertexBuffer) {\n                        continue;\n                    }\n                    this._gl.enableVertexAttribArray(order);\n                    if (!this._vaoRecordInProgress) {\n                        this._vertexAttribArraysEnabled[order] = true;\n                    }\n                    var buffer = vertexBuffer.getBuffer();\n                    this.vertexAttribPointer(buffer, order, vertexBuffer.getSize(), this._gl.FLOAT, false, vertexBuffer.getStrideSize() * 4, vertexBuffer.getOffset() * 4);\n                    if (vertexBuffer.getIsInstanced()) {\n                        this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());\n                        if (!this._vaoRecordInProgress) {\n                            this._currentInstanceLocations.push(order);\n                            this._currentInstanceBuffers.push(buffer);\n                        }\n                    }\n                }\n            }\n        };\n        Engine.prototype.recordVertexArrayObject = function (vertexBuffers, indexBuffer, effect) {\n            var vao = this._gl.createVertexArray();\n            this._vaoRecordInProgress = true;\n            this._gl.bindVertexArray(vao);\n            this._mustWipeVertexAttributes = true;\n            this._bindVertexBuffersAttributes(vertexBuffers, effect);\n            this.bindIndexBuffer(indexBuffer);\n            this._vaoRecordInProgress = false;\n            this._gl.bindVertexArray(null);\n            return vao;\n        };\n        Engine.prototype.bindVertexArrayObject = function (vertexArrayObject, indexBuffer) {\n            if (this._cachedVertexArrayObject !== vertexArrayObject) {\n                this._cachedVertexArrayObject = vertexArrayObject;\n                this._gl.bindVertexArray(vertexArrayObject);\n                this._cachedVertexBuffers = null;\n                this._cachedIndexBuffer = null;\n                this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;\n                this._mustWipeVertexAttributes = true;\n            }\n        };\n        Engine.prototype.bindBuffersDirectly = function (vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {\n            if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {\n                this._cachedVertexBuffers = vertexBuffer;\n                this._cachedEffectForVertexBuffers = effect;\n                var attributesCount = effect.getAttributesCount();\n                this._unBindVertexArrayObject();\n                this.unbindAllAttributes();\n                var offset = 0;\n                for (var index = 0; index < attributesCount; index++) {\n                    if (index < vertexDeclaration.length) {\n                        var order = effect.getAttributeLocation(index);\n                        if (order >= 0) {\n                            this._gl.enableVertexAttribArray(order);\n                            this._vertexAttribArraysEnabled[order] = true;\n                            this.vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);\n                        }\n                        offset += vertexDeclaration[index] * 4;\n                    }\n                }\n            }\n            this._bindIndexBufferWithCache(indexBuffer);\n        };\n        Engine.prototype._unBindVertexArrayObject = function () {\n            if (!this._cachedVertexArrayObject) {\n                return;\n            }\n            this._cachedVertexArrayObject = null;\n            this._gl.bindVertexArray(null);\n        };\n        Engine.prototype.bindBuffers = function (vertexBuffers, indexBuffer, effect) {\n            if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {\n                this._cachedVertexBuffers = vertexBuffers;\n                this._cachedEffectForVertexBuffers = effect;\n                this._bindVertexBuffersAttributes(vertexBuffers, effect);\n            }\n            this._bindIndexBufferWithCache(indexBuffer);\n        };\n        Engine.prototype.unbindInstanceAttributes = function () {\n            var boundBuffer;\n            for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {\n                var instancesBuffer = this._currentInstanceBuffers[i];\n                if (boundBuffer != instancesBuffer && instancesBuffer.references) {\n                    boundBuffer = instancesBuffer;\n                    this.bindArrayBuffer(instancesBuffer);\n                }\n                var offsetLocation = this._currentInstanceLocations[i];\n                this._gl.vertexAttribDivisor(offsetLocation, 0);\n            }\n            this._currentInstanceBuffers.length = 0;\n            this._currentInstanceLocations.length = 0;\n        };\n        Engine.prototype.releaseVertexArrayObject = function (vao) {\n            this._gl.deleteVertexArray(vao);\n        };\n        Engine.prototype._releaseBuffer = function (buffer) {\n            buffer.references--;\n            if (buffer.references === 0) {\n                this._gl.deleteBuffer(buffer);\n                return true;\n            }\n            return false;\n        };\n        Engine.prototype.createInstancesBuffer = function (capacity) {\n            var buffer = this._gl.createBuffer();\n            buffer.capacity = capacity;\n            this.bindArrayBuffer(buffer);\n            this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);\n            return buffer;\n        };\n        Engine.prototype.deleteInstancesBuffer = function (buffer) {\n            this._gl.deleteBuffer(buffer);\n        };\n        Engine.prototype.updateAndBindInstancesBuffer = function (instancesBuffer, data, offsetLocations) {\n            this.bindArrayBuffer(instancesBuffer);\n            if (data) {\n                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);\n            }\n            if (offsetLocations[0].index !== undefined) {\n                var stride = 0;\n                for (var i = 0; i < offsetLocations.length; i++) {\n                    var ai = offsetLocations[i];\n                    stride += ai.attributeSize * 4;\n                }\n                for (var i = 0; i < offsetLocations.length; i++) {\n                    var ai = offsetLocations[i];\n                    if (!this._vertexAttribArraysEnabled[ai.index]) {\n                        this._gl.enableVertexAttribArray(ai.index);\n                        this._vertexAttribArraysEnabled[ai.index] = true;\n                    }\n                    this.vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attribyteType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);\n                    this._gl.vertexAttribDivisor(ai.index, 1);\n                    this._currentInstanceLocations.push(ai.index);\n                    this._currentInstanceBuffers.push(instancesBuffer);\n                }\n            }\n            else {\n                for (var index = 0; index < 4; index++) {\n                    var offsetLocation = offsetLocations[index];\n                    if (!this._vertexAttribArraysEnabled[offsetLocation]) {\n                        this._gl.enableVertexAttribArray(offsetLocation);\n                        this._vertexAttribArraysEnabled[offsetLocation] = true;\n                    }\n                    this.vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);\n                    this._gl.vertexAttribDivisor(offsetLocation, 1);\n                    this._currentInstanceLocations.push(offsetLocation);\n                    this._currentInstanceBuffers.push(instancesBuffer);\n                }\n            }\n        };\n        Engine.prototype.applyStates = function () {\n            this._depthCullingState.apply(this._gl);\n            this._stencilState.apply(this._gl);\n            this._alphaState.apply(this._gl);\n        };\n        Engine.prototype.draw = function (useTriangles, indexStart, indexCount, instancesCount) {\n            // Apply states\n            this.applyStates();\n            this._drawCalls.addCount(1, false);\n            // Render\n            var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;\n            var mult = this._uintIndicesCurrentlySet ? 4 : 2;\n            if (instancesCount) {\n                this._gl.drawElementsInstanced(useTriangles ? this._gl.TRIANGLES : this._gl.LINES, indexCount, indexFormat, indexStart * mult, instancesCount);\n                return;\n            }\n            this._gl.drawElements(useTriangles ? this._gl.TRIANGLES : this._gl.LINES, indexCount, indexFormat, indexStart * mult);\n        };\n        Engine.prototype.drawPointClouds = function (verticesStart, verticesCount, instancesCount) {\n            // Apply states\n            this.applyStates();\n            this._drawCalls.addCount(1, false);\n            if (instancesCount) {\n                this._gl.drawArraysInstanced(this._gl.POINTS, verticesStart, verticesCount, instancesCount);\n                return;\n            }\n            this._gl.drawArrays(this._gl.POINTS, verticesStart, verticesCount);\n        };\n        Engine.prototype.drawUnIndexed = function (useTriangles, verticesStart, verticesCount, instancesCount) {\n            // Apply states\n            this.applyStates();\n            this._drawCalls.addCount(1, false);\n            if (instancesCount) {\n                this._gl.drawArraysInstanced(useTriangles ? this._gl.TRIANGLES : this._gl.LINES, verticesStart, verticesCount, instancesCount);\n                return;\n            }\n            this._gl.drawArrays(useTriangles ? this._gl.TRIANGLES : this._gl.LINES, verticesStart, verticesCount);\n        };\n        // Shaders\n        Engine.prototype._releaseEffect = function (effect) {\n            if (this._compiledEffects[effect._key]) {\n                delete this._compiledEffects[effect._key];\n                if (effect.getProgram()) {\n                    this._gl.deleteProgram(effect.getProgram());\n                }\n            }\n        };\n        Engine.prototype.createEffect = function (baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters) {\n            var vertex = baseName.vertexElement || baseName.vertex || baseName;\n            var fragment = baseName.fragmentElement || baseName.fragment || baseName;\n            var name = vertex + \"+\" + fragment + \"@\" + (defines ? defines : attributesNamesOrOptions.defines);\n            if (this._compiledEffects[name]) {\n                var compiledEffect = this._compiledEffects[name];\n                if (onCompiled && compiledEffect.isReady()) {\n                    onCompiled(compiledEffect);\n                }\n                return compiledEffect;\n            }\n            var effect = new BABYLON.Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters);\n            effect._key = name;\n            this._compiledEffects[name] = effect;\n            return effect;\n        };\n        Engine.prototype.createEffectForParticles = function (fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError) {\n            if (uniformsNames === void 0) { uniformsNames = []; }\n            if (samplers === void 0) { samplers = []; }\n            if (defines === void 0) { defines = \"\"; }\n            return this.createEffect({\n                vertex: \"particles\",\n                fragmentElement: fragmentName\n            }, [\"position\", \"color\", \"options\"], [\"view\", \"projection\"].concat(uniformsNames), [\"diffuseSampler\"].concat(samplers), defines, fallbacks, onCompiled, onError);\n        };\n        Engine.prototype.createShaderProgram = function (vertexCode, fragmentCode, defines, context) {\n            context = context || this._gl;\n            var shaderVersion = (this._webGLVersion > 1) ? \"#version 300 es\\n\" : \"\";\n            var vertexShader = compileShader(context, vertexCode, \"vertex\", defines, shaderVersion);\n            var fragmentShader = compileShader(context, fragmentCode, \"fragment\", defines, shaderVersion);\n            var shaderProgram = context.createProgram();\n            context.attachShader(shaderProgram, vertexShader);\n            context.attachShader(shaderProgram, fragmentShader);\n            context.linkProgram(shaderProgram);\n            var linked = context.getProgramParameter(shaderProgram, context.LINK_STATUS);\n            if (!linked) {\n                context.validateProgram(shaderProgram);\n                var error = context.getProgramInfoLog(shaderProgram);\n                if (error) {\n                    throw new Error(error);\n                }\n            }\n            context.deleteShader(vertexShader);\n            context.deleteShader(fragmentShader);\n            return shaderProgram;\n        };\n        Engine.prototype.getUniforms = function (shaderProgram, uniformsNames) {\n            var results = [];\n            for (var index = 0; index < uniformsNames.length; index++) {\n                results.push(this._gl.getUniformLocation(shaderProgram, uniformsNames[index]));\n            }\n            return results;\n        };\n        Engine.prototype.getAttributes = function (shaderProgram, attributesNames) {\n            var results = [];\n            for (var index = 0; index < attributesNames.length; index++) {\n                try {\n                    results.push(this._gl.getAttribLocation(shaderProgram, attributesNames[index]));\n                }\n                catch (e) {\n                    results.push(-1);\n                }\n            }\n            return results;\n        };\n        Engine.prototype.enableEffect = function (effect) {\n            // Use program\n            this.setProgram(effect.getProgram());\n            this._currentEffect = effect;\n            if (effect.onBind) {\n                effect.onBind(effect);\n            }\n            effect.onBindObservable.notifyObservers(effect);\n        };\n        Engine.prototype.setIntArray = function (uniform, array) {\n            if (!uniform)\n                return;\n            this._gl.uniform1iv(uniform, array);\n        };\n        Engine.prototype.setIntArray2 = function (uniform, array) {\n            if (!uniform || array.length % 2 !== 0)\n                return;\n            this._gl.uniform2iv(uniform, array);\n        };\n        Engine.prototype.setIntArray3 = function (uniform, array) {\n            if (!uniform || array.length % 3 !== 0)\n                return;\n            this._gl.uniform3iv(uniform, array);\n        };\n        Engine.prototype.setIntArray4 = function (uniform, array) {\n            if (!uniform || array.length % 4 !== 0)\n                return;\n            this._gl.uniform4iv(uniform, array);\n        };\n        Engine.prototype.setFloatArray = function (uniform, array) {\n            if (!uniform)\n                return;\n            this._gl.uniform1fv(uniform, array);\n        };\n        Engine.prototype.setFloatArray2 = function (uniform, array) {\n            if (!uniform || array.length % 2 !== 0)\n                return;\n            this._gl.uniform2fv(uniform, array);\n        };\n        Engine.prototype.setFloatArray3 = function (uniform, array) {\n            if (!uniform || array.length % 3 !== 0)\n                return;\n            this._gl.uniform3fv(uniform, array);\n        };\n        Engine.prototype.setFloatArray4 = function (uniform, array) {\n            if (!uniform || array.length % 4 !== 0)\n                return;\n            this._gl.uniform4fv(uniform, array);\n        };\n        Engine.prototype.setArray = function (uniform, array) {\n            if (!uniform)\n                return;\n            this._gl.uniform1fv(uniform, array);\n        };\n        Engine.prototype.setArray2 = function (uniform, array) {\n            if (!uniform || array.length % 2 !== 0)\n                return;\n            this._gl.uniform2fv(uniform, array);\n        };\n        Engine.prototype.setArray3 = function (uniform, array) {\n            if (!uniform || array.length % 3 !== 0)\n                return;\n            this._gl.uniform3fv(uniform, array);\n        };\n        Engine.prototype.setArray4 = function (uniform, array) {\n            if (!uniform || array.length % 4 !== 0)\n                return;\n            this._gl.uniform4fv(uniform, array);\n        };\n        Engine.prototype.setMatrices = function (uniform, matrices) {\n            if (!uniform)\n                return;\n            this._gl.uniformMatrix4fv(uniform, false, matrices);\n        };\n        Engine.prototype.setMatrix = function (uniform, matrix) {\n            if (!uniform)\n                return;\n            this._gl.uniformMatrix4fv(uniform, false, matrix.toArray());\n        };\n        Engine.prototype.setMatrix3x3 = function (uniform, matrix) {\n            if (!uniform)\n                return;\n            this._gl.uniformMatrix3fv(uniform, false, matrix);\n        };\n        Engine.prototype.setMatrix2x2 = function (uniform, matrix) {\n            if (!uniform)\n                return;\n            this._gl.uniformMatrix2fv(uniform, false, matrix);\n        };\n        Engine.prototype.setFloat = function (uniform, value) {\n            if (!uniform)\n                return;\n            this._gl.uniform1f(uniform, value);\n        };\n        Engine.prototype.setFloat2 = function (uniform, x, y) {\n            if (!uniform)\n                return;\n            this._gl.uniform2f(uniform, x, y);\n        };\n        Engine.prototype.setFloat3 = function (uniform, x, y, z) {\n            if (!uniform)\n                return;\n            this._gl.uniform3f(uniform, x, y, z);\n        };\n        Engine.prototype.setBool = function (uniform, bool) {\n            if (!uniform)\n                return;\n            this._gl.uniform1i(uniform, bool);\n        };\n        Engine.prototype.setFloat4 = function (uniform, x, y, z, w) {\n            if (!uniform)\n                return;\n            this._gl.uniform4f(uniform, x, y, z, w);\n        };\n        Engine.prototype.setColor3 = function (uniform, color3) {\n            if (!uniform)\n                return;\n            this._gl.uniform3f(uniform, color3.r, color3.g, color3.b);\n        };\n        Engine.prototype.setColor4 = function (uniform, color3, alpha) {\n            if (!uniform)\n                return;\n            this._gl.uniform4f(uniform, color3.r, color3.g, color3.b, alpha);\n        };\n        // States\n        Engine.prototype.setState = function (culling, zOffset, force, reverseSide) {\n            if (zOffset === void 0) { zOffset = 0; }\n            if (reverseSide === void 0) { reverseSide = false; }\n            // Culling        \n            var showSide = reverseSide ? this._gl.FRONT : this._gl.BACK;\n            var hideSide = reverseSide ? this._gl.BACK : this._gl.FRONT;\n            var cullFace = this.cullBackFaces ? showSide : hideSide;\n            if (this._depthCullingState.cull !== culling || force || this._depthCullingState.cullFace !== cullFace) {\n                if (culling) {\n                    this._depthCullingState.cullFace = cullFace;\n                    this._depthCullingState.cull = true;\n                }\n                else {\n                    this._depthCullingState.cull = false;\n                }\n            }\n            // Z offset\n            this.setZOffset(zOffset);\n        };\n        Engine.prototype.setZOffset = function (value) {\n            this._depthCullingState.zOffset = value;\n        };\n        Engine.prototype.getZOffset = function () {\n            return this._depthCullingState.zOffset;\n        };\n        Engine.prototype.setDepthBuffer = function (enable) {\n            this._depthCullingState.depthTest = enable;\n        };\n        Engine.prototype.getDepthWrite = function () {\n            return this._depthCullingState.depthMask;\n        };\n        Engine.prototype.setDepthWrite = function (enable) {\n            this._depthCullingState.depthMask = enable;\n        };\n        Engine.prototype.setColorWrite = function (enable) {\n            this._gl.colorMask(enable, enable, enable, enable);\n        };\n        Engine.prototype.setAlphaConstants = function (r, g, b, a) {\n            this._alphaState.setAlphaBlendConstants(r, g, b, a);\n        };\n        Engine.prototype.setAlphaMode = function (mode, noDepthWriteChange) {\n            if (noDepthWriteChange === void 0) { noDepthWriteChange = false; }\n            if (this._alphaMode === mode) {\n                return;\n            }\n            switch (mode) {\n                case Engine.ALPHA_DISABLE:\n                    this._alphaState.alphaBlend = false;\n                    break;\n                case Engine.ALPHA_PREMULTIPLIED:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_PREMULTIPLIED_PORTERDUFF:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_COMBINE:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_ONEONE:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_ADD:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_SUBTRACT:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_MULTIPLY:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_MAXIMIZED:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_INTERPOLATE:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);\n                    this._alphaState.alphaBlend = true;\n                    break;\n                case Engine.ALPHA_SCREENMODE:\n                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);\n                    this._alphaState.alphaBlend = true;\n                    break;\n            }\n            if (!noDepthWriteChange) {\n                this.setDepthWrite(mode === Engine.ALPHA_DISABLE);\n            }\n            this._alphaMode = mode;\n        };\n        Engine.prototype.getAlphaMode = function () {\n            return this._alphaMode;\n        };\n        Engine.prototype.setAlphaTesting = function (enable) {\n            this._alphaTest = enable;\n        };\n        Engine.prototype.getAlphaTesting = function () {\n            return !!this._alphaTest;\n        };\n        // Textures\n        Engine.prototype.wipeCaches = function (bruteForce) {\n            if (this.preventCacheWipeBetweenFrames) {\n                return;\n            }\n            this.resetTextureCache();\n            this._currentEffect = null;\n            // 6/8/2017: deltakosh: Should not be required anymore. \n            // This message is then mostly for the future myself which will scream out loud when seeing that actually it was required :)\n            if (bruteForce) {\n                this._stencilState.reset();\n                this._depthCullingState.reset();\n                this.setDepthFunctionToLessOrEqual();\n                this._alphaState.reset();\n            }\n            this._cachedVertexBuffers = null;\n            this._cachedIndexBuffer = null;\n            this._cachedEffectForVertexBuffers = null;\n            this._unBindVertexArrayObject();\n            this.bindIndexBuffer(null);\n            this.bindArrayBuffer(null);\n        };\n        /**\n         * Set the compressed texture format to use, based on the formats you have, and the formats\n         * supported by the hardware / browser.\n         *\n         * Khronos Texture Container (.ktx) files are used to support this.  This format has the\n         * advantage of being specifically designed for OpenGL.  Header elements directly correspond\n         * to API arguments needed to compressed textures.  This puts the burden on the container\n         * generator to house the arcane code for determining these for current & future formats.\n         *\n         * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n         * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n         *\n         * Note: The result of this call is not taken into account when a texture is base64.\n         *\n         * @param {Array<string>} formatsAvailable- The list of those format families you have created\n         * on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)\n         *\n         * Current families are astc, dxt, pvrtc, etc2, & etc1.\n         * @returns The extension selected.\n         */\n        Engine.prototype.setTextureFormatToUse = function (formatsAvailable) {\n            for (var i = 0, len1 = this.texturesSupported.length; i < len1; i++) {\n                for (var j = 0, len2 = formatsAvailable.length; j < len2; j++) {\n                    if (this._texturesSupported[i] === formatsAvailable[j].toLowerCase()) {\n                        return this._textureFormatInUse = this._texturesSupported[i];\n                    }\n                }\n            }\n            // actively set format to nothing, to allow this to be called more than once\n            // and possibly fail the 2nd time\n            return this._textureFormatInUse = null;\n        };\n        /**\n         * Usually called from BABYLON.Texture.ts.  Passed information to create a WebGLTexture.\n         * @param {string} urlArg- This contains one of the following:\n         *                         1. A conventional http URL, e.g. 'http://...' or 'file://...'\n         *                         2. A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'\n         *                         3. An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'\n         *\n         * @param {boolean} noMipmap- When true, no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file.\n         * @param {boolean} invertY- When true, image is flipped when loaded.  You probably want true. Ignored for compressed textures.  Must be flipped in the file.\n         * @param {Scene} scene- Needed for loading to the correct scene.\n         * @param {number} samplingMode- Mode with should be used sample / access the texture.  Default: TRILINEAR\n         * @param {callback} onLoad- Optional callback to be called upon successful completion.\n         * @param {callback} onError- Optional callback to be called upon failure.\n         * @param {ArrayBuffer | HTMLImageElement} buffer- A source of a file previously fetched as either an ArrayBuffer (compressed or image format) or HTMLImageElement (image format)\n         * @param {WebGLTexture} fallback- An internal argument in case the function must be called again, due to etc1 not having alpha capabilities.\n         * @param {number} format-  Internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures.\n         *\n         * @returns {WebGLTexture} for assignment back into BABYLON.Texture\n         */\n        Engine.prototype.createTexture = function (urlArg, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallBack, format) {\n            var _this = this;\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (buffer === void 0) { buffer = null; }\n            var texture = fallBack ? fallBack : this._gl.createTexture();\n            var url = String(urlArg); // assign a new string, so that the original is still available in case of fallback\n            var fromData = url.substr(0, 5) === \"data:\";\n            var isBase64 = fromData && url.indexOf(\"base64\") !== -1;\n            // establish the file extension, if possible\n            var lastDot = url.lastIndexOf('.');\n            var extension = (lastDot > 0) ? url.substring(lastDot).toLowerCase() : \"\";\n            var isDDS = this.getCaps().s3tc && (extension === \".dds\");\n            var isTGA = (extension === \".tga\");\n            // determine if a ktx file should be substituted\n            var isKTX = false;\n            if (this._textureFormatInUse && !isBase64 && !fallBack) {\n                url = url.substring(0, lastDot) + this._textureFormatInUse;\n                isKTX = true;\n            }\n            scene._addPendingData(texture);\n            texture.url = url;\n            texture.generateMipMaps = !noMipmap;\n            texture.references = 1;\n            texture.samplingMode = samplingMode;\n            texture.onLoadedCallbacks = [];\n            if (onLoad) {\n                texture.onLoadedCallbacks.push(onLoad);\n            }\n            if (!fallBack)\n                this._loadedTexturesCache.push(texture);\n            var onerror = function () {\n                scene._removePendingData(texture);\n                // fallback for when compressed file not found to try again.  For instance, etc1 does not have an alpha capable type\n                if (isKTX) {\n                    _this.createTexture(urlArg, noMipmap, invertY, scene, samplingMode, null, onError, buffer, texture);\n                }\n                else if (onError) {\n                    onError();\n                }\n            };\n            var callback;\n            // processing for non-image formats\n            if (isKTX || isTGA || isDDS) {\n                if (isKTX) {\n                    callback = function (data) {\n                        var ktx = new BABYLON.Internals.KhronosTextureContainer(data, 1);\n                        prepareWebGLTexture(texture, _this._gl, scene, ktx.pixelWidth, ktx.pixelHeight, invertY, false, true, function () {\n                            ktx.uploadLevels(_this._gl, !noMipmap);\n                        }, samplingMode);\n                    };\n                }\n                else if (isTGA) {\n                    callback = function (arrayBuffer) {\n                        var data = new Uint8Array(arrayBuffer);\n                        var header = BABYLON.Internals.TGATools.GetTGAHeader(data);\n                        prepareWebGLTexture(texture, _this._gl, scene, header.width, header.height, invertY, noMipmap, false, function () {\n                            BABYLON.Internals.TGATools.UploadContent(_this._gl, data);\n                        }, samplingMode);\n                    };\n                }\n                else if (isDDS) {\n                    callback = function (data) {\n                        var info = BABYLON.Internals.DDSTools.GetDDSInfo(data);\n                        var loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && !noMipmap && ((info.width >> (info.mipmapCount - 1)) === 1);\n                        prepareWebGLTexture(texture, _this._gl, scene, info.width, info.height, invertY, !loadMipmap, info.isFourCC, function () {\n                            BABYLON.Internals.DDSTools.UploadDDSLevels(_this, data, info, loadMipmap, 1);\n                        }, samplingMode);\n                    };\n                }\n                if (!buffer) {\n                    BABYLON.Tools.LoadFile(url, function (data) {\n                        callback(data);\n                    }, null, scene.database, true, onerror);\n                }\n                else {\n                    callback(buffer);\n                }\n                // image format processing\n            }\n            else {\n                var onload = function (img) {\n                    prepareWebGLTexture(texture, _this._gl, scene, img.width, img.height, invertY, noMipmap, false, function (potWidth, potHeight) {\n                        var isPot = (img.width === potWidth && img.height === potHeight);\n                        if (!isPot) {\n                            _this._prepareWorkingCanvas();\n                            _this._workingCanvas.width = potWidth;\n                            _this._workingCanvas.height = potHeight;\n                            if (samplingMode === BABYLON.Texture.NEAREST_SAMPLINGMODE) {\n                                _this._workingContext.imageSmoothingEnabled = false;\n                                _this._workingContext.mozImageSmoothingEnabled = false;\n                                _this._workingContext.oImageSmoothingEnabled = false;\n                                _this._workingContext.webkitImageSmoothingEnabled = false;\n                                _this._workingContext.msImageSmoothingEnabled = false;\n                            }\n                            _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);\n                            if (samplingMode === BABYLON.Texture.NEAREST_SAMPLINGMODE) {\n                                _this._workingContext.imageSmoothingEnabled = true;\n                                _this._workingContext.mozImageSmoothingEnabled = true;\n                                _this._workingContext.oImageSmoothingEnabled = true;\n                                _this._workingContext.webkitImageSmoothingEnabled = true;\n                                _this._workingContext.msImageSmoothingEnabled = true;\n                            }\n                        }\n                        var internalFormat = format ? _this._getInternalFormat(format) : ((extension === \".jpg\") ? _this._gl.RGB : _this._gl.RGBA);\n                        _this._gl.texImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, internalFormat, _this._gl.UNSIGNED_BYTE, isPot ? img : _this._workingCanvas);\n                    }, samplingMode);\n                };\n                if (!fromData || isBase64)\n                    BABYLON.Tools.LoadImage(url, onload, onerror, scene.database);\n                else if (buffer instanceof Array || typeof buffer === \"string\")\n                    BABYLON.Tools.LoadImage(buffer, onload, onerror, scene.database);\n                else\n                    onload(buffer);\n            }\n            return texture;\n        };\n        Engine.prototype._getInternalFormat = function (format) {\n            var internalFormat = this._gl.RGBA;\n            switch (format) {\n                case Engine.TEXTUREFORMAT_ALPHA:\n                    internalFormat = this._gl.ALPHA;\n                    break;\n                case Engine.TEXTUREFORMAT_LUMINANCE:\n                    internalFormat = this._gl.LUMINANCE;\n                    break;\n                case Engine.TEXTUREFORMAT_LUMINANCE_ALPHA:\n                    internalFormat = this._gl.LUMINANCE_ALPHA;\n                    break;\n                case Engine.TEXTUREFORMAT_RGB:\n                    internalFormat = this._gl.RGB;\n                    break;\n                case Engine.TEXTUREFORMAT_RGBA:\n                    internalFormat = this._gl.RGBA;\n                    break;\n            }\n            return internalFormat;\n        };\n        Engine.prototype.updateRawTexture = function (texture, data, format, invertY, compression) {\n            if (compression === void 0) { compression = null; }\n            var internalFormat = this._getInternalFormat(format);\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, invertY === undefined ? 1 : (invertY ? 1 : 0));\n            if (texture._width % 4 !== 0) {\n                this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);\n            }\n            if (compression) {\n                this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture._width, texture._height, 0, data);\n            }\n            else {\n                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, texture._width, texture._height, 0, internalFormat, this._gl.UNSIGNED_BYTE, data);\n            }\n            if (texture.generateMipMaps) {\n                this._gl.generateMipmap(this._gl.TEXTURE_2D);\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n            this.resetTextureCache();\n            texture.isReady = true;\n        };\n        Engine.prototype.createRawTexture = function (data, width, height, format, generateMipMaps, invertY, samplingMode, compression) {\n            if (compression === void 0) { compression = null; }\n            var texture = this._gl.createTexture();\n            texture._baseWidth = width;\n            texture._baseHeight = height;\n            texture._width = width;\n            texture._height = height;\n            texture.references = 1;\n            this.updateRawTexture(texture, data, format, invertY, compression);\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n            // Filters\n            var filters = getSamplingParameters(samplingMode, generateMipMaps, this._gl);\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n            if (generateMipMaps) {\n                this._gl.generateMipmap(this._gl.TEXTURE_2D);\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n            texture.samplingMode = samplingMode;\n            this._loadedTexturesCache.push(texture);\n            return texture;\n        };\n        Engine.prototype.createDynamicTexture = function (width, height, generateMipMaps, samplingMode) {\n            var texture = this._gl.createTexture();\n            texture._baseWidth = width;\n            texture._baseHeight = height;\n            if (generateMipMaps) {\n                width = BABYLON.Tools.GetExponentOfTwo(width, this._caps.maxTextureSize);\n                height = BABYLON.Tools.GetExponentOfTwo(height, this._caps.maxTextureSize);\n            }\n            this.resetTextureCache();\n            texture._width = width;\n            texture._height = height;\n            texture.isReady = false;\n            texture.generateMipMaps = generateMipMaps;\n            texture.references = 1;\n            texture.samplingMode = samplingMode;\n            this.updateTextureSamplingMode(samplingMode, texture);\n            this._loadedTexturesCache.push(texture);\n            return texture;\n        };\n        Engine.prototype.updateTextureSamplingMode = function (samplingMode, texture) {\n            var filters = getSamplingParameters(samplingMode, texture.generateMipMaps, this._gl);\n            if (texture.isCube) {\n                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture);\n                this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n                this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_MIN_FILTER, filters.min);\n                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n            }\n            else {\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);\n                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n            }\n            texture.samplingMode = samplingMode;\n        };\n        Engine.prototype.updateDynamicTexture = function (texture, canvas, invertY, premulAlpha, format) {\n            if (premulAlpha === void 0) { premulAlpha = false; }\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, invertY ? 1 : 0);\n            if (premulAlpha) {\n                this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\n            }\n            var internalFormat = format ? this._getInternalFormat(format) : this._gl.RGBA;\n            this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalFormat, internalFormat, this._gl.UNSIGNED_BYTE, canvas);\n            if (texture.generateMipMaps) {\n                this._gl.generateMipmap(this._gl.TEXTURE_2D);\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n            if (premulAlpha) {\n                this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\n            }\n            this.resetTextureCache();\n            texture.isReady = true;\n        };\n        Engine.prototype.updateVideoTexture = function (texture, video, invertY) {\n            if (texture._isDisabled) {\n                return;\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n            this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, invertY ? 0 : 1); // Video are upside down by default\n            try {\n                // Testing video texture support\n                if (this._videoTextureSupported === undefined) {\n                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n                    if (this._gl.getError() !== 0) {\n                        this._videoTextureSupported = false;\n                    }\n                    else {\n                        this._videoTextureSupported = true;\n                    }\n                }\n                // Copy video through the current working canvas if video texture is not supported\n                if (!this._videoTextureSupported) {\n                    if (!texture._workingCanvas) {\n                        texture._workingCanvas = document.createElement(\"canvas\");\n                        texture._workingContext = texture._workingCanvas.getContext(\"2d\");\n                        texture._workingCanvas.width = texture._width;\n                        texture._workingCanvas.height = texture._height;\n                    }\n                    texture._workingContext.drawImage(video, 0, 0, video.videoWidth, video.videoHeight, 0, 0, texture._width, texture._height);\n                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, texture._workingCanvas);\n                }\n                else {\n                    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, video);\n                }\n                if (texture.generateMipMaps) {\n                    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n                }\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n                this.resetTextureCache();\n                texture.isReady = true;\n            }\n            catch (ex) {\n                // Something unexpected\n                // Let's disable the texture\n                texture._isDisabled = true;\n            }\n        };\n        Engine.prototype.createRenderTargetTexture = function (size, options) {\n            // old version had a \"generateMipMaps\" arg instead of options.\n            // if options.generateMipMaps is undefined, consider that options itself if the generateMipmaps value\n            // in the same way, generateDepthBuffer is defaulted to true\n            var generateMipMaps = false;\n            var generateDepthBuffer = true;\n            var generateStencilBuffer = false;\n            var type = Engine.TEXTURETYPE_UNSIGNED_INT;\n            var samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE;\n            if (options !== undefined) {\n                generateMipMaps = options.generateMipMaps === undefined ? options : options.generateMipMaps;\n                generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n                generateStencilBuffer = generateDepthBuffer && options.generateStencilBuffer;\n                type = options.type === undefined ? type : options.type;\n                if (options.samplingMode !== undefined) {\n                    samplingMode = options.samplingMode;\n                }\n                if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\n                    // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n                    samplingMode = BABYLON.Texture.NEAREST_SAMPLINGMODE;\n                }\n                else if (type === Engine.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\n                    // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n                    samplingMode = BABYLON.Texture.NEAREST_SAMPLINGMODE;\n                }\n            }\n            var gl = this._gl;\n            var texture = gl.createTexture();\n            this._bindTextureDirectly(gl.TEXTURE_2D, texture);\n            var width = size.width || size;\n            var height = size.height || size;\n            var filters = getSamplingParameters(samplingMode, generateMipMaps, gl);\n            if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\n                type = Engine.TEXTURETYPE_UNSIGNED_INT;\n                BABYLON.Tools.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n            }\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n            // Create the framebuffer\n            var framebuffer = gl.createFramebuffer();\n            this.bindUnboundFramebuffer(framebuffer);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\n            if (generateMipMaps) {\n                this._gl.generateMipmap(this._gl.TEXTURE_2D);\n            }\n            // Unbind\n            this._bindTextureDirectly(gl.TEXTURE_2D, null);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            this.bindUnboundFramebuffer(null);\n            texture._framebuffer = framebuffer;\n            texture._baseWidth = width;\n            texture._baseHeight = height;\n            texture._width = width;\n            texture._height = height;\n            texture.isReady = true;\n            texture.samples = 1;\n            texture.generateMipMaps = generateMipMaps;\n            texture.references = 1;\n            texture.samplingMode = samplingMode;\n            texture.type = type;\n            texture._generateDepthBuffer = generateDepthBuffer;\n            texture._generateStencilBuffer = generateStencilBuffer;\n            this.resetTextureCache();\n            this._loadedTexturesCache.push(texture);\n            return texture;\n        };\n        Engine.prototype.createMultipleRenderTarget = function (size, options) {\n            var generateMipMaps = false;\n            var generateDepthBuffer = true;\n            var generateStencilBuffer = false;\n            var generateDepthTexture = false;\n            var textureCount = 1;\n            var defaultType = Engine.TEXTURETYPE_UNSIGNED_INT;\n            var defaultSamplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE;\n            var types = [], samplingModes = [];\n            if (options !== undefined) {\n                generateMipMaps = options.generateMipMaps;\n                generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n                generateStencilBuffer = options.generateStencilBuffer;\n                generateDepthTexture = options.generateDepthTexture;\n                textureCount = options.textureCount || 1;\n                if (options.types) {\n                    types = options.types;\n                }\n                if (options.samplingModes) {\n                    samplingModes = options.samplingModes;\n                }\n            }\n            var gl = this._gl;\n            // Create the framebuffer\n            var framebuffer = gl.createFramebuffer();\n            this.bindUnboundFramebuffer(framebuffer);\n            var width = size.width || size;\n            var height = size.height || size;\n            var textures = [];\n            var attachments = [];\n            var depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);\n            for (var i = 0; i < textureCount; i++) {\n                var samplingMode = samplingModes[i] || defaultSamplingMode;\n                var type = types[i] || defaultType;\n                if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\n                    // if floating point linear (gl.FLOAT) then force to NEAREST_SAMPLINGMODE\n                    samplingMode = BABYLON.Texture.NEAREST_SAMPLINGMODE;\n                }\n                else if (type === Engine.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\n                    // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n                    samplingMode = BABYLON.Texture.NEAREST_SAMPLINGMODE;\n                }\n                var filters = getSamplingParameters(samplingMode, generateMipMaps, gl);\n                if (type === Engine.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\n                    type = Engine.TEXTURETYPE_UNSIGNED_INT;\n                    BABYLON.Tools.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n                }\n                var texture = gl.createTexture();\n                var attachment = gl[\"COLOR_ATTACHMENT\" + i];\n                textures.push(texture);\n                attachments.push(attachment);\n                gl.activeTexture(gl[\"TEXTURE\" + i]);\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), width, height, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n                gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture, 0);\n                if (generateMipMaps) {\n                    this._gl.generateMipmap(this._gl.TEXTURE_2D);\n                }\n                // Unbind\n                this._bindTextureDirectly(gl.TEXTURE_2D, null);\n                texture._framebuffer = framebuffer;\n                texture._depthStencilBuffer = depthStencilBuffer;\n                texture._baseWidth = width;\n                texture._baseHeight = height;\n                texture._width = width;\n                texture._height = height;\n                texture.isReady = true;\n                texture.samples = 1;\n                texture.generateMipMaps = generateMipMaps;\n                texture.references = 1;\n                texture.samplingMode = samplingMode;\n                texture.type = type;\n                texture._generateDepthBuffer = generateDepthBuffer;\n                texture._generateStencilBuffer = generateStencilBuffer;\n                this._loadedTexturesCache.push(texture);\n            }\n            if (generateDepthTexture) {\n                // Depth texture\n                var depthTexture = gl.createTexture();\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, depthTexture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT16, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);\n                depthTexture._framebuffer = framebuffer;\n                depthTexture._baseWidth = width;\n                depthTexture._baseHeight = height;\n                depthTexture._width = width;\n                depthTexture._height = height;\n                depthTexture.isReady = true;\n                depthTexture.samples = 1;\n                depthTexture.generateMipMaps = generateMipMaps;\n                depthTexture.references = 1;\n                depthTexture.samplingMode = gl.NEAREST;\n                depthTexture._generateDepthBuffer = generateDepthBuffer;\n                depthTexture._generateStencilBuffer = generateStencilBuffer;\n                textures.push(depthTexture);\n                this._loadedTexturesCache.push(depthTexture);\n            }\n            gl.drawBuffers(attachments);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            this.bindUnboundFramebuffer(null);\n            this.resetTextureCache();\n            return textures;\n        };\n        Engine.prototype._setupFramebufferDepthAttachments = function (generateStencilBuffer, generateDepthBuffer, width, height, samples) {\n            if (samples === void 0) { samples = 1; }\n            var depthStencilBuffer = null;\n            var gl = this._gl;\n            // Create the depth/stencil buffer\n            if (generateStencilBuffer) {\n                depthStencilBuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n                if (samples > 1) {\n                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);\n                }\n                else {\n                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\n                }\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\n            }\n            else if (generateDepthBuffer) {\n                depthStencilBuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n                if (samples > 1) {\n                    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH_COMPONENT16, width, height);\n                }\n                else {\n                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\n                }\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\n            }\n            return depthStencilBuffer;\n        };\n        Engine.prototype.updateRenderTargetTextureSampleCount = function (texture, samples) {\n            if (this.webGLVersion < 2) {\n                return 1;\n            }\n            if (texture.samples === samples) {\n                return samples;\n            }\n            var gl = this._gl;\n            samples = Math.min(samples, gl.getParameter(gl.MAX_SAMPLES));\n            // Dispose previous render buffers\n            if (texture._depthStencilBuffer) {\n                gl.deleteRenderbuffer(texture._depthStencilBuffer);\n            }\n            if (texture._MSAAFramebuffer) {\n                gl.deleteFramebuffer(texture._MSAAFramebuffer);\n            }\n            if (texture._MSAARenderBuffer) {\n                gl.deleteRenderbuffer(texture._MSAARenderBuffer);\n            }\n            if (samples > 1) {\n                texture._MSAAFramebuffer = gl.createFramebuffer();\n                this.bindUnboundFramebuffer(texture._MSAAFramebuffer);\n                var colorRenderbuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);\n                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.RGBA8, texture._width, texture._height);\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, colorRenderbuffer);\n                texture._MSAARenderBuffer = colorRenderbuffer;\n            }\n            else {\n                this.bindUnboundFramebuffer(texture._framebuffer);\n            }\n            texture.samples = samples;\n            texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(texture._generateStencilBuffer, texture._generateDepthBuffer, texture._width, texture._height, samples);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            this.bindUnboundFramebuffer(null);\n            return samples;\n        };\n        Engine.prototype._uploadDataToTexture = function (target, lod, internalFormat, width, height, format, type, data) {\n            this._gl.texImage2D(target, lod, internalFormat, width, height, 0, format, type, data);\n        };\n        Engine.prototype._uploadCompressedDataToTexture = function (target, lod, internalFormat, width, height, data) {\n            this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);\n        };\n        Engine.prototype.createRenderTargetCubeTexture = function (size, options) {\n            var gl = this._gl;\n            var texture = gl.createTexture();\n            var generateMipMaps = true;\n            var generateDepthBuffer = true;\n            var generateStencilBuffer = false;\n            var samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE;\n            if (options !== undefined) {\n                generateMipMaps = options.generateMipMaps === undefined ? options : options.generateMipMaps;\n                generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n                generateStencilBuffer = generateDepthBuffer && options.generateStencilBuffer;\n                if (options.samplingMode !== undefined) {\n                    samplingMode = options.samplingMode;\n                }\n            }\n            texture.isCube = true;\n            texture.references = 1;\n            texture.generateMipMaps = generateMipMaps;\n            texture.references = 1;\n            texture.samples = 1;\n            texture.samplingMode = samplingMode;\n            var filters = getSamplingParameters(samplingMode, generateMipMaps, gl);\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n            for (var face = 0; face < 6; face++) {\n                gl.texImage2D((gl.TEXTURE_CUBE_MAP_POSITIVE_X + face), 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            }\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // Create the framebuffer\n            var framebuffer = gl.createFramebuffer();\n            this.bindUnboundFramebuffer(framebuffer);\n            texture._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, size, size);\n            // Mipmaps\n            if (texture.generateMipMaps) {\n                this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n            }\n            // Unbind\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n            this.bindUnboundFramebuffer(null);\n            texture._framebuffer = framebuffer;\n            texture._width = size;\n            texture._height = size;\n            texture.isReady = true;\n            this.resetTextureCache();\n            this._loadedTexturesCache.push(texture);\n            return texture;\n        };\n        Engine.prototype.createPrefilteredCubeTexture = function (rootUrl, scene, scale, offset, onLoad, onError, format) {\n            var _this = this;\n            if (onError === void 0) { onError = null; }\n            var callback = function (loadData) {\n                if (_this._caps.textureLOD || !loadData) {\n                    // Do not add extra process if texture lod is supported.\n                    if (onLoad) {\n                        onLoad();\n                    }\n                    return;\n                }\n                var mipSlices = 3;\n                var gl = _this._gl;\n                var width = loadData.width;\n                if (!width) {\n                    return;\n                }\n                var textures = [];\n                for (var i = 0; i < mipSlices; i++) {\n                    //compute LOD from even spacing in smoothness (matching shader calculation)\n                    var smoothness = i / (mipSlices - 1);\n                    var roughness = 1 - smoothness;\n                    var minLODIndex = offset; // roughness = 0\n                    var maxLODIndex = BABYLON.MathTools.Log2(width) * scale + offset; // roughness = 1\n                    var lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\n                    var mipmapIndex = Math.min(Math.max(Math.round(lodIndex), 0), maxLODIndex);\n                    var glTextureFromLod = gl.createTexture();\n                    glTextureFromLod.isCube = true;\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, glTextureFromLod);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    if (loadData.isDDS) {\n                        var info = loadData.info;\n                        var data = loadData.data;\n                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, info.isCompressed ? 1 : 0);\n                        BABYLON.Internals.DDSTools.UploadDDSLevels(_this, data, info, true, 6, mipmapIndex);\n                    }\n                    else {\n                        BABYLON.Tools.Warn(\"DDS is the only prefiltered cube map support so far.\");\n                    }\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n                    // Wrap in a base texture for easy binding.\n                    var lodTexture = new BABYLON.BaseTexture(scene);\n                    lodTexture.isCube = true;\n                    lodTexture._texture = glTextureFromLod;\n                    glTextureFromLod.isReady = true;\n                    textures.push(lodTexture);\n                }\n                loadData.texture._lodTextureHigh = textures[2];\n                loadData.texture._lodTextureMid = textures[1];\n                loadData.texture._lodTextureLow = textures[0];\n                if (onLoad) {\n                    onLoad();\n                }\n            };\n            return this.createCubeTexture(rootUrl, scene, null, false, callback, onError, format);\n        };\n        Engine.prototype.createCubeTexture = function (rootUrl, scene, files, noMipmap, onLoad, onError, format) {\n            var _this = this;\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            var gl = this._gl;\n            var texture = gl.createTexture();\n            texture.isCube = true;\n            texture.url = rootUrl;\n            texture.references = 1;\n            texture.onLoadedCallbacks = [];\n            texture.generateMipMaps = !noMipmap;\n            var isKTX = false;\n            var isDDS = false;\n            var lastDot = rootUrl.lastIndexOf('.');\n            var extension = rootUrl.substring(lastDot).toLowerCase();\n            if (this._textureFormatInUse) {\n                extension = this._textureFormatInUse;\n                rootUrl = rootUrl.substring(0, lastDot) + this._textureFormatInUse;\n                isKTX = true;\n            }\n            else {\n                isDDS = (extension === \".dds\");\n            }\n            if (isKTX) {\n                BABYLON.Tools.LoadFile(rootUrl, function (data) {\n                    var ktx = new BABYLON.Internals.KhronosTextureContainer(data, 6);\n                    var loadMipmap = ktx.numberOfMipmapLevels > 1 && !noMipmap;\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n                    ktx.uploadLevels(_this._gl, !noMipmap);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n                    _this.resetTextureCache();\n                    texture._width = ktx.pixelWidth;\n                    texture._height = ktx.pixelHeight;\n                    texture.isReady = true;\n                }, null, null, true, onError);\n            }\n            else if (isDDS) {\n                BABYLON.Tools.LoadFile(rootUrl, function (data) {\n                    var info = BABYLON.Internals.DDSTools.GetDDSInfo(data);\n                    var loadMipmap = (info.isRGB || info.isLuminance || info.mipmapCount > 1) && !noMipmap;\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, info.isCompressed ? 1 : 0);\n                    BABYLON.Internals.DDSTools.UploadDDSLevels(_this, data, info, loadMipmap, 6);\n                    if (!noMipmap && !info.isFourCC && info.mipmapCount === 1) {\n                        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n                    }\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n                    _this.resetTextureCache();\n                    texture._width = info.width;\n                    texture._height = info.height;\n                    texture.isReady = true;\n                    texture.type = info.textureType;\n                    if (onLoad) {\n                        onLoad({ isDDS: true, width: info.width, info: info, data: data, texture: texture });\n                    }\n                }, null, null, true, onError);\n            }\n            else {\n                cascadeLoad(rootUrl, scene, function (imgs) {\n                    var width = BABYLON.Tools.GetExponentOfTwo(imgs[0].width, _this._caps.maxCubemapTextureSize);\n                    var height = width;\n                    _this._prepareWorkingCanvas();\n                    _this._workingCanvas.width = width;\n                    _this._workingCanvas.height = height;\n                    var faces = [\n                        gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\n                        gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z\n                    ];\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n                    var internalFormat = format ? _this._getInternalFormat(format) : _this._gl.RGBA;\n                    for (var index = 0; index < faces.length; index++) {\n                        _this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);\n                        gl.texImage2D(faces[index], 0, internalFormat, internalFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);\n                    }\n                    if (!noMipmap) {\n                        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\n                    }\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, noMipmap ? gl.LINEAR : gl.LINEAR_MIPMAP_LINEAR);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n                    _this.resetTextureCache();\n                    texture._width = width;\n                    texture._height = height;\n                    texture.isReady = true;\n                    texture.onLoadedCallbacks.forEach(function (callback) {\n                        callback();\n                    });\n                    if (onLoad) {\n                        onLoad();\n                    }\n                }, files, onError);\n            }\n            this._loadedTexturesCache.push(texture);\n            return texture;\n        };\n        Engine.prototype.updateTextureSize = function (texture, width, height) {\n            texture._width = width;\n            texture._height = height;\n            texture._size = width * height;\n            texture._baseWidth = width;\n            texture._baseHeight = height;\n        };\n        Engine.prototype.updateRawCubeTexture = function (texture, data, format, type, invertY, compression, level) {\n            if (compression === void 0) { compression = null; }\n            if (level === void 0) { level = 0; }\n            var gl = this._gl;\n            var textureType = this._getWebGLTextureType(type);\n            var internalFormat = this._getInternalFormat(format);\n            var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n            var needConversion = false;\n            if (internalFormat === gl.RGB) {\n                internalFormat = gl.RGBA;\n                needConversion = true;\n            }\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY === undefined ? 1 : (invertY ? 1 : 0));\n            if (texture._width % 4 !== 0) {\n                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n            }\n            // Data are known to be in +X +Y +Z -X -Y -Z\n            for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n                var faceData = data[faceIndex];\n                if (compression) {\n                    gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture._width, texture._height, 0, faceData);\n                }\n                else {\n                    if (needConversion) {\n                        faceData = this._convertRGBtoRGBATextureData(faceData, texture._width, texture._height, type);\n                    }\n                    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture._width, texture._height, 0, internalFormat, textureType, faceData);\n                }\n            }\n            var isPot = (BABYLON.Tools.IsExponentOfTwo(texture._width) && BABYLON.Tools.IsExponentOfTwo(texture._height));\n            if (isPot && texture.generateMipMaps && level === 0) {\n                this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n            this.resetTextureCache();\n            texture.isReady = true;\n        };\n        Engine.prototype.createRawCubeTexture = function (data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {\n            if (compression === void 0) { compression = null; }\n            var gl = this._gl;\n            var texture = gl.createTexture();\n            texture.isCube = true;\n            texture.references = 1;\n            texture.generateMipMaps = generateMipMaps;\n            texture.format = format;\n            texture.type = type;\n            var textureType = this._getWebGLTextureType(type);\n            var internalFormat = this._getInternalFormat(format);\n            var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);\n            var needConversion = false;\n            if (internalFormat === gl.RGB) {\n                internalFormat = gl.RGBA;\n                needConversion = true;\n            }\n            var width = size;\n            var height = width;\n            texture._width = width;\n            texture._height = height;\n            // Double check on POT to generate Mips.\n            var isPot = (BABYLON.Tools.IsExponentOfTwo(texture._width) && BABYLON.Tools.IsExponentOfTwo(texture._height));\n            if (!isPot) {\n                generateMipMaps = false;\n            }\n            // Upload data if needed. The texture won t be ready until then.\n            if (data) {\n                this.updateRawCubeTexture(texture, data, format, type, invertY, compression);\n            }\n            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture);\n            // Filters\n            if (data && generateMipMaps) {\n                this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);\n            }\n            if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            }\n            else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            }\n            else {\n                var filters = getSamplingParameters(samplingMode, generateMipMaps, gl);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);\n                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);\n            }\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n            return texture;\n        };\n        Engine.prototype.createRawCubeTextureFromUrl = function (url, scene, size, format, type, noMipmap, callback, mipmmapGenerator, onLoad, onError, samplingMode, invertY) {\n            var _this = this;\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            if (invertY === void 0) { invertY = false; }\n            var gl = this._gl;\n            var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode);\n            scene._addPendingData(texture);\n            texture.url = url;\n            this._loadedTexturesCache.push(texture);\n            var onerror = function () {\n                scene._removePendingData(texture);\n                if (onError) {\n                    onError();\n                }\n            };\n            var internalCallback = function (data) {\n                var width = texture._width;\n                var height = texture._height;\n                var faceDataArrays = callback(data);\n                if (mipmmapGenerator) {\n                    var textureType = _this._getWebGLTextureType(type);\n                    var internalFormat = _this._getInternalFormat(format);\n                    var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);\n                    var needConversion = false;\n                    if (internalFormat === gl.RGB) {\n                        internalFormat = gl.RGBA;\n                        needConversion = true;\n                    }\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture);\n                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);\n                    var mipData = mipmmapGenerator(faceDataArrays);\n                    for (var level = 0; level < mipData.length; level++) {\n                        var mipSize = width >> level;\n                        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n                            var mipFaceData = mipData[level][faceIndex];\n                            if (needConversion) {\n                                mipFaceData = _this._convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);\n                            }\n                            gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);\n                        }\n                    }\n                    _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);\n                }\n                else {\n                    texture.generateMipMaps = !noMipmap;\n                    _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);\n                }\n                texture.isReady = true;\n                _this.resetTextureCache();\n                scene._removePendingData(texture);\n                if (onLoad) {\n                    onLoad();\n                }\n            };\n            BABYLON.Tools.LoadFile(url, function (data) {\n                internalCallback(data);\n            }, onerror, scene.database, true);\n            return texture;\n        };\n        ;\n        Engine.prototype._convertRGBtoRGBATextureData = function (rgbData, width, height, textureType) {\n            // Create new RGBA data container.\n            var rgbaData;\n            if (textureType === Engine.TEXTURETYPE_FLOAT) {\n                rgbaData = new Float32Array(width * height * 4);\n            }\n            else {\n                rgbaData = new Uint32Array(width * height * 4);\n            }\n            // Convert each pixel.\n            for (var x = 0; x < width; x++) {\n                for (var y = 0; y < height; y++) {\n                    var index = (y * width + x) * 3;\n                    var newIndex = (y * width + x) * 4;\n                    // Map Old Value to new value.\n                    rgbaData[newIndex + 0] = rgbData[index + 0];\n                    rgbaData[newIndex + 1] = rgbData[index + 1];\n                    rgbaData[newIndex + 2] = rgbData[index + 2];\n                    // Add fully opaque alpha channel.\n                    rgbaData[newIndex + 3] = 1;\n                }\n            }\n            return rgbaData;\n        };\n        Engine.prototype._releaseFramebufferObjects = function (texture) {\n            var gl = this._gl;\n            if (texture._framebuffer) {\n                gl.deleteFramebuffer(texture._framebuffer);\n                texture._framebuffer = null;\n            }\n            if (texture._depthStencilBuffer) {\n                gl.deleteRenderbuffer(texture._depthStencilBuffer);\n                texture._depthStencilBuffer = null;\n            }\n            if (texture._MSAAFramebuffer) {\n                gl.deleteFramebuffer(texture._MSAAFramebuffer);\n                texture._MSAAFramebuffer = null;\n            }\n            if (texture._MSAARenderBuffer) {\n                gl.deleteRenderbuffer(texture._MSAARenderBuffer);\n                texture._MSAARenderBuffer = null;\n            }\n        };\n        Engine.prototype._releaseTexture = function (texture) {\n            var gl = this._gl;\n            this._releaseFramebufferObjects(texture);\n            gl.deleteTexture(texture);\n            // Unbind channels\n            this.unbindAllTextures();\n            var index = this._loadedTexturesCache.indexOf(texture);\n            if (index !== -1) {\n                this._loadedTexturesCache.splice(index, 1);\n            }\n            // Integrated fixed lod samplers.\n            if (texture._lodTextureHigh) {\n                texture._lodTextureHigh.dispose();\n            }\n            if (texture._lodTextureMid) {\n                texture._lodTextureMid.dispose();\n            }\n            if (texture._lodTextureLow) {\n                texture._lodTextureLow.dispose();\n            }\n        };\n        Engine.prototype.setProgram = function (program) {\n            if (this._currentProgram !== program) {\n                this._gl.useProgram(program);\n                this._currentProgram = program;\n            }\n        };\n        Engine.prototype.bindSamplers = function (effect) {\n            this.setProgram(effect.getProgram());\n            var samplers = effect.getSamplers();\n            for (var index = 0; index < samplers.length; index++) {\n                var uniform = effect.getUniform(samplers[index]);\n                this._gl.uniform1i(uniform, index);\n            }\n            this._currentEffect = null;\n        };\n        Engine.prototype.activateTexture = function (texture) {\n            if (this._activeTexture !== texture) {\n                this._gl.activeTexture(texture);\n                this._activeTexture = texture;\n            }\n        };\n        Engine.prototype._bindTextureDirectly = function (target, texture) {\n            if (this._activeTexturesCache[this._activeTexture] !== texture) {\n                this._gl.bindTexture(target, texture);\n                this._activeTexturesCache[this._activeTexture] = texture;\n            }\n        };\n        Engine.prototype._bindTexture = function (channel, texture) {\n            if (channel < 0) {\n                return;\n            }\n            this.activateTexture(this._gl.TEXTURE0 + channel);\n            this._bindTextureDirectly(this._gl.TEXTURE_2D, texture);\n        };\n        Engine.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n            this._bindTexture(channel, postProcess._textures.data[postProcess._currentRenderTextureInd]);\n        };\n        Engine.prototype.unbindAllTextures = function () {\n            for (var channel = 0; channel < this._caps.maxTexturesImageUnits; channel++) {\n                this.activateTexture(this._gl[\"TEXTURE\" + channel]);\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n            }\n        };\n        Engine.prototype.setTexture = function (channel, uniform, texture) {\n            if (channel < 0) {\n                return;\n            }\n            this._gl.uniform1i(uniform, channel);\n            this._setTexture(channel, texture);\n        };\n        Engine.prototype._setTexture = function (channel, texture) {\n            // Not ready?\n            if (!texture) {\n                if (this._activeTexturesCache[channel] != null) {\n                    this.activateTexture(this._gl[\"TEXTURE\" + channel]);\n                    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);\n                    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);\n                }\n                return;\n            }\n            // Video\n            var alreadyActivated = false;\n            if (texture.video) {\n                this.activateTexture(this._gl[\"TEXTURE\" + channel]);\n                alreadyActivated = true;\n                texture.update();\n            }\n            else if (texture.delayLoadState === Engine.DELAYLOADSTATE_NOTLOADED) {\n                texture.delayLoad();\n                return;\n            }\n            var internalTexture = texture.isReady() ? texture.getInternalTexture() :\n                (texture.isCube ? this.emptyCubeTexture : this.emptyTexture);\n            if (this._activeTexturesCache[channel] === internalTexture) {\n                return;\n            }\n            if (!alreadyActivated) {\n                this.activateTexture(this._gl[\"TEXTURE\" + channel]);\n            }\n            if (internalTexture.isCube) {\n                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, internalTexture);\n                if (internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {\n                    internalTexture._cachedCoordinatesMode = texture.coordinatesMode;\n                    // CUBIC_MODE and SKYBOX_MODE both require CLAMP_TO_EDGE.  All other modes use REPEAT.\n                    var textureWrapMode = (texture.coordinatesMode !== BABYLON.Texture.CUBIC_MODE && texture.coordinatesMode !== BABYLON.Texture.SKYBOX_MODE) ? this._gl.REPEAT : this._gl.CLAMP_TO_EDGE;\n                    this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_S, textureWrapMode);\n                    this._gl.texParameteri(this._gl.TEXTURE_CUBE_MAP, this._gl.TEXTURE_WRAP_T, textureWrapMode);\n                }\n                this._setAnisotropicLevel(this._gl.TEXTURE_CUBE_MAP, texture);\n            }\n            else {\n                this._bindTextureDirectly(this._gl.TEXTURE_2D, internalTexture);\n                if (internalTexture._cachedWrapU !== texture.wrapU) {\n                    internalTexture._cachedWrapU = texture.wrapU;\n                    switch (texture.wrapU) {\n                        case BABYLON.Texture.WRAP_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.REPEAT);\n                            break;\n                        case BABYLON.Texture.CLAMP_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);\n                            break;\n                        case BABYLON.Texture.MIRROR_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.MIRRORED_REPEAT);\n                            break;\n                    }\n                }\n                if (internalTexture._cachedWrapV !== texture.wrapV) {\n                    internalTexture._cachedWrapV = texture.wrapV;\n                    switch (texture.wrapV) {\n                        case BABYLON.Texture.WRAP_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.REPEAT);\n                            break;\n                        case BABYLON.Texture.CLAMP_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);\n                            break;\n                        case BABYLON.Texture.MIRROR_ADDRESSMODE:\n                            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.MIRRORED_REPEAT);\n                            break;\n                    }\n                }\n                this._setAnisotropicLevel(this._gl.TEXTURE_2D, texture);\n            }\n        };\n        Engine.prototype.setTextureArray = function (channel, uniform, textures) {\n            if (channel < 0) {\n                return;\n            }\n            if (!this._textureUnits || this._textureUnits.length !== textures.length) {\n                this._textureUnits = new Int32Array(textures.length);\n            }\n            for (var i = 0; i < textures.length; i++) {\n                this._textureUnits[i] = channel + i;\n            }\n            this._gl.uniform1iv(uniform, this._textureUnits);\n            for (var index = 0; index < textures.length; index++) {\n                this._setTexture(channel + index, textures[index]);\n            }\n        };\n        Engine.prototype._setAnisotropicLevel = function (key, texture) {\n            var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;\n            var value = texture.anisotropicFilteringLevel;\n            if (texture.getInternalTexture().samplingMode === BABYLON.Texture.NEAREST_SAMPLINGMODE) {\n                value = 1;\n            }\n            if (anisotropicFilterExtension && texture._cachedAnisotropicFilteringLevel !== value) {\n                this._gl.texParameterf(key, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(value, this._caps.maxAnisotropy));\n                texture._cachedAnisotropicFilteringLevel = value;\n            }\n        };\n        Engine.prototype.readPixels = function (x, y, width, height) {\n            var data = new Uint8Array(height * width * 4);\n            this._gl.readPixels(x, y, width, height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);\n            return data;\n        };\n        /**\n         * Add an externaly attached data from its key.\n         * This method call will fail and return false, if such key already exists.\n         * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n         * @param key the unique key that identifies the data\n         * @param data the data object to associate to the key for this Engine instance\n         * @return true if no such key were already present and the data was added successfully, false otherwise\n         */\n        Engine.prototype.addExternalData = function (key, data) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.add(key, data);\n        };\n        /**\n         * Get an externaly attached data from its key\n         * @param key the unique key that identifies the data\n         * @return the associated data, if present (can be null), or undefined if not present\n         */\n        Engine.prototype.getExternalData = function (key) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.get(key);\n        };\n        /**\n         * Get an externaly attached data from its key, create it using a factory if it's not already present\n         * @param key the unique key that identifies the data\n         * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n         * @return the associated data, can be null if the factory returned null.\n         */\n        Engine.prototype.getOrAddExternalDataWithFactory = function (key, factory) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.getOrAddWithFactory(key, factory);\n        };\n        /**\n         * Remove an externaly attached data from the Engine instance\n         * @param key the unique key that identifies the data\n         * @return true if the data was successfully removed, false if it doesn't exist\n         */\n        Engine.prototype.removeExternalData = function (key) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.remove(key);\n        };\n        Engine.prototype.releaseInternalTexture = function (texture) {\n            if (!texture) {\n                return;\n            }\n            texture.references--;\n            // Final reference ?\n            if (texture.references === 0) {\n                var texturesCache = this.getLoadedTexturesCache();\n                var index = texturesCache.indexOf(texture);\n                if (index > -1) {\n                    texturesCache.splice(index, 1);\n                }\n                this._releaseTexture(texture);\n            }\n        };\n        Engine.prototype.unbindAllAttributes = function () {\n            if (this._mustWipeVertexAttributes) {\n                this._mustWipeVertexAttributes = false;\n                for (var i = 0; i < this._caps.maxVertexAttribs; i++) {\n                    this._gl.disableVertexAttribArray(i);\n                    this._vertexAttribArraysEnabled[i] = false;\n                    this._currentBufferPointers[i] = null;\n                }\n                return;\n            }\n            for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {\n                if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {\n                    continue;\n                }\n                this._gl.disableVertexAttribArray(i);\n                this._vertexAttribArraysEnabled[i] = false;\n                this._currentBufferPointers[i] = null;\n            }\n        };\n        Engine.prototype.releaseEffects = function () {\n            for (var name in this._compiledEffects) {\n                this._gl.deleteProgram(this._compiledEffects[name]._program);\n            }\n            this._compiledEffects = {};\n        };\n        // Dispose\n        Engine.prototype.dispose = function () {\n            this.hideLoadingUI();\n            this.stopRenderLoop();\n            // Empty texture\n            if (this._emptyTexture) {\n                this._releaseTexture(this._emptyTexture);\n                this._emptyTexture = null;\n            }\n            if (this._emptyCubeTexture) {\n                this._releaseTexture(this._emptyCubeTexture);\n                this._emptyCubeTexture = null;\n            }\n            // Release scenes\n            while (this.scenes.length) {\n                this.scenes[0].dispose();\n            }\n            // Release audio engine\n            if (Engine.audioEngine) {\n                Engine.audioEngine.dispose();\n            }\n            // Release effects\n            this.releaseEffects();\n            // Unbind\n            this.unbindAllAttributes();\n            if (this._dummyFramebuffer) {\n                this._gl.deleteFramebuffer(this._dummyFramebuffer);\n            }\n            this._gl = null;\n            //WebVR\n            this.disableVR();\n            // Events\n            window.removeEventListener(\"blur\", this._onBlur);\n            window.removeEventListener(\"focus\", this._onFocus);\n            this._renderingCanvas.removeEventListener(\"blur\", this._onCanvasBlur);\n            document.removeEventListener(\"fullscreenchange\", this._onFullscreenChange);\n            document.removeEventListener(\"mozfullscreenchange\", this._onFullscreenChange);\n            document.removeEventListener(\"webkitfullscreenchange\", this._onFullscreenChange);\n            document.removeEventListener(\"msfullscreenchange\", this._onFullscreenChange);\n            document.removeEventListener(\"pointerlockchange\", this._onPointerLockChange);\n            document.removeEventListener(\"mspointerlockchange\", this._onPointerLockChange);\n            document.removeEventListener(\"mozpointerlockchange\", this._onPointerLockChange);\n            document.removeEventListener(\"webkitpointerlockchange\", this._onPointerLockChange);\n            // Remove from Instances\n            var index = Engine.Instances.indexOf(this);\n            if (index >= 0) {\n                Engine.Instances.splice(index, 1);\n            }\n        };\n        // Loading screen\n        Engine.prototype.displayLoadingUI = function () {\n            var loadingScreen = this.loadingScreen;\n            if (loadingScreen) {\n                loadingScreen.displayLoadingUI();\n            }\n        };\n        Engine.prototype.hideLoadingUI = function () {\n            var loadingScreen = this.loadingScreen;\n            if (loadingScreen) {\n                loadingScreen.hideLoadingUI();\n            }\n        };\n        Object.defineProperty(Engine.prototype, \"loadingScreen\", {\n            get: function () {\n                if (!this._loadingScreen && BABYLON.DefaultLoadingScreen)\n                    this._loadingScreen = new BABYLON.DefaultLoadingScreen(this._renderingCanvas);\n                return this._loadingScreen;\n            },\n            set: function (loadingScreen) {\n                this._loadingScreen = loadingScreen;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"loadingUIText\", {\n            set: function (text) {\n                this.loadingScreen.loadingUIText = text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Engine.prototype, \"loadingUIBackgroundColor\", {\n            set: function (color) {\n                this.loadingScreen.loadingUIBackgroundColor = color;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Engine.prototype.attachContextLostEvent = function (callback) {\n            this._renderingCanvas.addEventListener(\"webglcontextlost\", callback, false);\n        };\n        Engine.prototype.attachContextRestoredEvent = function (callback) {\n            this._renderingCanvas.addEventListener(\"webglcontextrestored\", callback, false);\n        };\n        Engine.prototype.getVertexShaderSource = function (program) {\n            var shaders = this._gl.getAttachedShaders(program);\n            return this._gl.getShaderSource(shaders[0]);\n        };\n        Engine.prototype.getFragmentShaderSource = function (program) {\n            var shaders = this._gl.getAttachedShaders(program);\n            return this._gl.getShaderSource(shaders[1]);\n        };\n        Engine.prototype.getError = function () {\n            return this._gl.getError();\n        };\n        // FPS\n        Engine.prototype.getFps = function () {\n            return this.fps;\n        };\n        Engine.prototype.getDeltaTime = function () {\n            return this.deltaTime;\n        };\n        Engine.prototype._measureFps = function () {\n            this.previousFramesDuration.push(BABYLON.Tools.Now);\n            var length = this.previousFramesDuration.length;\n            if (length >= 2) {\n                this.deltaTime = this.previousFramesDuration[length - 1] - this.previousFramesDuration[length - 2];\n            }\n            if (length >= this.fpsRange) {\n                if (length > this.fpsRange) {\n                    this.previousFramesDuration.splice(0, 1);\n                    length = this.previousFramesDuration.length;\n                }\n                var sum = 0;\n                for (var id = 0; id < length - 1; id++) {\n                    sum += this.previousFramesDuration[id + 1] - this.previousFramesDuration[id];\n                }\n                this.fps = 1000.0 / (sum / (length - 1));\n            }\n        };\n        Engine.prototype._readTexturePixels = function (texture, width, height, faceIndex) {\n            if (faceIndex === void 0) { faceIndex = -1; }\n            var gl = this._gl;\n            if (!this._dummyFramebuffer) {\n                this._dummyFramebuffer = gl.createFramebuffer();\n            }\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);\n            if (faceIndex > -1) {\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, texture, 0);\n            }\n            else {\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            }\n            var readType = (texture.type !== undefined) ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;\n            var buffer;\n            switch (readType) {\n                case gl.UNSIGNED_BYTE:\n                    buffer = new Uint8Array(4 * width * height);\n                    readType = gl.UNSIGNED_BYTE;\n                    break;\n                default:\n                    buffer = new Float32Array(4 * width * height);\n                    readType = gl.FLOAT;\n                    break;\n            }\n            gl.readPixels(0, 0, width, height, gl.RGBA, readType, buffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            return buffer;\n        };\n        Engine.prototype._canRenderToFloatFramebuffer = function () {\n            if (this._webGLVersion > 1) {\n                return this._caps.colorBufferFloat;\n            }\n            return this._canRenderToFramebuffer(BABYLON.Engine.TEXTURETYPE_FLOAT);\n        };\n        Engine.prototype._canRenderToHalfFloatFramebuffer = function () {\n            if (this._webGLVersion > 1) {\n                return this._caps.colorBufferFloat;\n            }\n            return this._canRenderToFramebuffer(BABYLON.Engine.TEXTURETYPE_HALF_FLOAT);\n        };\n        // Thank you : http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture\n        Engine.prototype._canRenderToFramebuffer = function (type) {\n            var gl = this._gl;\n            //clear existing errors\n            while (gl.getError() !== gl.NO_ERROR) { }\n            var successful = true;\n            var texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            var fb = gl.createFramebuffer();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n            var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n            successful = successful && (status === gl.FRAMEBUFFER_COMPLETE);\n            successful = successful && (gl.getError() === gl.NO_ERROR);\n            //try render by clearing frame buffer's color buffer\n            if (successful) {\n                gl.clear(gl.COLOR_BUFFER_BIT);\n                successful = successful && (gl.getError() === gl.NO_ERROR);\n            }\n            //try reading from frame to ensure render occurs (just creating the FBO is not sufficient to determine if rendering is supported)\n            if (successful) {\n                //in practice it's sufficient to just read from the backbuffer rather than handle potentially issues reading from the texture\n                gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                var readFormat = gl.RGBA;\n                var readType = gl.UNSIGNED_BYTE;\n                var buffer = new Uint8Array(4);\n                gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);\n                successful = successful && (gl.getError() === gl.NO_ERROR);\n            }\n            //clean up\n            gl.deleteTexture(texture);\n            gl.deleteFramebuffer(fb);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            //clear accumulated errors\n            while (!successful && (gl.getError() !== gl.NO_ERROR)) { }\n            return successful;\n        };\n        Engine.prototype._getWebGLTextureType = function (type) {\n            if (type === Engine.TEXTURETYPE_FLOAT) {\n                return this._gl.FLOAT;\n            }\n            else if (type === Engine.TEXTURETYPE_HALF_FLOAT) {\n                // Add Half Float Constant.\n                return this._gl.HALF_FLOAT_OES;\n            }\n            return this._gl.UNSIGNED_BYTE;\n        };\n        ;\n        Engine.prototype._getRGBABufferInternalSizedFormat = function (type) {\n            if (this._webGLVersion === 1) {\n                return this._gl.RGBA;\n            }\n            if (type === Engine.TEXTURETYPE_FLOAT) {\n                return this._gl.RGBA32F;\n            }\n            else if (type === Engine.TEXTURETYPE_HALF_FLOAT) {\n                return this._gl.RGBA16F;\n            }\n            return this._gl.RGBA;\n        };\n        ;\n        // Statics\n        Engine.isSupported = function () {\n            try {\n                // Avoid creating an unsized context for CocoonJS, since size determined on first creation.  Is not resizable\n                if (navigator.isCocoonJS) {\n                    return true;\n                }\n                var tempcanvas = document.createElement(\"canvas\");\n                var gl = tempcanvas.getContext(\"webgl\") || tempcanvas.getContext(\"experimental-webgl\");\n                return gl != null && !!window.WebGLRenderingContext;\n            }\n            catch (e) {\n                return false;\n            }\n        };\n        return Engine;\n    }());\n    Engine.Instances = new Array();\n    // Const statics\n    Engine._ALPHA_DISABLE = 0;\n    Engine._ALPHA_ADD = 1;\n    Engine._ALPHA_COMBINE = 2;\n    Engine._ALPHA_SUBTRACT = 3;\n    Engine._ALPHA_MULTIPLY = 4;\n    Engine._ALPHA_MAXIMIZED = 5;\n    Engine._ALPHA_ONEONE = 6;\n    Engine._ALPHA_PREMULTIPLIED = 7;\n    Engine._ALPHA_PREMULTIPLIED_PORTERDUFF = 8;\n    Engine._ALPHA_INTERPOLATE = 9;\n    Engine._ALPHA_SCREENMODE = 10;\n    Engine._DELAYLOADSTATE_NONE = 0;\n    Engine._DELAYLOADSTATE_LOADED = 1;\n    Engine._DELAYLOADSTATE_LOADING = 2;\n    Engine._DELAYLOADSTATE_NOTLOADED = 4;\n    Engine._TEXTUREFORMAT_ALPHA = 0;\n    Engine._TEXTUREFORMAT_LUMINANCE = 1;\n    Engine._TEXTUREFORMAT_LUMINANCE_ALPHA = 2;\n    Engine._TEXTUREFORMAT_RGB = 4;\n    Engine._TEXTUREFORMAT_RGBA = 5;\n    Engine._TEXTURETYPE_UNSIGNED_INT = 0;\n    Engine._TEXTURETYPE_FLOAT = 1;\n    Engine._TEXTURETYPE_HALF_FLOAT = 2;\n    // Depht or Stencil test Constants.\n    Engine._NEVER = 0x0200; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn.\n    Engine._ALWAYS = 0x0207; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn.\n    Engine._LESS = 0x0201; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value.\n    Engine._EQUAL = 0x0202; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value.\n    Engine._LEQUAL = 0x0203; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value.\n    Engine._GREATER = 0x0204; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value.\n    Engine._GEQUAL = 0x0206; //\tPassed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value.\n    Engine._NOTEQUAL = 0x0205; //  Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value.\n    // Stencil Actions Constants.\n    Engine._KEEP = 0x1E00;\n    Engine._REPLACE = 0x1E01;\n    Engine._INCR = 0x1E02;\n    Engine._DECR = 0x1E03;\n    Engine._INVERT = 0x150A;\n    Engine._INCR_WRAP = 0x8507;\n    Engine._DECR_WRAP = 0x8508;\n    // Texture rescaling mode\n    Engine._SCALEMODE_FLOOR = 1;\n    Engine._SCALEMODE_NEAREST = 2;\n    Engine._SCALEMODE_CEILING = 3;\n    // Updatable statics so stick with vars here\n    Engine.CollisionsEpsilon = 0.001;\n    Engine.CodeRepository = \"src/\";\n    Engine.ShadersRepository = \"src/Shaders/\";\n    BABYLON.Engine = Engine;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.engine.js.map\n\n/// <reference path=\"Tools\\babylon.decorators.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * Node is the basic class for all scene objects (Mesh, Light Camera).\n     */\n    var Node = (function () {\n        /**\n         * @constructor\n         * @param {string} name - the name and id to be given to this node\n         * @param {BABYLON.Scene} the scene this node will be added to\n         */\n        function Node(name, scene) {\n            this.state = \"\";\n            this.metadata = null;\n            this.doNotSerialize = false;\n            this.animations = new Array();\n            this._ranges = {};\n            this._childrenFlag = -1;\n            this._isEnabled = true;\n            this._isReady = true;\n            this._currentRenderId = -1;\n            this._parentRenderId = -1;\n            /**\n            * An event triggered when the mesh is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            this.name = name;\n            this.id = name;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._initCache();\n        }\n        Object.defineProperty(Node.prototype, \"parent\", {\n            get: function () {\n                return this._parentNode;\n            },\n            set: function (parent) {\n                if (this._parentNode === parent) {\n                    return;\n                }\n                if (this._parentNode) {\n                    var index = this._parentNode._children.indexOf(this);\n                    if (index !== -1) {\n                        this._parentNode._children.splice(index, 1);\n                    }\n                }\n                this._parentNode = parent;\n                if (this._parentNode) {\n                    if (!this._parentNode._children) {\n                        this._parentNode._children = new Array();\n                    }\n                    this._parentNode._children.push(this);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Node.prototype.getClassName = function () {\n            return \"Node\";\n        };\n        Object.defineProperty(Node.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Node.prototype.getScene = function () {\n            return this._scene;\n        };\n        Node.prototype.getEngine = function () {\n            return this._scene.getEngine();\n        };\n        // override it in derived class\n        Node.prototype.getWorldMatrix = function () {\n            return BABYLON.Matrix.Identity();\n        };\n        // override it in derived class if you add new variables to the cache\n        // and call the parent class method\n        Node.prototype._initCache = function () {\n            this._cache = {};\n            this._cache.parent = undefined;\n        };\n        Node.prototype.updateCache = function (force) {\n            if (!force && this.isSynchronized())\n                return;\n            this._cache.parent = this.parent;\n            this._updateCache();\n        };\n        // override it in derived class if you add new variables to the cache\n        // and call the parent class method if !ignoreParentClass\n        Node.prototype._updateCache = function (ignoreParentClass) {\n        };\n        // override it in derived class if you add new variables to the cache\n        Node.prototype._isSynchronized = function () {\n            return true;\n        };\n        Node.prototype._markSyncedWithParent = function () {\n            this._parentRenderId = this.parent._currentRenderId;\n        };\n        Node.prototype.isSynchronizedWithParent = function () {\n            if (!this.parent) {\n                return true;\n            }\n            if (this._parentRenderId !== this.parent._currentRenderId) {\n                return false;\n            }\n            return this.parent.isSynchronized();\n        };\n        Node.prototype.isSynchronized = function (updateCache) {\n            var check = this.hasNewParent();\n            check = check || !this.isSynchronizedWithParent();\n            check = check || !this._isSynchronized();\n            if (updateCache)\n                this.updateCache(true);\n            return !check;\n        };\n        Node.prototype.hasNewParent = function (update) {\n            if (this._cache.parent === this.parent)\n                return false;\n            if (update)\n                this._cache.parent = this.parent;\n            return true;\n        };\n        /**\n         * Is this node ready to be used/rendered\n         * @return {boolean} is it ready\n         */\n        Node.prototype.isReady = function () {\n            return this._isReady;\n        };\n        /**\n         * Is this node enabled.\n         * If the node has a parent and is enabled, the parent will be inspected as well.\n         * @return {boolean} whether this node (and its parent) is enabled.\n         * @see setEnabled\n         */\n        Node.prototype.isEnabled = function () {\n            if (!this._isEnabled) {\n                return false;\n            }\n            if (this.parent) {\n                return this.parent.isEnabled();\n            }\n            return true;\n        };\n        /**\n         * Set the enabled state of this node.\n         * @param {boolean} value - the new enabled state\n         * @see isEnabled\n         */\n        Node.prototype.setEnabled = function (value) {\n            this._isEnabled = value;\n        };\n        /**\n         * Is this node a descendant of the given node.\n         * The function will iterate up the hierarchy until the ancestor was found or no more parents defined.\n         * @param {BABYLON.Node} ancestor - The parent node to inspect\n         * @see parent\n         */\n        Node.prototype.isDescendantOf = function (ancestor) {\n            if (this.parent) {\n                if (this.parent === ancestor) {\n                    return true;\n                }\n                return this.parent.isDescendantOf(ancestor);\n            }\n            return false;\n        };\n        /**\n         * Evaluate the list of children and determine if they should be considered as descendants considering the given criterias\n         * @param {BABYLON.Node[]} results the result array containing the nodes matching the given criterias\n         * @param {boolean} directDescendantsOnly if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered.\n         * @param predicate: an optional predicate that will be called on every evaluated children, the predicate must return true for a given child to be part of the result, otherwise it will be ignored.\n         */\n        Node.prototype._getDescendants = function (results, directDescendantsOnly, predicate) {\n            if (directDescendantsOnly === void 0) { directDescendantsOnly = false; }\n            if (!this._children) {\n                return;\n            }\n            for (var index = 0; index < this._children.length; index++) {\n                var item = this._children[index];\n                if (!predicate || predicate(item)) {\n                    results.push(item);\n                }\n                if (!directDescendantsOnly) {\n                    item._getDescendants(results, false, predicate);\n                }\n            }\n        };\n        /**\n         * Will return all nodes that have this node as ascendant.\n         * @param {boolean} directDescendantsOnly if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered.\n         * @param predicate: an optional predicate that will be called on every evaluated children, the predicate must return true for a given child to be part of the result, otherwise it will be ignored.\n         * @return {BABYLON.Node[]} all children nodes of all types.\n         */\n        Node.prototype.getDescendants = function (directDescendantsOnly, predicate) {\n            var results = [];\n            this._getDescendants(results, directDescendantsOnly, predicate);\n            return results;\n        };\n        /**\n         * Get all child-meshes of this node.\n         */\n        Node.prototype.getChildMeshes = function (directDecendantsOnly, predicate) {\n            var results = [];\n            this._getDescendants(results, directDecendantsOnly, function (node) {\n                return ((!predicate || predicate(node)) && (node instanceof BABYLON.AbstractMesh));\n            });\n            return results;\n        };\n        /**\n         * Get all direct children of this node.\n        */\n        Node.prototype.getChildren = function (predicate) {\n            return this.getDescendants(true, predicate);\n        };\n        Node.prototype._setReady = function (state) {\n            if (state === this._isReady) {\n                return;\n            }\n            if (!state) {\n                this._isReady = false;\n                return;\n            }\n            this._isReady = true;\n            if (this.onReady) {\n                this.onReady(this);\n            }\n        };\n        Node.prototype.getAnimationByName = function (name) {\n            for (var i = 0; i < this.animations.length; i++) {\n                var animation = this.animations[i];\n                if (animation.name === name) {\n                    return animation;\n                }\n            }\n            return null;\n        };\n        Node.prototype.createAnimationRange = function (name, from, to) {\n            // check name not already in use\n            if (!this._ranges[name]) {\n                this._ranges[name] = new BABYLON.AnimationRange(name, from, to);\n                for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {\n                    if (this.animations[i]) {\n                        this.animations[i].createRange(name, from, to);\n                    }\n                }\n            }\n        };\n        Node.prototype.deleteAnimationRange = function (name, deleteFrames) {\n            if (deleteFrames === void 0) { deleteFrames = true; }\n            for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {\n                if (this.animations[i]) {\n                    this.animations[i].deleteRange(name, deleteFrames);\n                }\n            }\n            this._ranges[name] = undefined; // said much faster than 'delete this._range[name]' \n        };\n        Node.prototype.getAnimationRange = function (name) {\n            return this._ranges[name];\n        };\n        Node.prototype.beginAnimation = function (name, loop, speedRatio, onAnimationEnd) {\n            var range = this.getAnimationRange(name);\n            if (!range) {\n                return null;\n            }\n            this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n        };\n        Node.prototype.serializeAnimationRanges = function () {\n            var serializationRanges = [];\n            for (var name in this._ranges) {\n                var range = {};\n                range.name = name;\n                range.from = this._ranges[name].from;\n                range.to = this._ranges[name].to;\n                serializationRanges.push(range);\n            }\n            return serializationRanges;\n        };\n        Node.prototype.dispose = function () {\n            this.parent = null;\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n        };\n        Node.ParseAnimationRanges = function (node, parsedNode, scene) {\n            if (parsedNode.ranges) {\n                for (var index = 0; index < parsedNode.ranges.length; index++) {\n                    var data = parsedNode.ranges[index];\n                    node.createAnimationRange(data.name, data.from, data.to);\n                }\n            }\n        };\n        return Node;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], Node.prototype, \"name\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Node.prototype, \"id\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Node.prototype, \"uniqueId\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Node.prototype, \"state\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Node.prototype, \"metadata\", void 0);\n    BABYLON.Node = Node;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.node.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var BoundingSphere = (function () {\n        function BoundingSphere(minimum, maximum) {\n            this.minimum = minimum;\n            this.maximum = maximum;\n            this._tempRadiusVector = BABYLON.Vector3.Zero();\n            var distance = BABYLON.Vector3.Distance(minimum, maximum);\n            this.center = BABYLON.Vector3.Lerp(minimum, maximum, 0.5);\n            this.radius = distance * 0.5;\n            this.centerWorld = BABYLON.Vector3.Zero();\n            this._update(BABYLON.Matrix.Identity());\n        }\n        // Methods\n        BoundingSphere.prototype._update = function (world) {\n            BABYLON.Vector3.TransformCoordinatesToRef(this.center, world, this.centerWorld);\n            BABYLON.Vector3.TransformNormalFromFloatsToRef(1.0, 1.0, 1.0, world, this._tempRadiusVector);\n            this.radiusWorld = Math.max(Math.abs(this._tempRadiusVector.x), Math.abs(this._tempRadiusVector.y), Math.abs(this._tempRadiusVector.z)) * this.radius;\n        };\n        BoundingSphere.prototype.isInFrustum = function (frustumPlanes) {\n            for (var i = 0; i < 6; i++) {\n                if (frustumPlanes[i].dotCoordinate(this.centerWorld) <= -this.radiusWorld)\n                    return false;\n            }\n            return true;\n        };\n        BoundingSphere.prototype.intersectsPoint = function (point) {\n            var x = this.centerWorld.x - point.x;\n            var y = this.centerWorld.y - point.y;\n            var z = this.centerWorld.z - point.z;\n            var distance = Math.sqrt((x * x) + (y * y) + (z * z));\n            if (Math.abs(this.radiusWorld - distance) < BABYLON.Epsilon)\n                return false;\n            return true;\n        };\n        // Statics\n        BoundingSphere.Intersects = function (sphere0, sphere1) {\n            var x = sphere0.centerWorld.x - sphere1.centerWorld.x;\n            var y = sphere0.centerWorld.y - sphere1.centerWorld.y;\n            var z = sphere0.centerWorld.z - sphere1.centerWorld.z;\n            var distance = Math.sqrt((x * x) + (y * y) + (z * z));\n            if (sphere0.radiusWorld + sphere1.radiusWorld < distance)\n                return false;\n            return true;\n        };\n        return BoundingSphere;\n    }());\n    BABYLON.BoundingSphere = BoundingSphere;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boundingSphere.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var BoundingBox = (function () {\n        function BoundingBox(minimum, maximum) {\n            this.minimum = minimum;\n            this.maximum = maximum;\n            this.vectors = new Array();\n            this.vectorsWorld = new Array();\n            // Bounding vectors\n            this.vectors.push(this.minimum.clone());\n            this.vectors.push(this.maximum.clone());\n            this.vectors.push(this.minimum.clone());\n            this.vectors[2].x = this.maximum.x;\n            this.vectors.push(this.minimum.clone());\n            this.vectors[3].y = this.maximum.y;\n            this.vectors.push(this.minimum.clone());\n            this.vectors[4].z = this.maximum.z;\n            this.vectors.push(this.maximum.clone());\n            this.vectors[5].z = this.minimum.z;\n            this.vectors.push(this.maximum.clone());\n            this.vectors[6].x = this.minimum.x;\n            this.vectors.push(this.maximum.clone());\n            this.vectors[7].y = this.minimum.y;\n            // OBB\n            this.center = this.maximum.add(this.minimum).scale(0.5);\n            this.extendSize = this.maximum.subtract(this.minimum).scale(0.5);\n            this.directions = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n            // World\n            for (var index = 0; index < this.vectors.length; index++) {\n                this.vectorsWorld[index] = BABYLON.Vector3.Zero();\n            }\n            this.minimumWorld = BABYLON.Vector3.Zero();\n            this.maximumWorld = BABYLON.Vector3.Zero();\n            this.centerWorld = BABYLON.Vector3.Zero();\n            this.extendSizeWorld = BABYLON.Vector3.Zero();\n            this._update(BABYLON.Matrix.Identity());\n        }\n        // Methods\n        BoundingBox.prototype.getWorldMatrix = function () {\n            return this._worldMatrix;\n        };\n        BoundingBox.prototype.setWorldMatrix = function (matrix) {\n            this._worldMatrix.copyFrom(matrix);\n            return this;\n        };\n        BoundingBox.prototype._update = function (world) {\n            BABYLON.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimumWorld);\n            BABYLON.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximumWorld);\n            for (var index = 0; index < this.vectors.length; index++) {\n                var v = this.vectorsWorld[index];\n                BABYLON.Vector3.TransformCoordinatesToRef(this.vectors[index], world, v);\n                if (v.x < this.minimumWorld.x)\n                    this.minimumWorld.x = v.x;\n                if (v.y < this.minimumWorld.y)\n                    this.minimumWorld.y = v.y;\n                if (v.z < this.minimumWorld.z)\n                    this.minimumWorld.z = v.z;\n                if (v.x > this.maximumWorld.x)\n                    this.maximumWorld.x = v.x;\n                if (v.y > this.maximumWorld.y)\n                    this.maximumWorld.y = v.y;\n                if (v.z > this.maximumWorld.z)\n                    this.maximumWorld.z = v.z;\n            }\n            // Extend\n            this.maximumWorld.subtractToRef(this.minimumWorld, this.extendSizeWorld);\n            this.extendSizeWorld.scaleInPlace(0.5);\n            // OBB\n            this.maximumWorld.addToRef(this.minimumWorld, this.centerWorld);\n            this.centerWorld.scaleInPlace(0.5);\n            BABYLON.Vector3.FromFloatArrayToRef(world.m, 0, this.directions[0]);\n            BABYLON.Vector3.FromFloatArrayToRef(world.m, 4, this.directions[1]);\n            BABYLON.Vector3.FromFloatArrayToRef(world.m, 8, this.directions[2]);\n            this._worldMatrix = world;\n        };\n        BoundingBox.prototype.isInFrustum = function (frustumPlanes) {\n            return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);\n        };\n        BoundingBox.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n            return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);\n        };\n        BoundingBox.prototype.intersectsPoint = function (point) {\n            var delta = -BABYLON.Epsilon;\n            if (this.maximumWorld.x - point.x < delta || delta > point.x - this.minimumWorld.x)\n                return false;\n            if (this.maximumWorld.y - point.y < delta || delta > point.y - this.minimumWorld.y)\n                return false;\n            if (this.maximumWorld.z - point.z < delta || delta > point.z - this.minimumWorld.z)\n                return false;\n            return true;\n        };\n        BoundingBox.prototype.intersectsSphere = function (sphere) {\n            return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);\n        };\n        BoundingBox.prototype.intersectsMinMax = function (min, max) {\n            if (this.maximumWorld.x < min.x || this.minimumWorld.x > max.x)\n                return false;\n            if (this.maximumWorld.y < min.y || this.minimumWorld.y > max.y)\n                return false;\n            if (this.maximumWorld.z < min.z || this.minimumWorld.z > max.z)\n                return false;\n            return true;\n        };\n        // Statics\n        BoundingBox.Intersects = function (box0, box1) {\n            if (box0.maximumWorld.x < box1.minimumWorld.x || box0.minimumWorld.x > box1.maximumWorld.x)\n                return false;\n            if (box0.maximumWorld.y < box1.minimumWorld.y || box0.minimumWorld.y > box1.maximumWorld.y)\n                return false;\n            if (box0.maximumWorld.z < box1.minimumWorld.z || box0.minimumWorld.z > box1.maximumWorld.z)\n                return false;\n            return true;\n        };\n        BoundingBox.IntersectsSphere = function (minPoint, maxPoint, sphereCenter, sphereRadius) {\n            var vector = BABYLON.Vector3.Clamp(sphereCenter, minPoint, maxPoint);\n            var num = BABYLON.Vector3.DistanceSquared(sphereCenter, vector);\n            return (num <= (sphereRadius * sphereRadius));\n        };\n        BoundingBox.IsCompletelyInFrustum = function (boundingVectors, frustumPlanes) {\n            for (var p = 0; p < 6; p++) {\n                for (var i = 0; i < 8; i++) {\n                    if (frustumPlanes[p].dotCoordinate(boundingVectors[i]) < 0) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        BoundingBox.IsInFrustum = function (boundingVectors, frustumPlanes) {\n            for (var p = 0; p < 6; p++) {\n                var inCount = 8;\n                for (var i = 0; i < 8; i++) {\n                    if (frustumPlanes[p].dotCoordinate(boundingVectors[i]) < 0) {\n                        --inCount;\n                    }\n                    else {\n                        break;\n                    }\n                }\n                if (inCount === 0)\n                    return false;\n            }\n            return true;\n        };\n        return BoundingBox;\n    }());\n    BABYLON.BoundingBox = BoundingBox;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boundingBox.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var computeBoxExtents = function (axis, box) {\n        var p = BABYLON.Vector3.Dot(box.centerWorld, axis);\n        var r0 = Math.abs(BABYLON.Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n        var r1 = Math.abs(BABYLON.Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n        var r2 = Math.abs(BABYLON.Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n        var r = r0 + r1 + r2;\n        return {\n            min: p - r,\n            max: p + r\n        };\n    };\n    var extentsOverlap = function (min0, max0, min1, max1) { return !(min0 > max1 || min1 > max0); };\n    var axisOverlap = function (axis, box0, box1) {\n        var result0 = computeBoxExtents(axis, box0);\n        var result1 = computeBoxExtents(axis, box1);\n        return extentsOverlap(result0.min, result0.max, result1.min, result1.max);\n    };\n    var BoundingInfo = (function () {\n        function BoundingInfo(minimum, maximum) {\n            this.minimum = minimum;\n            this.maximum = maximum;\n            this._isLocked = false;\n            this.boundingBox = new BABYLON.BoundingBox(minimum, maximum);\n            this.boundingSphere = new BABYLON.BoundingSphere(minimum, maximum);\n        }\n        Object.defineProperty(BoundingInfo.prototype, \"isLocked\", {\n            get: function () {\n                return this._isLocked;\n            },\n            set: function (value) {\n                this._isLocked = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        BoundingInfo.prototype.update = function (world) {\n            if (this._isLocked) {\n                return;\n            }\n            this.boundingBox._update(world);\n            this.boundingSphere._update(world);\n        };\n        BoundingInfo.prototype.isInFrustum = function (frustumPlanes) {\n            if (!this.boundingSphere.isInFrustum(frustumPlanes))\n                return false;\n            return this.boundingBox.isInFrustum(frustumPlanes);\n        };\n        BoundingInfo.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n            return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n        };\n        BoundingInfo.prototype._checkCollision = function (collider) {\n            return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n        };\n        BoundingInfo.prototype.intersectsPoint = function (point) {\n            if (!this.boundingSphere.centerWorld) {\n                return false;\n            }\n            if (!this.boundingSphere.intersectsPoint(point)) {\n                return false;\n            }\n            if (!this.boundingBox.intersectsPoint(point)) {\n                return false;\n            }\n            return true;\n        };\n        BoundingInfo.prototype.intersects = function (boundingInfo, precise) {\n            if (!this.boundingSphere.centerWorld || !boundingInfo.boundingSphere.centerWorld) {\n                return false;\n            }\n            if (!BABYLON.BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n                return false;\n            }\n            if (!BABYLON.BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n                return false;\n            }\n            if (!precise) {\n                return true;\n            }\n            var box0 = this.boundingBox;\n            var box1 = boundingInfo.boundingBox;\n            if (!axisOverlap(box0.directions[0], box0, box1))\n                return false;\n            if (!axisOverlap(box0.directions[1], box0, box1))\n                return false;\n            if (!axisOverlap(box0.directions[2], box0, box1))\n                return false;\n            if (!axisOverlap(box1.directions[0], box0, box1))\n                return false;\n            if (!axisOverlap(box1.directions[1], box0, box1))\n                return false;\n            if (!axisOverlap(box1.directions[2], box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1))\n                return false;\n            if (!axisOverlap(BABYLON.Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1))\n                return false;\n            return true;\n        };\n        return BoundingInfo;\n    }());\n    BABYLON.BoundingInfo = BoundingInfo;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boundingInfo.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var AbstractMesh = (function (_super) {\n        __extends(AbstractMesh, _super);\n        // Constructor\n        function AbstractMesh(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._facetNb = 0; // facet number\n            _this._partitioningSubdivisions = 10; // number of subdivisions per axis in the partioning space  \n            _this._partitioningBBoxRatio = 1.01; // the partioning array space is by default 1% bigger than the bounding box\n            _this._facetDataEnabled = false; // is the facet data feature enabled on this mesh ?\n            _this._facetParameters = {}; // keep a reference to the object parameters to avoid memory re-allocation\n            _this._bbSize = BABYLON.Vector3.Zero(); // bbox size approximated for facet data\n            _this._subDiv = {\n                max: 1,\n                X: 1,\n                Y: 1,\n                Z: 1\n            };\n            // Events\n            /**\n            * An event triggered when this mesh collides with another one\n            * @type {BABYLON.Observable}\n            */\n            _this.onCollideObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the collision's position changes\n            * @type {BABYLON.Observable}\n            */\n            _this.onCollisionPositionChangeObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after the world matrix is updated\n            * @type {BABYLON.Observable}\n            */\n            _this.onAfterWorldMatrixUpdateObservable = new BABYLON.Observable();\n            // Properties\n            _this.definedFacingForward = true; // orientation for POV movement & rotation\n            _this.position = BABYLON.Vector3.Zero();\n            _this._rotation = BABYLON.Vector3.Zero();\n            _this._scaling = BABYLON.Vector3.One();\n            _this.billboardMode = AbstractMesh.BILLBOARDMODE_NONE;\n            _this.visibility = 1.0;\n            _this.alphaIndex = Number.MAX_VALUE;\n            _this.infiniteDistance = false;\n            _this.isVisible = true;\n            _this.isPickable = true;\n            _this.showBoundingBox = false;\n            _this.showSubMeshesBoundingBox = false;\n            _this.isBlocker = false;\n            _this.renderingGroupId = 0;\n            _this._receiveShadows = false;\n            _this.renderOutline = false;\n            _this.outlineColor = BABYLON.Color3.Red();\n            _this.outlineWidth = 0.02;\n            _this.renderOverlay = false;\n            _this.overlayColor = BABYLON.Color3.Red();\n            _this.overlayAlpha = 0.5;\n            _this._hasVertexAlpha = false;\n            _this._useVertexColors = true;\n            _this._computeBonesUsingShaders = true;\n            _this._numBoneInfluencers = 4;\n            _this._applyFog = true;\n            _this.scalingDeterminant = 1;\n            _this.useOctreeForRenderingSelection = true;\n            _this.useOctreeForPicking = true;\n            _this.useOctreeForCollisions = true;\n            _this.layerMask = 0x0FFFFFFF;\n            /**\n             * True if the mesh must be rendered in any case.\n             */\n            _this.alwaysSelectAsActiveMesh = false;\n            // Collisions\n            _this._checkCollisions = false;\n            _this._collisionMask = -1;\n            _this._collisionGroup = -1;\n            _this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);\n            _this.ellipsoidOffset = new BABYLON.Vector3(0, 0, 0);\n            _this._oldPositionForCollisions = new BABYLON.Vector3(0, 0, 0);\n            _this._diffPositionForCollisions = new BABYLON.Vector3(0, 0, 0);\n            _this._newPositionForCollisions = new BABYLON.Vector3(0, 0, 0);\n            // Edges\n            _this.edgesWidth = 1;\n            _this.edgesColor = new BABYLON.Color4(1, 0, 0, 1);\n            // Cache\n            _this._localWorld = BABYLON.Matrix.Zero();\n            _this._worldMatrix = BABYLON.Matrix.Zero();\n            _this._absolutePosition = BABYLON.Vector3.Zero();\n            _this._collisionsTransformMatrix = BABYLON.Matrix.Zero();\n            _this._collisionsScalingMatrix = BABYLON.Matrix.Zero();\n            _this._isDirty = false;\n            _this._pivotMatrix = BABYLON.Matrix.Identity();\n            _this._isDisposed = false;\n            _this._renderId = 0;\n            _this._intersectionsInProgress = new Array();\n            _this._isWorldMatrixFrozen = false;\n            _this._unIndexed = false;\n            _this._lightSources = new Array();\n            _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n                if (collidedMesh === void 0) { collidedMesh = null; }\n                //TODO move this to the collision coordinator!\n                if (_this.getScene().workerCollisions)\n                    newPosition.multiplyInPlace(_this._collider.radius);\n                newPosition.subtractToRef(_this._oldPositionForCollisions, _this._diffPositionForCollisions);\n                if (_this._diffPositionForCollisions.length() > BABYLON.Engine.CollisionsEpsilon) {\n                    _this.position.addInPlace(_this._diffPositionForCollisions);\n                }\n                if (collidedMesh) {\n                    _this.onCollideObservable.notifyObservers(collidedMesh);\n                }\n                _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);\n            };\n            _this.getScene().addMesh(_this);\n            _this._resyncLightSources();\n            return _this;\n        }\n        Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_NONE\", {\n            get: function () {\n                return AbstractMesh._BILLBOARDMODE_NONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_X\", {\n            get: function () {\n                return AbstractMesh._BILLBOARDMODE_X;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Y\", {\n            get: function () {\n                return AbstractMesh._BILLBOARDMODE_Y;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_Z\", {\n            get: function () {\n                return AbstractMesh._BILLBOARDMODE_Z;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh, \"BILLBOARDMODE_ALL\", {\n            get: function () {\n                return AbstractMesh._BILLBOARDMODE_ALL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"facetNb\", {\n            /**\n             * Read-only : the number of facets in the mesh\n             */\n            get: function () {\n                return this._facetNb;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"partitioningSubdivisions\", {\n            /**\n             * The number (integer) of subdivisions per axis in the partioning space\n             */\n            get: function () {\n                return this._partitioningSubdivisions;\n            },\n            set: function (nb) {\n                this._partitioningSubdivisions = nb;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"partitioningBBoxRatio\", {\n            /**\n             * The ratio (float) to apply to the bouding box size to set to the partioning space.\n             * Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box.\n             */\n            get: function () {\n                return this._partitioningBBoxRatio;\n            },\n            set: function (ratio) {\n                this._partitioningBBoxRatio = ratio;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"isFacetDataEnabled\", {\n            /**\n             * Read-only boolean : is the feature facetData enabled ?\n             */\n            get: function () {\n                return this._facetDataEnabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"onCollide\", {\n            set: function (callback) {\n                if (this._onCollideObserver) {\n                    this.onCollideObservable.remove(this._onCollideObserver);\n                }\n                this._onCollideObserver = this.onCollideObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"onCollisionPositionChange\", {\n            set: function (callback) {\n                if (this._onCollisionPositionChangeObserver) {\n                    this.onCollisionPositionChangeObservable.remove(this._onCollisionPositionChangeObserver);\n                }\n                this._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"material\", {\n            get: function () {\n                return this._material;\n            },\n            set: function (value) {\n                if (this._material === value) {\n                    return;\n                }\n                this._material = value;\n                if (!this.subMeshes) {\n                    return;\n                }\n                for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n                    var subMesh = _a[_i];\n                    subMesh.setEffect(null);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"receiveShadows\", {\n            get: function () {\n                return this._receiveShadows;\n            },\n            set: function (value) {\n                if (this._receiveShadows === value) {\n                    return;\n                }\n                this._receiveShadows = value;\n                this._markSubMeshesAsLightDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"hasVertexAlpha\", {\n            get: function () {\n                return this._hasVertexAlpha;\n            },\n            set: function (value) {\n                if (this._hasVertexAlpha === value) {\n                    return;\n                }\n                this._hasVertexAlpha = value;\n                this._markSubMeshesAsAttributesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"useVertexColors\", {\n            get: function () {\n                return this._useVertexColors;\n            },\n            set: function (value) {\n                if (this._useVertexColors === value) {\n                    return;\n                }\n                this._useVertexColors = value;\n                this._markSubMeshesAsAttributesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"computeBonesUsingShaders\", {\n            get: function () {\n                return this._computeBonesUsingShaders;\n            },\n            set: function (value) {\n                if (this._computeBonesUsingShaders === value) {\n                    return;\n                }\n                this._computeBonesUsingShaders = value;\n                this._markSubMeshesAsAttributesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"numBoneInfluencers\", {\n            get: function () {\n                return this._numBoneInfluencers;\n            },\n            set: function (value) {\n                if (this._numBoneInfluencers === value) {\n                    return;\n                }\n                this._numBoneInfluencers = value;\n                this._markSubMeshesAsAttributesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"applyFog\", {\n            get: function () {\n                return this._applyFog;\n            },\n            set: function (value) {\n                if (this._applyFog === value) {\n                    return;\n                }\n                this._applyFog = value;\n                this._markSubMeshesAsMiscDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"collisionMask\", {\n            get: function () {\n                return this._collisionMask;\n            },\n            set: function (mask) {\n                this._collisionMask = !isNaN(mask) ? mask : -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"collisionGroup\", {\n            get: function () {\n                return this._collisionGroup;\n            },\n            set: function (mask) {\n                this._collisionGroup = !isNaN(mask) ? mask : -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"_positions\", {\n            get: function () {\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"skeleton\", {\n            get: function () {\n                return this._skeleton;\n            },\n            set: function (value) {\n                if (this._skeleton && this._skeleton.needInitialSkinMatrix) {\n                    this._skeleton._unregisterMeshWithPoseMatrix(this);\n                }\n                if (value && value.needInitialSkinMatrix) {\n                    value._registerMeshWithPoseMatrix(this);\n                }\n                this._skeleton = value;\n                if (!this._skeleton) {\n                    this._bonesTransformMatrices = null;\n                }\n                this._markSubMeshesAsAttributesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the string \"AbstractMesh\"\n         */\n        AbstractMesh.prototype.getClassName = function () {\n            return \"AbstractMesh\";\n        };\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        AbstractMesh.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name + \", isInstance: \" + (this instanceof BABYLON.InstancedMesh ? \"YES\" : \"NO\");\n            ret += \", # of submeshes: \" + (this.subMeshes ? this.subMeshes.length : 0);\n            if (this._skeleton) {\n                ret += \", skeleton: \" + this._skeleton.name;\n            }\n            if (fullDetails) {\n                ret += \", billboard mode: \" + ([\"NONE\", \"X\", \"Y\", null, \"Z\", null, null, \"ALL\"])[this.billboardMode];\n                ret += \", freeze wrld mat: \" + (this._isWorldMatrixFrozen || this._waitingFreezeWorldMatrix ? \"YES\" : \"NO\");\n            }\n            return ret;\n        };\n        AbstractMesh.prototype._resyncLightSources = function () {\n            this._lightSources.length = 0;\n            for (var _i = 0, _a = this.getScene().lights; _i < _a.length; _i++) {\n                var light = _a[_i];\n                if (!light.isEnabled()) {\n                    continue;\n                }\n                if (light.canAffectMesh(this)) {\n                    this._lightSources.push(light);\n                }\n            }\n            this._markSubMeshesAsLightDirty();\n        };\n        AbstractMesh.prototype._resyncLighSource = function (light) {\n            var isIn = light.isEnabled() && light.canAffectMesh(this);\n            var index = this._lightSources.indexOf(light);\n            if (index === -1) {\n                if (!isIn) {\n                    return;\n                }\n                this._lightSources.push(light);\n            }\n            else {\n                if (isIn) {\n                    return;\n                }\n                this._lightSources.splice(index, 1);\n            }\n            this._markSubMeshesAsLightDirty();\n        };\n        AbstractMesh.prototype._removeLightSource = function (light) {\n            var index = this._lightSources.indexOf(light);\n            if (index === -1) {\n                return;\n            }\n            this._lightSources.splice(index, 1);\n        };\n        AbstractMesh.prototype._markSubMeshesAsDirty = function (func) {\n            if (!this.subMeshes) {\n                return;\n            }\n            for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n                var subMesh = _a[_i];\n                if (subMesh._materialDefines) {\n                    func(subMesh._materialDefines);\n                }\n            }\n        };\n        AbstractMesh.prototype._markSubMeshesAsLightDirty = function () {\n            this._markSubMeshesAsDirty(function (defines) { return defines.markAsLightDirty(); });\n        };\n        AbstractMesh.prototype._markSubMeshesAsAttributesDirty = function () {\n            this._markSubMeshesAsDirty(function (defines) { return defines.markAsAttributesDirty(); });\n        };\n        AbstractMesh.prototype._markSubMeshesAsMiscDirty = function () {\n            if (!this.subMeshes) {\n                return;\n            }\n            for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n                var subMesh = _a[_i];\n                var material = subMesh.getMaterial();\n                if (material) {\n                    material.markAsDirty(BABYLON.Material.MiscDirtyFlag);\n                }\n            }\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"rotation\", {\n            /**\n             * Rotation property : a Vector3 depicting the rotation value in radians around each local axis X, Y, Z.\n             * If rotation quaternion is set, this Vector3 will (almost always) be the Zero vector!\n             * Default : (0.0, 0.0, 0.0)\n             */\n            get: function () {\n                return this._rotation;\n            },\n            set: function (newRotation) {\n                this._rotation = newRotation;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"scaling\", {\n            /**\n             * Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.\n             * Default : (1.0, 1.0, 1.0)\n             */\n            get: function () {\n                return this._scaling;\n            },\n            set: function (newScaling) {\n                this._scaling = newScaling;\n                if (this.physicsImpostor) {\n                    this.physicsImpostor.forceUpdate();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"rotationQuaternion\", {\n            /**\n             * Rotation Quaternion property : this a Quaternion object depicting the mesh rotation by using a unit quaternion.\n             * It's null by default.\n             * If set, only the rotationQuaternion is then used to compute the mesh rotation and its property `.rotation\\ is then ignored and set to (0.0, 0.0, 0.0)\n             */\n            get: function () {\n                return this._rotationQuaternion;\n            },\n            set: function (quaternion) {\n                this._rotationQuaternion = quaternion;\n                //reset the rotation vector. \n                if (quaternion && this.rotation.length()) {\n                    this.rotation.copyFromFloats(0.0, 0.0, 0.0);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        /**\n         * Copies the paramater passed Matrix into the mesh Pose matrix.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.updatePoseMatrix = function (matrix) {\n            this._poseMatrix.copyFrom(matrix);\n            return this;\n        };\n        /**\n         * Returns the mesh Pose matrix.\n         * Returned object : Matrix\n         */\n        AbstractMesh.prototype.getPoseMatrix = function () {\n            return this._poseMatrix;\n        };\n        /**\n         * Disables the mesh edger rendering mode.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.disableEdgesRendering = function () {\n            if (this._edgesRenderer !== undefined) {\n                this._edgesRenderer.dispose();\n                this._edgesRenderer = undefined;\n            }\n            return this;\n        };\n        /**\n         * Enables the edge rendering mode on the mesh.\n         * This mode makes the mesh edges visible.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.enableEdgesRendering = function (epsilon, checkVerticesInsteadOfIndices) {\n            if (epsilon === void 0) { epsilon = 0.95; }\n            if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n            this.disableEdgesRendering();\n            this._edgesRenderer = new BABYLON.EdgesRenderer(this, epsilon, checkVerticesInsteadOfIndices);\n            return this;\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"isBlocked\", {\n            /**\n             * Returns true if the mesh is blocked. Used by the class Mesh.\n             * Returns the boolean `false` by default.\n             */\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the mesh itself by default, used by the class Mesh.\n         * Returned type : AbstractMesh\n         */\n        AbstractMesh.prototype.getLOD = function (camera) {\n            return this;\n        };\n        /**\n         * Returns 0 by default, used by the class Mesh.\n         * Returns an integer.\n         */\n        AbstractMesh.prototype.getTotalVertices = function () {\n            return 0;\n        };\n        /**\n         * Returns null by default, used by the class Mesh.\n         * Returned type : integer array\n         */\n        AbstractMesh.prototype.getIndices = function () {\n            return null;\n        };\n        /**\n         * Returns the array of the requested vertex data kind. Used by the class Mesh. Returns null here.\n         * Returned type : float array or Float32Array\n         */\n        AbstractMesh.prototype.getVerticesData = function (kind) {\n            return null;\n        };\n        /**\n         * Sets the vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n         * The `data` are either a numeric array either a Float32Array.\n         * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\n         * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n         * Note that a new underlying VertexBuffer object is created each call.\n         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        AbstractMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n            return null;\n        };\n        /**\n         * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, it is simply returned as it is.\n         * The `data` are either a numeric array either a Float32Array.\n         * No new underlying VertexBuffer object is created.\n         * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        AbstractMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n            return null;\n        };\n        /**\n         * Sets the mesh indices.\n         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n         * This method creates a new index buffer each call.\n         * Returns the Mesh.\n         */\n        AbstractMesh.prototype.setIndices = function (indices, totalVertices) {\n            return null;\n        };\n        /** Returns false by default, used by the class Mesh.\n         *  Returns a boolean\n        */\n        AbstractMesh.prototype.isVerticesDataPresent = function (kind) {\n            return false;\n        };\n        /**\n         * Returns the mesh BoundingInfo object or creates a new one and returns it if undefined.\n         * Returns a BoundingInfo\n         */\n        AbstractMesh.prototype.getBoundingInfo = function () {\n            if (this._masterMesh) {\n                return this._masterMesh.getBoundingInfo();\n            }\n            if (!this._boundingInfo) {\n                this._updateBoundingInfo();\n            }\n            return this._boundingInfo;\n        };\n        /**\n         * Sets a mesh new object BoundingInfo.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.setBoundingInfo = function (boundingInfo) {\n            this._boundingInfo = boundingInfo;\n            return this;\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"useBones\", {\n            get: function () {\n                return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesWeightsKind);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        AbstractMesh.prototype._preActivate = function () {\n        };\n        AbstractMesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n        };\n        AbstractMesh.prototype._activate = function (renderId) {\n            this._renderId = renderId;\n        };\n        /**\n         * Returns the last update of the World matrix\n         * Returns a Matrix.\n         */\n        AbstractMesh.prototype.getWorldMatrix = function () {\n            if (this._masterMesh) {\n                return this._masterMesh.getWorldMatrix();\n            }\n            if (this._currentRenderId !== this.getScene().getRenderId() || !this.isSynchronized()) {\n                this.computeWorldMatrix();\n            }\n            return this._worldMatrix;\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"worldMatrixFromCache\", {\n            /**\n             * Returns directly the last state of the mesh World matrix.\n             * A Matrix is returned.\n             */\n            get: function () {\n                return this._worldMatrix;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractMesh.prototype, \"absolutePosition\", {\n            /**\n             * Returns the current mesh absolute position.\n             * Retuns a Vector3.\n             */\n            get: function () {\n                return this._absolutePosition;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Prevents the World matrix to be computed any longer.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.freezeWorldMatrix = function () {\n            this._isWorldMatrixFrozen = false; // no guarantee world is not already frozen, switch off temporarily\n            this.computeWorldMatrix(true);\n            this._isWorldMatrixFrozen = true;\n            return this;\n        };\n        /**\n         * Allows back the World matrix computation.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.unfreezeWorldMatrix = function () {\n            this._isWorldMatrixFrozen = false;\n            this.computeWorldMatrix(true);\n            return this;\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"isWorldMatrixFrozen\", {\n            /**\n             * True if the World matrix has been frozen.\n             * Returns a boolean.\n             */\n            get: function () {\n                return this._isWorldMatrixFrozen;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.\n         * space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.\n         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n         * The passed axis is also normalized.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.rotate = function (axis, amount, space) {\n            axis.normalize();\n            if (!this.rotationQuaternion) {\n                this.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n                this.rotation = BABYLON.Vector3.Zero();\n            }\n            var rotationQuaternion;\n            if (!space || space === BABYLON.Space.LOCAL) {\n                rotationQuaternion = BABYLON.Quaternion.RotationAxisToRef(axis, amount, AbstractMesh._rotationAxisCache);\n                this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);\n            }\n            else {\n                if (this.parent) {\n                    var invertParentWorldMatrix = this.parent.getWorldMatrix().clone();\n                    invertParentWorldMatrix.invert();\n                    axis = BABYLON.Vector3.TransformNormal(axis, invertParentWorldMatrix);\n                }\n                rotationQuaternion = BABYLON.Quaternion.RotationAxisToRef(axis, amount, AbstractMesh._rotationAxisCache);\n                rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n            }\n            return this;\n        };\n        /**\n         * Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.\n         * Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.\n         * The passed axis is also normalized.\n         * Returns the AbstractMesh.\n         * Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm\n         */\n        AbstractMesh.prototype.rotateAround = function (point, axis, amount) {\n            axis.normalize();\n            if (!this.rotationQuaternion) {\n                this.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n                this.rotation.copyFromFloats(0, 0, 0);\n            }\n            point.subtractToRef(this.position, BABYLON.Tmp.Vector3[0]);\n            BABYLON.Matrix.TranslationToRef(BABYLON.Tmp.Vector3[0].x, BABYLON.Tmp.Vector3[0].y, BABYLON.Tmp.Vector3[0].z, BABYLON.Tmp.Matrix[0]);\n            BABYLON.Tmp.Matrix[0].invertToRef(BABYLON.Tmp.Matrix[2]);\n            BABYLON.Matrix.RotationAxisToRef(axis, amount, BABYLON.Tmp.Matrix[1]);\n            BABYLON.Tmp.Matrix[2].multiplyToRef(BABYLON.Tmp.Matrix[1], BABYLON.Tmp.Matrix[2]);\n            BABYLON.Tmp.Matrix[2].multiplyToRef(BABYLON.Tmp.Matrix[0], BABYLON.Tmp.Matrix[2]);\n            BABYLON.Tmp.Matrix[2].decompose(BABYLON.Tmp.Vector3[0], BABYLON.Tmp.Quaternion[0], BABYLON.Tmp.Vector3[1]);\n            this.position.addInPlace(BABYLON.Tmp.Vector3[1]);\n            this.rotationQuaternion.multiplyInPlace(BABYLON.Tmp.Quaternion[0]);\n            return this;\n        };\n        /**\n         * Translates the mesh along the axis vector for the passed distance in the given space.\n         * space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.translate = function (axis, distance, space) {\n            var displacementVector = axis.scale(distance);\n            if (!space || space === BABYLON.Space.LOCAL) {\n                var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);\n                this.setPositionWithLocalVector(tempV3);\n            }\n            else {\n                this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));\n            }\n            return this;\n        };\n        /**\n         * Adds a rotation step to the mesh current rotation.\n         * x, y, z are Euler angles expressed in radians.\n         * This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.\n         * This means this rotation is made in the mesh local space only.\n         * It's useful to set a custom rotation order different from the BJS standard one YXZ.\n         * Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.\n         * ```javascript\n         * mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);\n         * ```\n         * Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.\n         * Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.addRotation = function (x, y, z) {\n            var rotationQuaternion;\n            if (this.rotationQuaternion) {\n                rotationQuaternion = this.rotationQuaternion;\n            }\n            else {\n                rotationQuaternion = BABYLON.Tmp.Quaternion[1];\n                BABYLON.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);\n            }\n            var accumulation = BABYLON.Tmp.Quaternion[0];\n            BABYLON.Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);\n            rotationQuaternion.multiplyInPlace(accumulation);\n            if (!this.rotationQuaternion) {\n                rotationQuaternion.toEulerAnglesToRef(this.rotation);\n            }\n            return this;\n        };\n        /**\n         * Retuns the mesh absolute position in the World.\n         * Returns a Vector3.\n         */\n        AbstractMesh.prototype.getAbsolutePosition = function () {\n            this.computeWorldMatrix();\n            return this._absolutePosition;\n        };\n        /**\n         * Sets the mesh absolute position in the World from a Vector3 or an Array(3).\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.setAbsolutePosition = function (absolutePosition) {\n            if (!absolutePosition) {\n                return;\n            }\n            var absolutePositionX;\n            var absolutePositionY;\n            var absolutePositionZ;\n            if (absolutePosition.x === undefined) {\n                if (arguments.length < 3) {\n                    return;\n                }\n                absolutePositionX = arguments[0];\n                absolutePositionY = arguments[1];\n                absolutePositionZ = arguments[2];\n            }\n            else {\n                absolutePositionX = absolutePosition.x;\n                absolutePositionY = absolutePosition.y;\n                absolutePositionZ = absolutePosition.z;\n            }\n            if (this.parent) {\n                var invertParentWorldMatrix = this.parent.getWorldMatrix().clone();\n                invertParentWorldMatrix.invert();\n                var worldPosition = new BABYLON.Vector3(absolutePositionX, absolutePositionY, absolutePositionZ);\n                this.position = BABYLON.Vector3.TransformCoordinates(worldPosition, invertParentWorldMatrix);\n            }\n            else {\n                this.position.x = absolutePositionX;\n                this.position.y = absolutePositionY;\n                this.position.z = absolutePositionZ;\n            }\n            return this;\n        };\n        // ================================== Point of View Movement =================================\n        /**\n         * Perform relative position change from the point of view of behind the front of the mesh.\n         * This is performed taking into account the meshes current rotation, so you do not have to care.\n         * Supports definition of mesh facing forward or backward.\n         * @param {number} amountRight\n         * @param {number} amountUp\n         * @param {number} amountForward\n         *\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.movePOV = function (amountRight, amountUp, amountForward) {\n            this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));\n            return this;\n        };\n        /**\n         * Calculate relative position change from the point of view of behind the front of the mesh.\n         * This is performed taking into account the meshes current rotation, so you do not have to care.\n         * Supports definition of mesh facing forward or backward.\n         * @param {number} amountRight\n         * @param {number} amountUp\n         * @param {number} amountForward\n         *\n         * Returns a new Vector3.\n         */\n        AbstractMesh.prototype.calcMovePOV = function (amountRight, amountUp, amountForward) {\n            var rotMatrix = new BABYLON.Matrix();\n            var rotQuaternion = (this.rotationQuaternion) ? this.rotationQuaternion : BABYLON.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);\n            rotQuaternion.toRotationMatrix(rotMatrix);\n            var translationDelta = BABYLON.Vector3.Zero();\n            var defForwardMult = this.definedFacingForward ? -1 : 1;\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);\n            return translationDelta;\n        };\n        // ================================== Point of View Rotation =================================\n        /**\n         * Perform relative rotation change from the point of view of behind the front of the mesh.\n         * Supports definition of mesh facing forward or backward.\n         * @param {number} flipBack\n         * @param {number} twirlClockwise\n         * @param {number} tiltRight\n         *\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.rotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n            this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));\n            return this;\n        };\n        /**\n         * Calculate relative rotation change from the point of view of behind the front of the mesh.\n         * Supports definition of mesh facing forward or backward.\n         * @param {number} flipBack\n         * @param {number} twirlClockwise\n         * @param {number} tiltRight\n         *\n         * Returns a new Vector3.\n         */\n        AbstractMesh.prototype.calcRotatePOV = function (flipBack, twirlClockwise, tiltRight) {\n            var defForwardMult = this.definedFacingForward ? 1 : -1;\n            return new BABYLON.Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);\n        };\n        /**\n         * Sets a new pivot matrix to the mesh.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.setPivotMatrix = function (matrix) {\n            this._pivotMatrix = matrix;\n            this._cache.pivotMatrixUpdated = true;\n            return this;\n        };\n        /**\n         * Returns the mesh pivot matrix.\n         * Default : Identity.\n         * A Matrix is returned.\n         */\n        AbstractMesh.prototype.getPivotMatrix = function () {\n            return this._pivotMatrix;\n        };\n        AbstractMesh.prototype._isSynchronized = function () {\n            if (this._isDirty) {\n                return false;\n            }\n            if (this.billboardMode !== this._cache.billboardMode || this.billboardMode !== AbstractMesh.BILLBOARDMODE_NONE)\n                return false;\n            if (this._cache.pivotMatrixUpdated) {\n                return false;\n            }\n            if (this.infiniteDistance) {\n                return false;\n            }\n            if (!this._cache.position.equals(this.position))\n                return false;\n            if (this.rotationQuaternion) {\n                if (!this._cache.rotationQuaternion.equals(this.rotationQuaternion))\n                    return false;\n            }\n            if (!this._cache.rotation.equals(this.rotation))\n                return false;\n            if (!this._cache.scaling.equals(this.scaling))\n                return false;\n            return true;\n        };\n        AbstractMesh.prototype._initCache = function () {\n            _super.prototype._initCache.call(this);\n            this._cache.localMatrixUpdated = false;\n            this._cache.position = BABYLON.Vector3.Zero();\n            this._cache.scaling = BABYLON.Vector3.Zero();\n            this._cache.rotation = BABYLON.Vector3.Zero();\n            this._cache.rotationQuaternion = new BABYLON.Quaternion(0, 0, 0, 0);\n            this._cache.billboardMode = -1;\n        };\n        AbstractMesh.prototype.markAsDirty = function (property) {\n            if (property === \"rotation\") {\n                this.rotationQuaternion = null;\n            }\n            this._currentRenderId = Number.MAX_VALUE;\n            this._isDirty = true;\n            return this;\n        };\n        /**\n         * Updates the mesh BoundingInfo object and all its children BoundingInfo objects also.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype._updateBoundingInfo = function () {\n            this._boundingInfo = this._boundingInfo || new BABYLON.BoundingInfo(this.absolutePosition, this.absolutePosition);\n            this._boundingInfo.update(this.worldMatrixFromCache);\n            this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n            return this;\n        };\n        /**\n         * Update a mesh's children BoundingInfo objects only.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype._updateSubMeshesBoundingInfo = function (matrix) {\n            if (!this.subMeshes) {\n                return;\n            }\n            for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n                var subMesh = this.subMeshes[subIndex];\n                if (!subMesh.IsGlobal) {\n                    subMesh.updateBoundingInfo(matrix);\n                }\n            }\n            return this;\n        };\n        /**\n         * Computes the mesh World matrix and returns it.\n         * If the mesh world matrix is frozen, this computation does nothing more than returning the last frozen values.\n         * If the parameter `force` is let to `false` (default), the current cached World matrix is returned.\n         * If the parameter `force`is set to `true`, the actual computation is done.\n         * Returns the mesh World Matrix.\n         */\n        AbstractMesh.prototype.computeWorldMatrix = function (force) {\n            if (this._isWorldMatrixFrozen) {\n                return this._worldMatrix;\n            }\n            if (!force && this.isSynchronized(true)) {\n                this._currentRenderId = this.getScene().getRenderId();\n                return this._worldMatrix;\n            }\n            this._cache.position.copyFrom(this.position);\n            this._cache.scaling.copyFrom(this.scaling);\n            this._cache.pivotMatrixUpdated = false;\n            this._cache.billboardMode = this.billboardMode;\n            this._currentRenderId = this.getScene().getRenderId();\n            this._isDirty = false;\n            // Scaling\n            BABYLON.Matrix.ScalingToRef(this.scaling.x * this.scalingDeterminant, this.scaling.y * this.scalingDeterminant, this.scaling.z * this.scalingDeterminant, BABYLON.Tmp.Matrix[1]);\n            // Rotation\n            //rotate, if quaternion is set and rotation was used\n            if (this.rotationQuaternion) {\n                var len = this.rotation.length();\n                if (len) {\n                    this.rotationQuaternion.multiplyInPlace(BABYLON.Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z));\n                    this.rotation.copyFromFloats(0, 0, 0);\n                }\n            }\n            if (this.rotationQuaternion) {\n                this.rotationQuaternion.toRotationMatrix(BABYLON.Tmp.Matrix[0]);\n                this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n            }\n            else {\n                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, BABYLON.Tmp.Matrix[0]);\n                this._cache.rotation.copyFrom(this.rotation);\n            }\n            // Translation\n            if (this.infiniteDistance && !this.parent) {\n                var camera = this.getScene().activeCamera;\n                if (camera) {\n                    var cameraWorldMatrix = camera.getWorldMatrix();\n                    var cameraGlobalPosition = new BABYLON.Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);\n                    BABYLON.Matrix.TranslationToRef(this.position.x + cameraGlobalPosition.x, this.position.y + cameraGlobalPosition.y, this.position.z + cameraGlobalPosition.z, BABYLON.Tmp.Matrix[2]);\n                }\n            }\n            else {\n                BABYLON.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, BABYLON.Tmp.Matrix[2]);\n            }\n            // Composing transformations\n            this._pivotMatrix.multiplyToRef(BABYLON.Tmp.Matrix[1], BABYLON.Tmp.Matrix[4]);\n            BABYLON.Tmp.Matrix[4].multiplyToRef(BABYLON.Tmp.Matrix[0], BABYLON.Tmp.Matrix[5]);\n            // Billboarding (testing PG:http://www.babylonjs-playground.com/#UJEIL#13)\n            if (this.billboardMode !== AbstractMesh.BILLBOARDMODE_NONE && this.getScene().activeCamera) {\n                if ((this.billboardMode & AbstractMesh.BILLBOARDMODE_ALL) !== AbstractMesh.BILLBOARDMODE_ALL) {\n                    // Need to decompose each rotation here\n                    var currentPosition = BABYLON.Tmp.Vector3[3];\n                    if (this.parent && this.parent.getWorldMatrix) {\n                        if (this._meshToBoneReferal) {\n                            this.parent.getWorldMatrix().multiplyToRef(this._meshToBoneReferal.getWorldMatrix(), BABYLON.Tmp.Matrix[6]);\n                            BABYLON.Vector3.TransformCoordinatesToRef(this.position, BABYLON.Tmp.Matrix[6], currentPosition);\n                        }\n                        else {\n                            BABYLON.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), currentPosition);\n                        }\n                    }\n                    else {\n                        currentPosition.copyFrom(this.position);\n                    }\n                    currentPosition.subtractInPlace(this.getScene().activeCamera.globalPosition);\n                    var finalEuler = BABYLON.Tmp.Vector3[4].copyFromFloats(0, 0, 0);\n                    if ((this.billboardMode & AbstractMesh.BILLBOARDMODE_X) === AbstractMesh.BILLBOARDMODE_X) {\n                        finalEuler.x = Math.atan2(-currentPosition.y, currentPosition.z);\n                    }\n                    if ((this.billboardMode & AbstractMesh.BILLBOARDMODE_Y) === AbstractMesh.BILLBOARDMODE_Y) {\n                        finalEuler.y = Math.atan2(currentPosition.x, currentPosition.z);\n                    }\n                    if ((this.billboardMode & AbstractMesh.BILLBOARDMODE_Z) === AbstractMesh.BILLBOARDMODE_Z) {\n                        finalEuler.z = Math.atan2(currentPosition.y, currentPosition.x);\n                    }\n                    BABYLON.Matrix.RotationYawPitchRollToRef(finalEuler.y, finalEuler.x, finalEuler.z, BABYLON.Tmp.Matrix[0]);\n                }\n                else {\n                    BABYLON.Tmp.Matrix[1].copyFrom(this.getScene().activeCamera.getViewMatrix());\n                    BABYLON.Tmp.Matrix[1].setTranslationFromFloats(0, 0, 0);\n                    BABYLON.Tmp.Matrix[1].invertToRef(BABYLON.Tmp.Matrix[0]);\n                }\n                BABYLON.Tmp.Matrix[1].copyFrom(BABYLON.Tmp.Matrix[5]);\n                BABYLON.Tmp.Matrix[1].multiplyToRef(BABYLON.Tmp.Matrix[0], BABYLON.Tmp.Matrix[5]);\n            }\n            // Local world\n            BABYLON.Tmp.Matrix[5].multiplyToRef(BABYLON.Tmp.Matrix[2], this._localWorld);\n            // Parent\n            if (this.parent && this.parent.getWorldMatrix) {\n                if (this.billboardMode !== AbstractMesh.BILLBOARDMODE_NONE) {\n                    if (this._meshToBoneReferal) {\n                        this.parent.getWorldMatrix().multiplyToRef(this._meshToBoneReferal.getWorldMatrix(), BABYLON.Tmp.Matrix[6]);\n                        BABYLON.Tmp.Matrix[5].copyFrom(BABYLON.Tmp.Matrix[6]);\n                    }\n                    else {\n                        BABYLON.Tmp.Matrix[5].copyFrom(this.parent.getWorldMatrix());\n                    }\n                    this._localWorld.getTranslationToRef(BABYLON.Tmp.Vector3[5]);\n                    BABYLON.Vector3.TransformCoordinatesToRef(BABYLON.Tmp.Vector3[5], BABYLON.Tmp.Matrix[5], BABYLON.Tmp.Vector3[5]);\n                    this._worldMatrix.copyFrom(this._localWorld);\n                    this._worldMatrix.setTranslation(BABYLON.Tmp.Vector3[5]);\n                }\n                else {\n                    if (this._meshToBoneReferal) {\n                        this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), BABYLON.Tmp.Matrix[6]);\n                        BABYLON.Tmp.Matrix[6].multiplyToRef(this._meshToBoneReferal.getWorldMatrix(), this._worldMatrix);\n                    }\n                    else {\n                        this._localWorld.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\n                    }\n                }\n                this._markSyncedWithParent();\n            }\n            else {\n                this._worldMatrix.copyFrom(this._localWorld);\n            }\n            // Bounding info\n            this._updateBoundingInfo();\n            // Absolute position\n            this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);\n            // Callbacks\n            this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);\n            if (!this._poseMatrix) {\n                this._poseMatrix = BABYLON.Matrix.Invert(this._worldMatrix);\n            }\n            return this._worldMatrix;\n        };\n        /**\n        * If you'd like to be called back after the mesh position, rotation or scaling has been updated.\n        * @param func: callback function to add\n        *\n        * Returns the AbstractMesh.\n        */\n        AbstractMesh.prototype.registerAfterWorldMatrixUpdate = function (func) {\n            this.onAfterWorldMatrixUpdateObservable.add(func);\n            return this;\n        };\n        /**\n         * Removes a registered callback function.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.unregisterAfterWorldMatrixUpdate = function (func) {\n            this.onAfterWorldMatrixUpdateObservable.removeCallback(func);\n            return this;\n        };\n        /**\n         * Sets the mesh position in its local space.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.setPositionWithLocalVector = function (vector3) {\n            this.computeWorldMatrix();\n            this.position = BABYLON.Vector3.TransformNormal(vector3, this._localWorld);\n            return this;\n        };\n        /**\n         * Returns the mesh position in the local space from the current World matrix values.\n         * Returns a new Vector3.\n         */\n        AbstractMesh.prototype.getPositionExpressedInLocalSpace = function () {\n            this.computeWorldMatrix();\n            var invLocalWorldMatrix = this._localWorld.clone();\n            invLocalWorldMatrix.invert();\n            return BABYLON.Vector3.TransformNormal(this.position, invLocalWorldMatrix);\n        };\n        /**\n         * Translates the mesh along the passed Vector3 in its local space.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.locallyTranslate = function (vector3) {\n            this.computeWorldMatrix(true);\n            this.position = BABYLON.Vector3.TransformCoordinates(vector3, this._localWorld);\n            return this;\n        };\n        AbstractMesh.prototype.lookAt = function (targetPoint, yawCor, pitchCor, rollCor, space) {\n            /// <summary>Orients a mesh towards a target point. Mesh must be drawn facing user.</summary>\n            /// <param name=\"targetPoint\" type=\"Vector3\">The position (must be in same space as current mesh) to look at</param>\n            /// <param name=\"yawCor\" type=\"Number\">optional yaw (y-axis) correction in radians</param>\n            /// <param name=\"pitchCor\" type=\"Number\">optional pitch (x-axis) correction in radians</param>\n            /// <param name=\"rollCor\" type=\"Number\">optional roll (z-axis) correction in radians</param>\n            /// <returns>Mesh oriented towards targetMesh</returns>\n            if (yawCor === void 0) { yawCor = 0; }\n            if (pitchCor === void 0) { pitchCor = 0; }\n            if (rollCor === void 0) { rollCor = 0; }\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var dv = AbstractMesh._lookAtVectorCache;\n            var pos = space === BABYLON.Space.LOCAL ? this.position : this.getAbsolutePosition();\n            targetPoint.subtractToRef(pos, dv);\n            var yaw = -Math.atan2(dv.z, dv.x) - Math.PI / 2;\n            var len = Math.sqrt(dv.x * dv.x + dv.z * dv.z);\n            var pitch = Math.atan2(dv.y, len);\n            this.rotationQuaternion = this.rotationQuaternion || new BABYLON.Quaternion();\n            BABYLON.Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);\n            return this;\n        };\n        AbstractMesh.prototype.attachToBone = function (bone, affectedMesh) {\n            this._meshToBoneReferal = affectedMesh;\n            this.parent = bone;\n            if (bone.getWorldMatrix().determinant() < 0) {\n                this.scalingDeterminant *= -1;\n            }\n            return this;\n        };\n        AbstractMesh.prototype.detachFromBone = function () {\n            if (this.parent.getWorldMatrix().determinant() < 0) {\n                this.scalingDeterminant *= -1;\n            }\n            this._meshToBoneReferal = null;\n            this.parent = null;\n            return this;\n        };\n        /**\n         * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n         * A mesh is in the frustum if its bounding box intersects the frustum.\n         * Boolean returned.\n         */\n        AbstractMesh.prototype.isInFrustum = function (frustumPlanes) {\n            return this._boundingInfo.isInFrustum(frustumPlanes);\n        };\n        /**\n         * Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.\n         * A mesh is completely in the frustum if its bounding box it completely inside the frustum.\n         * Boolean returned.\n         */\n        AbstractMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n            return this._boundingInfo.isCompletelyInFrustum(frustumPlanes);\n            ;\n        };\n        /**\n         * True if the mesh intersects another mesh or a SolidParticle object.\n         * Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)\n         * Returns a boolean.\n         */\n        AbstractMesh.prototype.intersectsMesh = function (mesh, precise) {\n            if (!this._boundingInfo || !mesh._boundingInfo) {\n                return false;\n            }\n            return this._boundingInfo.intersects(mesh._boundingInfo, precise);\n        };\n        /**\n         * Returns true if the passed point (Vector3) is inside the mesh bounding box.\n         * Returns a boolean.\n         */\n        AbstractMesh.prototype.intersectsPoint = function (point) {\n            if (!this._boundingInfo) {\n                return false;\n            }\n            return this._boundingInfo.intersectsPoint(point);\n        };\n        AbstractMesh.prototype.getPhysicsImpostor = function () {\n            return this.physicsImpostor;\n        };\n        AbstractMesh.prototype.getPositionInCameraSpace = function (camera) {\n            if (!camera) {\n                camera = this.getScene().activeCamera;\n            }\n            return BABYLON.Vector3.TransformCoordinates(this.absolutePosition, camera.getViewMatrix());\n        };\n        /**\n         * Returns the distance from the mesh to the active camera.\n         * Returns a float.\n         */\n        AbstractMesh.prototype.getDistanceToCamera = function (camera) {\n            if (!camera) {\n                camera = this.getScene().activeCamera;\n            }\n            return this.absolutePosition.subtract(camera.position).length();\n        };\n        AbstractMesh.prototype.applyImpulse = function (force, contactPoint) {\n            if (!this.physicsImpostor) {\n                return;\n            }\n            this.physicsImpostor.applyImpulse(force, contactPoint);\n            return this;\n        };\n        AbstractMesh.prototype.setPhysicsLinkWith = function (otherMesh, pivot1, pivot2, options) {\n            if (!this.physicsImpostor || !otherMesh.physicsImpostor) {\n                return;\n            }\n            this.physicsImpostor.createJoint(otherMesh.physicsImpostor, BABYLON.PhysicsJoint.HingeJoint, {\n                mainPivot: pivot1,\n                connectedPivot: pivot2,\n                nativeParams: options\n            });\n            return this;\n        };\n        Object.defineProperty(AbstractMesh.prototype, \"checkCollisions\", {\n            // Collisions\n            /**\n             * Property checkCollisions : Boolean, whether the camera should check the collisions against the mesh.\n             * Default `false`.\n             */\n            get: function () {\n                return this._checkCollisions;\n            },\n            set: function (collisionEnabled) {\n                this._checkCollisions = collisionEnabled;\n                if (this.getScene().workerCollisions) {\n                    this.getScene().collisionCoordinator.onMeshUpdated(this);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        AbstractMesh.prototype.moveWithCollisions = function (velocity) {\n            var globalPosition = this.getAbsolutePosition();\n            globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPositionForCollisions);\n            this._oldPositionForCollisions.addInPlace(this.ellipsoidOffset);\n            if (!this._collider) {\n                this._collider = new BABYLON.Collider();\n            }\n            this._collider.radius = this.ellipsoid;\n            this.getScene().collisionCoordinator.getNewPosition(this._oldPositionForCollisions, velocity, this._collider, 3, this, this._onCollisionPositionChange, this.uniqueId);\n            return this;\n        };\n        // Submeshes octree\n        /**\n        * This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.\n        * Please note that you must have a decent number of submeshes to get performance improvements when using an octree.\n        * Returns an Octree of submeshes.\n        */\n        AbstractMesh.prototype.createOrUpdateSubmeshesOctree = function (maxCapacity, maxDepth) {\n            if (maxCapacity === void 0) { maxCapacity = 64; }\n            if (maxDepth === void 0) { maxDepth = 2; }\n            if (!this._submeshesOctree) {\n                this._submeshesOctree = new BABYLON.Octree(BABYLON.Octree.CreationFuncForSubMeshes, maxCapacity, maxDepth);\n            }\n            this.computeWorldMatrix(true);\n            // Update octree\n            var bbox = this.getBoundingInfo().boundingBox;\n            this._submeshesOctree.update(bbox.minimumWorld, bbox.maximumWorld, this.subMeshes);\n            return this._submeshesOctree;\n        };\n        // Collisions\n        AbstractMesh.prototype._collideForSubMesh = function (subMesh, transformMatrix, collider) {\n            this._generatePointsArray();\n            // Transformation\n            if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {\n                subMesh._lastColliderTransformMatrix = transformMatrix.clone();\n                subMesh._lastColliderWorldVertices = [];\n                subMesh._trianglePlanes = [];\n                var start = subMesh.verticesStart;\n                var end = (subMesh.verticesStart + subMesh.verticesCount);\n                for (var i = start; i < end; i++) {\n                    subMesh._lastColliderWorldVertices.push(BABYLON.Vector3.TransformCoordinates(this._positions[i], transformMatrix));\n                }\n            }\n            // Collide\n            collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial());\n            if (collider.collisionFound) {\n                collider.collidedMesh = this;\n            }\n            return this;\n        };\n        AbstractMesh.prototype._processCollisionsForSubMeshes = function (collider, transformMatrix) {\n            var subMeshes;\n            var len;\n            // Octrees\n            if (this._submeshesOctree && this.useOctreeForCollisions) {\n                var radius = collider.velocityWorldLength + Math.max(collider.radius.x, collider.radius.y, collider.radius.z);\n                var intersections = this._submeshesOctree.intersects(collider.basePointWorld, radius);\n                len = intersections.length;\n                subMeshes = intersections.data;\n            }\n            else {\n                subMeshes = this.subMeshes;\n                len = subMeshes.length;\n            }\n            for (var index = 0; index < len; index++) {\n                var subMesh = subMeshes[index];\n                // Bounding test\n                if (len > 1 && !subMesh._checkCollision(collider))\n                    continue;\n                this._collideForSubMesh(subMesh, transformMatrix, collider);\n            }\n            return this;\n        };\n        AbstractMesh.prototype._checkCollision = function (collider) {\n            // Bounding box test\n            if (!this._boundingInfo._checkCollision(collider))\n                return this;\n            // Transformation matrix\n            BABYLON.Matrix.ScalingToRef(1.0 / collider.radius.x, 1.0 / collider.radius.y, 1.0 / collider.radius.z, this._collisionsScalingMatrix);\n            this.worldMatrixFromCache.multiplyToRef(this._collisionsScalingMatrix, this._collisionsTransformMatrix);\n            this._processCollisionsForSubMeshes(collider, this._collisionsTransformMatrix);\n            return this;\n        };\n        // Picking\n        AbstractMesh.prototype._generatePointsArray = function () {\n            return false;\n        };\n        /**\n         * Checks if the passed Ray intersects with the mesh.\n         * Returns an object PickingInfo.\n         */\n        AbstractMesh.prototype.intersects = function (ray, fastCheck) {\n            var pickingInfo = new BABYLON.PickingInfo();\n            if (!this.subMeshes || !this._boundingInfo || !ray.intersectsSphere(this._boundingInfo.boundingSphere) || !ray.intersectsBox(this._boundingInfo.boundingBox)) {\n                return pickingInfo;\n            }\n            if (!this._generatePointsArray()) {\n                return pickingInfo;\n            }\n            var intersectInfo = null;\n            // Octrees\n            var subMeshes;\n            var len;\n            if (this._submeshesOctree && this.useOctreeForPicking) {\n                var worldRay = BABYLON.Ray.Transform(ray, this.getWorldMatrix());\n                var intersections = this._submeshesOctree.intersectsRay(worldRay);\n                len = intersections.length;\n                subMeshes = intersections.data;\n            }\n            else {\n                subMeshes = this.subMeshes;\n                len = subMeshes.length;\n            }\n            for (var index = 0; index < len; index++) {\n                var subMesh = subMeshes[index];\n                // Bounding test\n                if (len > 1 && !subMesh.canIntersects(ray))\n                    continue;\n                var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck);\n                if (currentIntersectInfo) {\n                    if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                        intersectInfo = currentIntersectInfo;\n                        intersectInfo.subMeshId = index;\n                        if (fastCheck) {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (intersectInfo) {\n                // Get picked point\n                var world = this.getWorldMatrix();\n                var worldOrigin = BABYLON.Vector3.TransformCoordinates(ray.origin, world);\n                var direction = ray.direction.clone();\n                direction = direction.scale(intersectInfo.distance);\n                var worldDirection = BABYLON.Vector3.TransformNormal(direction, world);\n                var pickedPoint = worldOrigin.add(worldDirection);\n                // Return result\n                pickingInfo.hit = true;\n                pickingInfo.distance = BABYLON.Vector3.Distance(worldOrigin, pickedPoint);\n                pickingInfo.pickedPoint = pickedPoint;\n                pickingInfo.pickedMesh = this;\n                pickingInfo.bu = intersectInfo.bu;\n                pickingInfo.bv = intersectInfo.bv;\n                pickingInfo.faceId = intersectInfo.faceId;\n                pickingInfo.subMeshId = intersectInfo.subMeshId;\n                return pickingInfo;\n            }\n            return pickingInfo;\n        };\n        /**\n         * Clones the mesh, used by the class Mesh.\n         * Just returns `null` for an AbstractMesh.\n         */\n        AbstractMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n            return null;\n        };\n        /**\n         * Disposes all the mesh submeshes.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.releaseSubMeshes = function () {\n            if (this.subMeshes) {\n                while (this.subMeshes.length) {\n                    this.subMeshes[0].dispose();\n                }\n            }\n            else {\n                this.subMeshes = new Array();\n            }\n            return this;\n        };\n        /**\n         * Disposes the AbstractMesh.\n         * Some internal references are kept for further use.\n         * By default, all the mesh children are also disposed unless the parameter `doNotRecurse` is set to `true`.\n         * Returns nothing.\n         */\n        AbstractMesh.prototype.dispose = function (doNotRecurse) {\n            var _this = this;\n            var index;\n            // Action manager\n            if (this.actionManager) {\n                this.actionManager.dispose();\n                this.actionManager = null;\n            }\n            // Skeleton\n            this.skeleton = null;\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Physics\n            if (this.physicsImpostor) {\n                this.physicsImpostor.dispose();\n            }\n            // Intersections in progress\n            for (index = 0; index < this._intersectionsInProgress.length; index++) {\n                var other = this._intersectionsInProgress[index];\n                var pos = other._intersectionsInProgress.indexOf(this);\n                other._intersectionsInProgress.splice(pos, 1);\n            }\n            this._intersectionsInProgress = [];\n            // Lights\n            var lights = this.getScene().lights;\n            lights.forEach(function (light) {\n                var meshIndex = light.includedOnlyMeshes.indexOf(_this);\n                if (meshIndex !== -1) {\n                    light.includedOnlyMeshes.splice(meshIndex, 1);\n                }\n                meshIndex = light.excludedMeshes.indexOf(_this);\n                if (meshIndex !== -1) {\n                    light.excludedMeshes.splice(meshIndex, 1);\n                }\n                // Shadow generators\n                var generator = light.getShadowGenerator();\n                if (generator) {\n                    var shadowMap = generator.getShadowMap();\n                    meshIndex = shadowMap.renderList.indexOf(_this);\n                    if (meshIndex !== -1) {\n                        shadowMap.renderList.splice(meshIndex, 1);\n                    }\n                }\n            });\n            // Edges\n            if (this._edgesRenderer) {\n                this._edgesRenderer.dispose();\n                this._edgesRenderer = null;\n            }\n            // SubMeshes\n            if (this.getClassName() !== \"InstancedMesh\") {\n                this.releaseSubMeshes();\n            }\n            // Octree\n            var sceneOctree = this.getScene().selectionOctree;\n            if (sceneOctree) {\n                var index = sceneOctree.dynamicContent.indexOf(this);\n                if (index !== -1) {\n                    sceneOctree.dynamicContent.splice(index, 1);\n                }\n            }\n            // Engine\n            this.getScene().getEngine().wipeCaches();\n            // Remove from scene\n            this.getScene().removeMesh(this);\n            if (!doNotRecurse) {\n                // Particles\n                for (index = 0; index < this.getScene().particleSystems.length; index++) {\n                    if (this.getScene().particleSystems[index].emitter === this) {\n                        this.getScene().particleSystems[index].dispose();\n                        index--;\n                    }\n                }\n                // Children\n                var objects = this.getDescendants(true);\n                for (index = 0; index < objects.length; index++) {\n                    objects[index].dispose();\n                }\n            }\n            else {\n                var childMeshes = this.getChildMeshes(true);\n                for (index = 0; index < childMeshes.length; index++) {\n                    var child = childMeshes[index];\n                    child.parent = null;\n                    child.computeWorldMatrix(true);\n                }\n            }\n            // facet data\n            if (this._facetDataEnabled) {\n                this.disableFacetData();\n            }\n            this.onAfterWorldMatrixUpdateObservable.clear();\n            this.onCollideObservable.clear();\n            this.onCollisionPositionChangeObservable.clear();\n            this._isDisposed = true;\n            _super.prototype.dispose.call(this);\n        };\n        /**\n         * Returns a new Vector3 what is the localAxis, expressed in the mesh local space, rotated like the mesh.\n         * This Vector3 is expressed in the World space.\n         */\n        AbstractMesh.prototype.getDirection = function (localAxis) {\n            var result = BABYLON.Vector3.Zero();\n            this.getDirectionToRef(localAxis, result);\n            return result;\n        };\n        /**\n         * Sets the Vector3 \"result\" as the rotated Vector3 \"localAxis\" in the same rotation than the mesh.\n         * localAxis is expressed in the mesh local space.\n         * result is computed in the Wordl space from the mesh World matrix.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.getDirectionToRef = function (localAxis, result) {\n            BABYLON.Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n            return this;\n        };\n        AbstractMesh.prototype.setPivotPoint = function (point, space) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            if (this.getScene().getRenderId() == 0) {\n                this.computeWorldMatrix(true);\n            }\n            var wm = this.getWorldMatrix();\n            if (space == BABYLON.Space.WORLD) {\n                var tmat = BABYLON.Tmp.Matrix[0];\n                wm.invertToRef(tmat);\n                point = BABYLON.Vector3.TransformCoordinates(point, tmat);\n            }\n            BABYLON.Vector3.TransformCoordinatesToRef(point, wm, this.position);\n            this._pivotMatrix.m[12] = -point.x;\n            this._pivotMatrix.m[13] = -point.y;\n            this._pivotMatrix.m[14] = -point.z;\n            this._cache.pivotMatrixUpdated = true;\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the mesh pivot point coordinates in the local space.\n         */\n        AbstractMesh.prototype.getPivotPoint = function () {\n            var point = BABYLON.Vector3.Zero();\n            this.getPivotPointToRef(point);\n            return point;\n        };\n        /**\n         * Sets the passed Vector3 \"result\" with the coordinates of the mesh pivot point in the local space.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.getPivotPointToRef = function (result) {\n            result.x = -this._pivotMatrix.m[12];\n            result.y = -this._pivotMatrix.m[13];\n            result.z = -this._pivotMatrix.m[14];\n            return this;\n        };\n        /**\n         * Returns a new Vector3 set with the mesh pivot point World coordinates.\n         */\n        AbstractMesh.prototype.getAbsolutePivotPoint = function () {\n            var point = BABYLON.Vector3.Zero();\n            this.getAbsolutePivotPointToRef(point);\n            return point;\n        };\n        /**\n         * Defines the passed mesh as the parent of the current mesh.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.setParent = function (mesh) {\n            var child = this;\n            var parent = mesh;\n            if (mesh == null) {\n                var rotation = BABYLON.Tmp.Quaternion[0];\n                var position = BABYLON.Tmp.Vector3[0];\n                var scale = BABYLON.Tmp.Vector3[1];\n                child.getWorldMatrix().decompose(scale, rotation, position);\n                if (child.rotationQuaternion) {\n                    child.rotationQuaternion.copyFrom(rotation);\n                }\n                else {\n                    rotation.toEulerAnglesToRef(child.rotation);\n                }\n                child.position.x = position.x;\n                child.position.y = position.y;\n                child.position.z = position.z;\n            }\n            else {\n                var rotation = BABYLON.Tmp.Quaternion[0];\n                var position = BABYLON.Tmp.Vector3[0];\n                var scale = BABYLON.Tmp.Vector3[1];\n                var m1 = BABYLON.Tmp.Matrix[0];\n                var m2 = BABYLON.Tmp.Matrix[1];\n                parent.getWorldMatrix().decompose(scale, rotation, position);\n                rotation.toRotationMatrix(m1);\n                m2.setTranslation(position);\n                m2.multiplyToRef(m1, m1);\n                var invParentMatrix = BABYLON.Matrix.Invert(m1);\n                var m = child.getWorldMatrix().multiply(invParentMatrix);\n                m.decompose(scale, rotation, position);\n                if (child.rotationQuaternion) {\n                    child.rotationQuaternion.copyFrom(rotation);\n                }\n                else {\n                    rotation.toEulerAnglesToRef(child.rotation);\n                }\n                invParentMatrix = BABYLON.Matrix.Invert(parent.getWorldMatrix());\n                var m = child.getWorldMatrix().multiply(invParentMatrix);\n                m.decompose(scale, rotation, position);\n                child.position.x = position.x;\n                child.position.y = position.y;\n                child.position.z = position.z;\n            }\n            child.parent = parent;\n            return this;\n        };\n        /**\n         * Adds the passed mesh as a child to the current mesh.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.addChild = function (mesh) {\n            mesh.setParent(this);\n            return this;\n        };\n        /**\n         * Removes the passed mesh from the current mesh children list.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.removeChild = function (mesh) {\n            mesh.setParent(null);\n            return this;\n        };\n        /**\n         * Sets the Vector3 \"result\" coordinates with the mesh pivot point World coordinates.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.getAbsolutePivotPointToRef = function (result) {\n            result.x = this._pivotMatrix.m[12];\n            result.y = this._pivotMatrix.m[13];\n            result.z = this._pivotMatrix.m[14];\n            this.getPivotPointToRef(result);\n            BABYLON.Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);\n            return this;\n        };\n        // Facet data\n        /**\n         *  Initialize the facet data arrays : facetNormals, facetPositions and facetPartitioning.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype._initFacetData = function () {\n            if (!this._facetNormals) {\n                this._facetNormals = new Array();\n            }\n            if (!this._facetPositions) {\n                this._facetPositions = new Array();\n            }\n            if (!this._facetPartitioning) {\n                this._facetPartitioning = new Array();\n            }\n            this._facetNb = this.getIndices().length / 3;\n            this._partitioningSubdivisions = (this._partitioningSubdivisions) ? this._partitioningSubdivisions : 10; // default nb of partitioning subdivisions = 10\n            this._partitioningBBoxRatio = (this._partitioningBBoxRatio) ? this._partitioningBBoxRatio : 1.01; // default ratio 1.01 = the partitioning is 1% bigger than the bounding box\n            for (var f = 0; f < this._facetNb; f++) {\n                this._facetNormals[f] = BABYLON.Vector3.Zero();\n                this._facetPositions[f] = BABYLON.Vector3.Zero();\n            }\n            this._facetDataEnabled = true;\n            return this;\n        };\n        /**\n         * Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.\n         * This method can be called within the render loop.\n         * You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.updateFacetData = function () {\n            if (!this._facetDataEnabled) {\n                this._initFacetData();\n            }\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var indices = this.getIndices();\n            var normals = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var bInfo = this.getBoundingInfo();\n            this._bbSize.x = (bInfo.maximum.x - bInfo.minimum.x > BABYLON.Epsilon) ? bInfo.maximum.x - bInfo.minimum.x : BABYLON.Epsilon;\n            this._bbSize.y = (bInfo.maximum.y - bInfo.minimum.y > BABYLON.Epsilon) ? bInfo.maximum.y - bInfo.minimum.y : BABYLON.Epsilon;\n            this._bbSize.z = (bInfo.maximum.z - bInfo.minimum.z > BABYLON.Epsilon) ? bInfo.maximum.z - bInfo.minimum.z : BABYLON.Epsilon;\n            var bbSizeMax = (this._bbSize.x > this._bbSize.y) ? this._bbSize.x : this._bbSize.y;\n            bbSizeMax = (bbSizeMax > this._bbSize.z) ? bbSizeMax : this._bbSize.z;\n            this._subDiv.max = this._partitioningSubdivisions;\n            this._subDiv.X = Math.floor(this._subDiv.max * this._bbSize.x / bbSizeMax); // adjust the number of subdivisions per axis\n            this._subDiv.Y = Math.floor(this._subDiv.max * this._bbSize.y / bbSizeMax); // according to each bbox size per axis\n            this._subDiv.Z = Math.floor(this._subDiv.max * this._bbSize.z / bbSizeMax);\n            this._subDiv.X = this._subDiv.X < 1 ? 1 : this._subDiv.X; // at least one subdivision\n            this._subDiv.Y = this._subDiv.Y < 1 ? 1 : this._subDiv.Y;\n            this._subDiv.Z = this._subDiv.Z < 1 ? 1 : this._subDiv.Z;\n            // set the parameters for ComputeNormals()\n            this._facetParameters.facetNormals = this.getFacetLocalNormals();\n            this._facetParameters.facetPositions = this.getFacetLocalPositions();\n            this._facetParameters.facetPartitioning = this.getFacetLocalPartitioning();\n            this._facetParameters.bInfo = bInfo;\n            this._facetParameters.bbSize = this._bbSize;\n            this._facetParameters.subDiv = this._subDiv;\n            this._facetParameters.ratio = this.partitioningBBoxRatio;\n            BABYLON.VertexData.ComputeNormals(positions, indices, normals, this._facetParameters);\n            return this;\n        };\n        /**\n         * Returns the facetLocalNormals array.\n         * The normals are expressed in the mesh local space.\n         */\n        AbstractMesh.prototype.getFacetLocalNormals = function () {\n            if (!this._facetNormals) {\n                this.updateFacetData();\n            }\n            return this._facetNormals;\n        };\n        /**\n         * Returns the facetLocalPositions array.\n         * The facet positions are expressed in the mesh local space.\n         */\n        AbstractMesh.prototype.getFacetLocalPositions = function () {\n            if (!this._facetPositions) {\n                this.updateFacetData();\n            }\n            return this._facetPositions;\n        };\n        /**\n         * Returns the facetLocalPartioning array.\n         */\n        AbstractMesh.prototype.getFacetLocalPartitioning = function () {\n            if (!this._facetPartitioning) {\n                this.updateFacetData();\n            }\n            return this._facetPartitioning;\n        };\n        /**\n         * Returns the i-th facet position in the world system.\n         * This method allocates a new Vector3 per call.\n         */\n        AbstractMesh.prototype.getFacetPosition = function (i) {\n            var pos = BABYLON.Vector3.Zero();\n            this.getFacetPositionToRef(i, pos);\n            return pos;\n        };\n        /**\n         * Sets the reference Vector3 with the i-th facet position in the world system.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.getFacetPositionToRef = function (i, ref) {\n            var localPos = (this.getFacetLocalPositions())[i];\n            var world = this.getWorldMatrix();\n            BABYLON.Vector3.TransformCoordinatesToRef(localPos, world, ref);\n            return this;\n        };\n        /**\n         * Returns the i-th facet normal in the world system.\n         * This method allocates a new Vector3 per call.\n         */\n        AbstractMesh.prototype.getFacetNormal = function (i) {\n            var norm = BABYLON.Vector3.Zero();\n            this.getFacetNormalToRef(i, norm);\n            return norm;\n        };\n        /**\n         * Sets the reference Vector3 with the i-th facet normal in the world system.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.getFacetNormalToRef = function (i, ref) {\n            var localNorm = (this.getFacetLocalNormals())[i];\n            BABYLON.Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);\n            return this;\n        };\n        /**\n         * Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system).\n         */\n        AbstractMesh.prototype.getFacetsAtLocalCoordinates = function (x, y, z) {\n            var bInfo = this.getBoundingInfo();\n            var ox = Math.floor((x - bInfo.minimum.x * this._partitioningBBoxRatio) * this._subDiv.X * this._partitioningBBoxRatio / this._bbSize.x);\n            var oy = Math.floor((y - bInfo.minimum.y * this._partitioningBBoxRatio) * this._subDiv.Y * this._partitioningBBoxRatio / this._bbSize.y);\n            var oz = Math.floor((z - bInfo.minimum.z * this._partitioningBBoxRatio) * this._subDiv.Z * this._partitioningBBoxRatio / this._bbSize.z);\n            if (ox < 0 || ox > this._subDiv.max || oy < 0 || oy > this._subDiv.max || oz < 0 || oz > this._subDiv.max) {\n                return null;\n            }\n            return this._facetPartitioning[ox + this._subDiv.max * oy + this._subDiv.max * this._subDiv.max * oz];\n        };\n        /**\n         * Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found.\n         * If the parameter projected (vector3) is passed, it is set as the (x,y,z) World projection on the facet.\n         * If checkFace is true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned.\n         * If facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position.\n         * If facing si false and checkFace is true, only the facet \"turning their backs\" to (x, y, z) are returned : negative dot (x, y, z) * facet position.\n         */\n        AbstractMesh.prototype.getClosestFacetAtCoordinates = function (x, y, z, projected, checkFace, facing) {\n            if (checkFace === void 0) { checkFace = false; }\n            if (facing === void 0) { facing = true; }\n            var world = this.getWorldMatrix();\n            var invMat = BABYLON.Tmp.Matrix[5];\n            world.invertToRef(invMat);\n            var invVect = BABYLON.Tmp.Vector3[8];\n            var closest = null;\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect); // transform (x,y,z) to coordinates in the mesh local space\n            closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);\n            if (projected) {\n                // tranform the local computed projected vector to world coordinates\n                BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);\n            }\n            return closest;\n        };\n        /**\n         * Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found.\n         * If the parameter projected (vector3) is passed, it is set as the (x,y,z) local projection on the facet.\n         * If checkFace is true (default false), only the facet \"facing\" to (x,y,z) or only the ones \"turning their backs\", according to the parameter \"facing\" are returned.\n         * If facing and checkFace are true, only the facet \"facing\" to (x, y, z) are returned : positive dot (x, y, z) * facet position.\n         * If facing si false and checkFace is true, only the facet \"turning their backs\"  to (x, y, z) are returned : negative dot (x, y, z) * facet position.\n         */\n        AbstractMesh.prototype.getClosestFacetAtLocalCoordinates = function (x, y, z, projected, checkFace, facing) {\n            if (checkFace === void 0) { checkFace = false; }\n            if (facing === void 0) { facing = true; }\n            var closest = null;\n            var tmpx = 0.0;\n            var tmpy = 0.0;\n            var tmpz = 0.0;\n            var d = 0.0; // tmp dot facet normal * facet position\n            var t0 = 0.0;\n            var projx = 0.0;\n            var projy = 0.0;\n            var projz = 0.0;\n            // Get all the facets in the same partitioning block than (x, y, z)\n            var facetPositions = this.getFacetLocalPositions();\n            var facetNormals = this.getFacetLocalNormals();\n            var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);\n            if (!facetsInBlock) {\n                return null;\n            }\n            // Get the closest facet to (x, y, z)\n            var shortest = Number.MAX_VALUE; // init distance vars\n            var tmpDistance = shortest;\n            var fib; // current facet in the block\n            var norm; // current facet normal\n            var p0; // current facet barycenter position\n            // loop on all the facets in the current partitioning block\n            for (var idx = 0; idx < facetsInBlock.length; idx++) {\n                fib = facetsInBlock[idx];\n                norm = facetNormals[fib];\n                p0 = facetPositions[fib];\n                d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;\n                if (!checkFace || (checkFace && facing && d >= 0.0) || (checkFace && !facing && d <= 0.0)) {\n                    // compute (x,y,z) projection on the facet = (projx, projy, projz)\n                    d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;\n                    t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);\n                    projx = x + norm.x * t0;\n                    projy = y + norm.y * t0;\n                    projz = z + norm.z * t0;\n                    tmpx = projx - x;\n                    tmpy = projy - y;\n                    tmpz = projz - z;\n                    tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz; // compute length between (x, y, z) and its projection on the facet\n                    if (tmpDistance < shortest) {\n                        shortest = tmpDistance;\n                        closest = fib;\n                        if (projected) {\n                            projected.x = projx;\n                            projected.y = projy;\n                            projected.z = projz;\n                        }\n                    }\n                }\n            }\n            return closest;\n        };\n        /**\n         * Returns the object \"parameter\" set with all the expected parameters for facetData computation by ComputeNormals()\n         */\n        AbstractMesh.prototype.getFacetDataParameters = function () {\n            return this._facetParameters;\n        };\n        /**\n         * Disables the feature FacetData and frees the related memory.\n         * Returns the AbstractMesh.\n         */\n        AbstractMesh.prototype.disableFacetData = function () {\n            if (this._facetDataEnabled) {\n                this._facetDataEnabled = false;\n                this._facetPositions = null;\n                this._facetNormals = null;\n                this._facetPartitioning = null;\n                this._facetParameters = null;\n            }\n            return this;\n        };\n        /**\n         * Creates new normals data for the mesh.\n         * @param updatable.\n         */\n        AbstractMesh.prototype.createNormals = function (updatable) {\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var indices = this.getIndices();\n            var normals;\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                normals = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            }\n            else {\n                normals = [];\n            }\n            BABYLON.VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });\n            this.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);\n        };\n        return AbstractMesh;\n    }(BABYLON.Node));\n    // Statics\n    AbstractMesh._BILLBOARDMODE_NONE = 0;\n    AbstractMesh._BILLBOARDMODE_X = 1;\n    AbstractMesh._BILLBOARDMODE_Y = 2;\n    AbstractMesh._BILLBOARDMODE_Z = 4;\n    AbstractMesh._BILLBOARDMODE_ALL = 7;\n    AbstractMesh._rotationAxisCache = new BABYLON.Quaternion();\n    AbstractMesh._lookAtVectorCache = new BABYLON.Vector3(0, 0, 0);\n    BABYLON.AbstractMesh = AbstractMesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.abstractMesh.js.map\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Light = (function (_super) {\n        __extends(Light, _super);\n        /**\n         * Creates a Light object in the scene.\n         * Documentation : http://doc.babylonjs.com/tutorials/lights\n         */\n        function Light(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.diffuse = new BABYLON.Color3(1.0, 1.0, 1.0);\n            _this.specular = new BABYLON.Color3(1.0, 1.0, 1.0);\n            _this.intensity = 1.0;\n            _this.range = Number.MAX_VALUE;\n            /**\n             * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\n             * of light.\n             */\n            _this._photometricScale = 1.0;\n            _this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;\n            _this._radius = 0.00001;\n            _this.renderPriority = 0;\n            /**\n             * Defines wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\n             * the current shadow generator.\n             */\n            _this.shadowEnabled = true;\n            _this._excludeWithLayerMask = 0;\n            _this._includeOnlyWithLayerMask = 0;\n            _this._lightmapMode = 0;\n            _this._excludedMeshesIds = new Array();\n            _this._includedOnlyMeshesIds = new Array();\n            _this.getScene().addLight(_this);\n            _this._uniformBuffer = new BABYLON.UniformBuffer(_this.getScene().getEngine());\n            _this._buildUniformLayout();\n            _this.includedOnlyMeshes = new Array();\n            _this.excludedMeshes = new Array();\n            _this._resyncMeshes();\n            return _this;\n        }\n        Object.defineProperty(Light, \"LIGHTMAP_DEFAULT\", {\n            /**\n             * If every light affecting the material is in this lightmapMode,\n             * material.lightmapTexture adds or multiplies\n             * (depends on material.useLightmapAsShadowmap)\n             * after every other light calculations.\n             */\n            get: function () {\n                return Light._LIGHTMAP_DEFAULT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTMAP_SPECULAR\", {\n            /**\n             * material.lightmapTexture as only diffuse lighting from this light\n             * adds pnly specular lighting from this light\n             * adds dynamic shadows\n             */\n            get: function () {\n                return Light._LIGHTMAP_SPECULAR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTMAP_SHADOWSONLY\", {\n            /**\n             * material.lightmapTexture as only lighting\n             * no light calculation from this light\n             * only adds dynamic shadows from this light\n             */\n            get: function () {\n                return Light._LIGHTMAP_SHADOWSONLY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"INTENSITYMODE_AUTOMATIC\", {\n            /**\n             * Each light type uses the default quantity according to its type:\n             *      point/spot lights use luminous intensity\n             *      directional lights use illuminance\n             */\n            get: function () {\n                return Light._INTENSITYMODE_AUTOMATIC;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"INTENSITYMODE_LUMINOUSPOWER\", {\n            /**\n             * lumen (lm)\n             */\n            get: function () {\n                return Light._INTENSITYMODE_LUMINOUSPOWER;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"INTENSITYMODE_LUMINOUSINTENSITY\", {\n            /**\n             * candela (lm/sr)\n             */\n            get: function () {\n                return Light._INTENSITYMODE_LUMINOUSINTENSITY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"INTENSITYMODE_ILLUMINANCE\", {\n            /**\n             * lux (lm/m^2)\n             */\n            get: function () {\n                return Light._INTENSITYMODE_ILLUMINANCE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"INTENSITYMODE_LUMINANCE\", {\n            /**\n             * nit (cd/m^2)\n             */\n            get: function () {\n                return Light._INTENSITYMODE_LUMINANCE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTTYPEID_POINTLIGHT\", {\n            /**\n             * Light type const id of the point light.\n             */\n            get: function () {\n                return Light._LIGHTTYPEID_POINTLIGHT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTTYPEID_DIRECTIONALLIGHT\", {\n            /**\n             * Light type const id of the directional light.\n             */\n            get: function () {\n                return Light._LIGHTTYPEID_DIRECTIONALLIGHT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTTYPEID_SPOTLIGHT\", {\n            /**\n             * Light type const id of the spot light.\n             */\n            get: function () {\n                return Light._LIGHTTYPEID_SPOTLIGHT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light, \"LIGHTTYPEID_HEMISPHERICLIGHT\", {\n            /**\n             * Light type const id of the hemispheric light.\n             */\n            get: function () {\n                return Light._LIGHTTYPEID_HEMISPHERICLIGHT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light.prototype, \"intensityMode\", {\n            /**\n             * Gets the photometric scale used to interpret the intensity.\n             * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n             */\n            get: function () {\n                return this._intensityMode;\n            },\n            /**\n             * Sets the photometric scale used to interpret the intensity.\n             * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\n             */\n            set: function (value) {\n                this._intensityMode = value;\n                this._computePhotometricScale();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(Light.prototype, \"radius\", {\n            /**\n             * Gets the light radius used by PBR Materials to simulate soft area lights.\n             */\n            get: function () {\n                return this._radius;\n            },\n            /**\n             * sets the light radius used by PBR Materials to simulate soft area lights.\n             */\n            set: function (value) {\n                this._radius = value;\n                this._computePhotometricScale();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(Light.prototype, \"includedOnlyMeshes\", {\n            get: function () {\n                return this._includedOnlyMeshes;\n            },\n            set: function (value) {\n                this._includedOnlyMeshes = value;\n                this._hookArrayForIncludedOnly(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light.prototype, \"excludedMeshes\", {\n            get: function () {\n                return this._excludedMeshes;\n            },\n            set: function (value) {\n                this._excludedMeshes = value;\n                this._hookArrayForExcluded(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light.prototype, \"excludeWithLayerMask\", {\n            get: function () {\n                return this._excludeWithLayerMask;\n            },\n            set: function (value) {\n                this._excludeWithLayerMask = value;\n                this._resyncMeshes();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light.prototype, \"includeOnlyWithLayerMask\", {\n            get: function () {\n                return this._includeOnlyWithLayerMask;\n            },\n            set: function (value) {\n                this._includeOnlyWithLayerMask = value;\n                this._resyncMeshes();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Light.prototype, \"lightmapMode\", {\n            get: function () {\n                return this._lightmapMode;\n            },\n            set: function (value) {\n                if (this._lightmapMode === value) {\n                    return;\n                }\n                this._lightmapMode = value;\n                this._markMeshesAsLightDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Light.prototype._buildUniformLayout = function () {\n            // Overridden\n        };\n        /**\n         * Returns the string \"Light\".\n         */\n        Light.prototype.getClassName = function () {\n            return \"Light\";\n        };\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        Light.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name;\n            ret += \", type: \" + ([\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"])[this.getTypeID()];\n            if (this.animations) {\n                for (var i = 0; i < this.animations.length; i++) {\n                    ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n                }\n            }\n            if (fullDetails) {\n            }\n            return ret;\n        };\n        /**\n         * Set the enabled state of this node.\n         * @param {boolean} value - the new enabled state\n         * @see isEnabled\n         */\n        Light.prototype.setEnabled = function (value) {\n            _super.prototype.setEnabled.call(this, value);\n            this._resyncMeshes();\n        };\n        /**\n         * Returns the Light associated shadow generator.\n         */\n        Light.prototype.getShadowGenerator = function () {\n            return this._shadowGenerator;\n        };\n        /**\n         * Returns a Vector3, the absolute light position in the World.\n         */\n        Light.prototype.getAbsolutePosition = function () {\n            return BABYLON.Vector3.Zero();\n        };\n        Light.prototype.transferToEffect = function (effect, lightIndex) {\n        };\n        Light.prototype._getWorldMatrix = function () {\n            return BABYLON.Matrix.Identity();\n        };\n        /**\n         * Boolean : True if the light will affect the passed mesh.\n         */\n        Light.prototype.canAffectMesh = function (mesh) {\n            if (!mesh) {\n                return true;\n            }\n            if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\n                return false;\n            }\n            if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n                return false;\n            }\n            if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\n                return false;\n            }\n            if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\n                return false;\n            }\n            return true;\n        };\n        /**\n         * Returns the light World matrix.\n         */\n        Light.prototype.getWorldMatrix = function () {\n            this._currentRenderId = this.getScene().getRenderId();\n            var worldMatrix = this._getWorldMatrix();\n            if (this.parent && this.parent.getWorldMatrix) {\n                if (!this._parentedWorldMatrix) {\n                    this._parentedWorldMatrix = BABYLON.Matrix.Identity();\n                }\n                worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._parentedWorldMatrix);\n                this._markSyncedWithParent();\n                return this._parentedWorldMatrix;\n            }\n            return worldMatrix;\n        };\n        /**\n         * Sort function to order lights for rendering.\n         * @param a First Light object to compare to second.\n         * @param b Second Light object to compare first.\n         * @return -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\n         */\n        Light.compareLightsPriority = function (a, b) {\n            //shadow-casting lights have priority over non-shadow-casting lights\n            //the renderPrioirty is a secondary sort criterion\n            if (a.shadowEnabled !== b.shadowEnabled) {\n                return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n            }\n            return b.renderPriority - a.renderPriority;\n        };\n        /**\n         * Disposes the light.\n         */\n        Light.prototype.dispose = function () {\n            if (this._shadowGenerator) {\n                this._shadowGenerator.dispose();\n                this._shadowGenerator = null;\n            }\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Remove from meshes\n            for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n                var mesh = _a[_i];\n                mesh._removeLightSource(this);\n            }\n            this._uniformBuffer.dispose();\n            // Remove from scene\n            this.getScene().removeLight(this);\n            _super.prototype.dispose.call(this);\n        };\n        /**\n         * Returns the light type ID (integer).\n         */\n        Light.prototype.getTypeID = function () {\n            return 0;\n        };\n        /**\n         * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\n         */\n        Light.prototype.getScaledIntensity = function () {\n            return this._photometricScale * this.intensity;\n        };\n        /**\n         * Returns a new Light object, named \"name\", from the current one.\n         */\n        Light.prototype.clone = function (name) {\n            return BABYLON.SerializationHelper.Clone(Light.GetConstructorFromName(this.getTypeID(), name, this.getScene()), this);\n        };\n        /**\n         * Serializes the current light into a Serialization object.\n         * Returns the serialized object.\n         */\n        Light.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            // Type\n            serializationObject.type = this.getTypeID();\n            // Parent\n            if (this.parent) {\n                serializationObject.parentId = this.parent.id;\n            }\n            // Inclusion / exclusions\n            if (this.excludedMeshes.length > 0) {\n                serializationObject.excludedMeshesIds = [];\n                this.excludedMeshes.forEach(function (mesh) {\n                    serializationObject.excludedMeshesIds.push(mesh.id);\n                });\n            }\n            if (this.includedOnlyMeshes.length > 0) {\n                serializationObject.includedOnlyMeshesIds = [];\n                this.includedOnlyMeshes.forEach(function (mesh) {\n                    serializationObject.includedOnlyMeshesIds.push(mesh.id);\n                });\n            }\n            // Animations  \n            BABYLON.Animation.AppendSerializedAnimations(this, serializationObject);\n            serializationObject.ranges = this.serializeAnimationRanges();\n            return serializationObject;\n        };\n        /**\n         * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\n         * This new light is named \"name\" and added to the passed scene.\n         */\n        Light.GetConstructorFromName = function (type, name, scene) {\n            switch (type) {\n                case 0:\n                    return function () { return new BABYLON.PointLight(name, BABYLON.Vector3.Zero(), scene); };\n                case 1:\n                    return function () { return new BABYLON.DirectionalLight(name, BABYLON.Vector3.Zero(), scene); };\n                case 2:\n                    return function () { return new BABYLON.SpotLight(name, BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), 0, 0, scene); };\n                case 3:\n                    return function () { return new BABYLON.HemisphericLight(name, BABYLON.Vector3.Zero(), scene); };\n            }\n        };\n        /**\n         * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\n         */\n        Light.Parse = function (parsedLight, scene) {\n            var light = BABYLON.SerializationHelper.Parse(Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene), parsedLight, scene);\n            // Inclusion / exclusions\n            if (parsedLight.excludedMeshesIds) {\n                light._excludedMeshesIds = parsedLight.excludedMeshesIds;\n            }\n            if (parsedLight.includedOnlyMeshesIds) {\n                light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\n            }\n            // Parent\n            if (parsedLight.parentId) {\n                light._waitingParentId = parsedLight.parentId;\n            }\n            // Animations\n            if (parsedLight.animations) {\n                for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedLight.animations[animationIndex];\n                    light.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n                BABYLON.Node.ParseAnimationRanges(light, parsedLight, scene);\n            }\n            if (parsedLight.autoAnimate) {\n                scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\n            }\n            return light;\n        };\n        Light.prototype._hookArrayForExcluded = function (array) {\n            var _this = this;\n            var oldPush = array.push;\n            array.push = function () {\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                var result = oldPush.apply(array, items);\n                for (var _a = 0, items_1 = items; _a < items_1.length; _a++) {\n                    var item = items_1[_a];\n                    item._resyncLighSource(_this);\n                }\n                return result;\n            };\n            var oldSplice = array.splice;\n            array.splice = function (index, deleteCount) {\n                var deleted = oldSplice.apply(array, [index, deleteCount]);\n                for (var _i = 0, deleted_1 = deleted; _i < deleted_1.length; _i++) {\n                    var item = deleted_1[_i];\n                    item._resyncLighSource(_this);\n                }\n                return deleted;\n            };\n            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n                var item = array_1[_i];\n                item._resyncLighSource(this);\n            }\n        };\n        Light.prototype._hookArrayForIncludedOnly = function (array) {\n            var _this = this;\n            var oldPush = array.push;\n            array.push = function () {\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                var result = oldPush.apply(array, items);\n                _this._resyncMeshes();\n                return result;\n            };\n            var oldSplice = array.splice;\n            array.splice = function (index, deleteCount) {\n                var deleted = oldSplice.apply(array, [index, deleteCount]);\n                _this._resyncMeshes();\n                return deleted;\n            };\n            this._resyncMeshes();\n        };\n        Light.prototype._resyncMeshes = function () {\n            for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n                var mesh = _a[_i];\n                mesh._resyncLighSource(this);\n            }\n        };\n        Light.prototype._markMeshesAsLightDirty = function () {\n            for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n                var mesh = _a[_i];\n                if (mesh._lightSources.indexOf(this) !== -1) {\n                    mesh._markSubMeshesAsLightDirty();\n                }\n            }\n        };\n        /**\n         * Recomputes the cached photometric scale if needed.\n         */\n        Light.prototype._computePhotometricScale = function () {\n            this._photometricScale = this._getPhotometricScale();\n            this.getScene().resetCachedMaterial();\n        };\n        /**\n         * Returns the Photometric Scale according to the light type and intensity mode.\n         */\n        Light.prototype._getPhotometricScale = function () {\n            var photometricScale = 0.0;\n            var lightTypeID = this.getTypeID();\n            //get photometric mode\n            var photometricMode = this.intensityMode;\n            if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\n                if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\n                    photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\n                }\n                else {\n                    photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\n                }\n            }\n            //compute photometric scale\n            switch (lightTypeID) {\n                case Light.LIGHTTYPEID_POINTLIGHT:\n                case Light.LIGHTTYPEID_SPOTLIGHT:\n                    switch (photometricMode) {\n                        case Light.INTENSITYMODE_LUMINOUSPOWER:\n                            photometricScale = 1.0 / (4.0 * Math.PI);\n                            break;\n                        case Light.INTENSITYMODE_LUMINOUSINTENSITY:\n                            photometricScale = 1.0;\n                            break;\n                        case Light.INTENSITYMODE_LUMINANCE:\n                            photometricScale = this.radius * this.radius;\n                            break;\n                    }\n                    break;\n                case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\n                    switch (photometricMode) {\n                        case Light.INTENSITYMODE_ILLUMINANCE:\n                            photometricScale = 1.0;\n                            break;\n                        case Light.INTENSITYMODE_LUMINANCE:\n                            // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\n                            // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\n                            var apexAngleRadians = this.radius;\n                            // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\n                            apexAngleRadians = Math.max(apexAngleRadians, 0.001);\n                            var solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\n                            photometricScale = solidAngle;\n                            break;\n                    }\n                    break;\n                case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\n                    // No fall off in hemisperic light.\n                    photometricScale = 1.0;\n                    break;\n            }\n            return photometricScale;\n        };\n        Light.prototype._reorderLightsInScene = function () {\n            var scene = this.getScene();\n            if (this.renderPriority != 0) {\n                scene.requireLightSorting = true;\n            }\n            this.getScene().sortLightsByPriority();\n        };\n        return Light;\n    }(BABYLON.Node));\n    //lightmapMode Consts\n    Light._LIGHTMAP_DEFAULT = 0;\n    Light._LIGHTMAP_SPECULAR = 1;\n    Light._LIGHTMAP_SHADOWSONLY = 2;\n    // Intensity Mode Consts\n    Light._INTENSITYMODE_AUTOMATIC = 0;\n    Light._INTENSITYMODE_LUMINOUSPOWER = 1;\n    Light._INTENSITYMODE_LUMINOUSINTENSITY = 2;\n    Light._INTENSITYMODE_ILLUMINANCE = 3;\n    Light._INTENSITYMODE_LUMINANCE = 4;\n    // Light types ids const.\n    Light._LIGHTTYPEID_POINTLIGHT = 0;\n    Light._LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n    Light._LIGHTTYPEID_SPOTLIGHT = 2;\n    Light._LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n    __decorate([\n        BABYLON.serializeAsColor3()\n    ], Light.prototype, \"diffuse\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3()\n    ], Light.prototype, \"specular\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"intensity\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"range\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"intensityMode\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"radius\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"_renderPriority\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_reorderLightsInScene\")\n    ], Light.prototype, \"renderPriority\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Light.prototype, \"shadowEnabled\", void 0);\n    __decorate([\n        BABYLON.serialize(\"excludeWithLayerMask\")\n    ], Light.prototype, \"_excludeWithLayerMask\", void 0);\n    __decorate([\n        BABYLON.serialize(\"includeOnlyWithLayerMask\")\n    ], Light.prototype, \"_includeOnlyWithLayerMask\", void 0);\n    __decorate([\n        BABYLON.serialize(\"lightmapMode\")\n    ], Light.prototype, \"_lightmapMode\", void 0);\n    BABYLON.Light = Light;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.light.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Camera = (function (_super) {\n        __extends(Camera, _super);\n        function Camera(name, position, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.upVector = BABYLON.Vector3.Up();\n            _this.orthoLeft = null;\n            _this.orthoRight = null;\n            _this.orthoBottom = null;\n            _this.orthoTop = null;\n            _this.fov = 0.8;\n            _this.minZ = 1.0;\n            _this.maxZ = 10000.0;\n            _this.inertia = 0.9;\n            _this.mode = Camera.PERSPECTIVE_CAMERA;\n            _this.isIntermediate = false;\n            _this.viewport = new BABYLON.Viewport(0, 0, 1.0, 1.0);\n            _this.layerMask = 0x0FFFFFFF;\n            _this.fovMode = Camera.FOVMODE_VERTICAL_FIXED;\n            // Camera rig members\n            _this.cameraRigMode = Camera.RIG_MODE_NONE;\n            _this._rigCameras = new Array();\n            _this._webvrViewMatrix = BABYLON.Matrix.Identity();\n            _this.customRenderTargets = new Array();\n            // Cache\n            _this._computedViewMatrix = BABYLON.Matrix.Identity();\n            _this._projectionMatrix = new BABYLON.Matrix();\n            _this._doNotComputeProjectionMatrix = false;\n            _this._postProcesses = new Array();\n            _this._transformMatrix = BABYLON.Matrix.Zero();\n            _this._activeMeshes = new BABYLON.SmartArray(256);\n            _this._globalPosition = BABYLON.Vector3.Zero();\n            _this._refreshFrustumPlanes = true;\n            _this.getScene().addCamera(_this);\n            if (!_this.getScene().activeCamera) {\n                _this.getScene().activeCamera = _this;\n            }\n            _this.position = position;\n            return _this;\n        }\n        Object.defineProperty(Camera, \"PERSPECTIVE_CAMERA\", {\n            get: function () {\n                return Camera._PERSPECTIVE_CAMERA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"ORTHOGRAPHIC_CAMERA\", {\n            get: function () {\n                return Camera._ORTHOGRAPHIC_CAMERA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"FOVMODE_VERTICAL_FIXED\", {\n            get: function () {\n                return Camera._FOVMODE_VERTICAL_FIXED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"FOVMODE_HORIZONTAL_FIXED\", {\n            get: function () {\n                return Camera._FOVMODE_HORIZONTAL_FIXED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_NONE\", {\n            get: function () {\n                return Camera._RIG_MODE_NONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_STEREOSCOPIC_ANAGLYPH\", {\n            get: function () {\n                return Camera._RIG_MODE_STEREOSCOPIC_ANAGLYPH;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL\", {\n            get: function () {\n                return Camera._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED\", {\n            get: function () {\n                return Camera._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_STEREOSCOPIC_OVERUNDER\", {\n            get: function () {\n                return Camera._RIG_MODE_STEREOSCOPIC_OVERUNDER;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_VR\", {\n            get: function () {\n                return Camera._RIG_MODE_VR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera, \"RIG_MODE_WEBVR\", {\n            get: function () {\n                return Camera._RIG_MODE_WEBVR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Camera.prototype.getClassName = function () {\n            return \"Camera\";\n        };\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        Camera.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name;\n            ret += \", type: \" + this.getClassName();\n            if (this.animations) {\n                for (var i = 0; i < this.animations.length; i++) {\n                    ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n                }\n            }\n            if (fullDetails) {\n            }\n            return ret;\n        };\n        Object.defineProperty(Camera.prototype, \"globalPosition\", {\n            get: function () {\n                return this._globalPosition;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Camera.prototype.getActiveMeshes = function () {\n            return this._activeMeshes;\n        };\n        Camera.prototype.isActiveMesh = function (mesh) {\n            return (this._activeMeshes.indexOf(mesh) !== -1);\n        };\n        //Cache\n        Camera.prototype._initCache = function () {\n            _super.prototype._initCache.call(this);\n            this._cache.position = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            this._cache.upVector = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            this._cache.mode = undefined;\n            this._cache.minZ = undefined;\n            this._cache.maxZ = undefined;\n            this._cache.fov = undefined;\n            this._cache.fovMode = undefined;\n            this._cache.aspectRatio = undefined;\n            this._cache.orthoLeft = undefined;\n            this._cache.orthoRight = undefined;\n            this._cache.orthoBottom = undefined;\n            this._cache.orthoTop = undefined;\n            this._cache.renderWidth = undefined;\n            this._cache.renderHeight = undefined;\n        };\n        Camera.prototype._updateCache = function (ignoreParentClass) {\n            if (!ignoreParentClass) {\n                _super.prototype._updateCache.call(this);\n            }\n            var engine = this.getEngine();\n            this._cache.position.copyFrom(this.position);\n            this._cache.upVector.copyFrom(this.upVector);\n            this._cache.mode = this.mode;\n            this._cache.minZ = this.minZ;\n            this._cache.maxZ = this.maxZ;\n            this._cache.fov = this.fov;\n            this._cache.fovMode = this.fovMode;\n            this._cache.aspectRatio = engine.getAspectRatio(this);\n            this._cache.orthoLeft = this.orthoLeft;\n            this._cache.orthoRight = this.orthoRight;\n            this._cache.orthoBottom = this.orthoBottom;\n            this._cache.orthoTop = this.orthoTop;\n            this._cache.renderWidth = engine.getRenderWidth();\n            this._cache.renderHeight = engine.getRenderHeight();\n        };\n        Camera.prototype._updateFromScene = function () {\n            this.updateCache();\n            this.update();\n        };\n        // Synchronized\n        Camera.prototype._isSynchronized = function () {\n            return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();\n        };\n        Camera.prototype._isSynchronizedViewMatrix = function () {\n            if (!_super.prototype._isSynchronized.call(this))\n                return false;\n            return this._cache.position.equals(this.position)\n                && this._cache.upVector.equals(this.upVector)\n                && this.isSynchronizedWithParent();\n        };\n        Camera.prototype._isSynchronizedProjectionMatrix = function () {\n            var check = this._cache.mode === this.mode\n                && this._cache.minZ === this.minZ\n                && this._cache.maxZ === this.maxZ;\n            if (!check) {\n                return false;\n            }\n            var engine = this.getEngine();\n            if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n                check = this._cache.fov === this.fov\n                    && this._cache.fovMode === this.fovMode\n                    && this._cache.aspectRatio === engine.getAspectRatio(this);\n            }\n            else {\n                check = this._cache.orthoLeft === this.orthoLeft\n                    && this._cache.orthoRight === this.orthoRight\n                    && this._cache.orthoBottom === this.orthoBottom\n                    && this._cache.orthoTop === this.orthoTop\n                    && this._cache.renderWidth === engine.getRenderWidth()\n                    && this._cache.renderHeight === engine.getRenderHeight();\n            }\n            return check;\n        };\n        // Controls\n        Camera.prototype.attachControl = function (element, noPreventDefault) {\n        };\n        Camera.prototype.detachControl = function (element) {\n        };\n        Camera.prototype.update = function () {\n            if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n                this._updateRigCameras();\n            }\n            this._checkInputs();\n        };\n        Camera.prototype._checkInputs = function () {\n        };\n        Object.defineProperty(Camera.prototype, \"rigCameras\", {\n            get: function () {\n                return this._rigCameras;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera.prototype, \"rigPostProcess\", {\n            get: function () {\n                return this._rigPostProcess;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Camera.prototype._cascadePostProcessesToRigCams = function () {\n            // invalidate framebuffer\n            if (this._postProcesses.length > 0) {\n                this._postProcesses[0].markTextureDirty();\n            }\n            // glue the rigPostProcess to the end of the user postprocesses & assign to each sub-camera\n            for (var i = 0, len = this._rigCameras.length; i < len; i++) {\n                var cam = this._rigCameras[i];\n                var rigPostProcess = cam._rigPostProcess;\n                // for VR rig, there does not have to be a post process \n                if (rigPostProcess) {\n                    var isPass = rigPostProcess instanceof BABYLON.PassPostProcess;\n                    if (isPass) {\n                        // any rig which has a PassPostProcess for rig[0], cannot be isIntermediate when there are also user postProcesses\n                        cam.isIntermediate = this._postProcesses.length === 0;\n                    }\n                    cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);\n                    rigPostProcess.markTextureDirty();\n                }\n                else {\n                    cam._postProcesses = this._postProcesses.slice(0);\n                }\n            }\n        };\n        Camera.prototype.attachPostProcess = function (postProcess, insertAt) {\n            if (insertAt === void 0) { insertAt = null; }\n            if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {\n                BABYLON.Tools.Error(\"You're trying to reuse a post process not defined as reusable.\");\n                return 0;\n            }\n            if (insertAt == null || insertAt < 0) {\n                this._postProcesses.push(postProcess);\n            }\n            else {\n                this._postProcesses.splice(insertAt, 0, postProcess);\n            }\n            this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated            \n            return this._postProcesses.indexOf(postProcess);\n        };\n        Camera.prototype.detachPostProcess = function (postProcess, atIndices) {\n            if (atIndices === void 0) { atIndices = null; }\n            var result = [];\n            var i;\n            var index;\n            if (!atIndices) {\n                var idx = this._postProcesses.indexOf(postProcess);\n                if (idx !== -1) {\n                    this._postProcesses.splice(idx, 1);\n                }\n            }\n            else {\n                atIndices = (atIndices instanceof Array) ? atIndices : [atIndices];\n                // iterate descending, so can just splice as we go\n                for (i = atIndices.length - 1; i >= 0; i--) {\n                    if (this._postProcesses[atIndices[i]] !== postProcess) {\n                        result.push(i);\n                        continue;\n                    }\n                    index = atIndices[i];\n                    this._postProcesses.splice(index, 1);\n                }\n            }\n            this._cascadePostProcessesToRigCams(); // also ensures framebuffer invalidated\n            return result;\n        };\n        Camera.prototype.getWorldMatrix = function () {\n            if (!this._worldMatrix) {\n                this._worldMatrix = BABYLON.Matrix.Identity();\n            }\n            var viewMatrix = this.getViewMatrix();\n            viewMatrix.invertToRef(this._worldMatrix);\n            return this._worldMatrix;\n        };\n        Camera.prototype._getViewMatrix = function () {\n            return BABYLON.Matrix.Identity();\n        };\n        Camera.prototype.getViewMatrix = function (force) {\n            this._computedViewMatrix = this._computeViewMatrix(force);\n            if (!force && this._isSynchronizedViewMatrix()) {\n                return this._computedViewMatrix;\n            }\n            this._refreshFrustumPlanes = true;\n            if (!this.parent || !this.parent.getWorldMatrix) {\n                this._globalPosition.copyFrom(this.position);\n            }\n            else {\n                if (!this._worldMatrix) {\n                    this._worldMatrix = BABYLON.Matrix.Identity();\n                }\n                this._computedViewMatrix.invertToRef(this._worldMatrix);\n                this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._computedViewMatrix);\n                this._globalPosition.copyFromFloats(this._computedViewMatrix.m[12], this._computedViewMatrix.m[13], this._computedViewMatrix.m[14]);\n                this._computedViewMatrix.invert();\n                this._markSyncedWithParent();\n            }\n            if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {\n                this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);\n            }\n            this._currentRenderId = this.getScene().getRenderId();\n            return this._computedViewMatrix;\n        };\n        Camera.prototype._computeViewMatrix = function (force) {\n            if (!force && this._isSynchronizedViewMatrix()) {\n                return this._computedViewMatrix;\n            }\n            this._computedViewMatrix = this._getViewMatrix();\n            this._currentRenderId = this.getScene().getRenderId();\n            return this._computedViewMatrix;\n        };\n        Camera.prototype.freezeProjectionMatrix = function (projection) {\n            this._doNotComputeProjectionMatrix = true;\n            if (projection !== undefined) {\n                this._projectionMatrix = projection;\n            }\n        };\n        ;\n        Camera.prototype.unfreezeProjectionMatrix = function () {\n            this._doNotComputeProjectionMatrix = false;\n        };\n        ;\n        Camera.prototype.getProjectionMatrix = function (force) {\n            if (this._doNotComputeProjectionMatrix || (!force && this._isSynchronizedProjectionMatrix())) {\n                return this._projectionMatrix;\n            }\n            this._refreshFrustumPlanes = true;\n            var engine = this.getEngine();\n            var scene = this.getScene();\n            if (this.mode === Camera.PERSPECTIVE_CAMERA) {\n                if (this.minZ <= 0) {\n                    this.minZ = 0.1;\n                }\n                if (scene.useRightHandedSystem) {\n                    BABYLON.Matrix.PerspectiveFovRHToRef(this.fov, engine.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED);\n                }\n                else {\n                    BABYLON.Matrix.PerspectiveFovLHToRef(this.fov, engine.getAspectRatio(this), this.minZ, this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED);\n                }\n                return this._projectionMatrix;\n            }\n            var halfWidth = engine.getRenderWidth() / 2.0;\n            var halfHeight = engine.getRenderHeight() / 2.0;\n            if (scene.useRightHandedSystem) {\n                BABYLON.Matrix.OrthoOffCenterRHToRef(this.orthoLeft || -halfWidth, this.orthoRight || halfWidth, this.orthoBottom || -halfHeight, this.orthoTop || halfHeight, this.minZ, this.maxZ, this._projectionMatrix);\n            }\n            else {\n                BABYLON.Matrix.OrthoOffCenterLHToRef(this.orthoLeft || -halfWidth, this.orthoRight || halfWidth, this.orthoBottom || -halfHeight, this.orthoTop || halfHeight, this.minZ, this.maxZ, this._projectionMatrix);\n            }\n            return this._projectionMatrix;\n        };\n        Camera.prototype.getTranformationMatrix = function () {\n            this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n            return this._transformMatrix;\n        };\n        Camera.prototype.updateFrustumPlanes = function () {\n            if (!this._refreshFrustumPlanes) {\n                return;\n            }\n            this.getTranformationMatrix();\n            if (!this._frustumPlanes) {\n                this._frustumPlanes = BABYLON.Frustum.GetPlanes(this._transformMatrix);\n            }\n            else {\n                BABYLON.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n            }\n            this._refreshFrustumPlanes = false;\n        };\n        Camera.prototype.isInFrustum = function (target) {\n            this.updateFrustumPlanes();\n            return target.isInFrustum(this._frustumPlanes);\n        };\n        Camera.prototype.isCompletelyInFrustum = function (target) {\n            this.updateFrustumPlanes();\n            return target.isCompletelyInFrustum(this._frustumPlanes);\n        };\n        Camera.prototype.getForwardRay = function (length, transform, origin) {\n            if (length === void 0) { length = 100; }\n            if (!transform) {\n                transform = this.getWorldMatrix();\n            }\n            if (!origin) {\n                origin = this.position;\n            }\n            var forward = new BABYLON.Vector3(0, 0, 1);\n            var forwardWorld = BABYLON.Vector3.TransformNormal(forward, transform);\n            var direction = BABYLON.Vector3.Normalize(forwardWorld);\n            return new BABYLON.Ray(origin, direction, length);\n        };\n        Camera.prototype.dispose = function () {\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Remove from scene\n            this.getScene().removeCamera(this);\n            while (this._rigCameras.length > 0) {\n                this._rigCameras.pop().dispose();\n            }\n            // Postprocesses\n            var i = this._postProcesses.length;\n            while (--i >= 0) {\n                this._postProcesses[i].dispose(this);\n            }\n            _super.prototype.dispose.call(this);\n        };\n        Object.defineProperty(Camera.prototype, \"leftCamera\", {\n            // ---- Camera rigs section ----\n            get: function () {\n                if (this._rigCameras.length < 1) {\n                    return undefined;\n                }\n                return this._rigCameras[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Camera.prototype, \"rightCamera\", {\n            get: function () {\n                if (this._rigCameras.length < 2) {\n                    return undefined;\n                }\n                return this._rigCameras[1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Camera.prototype.getLeftTarget = function () {\n            if (this._rigCameras.length < 1) {\n                return undefined;\n            }\n            return this._rigCameras[0].getTarget();\n        };\n        Camera.prototype.getRightTarget = function () {\n            if (this._rigCameras.length < 2) {\n                return undefined;\n            }\n            return this._rigCameras[1].getTarget();\n        };\n        Camera.prototype.setCameraRigMode = function (mode, rigParams) {\n            while (this._rigCameras.length > 0) {\n                this._rigCameras.pop().dispose();\n            }\n            this.cameraRigMode = mode;\n            this._cameraRigParams = {};\n            //we have to implement stereo camera calcultating left and right viewpoints from interaxialDistance and target, \n            //not from a given angle as it is now, but until that complete code rewriting provisional stereoHalfAngle value is introduced\n            this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;\n            this._cameraRigParams.stereoHalfAngle = BABYLON.Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);\n            // create the rig cameras, unless none\n            if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\n                this._rigCameras.push(this.createRigCamera(this.name + \"_L\", 0));\n                this._rigCameras.push(this.createRigCamera(this.name + \"_R\", 1));\n            }\n            switch (this.cameraRigMode) {\n                case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n                    this._rigCameras[0]._rigPostProcess = new BABYLON.PassPostProcess(this.name + \"_passthru\", 1.0, this._rigCameras[0]);\n                    this._rigCameras[1]._rigPostProcess = new BABYLON.AnaglyphPostProcess(this.name + \"_anaglyph\", 1.0, this._rigCameras);\n                    break;\n                case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n                case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n                    var isStereoscopicHoriz = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL || this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED;\n                    this._rigCameras[0]._rigPostProcess = new BABYLON.PassPostProcess(this.name + \"_passthru\", 1.0, this._rigCameras[0]);\n                    this._rigCameras[1]._rigPostProcess = new BABYLON.StereoscopicInterlacePostProcess(this.name + \"_stereoInterlace\", this._rigCameras, isStereoscopicHoriz);\n                    break;\n                case Camera.RIG_MODE_VR:\n                    var metrics = rigParams.vrCameraMetrics || BABYLON.VRCameraMetrics.GetDefault();\n                    this._rigCameras[0]._cameraRigParams.vrMetrics = metrics;\n                    this._rigCameras[0].viewport = new BABYLON.Viewport(0, 0, 0.5, 1.0);\n                    this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new BABYLON.Matrix();\n                    this._rigCameras[0]._cameraRigParams.vrHMatrix = metrics.leftHMatrix;\n                    this._rigCameras[0]._cameraRigParams.vrPreViewMatrix = metrics.leftPreViewMatrix;\n                    this._rigCameras[0].getProjectionMatrix = this._rigCameras[0]._getVRProjectionMatrix;\n                    this._rigCameras[1]._cameraRigParams.vrMetrics = metrics;\n                    this._rigCameras[1].viewport = new BABYLON.Viewport(0.5, 0, 0.5, 1.0);\n                    this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new BABYLON.Matrix();\n                    this._rigCameras[1]._cameraRigParams.vrHMatrix = metrics.rightHMatrix;\n                    this._rigCameras[1]._cameraRigParams.vrPreViewMatrix = metrics.rightPreViewMatrix;\n                    this._rigCameras[1].getProjectionMatrix = this._rigCameras[1]._getVRProjectionMatrix;\n                    if (metrics.compensateDistortion) {\n                        this._rigCameras[0]._rigPostProcess = new BABYLON.VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Left\", this._rigCameras[0], false, metrics);\n                        this._rigCameras[1]._rigPostProcess = new BABYLON.VRDistortionCorrectionPostProcess(\"VR_Distort_Compensation_Right\", this._rigCameras[1], true, metrics);\n                    }\n                    break;\n                case Camera.RIG_MODE_WEBVR:\n                    if (rigParams.vrDisplay) {\n                        var leftEye = rigParams.vrDisplay.getEyeParameters('left');\n                        var rightEye = rigParams.vrDisplay.getEyeParameters('right');\n                        //Left eye\n                        this._rigCameras[0].viewport = new BABYLON.Viewport(0, 0, 0.5, 1.0);\n                        this._rigCameras[0].setCameraRigParameter(\"left\", true);\n                        this._rigCameras[0].setCameraRigParameter(\"specs\", rigParams.specs);\n                        this._rigCameras[0].setCameraRigParameter(\"eyeParameters\", leftEye);\n                        this._rigCameras[0].setCameraRigParameter(\"frameData\", rigParams.frameData);\n                        this._rigCameras[0].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\n                        this._rigCameras[0]._cameraRigParams.vrWorkMatrix = new BABYLON.Matrix();\n                        this._rigCameras[0].getProjectionMatrix = this._getWebVRProjectionMatrix;\n                        this._rigCameras[0].parent = this;\n                        this._rigCameras[0]._getViewMatrix = this._getWebVRViewMatrix;\n                        //Right eye\n                        this._rigCameras[1].viewport = new BABYLON.Viewport(0.5, 0, 0.5, 1.0);\n                        this._rigCameras[1].setCameraRigParameter('eyeParameters', rightEye);\n                        this._rigCameras[1].setCameraRigParameter(\"specs\", rigParams.specs);\n                        this._rigCameras[1].setCameraRigParameter(\"frameData\", rigParams.frameData);\n                        this._rigCameras[1].setCameraRigParameter(\"parentCamera\", rigParams.parentCamera);\n                        this._rigCameras[1]._cameraRigParams.vrWorkMatrix = new BABYLON.Matrix();\n                        this._rigCameras[1].getProjectionMatrix = this._getWebVRProjectionMatrix;\n                        this._rigCameras[1].parent = this;\n                        this._rigCameras[1]._getViewMatrix = this._getWebVRViewMatrix;\n                    }\n                    break;\n            }\n            this._cascadePostProcessesToRigCams();\n            this.\n                update();\n        };\n        Camera.prototype._getVRProjectionMatrix = function () {\n            BABYLON.Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix);\n            this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);\n            return this._projectionMatrix;\n        };\n        Camera.prototype._updateCameraRotationMatrix = function () {\n            //Here for WebVR\n        };\n        Camera.prototype._updateWebVRCameraRotationMatrix = function () {\n            //Here for WebVR\n        };\n        /**\n         * This function MUST be overwritten by the different WebVR cameras available.\n         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n         */\n        Camera.prototype._getWebVRProjectionMatrix = function () {\n            return BABYLON.Matrix.Identity();\n        };\n        /**\n         * This function MUST be overwritten by the different WebVR cameras available.\n         * The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.\n         */\n        Camera.prototype._getWebVRViewMatrix = function () {\n            return BABYLON.Matrix.Identity();\n        };\n        Camera.prototype.setCameraRigParameter = function (name, value) {\n            if (!this._cameraRigParams) {\n                this._cameraRigParams = {};\n            }\n            this._cameraRigParams[name] = value;\n            //provisionnally:\n            if (name === \"interaxialDistance\") {\n                this._cameraRigParams.stereoHalfAngle = BABYLON.Tools.ToRadians(value / 0.0637);\n            }\n        };\n        /**\n         * needs to be overridden by children so sub has required properties to be copied\n         */\n        Camera.prototype.createRigCamera = function (name, cameraIndex) {\n            return null;\n        };\n        /**\n         * May need to be overridden by children\n         */\n        Camera.prototype._updateRigCameras = function () {\n            for (var i = 0; i < this._rigCameras.length; i++) {\n                this._rigCameras[i].minZ = this.minZ;\n                this._rigCameras[i].maxZ = this.maxZ;\n                this._rigCameras[i].fov = this.fov;\n            }\n            // only update viewport when ANAGLYPH\n            if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {\n                this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;\n            }\n        };\n        Camera.prototype._setupInputs = function () {\n        };\n        Camera.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            // Type\n            serializationObject.type = this.getClassName();\n            // Parent\n            if (this.parent) {\n                serializationObject.parentId = this.parent.id;\n            }\n            if (this.inputs) {\n                this.inputs.serialize(serializationObject);\n            }\n            // Animations\n            BABYLON.Animation.AppendSerializedAnimations(this, serializationObject);\n            serializationObject.ranges = this.serializeAnimationRanges();\n            return serializationObject;\n        };\n        Camera.prototype.clone = function (name) {\n            return BABYLON.SerializationHelper.Clone(Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);\n        };\n        Camera.prototype.getDirection = function (localAxis) {\n            var result = BABYLON.Vector3.Zero();\n            this.getDirectionToRef(localAxis, result);\n            return result;\n        };\n        Camera.prototype.getDirectionToRef = function (localAxis, result) {\n            BABYLON.Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);\n        };\n        Camera.GetConstructorFromName = function (type, name, scene, interaxial_distance, isStereoscopicSideBySide) {\n            if (interaxial_distance === void 0) { interaxial_distance = 0; }\n            if (isStereoscopicSideBySide === void 0) { isStereoscopicSideBySide = true; }\n            switch (type) {\n                case \"ArcRotateCamera\":\n                    return function () { return new BABYLON.ArcRotateCamera(name, 0, 0, 1.0, BABYLON.Vector3.Zero(), scene); };\n                case \"DeviceOrientationCamera\":\n                    return function () { return new BABYLON.DeviceOrientationCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"FollowCamera\":\n                    return function () { return new BABYLON.FollowCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"ArcFollowCamera\":\n                    return function () { return new BABYLON.ArcFollowCamera(name, 0, 0, 1.0, null, scene); };\n                case \"GamepadCamera\":\n                    return function () { return new BABYLON.GamepadCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"TouchCamera\":\n                    return function () { return new BABYLON.TouchCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"VirtualJoysticksCamera\":\n                    return function () { return new BABYLON.VirtualJoysticksCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"WebVRFreeCamera\":\n                    return function () { return new BABYLON.WebVRFreeCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"WebVRGamepadCamera\":\n                    return function () { return new BABYLON.WebVRFreeCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"VRDeviceOrientationFreeCamera\":\n                    return function () { return new BABYLON.VRDeviceOrientationFreeCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"VRDeviceOrientationGamepadCamera\":\n                    return function () { return new BABYLON.VRDeviceOrientationGamepadCamera(name, BABYLON.Vector3.Zero(), scene); };\n                case \"AnaglyphArcRotateCamera\":\n                    return function () { return new BABYLON.AnaglyphArcRotateCamera(name, 0, 0, 1.0, BABYLON.Vector3.Zero(), interaxial_distance, scene); };\n                case \"AnaglyphFreeCamera\":\n                    return function () { return new BABYLON.AnaglyphFreeCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, scene); };\n                case \"AnaglyphGamepadCamera\":\n                    return function () { return new BABYLON.AnaglyphGamepadCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, scene); };\n                case \"AnaglyphUniversalCamera\":\n                    return function () { return new BABYLON.AnaglyphUniversalCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, scene); };\n                case \"StereoscopicArcRotateCamera\":\n                    return function () { return new BABYLON.StereoscopicArcRotateCamera(name, 0, 0, 1.0, BABYLON.Vector3.Zero(), interaxial_distance, isStereoscopicSideBySide, scene); };\n                case \"StereoscopicFreeCamera\":\n                    return function () { return new BABYLON.StereoscopicFreeCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, isStereoscopicSideBySide, scene); };\n                case \"StereoscopicGamepadCamera\":\n                    return function () { return new BABYLON.StereoscopicGamepadCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, isStereoscopicSideBySide, scene); };\n                case \"StereoscopicUniversalCamera\":\n                    return function () { return new BABYLON.StereoscopicUniversalCamera(name, BABYLON.Vector3.Zero(), interaxial_distance, isStereoscopicSideBySide, scene); };\n                case \"FreeCamera\":\n                    return function () { return new BABYLON.UniversalCamera(name, BABYLON.Vector3.Zero(), scene); };\n                default:\n                    return function () { return new BABYLON.UniversalCamera(name, BABYLON.Vector3.Zero(), scene); };\n            }\n        };\n        Camera.Parse = function (parsedCamera, scene) {\n            var type = parsedCamera.type;\n            var construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);\n            var camera = BABYLON.SerializationHelper.Parse(construct, parsedCamera, scene);\n            // Parent\n            if (parsedCamera.parentId) {\n                camera._waitingParentId = parsedCamera.parentId;\n            }\n            //If camera has an input manager, let it parse inputs settings\n            if (camera.inputs) {\n                camera.inputs.parse(parsedCamera);\n                camera._setupInputs();\n            }\n            if (camera.setPosition) {\n                camera.position.copyFromFloats(0, 0, 0);\n                camera.setPosition(BABYLON.Vector3.FromArray(parsedCamera.position));\n            }\n            // Target\n            if (parsedCamera.target) {\n                if (camera.setTarget) {\n                    camera.setTarget(BABYLON.Vector3.FromArray(parsedCamera.target));\n                }\n            }\n            // Apply 3d rig, when found\n            if (parsedCamera.cameraRigMode) {\n                var rigParams = (parsedCamera.interaxial_distance) ? { interaxialDistance: parsedCamera.interaxial_distance } : {};\n                camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);\n            }\n            // Animations\n            if (parsedCamera.animations) {\n                for (var animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedCamera.animations[animationIndex];\n                    camera.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n                BABYLON.Node.ParseAnimationRanges(camera, parsedCamera, scene);\n            }\n            if (parsedCamera.autoAnimate) {\n                scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1.0);\n            }\n            return camera;\n        };\n        return Camera;\n    }(BABYLON.Node));\n    // Statics\n    Camera._PERSPECTIVE_CAMERA = 0;\n    Camera._ORTHOGRAPHIC_CAMERA = 1;\n    Camera._FOVMODE_VERTICAL_FIXED = 0;\n    Camera._FOVMODE_HORIZONTAL_FIXED = 1;\n    Camera._RIG_MODE_NONE = 0;\n    Camera._RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;\n    Camera._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;\n    Camera._RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;\n    Camera._RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;\n    Camera._RIG_MODE_VR = 20;\n    Camera._RIG_MODE_WEBVR = 21;\n    Camera.ForceAttachControlToAlwaysPreventDefault = false;\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], Camera.prototype, \"position\", void 0);\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], Camera.prototype, \"upVector\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"orthoLeft\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"orthoRight\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"orthoBottom\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"orthoTop\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"fov\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"minZ\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"maxZ\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"inertia\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"mode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"layerMask\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"fovMode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"cameraRigMode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"interaxialDistance\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Camera.prototype, \"isStereoscopicSideBySide\", void 0);\n    BABYLON.Camera = Camera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.camera.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var RenderingManager = (function () {\n        function RenderingManager(scene) {\n            this._renderingGroups = new Array();\n            this._autoClearDepthStencil = {};\n            this._customOpaqueSortCompareFn = {};\n            this._customAlphaTestSortCompareFn = {};\n            this._customTransparentSortCompareFn = {};\n            this._renderinGroupInfo = null;\n            this._scene = scene;\n            for (var i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {\n                this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };\n            }\n        }\n        RenderingManager.prototype._clearDepthStencilBuffer = function (depth, stencil) {\n            if (depth === void 0) { depth = true; }\n            if (stencil === void 0) { stencil = true; }\n            if (this._depthStencilBufferAlreadyCleaned) {\n                return;\n            }\n            this._scene.getEngine().clear(null, false, depth, stencil);\n            this._depthStencilBufferAlreadyCleaned = true;\n        };\n        RenderingManager.prototype.render = function (customRenderFunction, activeMeshes, renderParticles, renderSprites) {\n            // Check if there's at least on observer on the onRenderingGroupObservable and initialize things to fire it\n            var observable = this._scene.onRenderingGroupObservable.hasObservers() ? this._scene.onRenderingGroupObservable : null;\n            var info = null;\n            if (observable) {\n                if (!this._renderinGroupInfo) {\n                    this._renderinGroupInfo = new BABYLON.RenderingGroupInfo();\n                }\n                info = this._renderinGroupInfo;\n                info.scene = this._scene;\n                info.camera = this._scene.activeCamera;\n            }\n            // Dispatch sprites\n            if (renderSprites) {\n                for (var index = 0; index < this._scene.spriteManagers.length; index++) {\n                    var manager = this._scene.spriteManagers[index];\n                    this.dispatchSprites(manager);\n                }\n            }\n            // Render\n            for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n                this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;\n                var renderingGroup = this._renderingGroups[index];\n                if (!renderingGroup && !observable)\n                    continue;\n                this._currentIndex = index;\n                var renderingGroupMask = 0;\n                // Fire PRECLEAR stage\n                if (observable) {\n                    renderingGroupMask = Math.pow(2, index);\n                    info.renderStage = BABYLON.RenderingGroupInfo.STAGE_PRECLEAR;\n                    info.renderingGroupId = index;\n                    observable.notifyObservers(info, renderingGroupMask);\n                }\n                // Clear depth/stencil if needed\n                if (RenderingManager.AUTOCLEAR) {\n                    var autoClear = this._autoClearDepthStencil[index];\n                    if (autoClear && autoClear.autoClear) {\n                        this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);\n                    }\n                }\n                if (observable) {\n                    // Fire PREOPAQUE stage\n                    info.renderStage = BABYLON.RenderingGroupInfo.STAGE_PREOPAQUE;\n                    observable.notifyObservers(info, renderingGroupMask);\n                    // Fire PRETRANSPARENT stage\n                    info.renderStage = BABYLON.RenderingGroupInfo.STAGE_PRETRANSPARENT;\n                    observable.notifyObservers(info, renderingGroupMask);\n                }\n                if (renderingGroup)\n                    renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);\n                // Fire POSTTRANSPARENT stage\n                if (observable) {\n                    info.renderStage = BABYLON.RenderingGroupInfo.STAGE_POSTTRANSPARENT;\n                    observable.notifyObservers(info, renderingGroupMask);\n                }\n            }\n        };\n        RenderingManager.prototype.reset = function () {\n            for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n                var renderingGroup = this._renderingGroups[index];\n                if (renderingGroup) {\n                    renderingGroup.prepare();\n                }\n            }\n        };\n        RenderingManager.prototype.dispose = function () {\n            for (var index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {\n                var renderingGroup = this._renderingGroups[index];\n                if (renderingGroup) {\n                    renderingGroup.dispose();\n                }\n            }\n            this._renderingGroups.length = 0;\n        };\n        RenderingManager.prototype._prepareRenderingGroup = function (renderingGroupId) {\n            if (!this._renderingGroups[renderingGroupId]) {\n                this._renderingGroups[renderingGroupId] = new BABYLON.RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);\n            }\n        };\n        RenderingManager.prototype.dispatchSprites = function (spriteManager) {\n            var renderingGroupId = spriteManager.renderingGroupId || 0;\n            this._prepareRenderingGroup(renderingGroupId);\n            this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);\n        };\n        RenderingManager.prototype.dispatchParticles = function (particleSystem) {\n            var renderingGroupId = particleSystem.renderingGroupId || 0;\n            this._prepareRenderingGroup(renderingGroupId);\n            this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);\n        };\n        RenderingManager.prototype.dispatch = function (subMesh) {\n            var mesh = subMesh.getMesh();\n            var renderingGroupId = mesh.renderingGroupId || 0;\n            this._prepareRenderingGroup(renderingGroupId);\n            this._renderingGroups[renderingGroupId].dispatch(subMesh);\n        };\n        /**\n         * Overrides the default sort function applied in the renderging group to prepare the meshes.\n         * This allowed control for front to back rendering or reversly depending of the special needs.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n         * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n         */\n        RenderingManager.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n            if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n            if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n            if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n            this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;\n            this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;\n            this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;\n            if (this._renderingGroups[renderingGroupId]) {\n                var group = this._renderingGroups[renderingGroupId];\n                group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];\n                group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];\n                group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];\n            }\n        };\n        /**\n         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n         * @param depth Automatically clears depth between groups if true and autoClear is true.\n         * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n         */\n        RenderingManager.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n            if (depth === void 0) { depth = true; }\n            if (stencil === void 0) { stencil = true; }\n            this._autoClearDepthStencil[renderingGroupId] = {\n                autoClear: autoClearDepthStencil,\n                depth: depth,\n                stencil: stencil\n            };\n        };\n        return RenderingManager;\n    }());\n    /**\n     * The max id used for rendering groups (not included)\n     */\n    RenderingManager.MAX_RENDERINGGROUPS = 4;\n    /**\n     * The min id used for rendering groups (included)\n     */\n    RenderingManager.MIN_RENDERINGGROUPS = 0;\n    /**\n     * Used to globally prevent autoclearing scenes.\n     */\n    RenderingManager.AUTOCLEAR = true;\n    BABYLON.RenderingManager = RenderingManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.renderingManager.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var RenderingGroup = (function () {\n        /**\n         * Creates a new rendering group.\n         * @param index The rendering group index\n         * @param opaqueSortCompareFn The opaque sort comparison function. If null no order is applied\n         * @param alphaTestSortCompareFn The alpha test sort comparison function. If null no order is applied\n         * @param transparentSortCompareFn The transparent sort comparison function. If null back to front + alpha index sort is applied\n         */\n        function RenderingGroup(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n            if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n            if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n            if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n            this.index = index;\n            this._opaqueSubMeshes = new BABYLON.SmartArray(256);\n            this._transparentSubMeshes = new BABYLON.SmartArray(256);\n            this._alphaTestSubMeshes = new BABYLON.SmartArray(256);\n            this._particleSystems = new BABYLON.SmartArray(256);\n            this._spriteManagers = new BABYLON.SmartArray(256);\n            this._edgesRenderers = new BABYLON.SmartArray(16);\n            this._scene = scene;\n            this.opaqueSortCompareFn = opaqueSortCompareFn;\n            this.alphaTestSortCompareFn = alphaTestSortCompareFn;\n            this.transparentSortCompareFn = transparentSortCompareFn;\n        }\n        Object.defineProperty(RenderingGroup.prototype, \"opaqueSortCompareFn\", {\n            /**\n             * Set the opaque sort comparison function.\n             * If null the sub meshes will be render in the order they were created\n             */\n            set: function (value) {\n                this._opaqueSortCompareFn = value;\n                if (value) {\n                    this._renderOpaque = this.renderOpaqueSorted;\n                }\n                else {\n                    this._renderOpaque = RenderingGroup.renderUnsorted;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderingGroup.prototype, \"alphaTestSortCompareFn\", {\n            /**\n             * Set the alpha test sort comparison function.\n             * If null the sub meshes will be render in the order they were created\n             */\n            set: function (value) {\n                this._alphaTestSortCompareFn = value;\n                if (value) {\n                    this._renderAlphaTest = this.renderAlphaTestSorted;\n                }\n                else {\n                    this._renderAlphaTest = RenderingGroup.renderUnsorted;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderingGroup.prototype, \"transparentSortCompareFn\", {\n            /**\n             * Set the transparent sort comparison function.\n             * If null the sub meshes will be render in the order they were created\n             */\n            set: function (value) {\n                if (value) {\n                    this._transparentSortCompareFn = value;\n                }\n                else {\n                    this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;\n                }\n                this._renderTransparent = this.renderTransparentSorted;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Render all the sub meshes contained in the group.\n         * @param customRenderFunction Used to override the default render behaviour of the group.\n         * @returns true if rendered some submeshes.\n         */\n        RenderingGroup.prototype.render = function (customRenderFunction, renderSprites, renderParticles, activeMeshes) {\n            if (customRenderFunction) {\n                customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes);\n                return;\n            }\n            var engine = this._scene.getEngine();\n            // Opaque\n            if (this._opaqueSubMeshes.length !== 0) {\n                this._renderOpaque(this._opaqueSubMeshes);\n            }\n            // Alpha test\n            if (this._alphaTestSubMeshes.length !== 0) {\n                engine.setAlphaTesting(true);\n                this._renderAlphaTest(this._alphaTestSubMeshes);\n                engine.setAlphaTesting(false);\n            }\n            var stencilState = engine.getStencilBuffer();\n            engine.setStencilBuffer(false);\n            // Sprites\n            if (renderSprites) {\n                this._renderSprites();\n            }\n            // Particles\n            if (renderParticles) {\n                this._renderParticles(activeMeshes);\n            }\n            if (this.onBeforeTransparentRendering) {\n                this.onBeforeTransparentRendering();\n            }\n            // Transparent\n            if (this._transparentSubMeshes.length !== 0) {\n                this._renderTransparent(this._transparentSubMeshes);\n                engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n            }\n            engine.setStencilBuffer(stencilState);\n            // Edges\n            for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {\n                this._edgesRenderers.data[edgesRendererIndex].render();\n            }\n        };\n        /**\n         * Renders the opaque submeshes in the order from the opaqueSortCompareFn.\n         * @param subMeshes The submeshes to render\n         */\n        RenderingGroup.prototype.renderOpaqueSorted = function (subMeshes) {\n            return RenderingGroup.renderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera.globalPosition, false);\n        };\n        /**\n         * Renders the opaque submeshes in the order from the alphatestSortCompareFn.\n         * @param subMeshes The submeshes to render\n         */\n        RenderingGroup.prototype.renderAlphaTestSorted = function (subMeshes) {\n            return RenderingGroup.renderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera.globalPosition, false);\n        };\n        /**\n         * Renders the opaque submeshes in the order from the transparentSortCompareFn.\n         * @param subMeshes The submeshes to render\n         */\n        RenderingGroup.prototype.renderTransparentSorted = function (subMeshes) {\n            return RenderingGroup.renderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera.globalPosition, true);\n        };\n        /**\n         * Renders the submeshes in a specified order.\n         * @param subMeshes The submeshes to sort before render\n         * @param sortCompareFn The comparison function use to sort\n         * @param cameraPosition The camera position use to preprocess the submeshes to help sorting\n         * @param transparent Specifies to activate blending if true\n         */\n        RenderingGroup.renderSorted = function (subMeshes, sortCompareFn, cameraPosition, transparent) {\n            var subIndex = 0;\n            var subMesh;\n            for (; subIndex < subMeshes.length; subIndex++) {\n                subMesh = subMeshes.data[subIndex];\n                subMesh._alphaIndex = subMesh.getMesh().alphaIndex;\n                subMesh._distanceToCamera = subMesh.getBoundingInfo().boundingSphere.centerWorld.subtract(cameraPosition).length();\n            }\n            var sortedArray = subMeshes.data.slice(0, subMeshes.length);\n            sortedArray.sort(sortCompareFn);\n            for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {\n                subMesh = sortedArray[subIndex];\n                subMesh.render(transparent);\n            }\n        };\n        /**\n         * Renders the submeshes in the order they were dispatched (no sort applied).\n         * @param subMeshes The submeshes to render\n         */\n        RenderingGroup.renderUnsorted = function (subMeshes) {\n            for (var subIndex = 0; subIndex < subMeshes.length; subIndex++) {\n                var submesh = subMeshes.data[subIndex];\n                submesh.render(false);\n            }\n        };\n        /**\n         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n         * are rendered back to front if in the same alpha index.\n         *\n         * @param a The first submesh\n         * @param b The second submesh\n         * @returns The result of the comparison\n         */\n        RenderingGroup.defaultTransparentSortCompare = function (a, b) {\n            // Alpha index first\n            if (a._alphaIndex > b._alphaIndex) {\n                return 1;\n            }\n            if (a._alphaIndex < b._alphaIndex) {\n                return -1;\n            }\n            // Then distance to camera\n            return RenderingGroup.backToFrontSortCompare(a, b);\n        };\n        /**\n         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n         * are rendered back to front.\n         *\n         * @param a The first submesh\n         * @param b The second submesh\n         * @returns The result of the comparison\n         */\n        RenderingGroup.backToFrontSortCompare = function (a, b) {\n            // Then distance to camera\n            if (a._distanceToCamera < b._distanceToCamera) {\n                return 1;\n            }\n            if (a._distanceToCamera > b._distanceToCamera) {\n                return -1;\n            }\n            return 0;\n        };\n        /**\n         * Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)\n         * are rendered front to back (prevent overdraw).\n         *\n         * @param a The first submesh\n         * @param b The second submesh\n         * @returns The result of the comparison\n         */\n        RenderingGroup.frontToBackSortCompare = function (a, b) {\n            // Then distance to camera\n            if (a._distanceToCamera < b._distanceToCamera) {\n                return -1;\n            }\n            if (a._distanceToCamera > b._distanceToCamera) {\n                return 1;\n            }\n            return 0;\n        };\n        /**\n         * Resets the different lists of submeshes to prepare a new frame.\n         */\n        RenderingGroup.prototype.prepare = function () {\n            this._opaqueSubMeshes.reset();\n            this._transparentSubMeshes.reset();\n            this._alphaTestSubMeshes.reset();\n            this._particleSystems.reset();\n            this._spriteManagers.reset();\n            this._edgesRenderers.reset();\n        };\n        RenderingGroup.prototype.dispose = function () {\n            this._opaqueSubMeshes.dispose();\n            this._transparentSubMeshes.dispose();\n            this._alphaTestSubMeshes.dispose();\n            this._particleSystems.dispose();\n            this._spriteManagers.dispose();\n            this._edgesRenderers.dispose();\n        };\n        /**\n         * Inserts the submesh in its correct queue depending on its material.\n         * @param subMesh The submesh to dispatch\n         */\n        RenderingGroup.prototype.dispatch = function (subMesh) {\n            var material = subMesh.getMaterial();\n            var mesh = subMesh.getMesh();\n            if (material.needAlphaBlending() || mesh.visibility < 1.0 || mesh.hasVertexAlpha) {\n                this._transparentSubMeshes.push(subMesh);\n            }\n            else if (material.needAlphaTesting()) {\n                this._alphaTestSubMeshes.push(subMesh);\n            }\n            else {\n                this._opaqueSubMeshes.push(subMesh); // Opaque\n            }\n            if (mesh._edgesRenderer) {\n                this._edgesRenderers.push(mesh._edgesRenderer);\n            }\n        };\n        RenderingGroup.prototype.dispatchSprites = function (spriteManager) {\n            this._spriteManagers.push(spriteManager);\n        };\n        RenderingGroup.prototype.dispatchParticles = function (particleSystem) {\n            this._particleSystems.push(particleSystem);\n        };\n        RenderingGroup.prototype._renderParticles = function (activeMeshes) {\n            if (this._particleSystems.length === 0) {\n                return;\n            }\n            // Particles\n            var activeCamera = this._scene.activeCamera;\n            this._scene._particlesDuration.beginMonitoring();\n            for (var particleIndex = 0; particleIndex < this._scene._activeParticleSystems.length; particleIndex++) {\n                var particleSystem = this._scene._activeParticleSystems.data[particleIndex];\n                if ((activeCamera.layerMask & particleSystem.layerMask) === 0) {\n                    continue;\n                }\n                if (!particleSystem.emitter.position || !activeMeshes || activeMeshes.indexOf(particleSystem.emitter) !== -1) {\n                    this._scene._activeParticles.addCount(particleSystem.render(), false);\n                }\n            }\n            this._scene._particlesDuration.endMonitoring(false);\n        };\n        RenderingGroup.prototype._renderSprites = function () {\n            if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {\n                return;\n            }\n            // Sprites       \n            var activeCamera = this._scene.activeCamera;\n            this._scene._spritesDuration.beginMonitoring();\n            for (var id = 0; id < this._spriteManagers.length; id++) {\n                var spriteManager = this._spriteManagers.data[id];\n                if (((activeCamera.layerMask & spriteManager.layerMask) !== 0)) {\n                    spriteManager.render();\n                }\n            }\n            this._scene._spritesDuration.endMonitoring(false);\n        };\n        return RenderingGroup;\n    }());\n    BABYLON.RenderingGroup = RenderingGroup;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.renderingGroup.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ClickInfo = (function () {\n        function ClickInfo() {\n            this._singleClick = false;\n            this._doubleClick = false;\n            this._hasSwiped = false;\n            this._ignore = false;\n        }\n        Object.defineProperty(ClickInfo.prototype, \"singleClick\", {\n            get: function () {\n                return this._singleClick;\n            },\n            set: function (b) {\n                this._singleClick = b;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ClickInfo.prototype, \"doubleClick\", {\n            get: function () {\n                return this._doubleClick;\n            },\n            set: function (b) {\n                this._doubleClick = b;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ClickInfo.prototype, \"hasSwiped\", {\n            get: function () {\n                return this._hasSwiped;\n            },\n            set: function (b) {\n                this._hasSwiped = b;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ClickInfo.prototype, \"ignore\", {\n            get: function () {\n                return this._ignore;\n            },\n            set: function (b) {\n                this._ignore = b;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ClickInfo;\n    }());\n    var PointerEventTypes = (function () {\n        function PointerEventTypes() {\n        }\n        Object.defineProperty(PointerEventTypes, \"POINTERDOWN\", {\n            get: function () {\n                return PointerEventTypes._POINTERDOWN;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERUP\", {\n            get: function () {\n                return PointerEventTypes._POINTERUP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERMOVE\", {\n            get: function () {\n                return PointerEventTypes._POINTERMOVE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERWHEEL\", {\n            get: function () {\n                return PointerEventTypes._POINTERWHEEL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERPICK\", {\n            get: function () {\n                return PointerEventTypes._POINTERPICK;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERTAP\", {\n            get: function () {\n                return PointerEventTypes._POINTERTAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointerEventTypes, \"POINTERDOUBLETAP\", {\n            get: function () {\n                return PointerEventTypes._POINTERDOUBLETAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return PointerEventTypes;\n    }());\n    PointerEventTypes._POINTERDOWN = 0x01;\n    PointerEventTypes._POINTERUP = 0x02;\n    PointerEventTypes._POINTERMOVE = 0x04;\n    PointerEventTypes._POINTERWHEEL = 0x08;\n    PointerEventTypes._POINTERPICK = 0x10;\n    PointerEventTypes._POINTERTAP = 0x20;\n    PointerEventTypes._POINTERDOUBLETAP = 0x40;\n    BABYLON.PointerEventTypes = PointerEventTypes;\n    var PointerInfoBase = (function () {\n        function PointerInfoBase(type, event) {\n            this.type = type;\n            this.event = event;\n        }\n        return PointerInfoBase;\n    }());\n    BABYLON.PointerInfoBase = PointerInfoBase;\n    /**\n     * This class is used to store pointer related info for the onPrePointerObservable event.\n     * Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable\n     */\n    var PointerInfoPre = (function (_super) {\n        __extends(PointerInfoPre, _super);\n        function PointerInfoPre(type, event, localX, localY) {\n            var _this = _super.call(this, type, event) || this;\n            _this.skipOnPointerObservable = false;\n            _this.localPosition = new BABYLON.Vector2(localX, localY);\n            return _this;\n        }\n        return PointerInfoPre;\n    }(PointerInfoBase));\n    BABYLON.PointerInfoPre = PointerInfoPre;\n    /**\n     * This type contains all the data related to a pointer event in Babylon.js.\n     * The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.\n     */\n    var PointerInfo = (function (_super) {\n        __extends(PointerInfo, _super);\n        function PointerInfo(type, event, pickInfo) {\n            var _this = _super.call(this, type, event) || this;\n            _this.pickInfo = pickInfo;\n            return _this;\n        }\n        return PointerInfo;\n    }(PointerInfoBase));\n    BABYLON.PointerInfo = PointerInfo;\n    /**\n     * This class is used by the onRenderingGroupObservable\n     */\n    var RenderingGroupInfo = (function () {\n        function RenderingGroupInfo() {\n        }\n        return RenderingGroupInfo;\n    }());\n    /**\n     * Stage corresponding to the very first hook in the renderingGroup phase: before the render buffer may be cleared\n     * This stage will be fired no matter what\n     */\n    RenderingGroupInfo.STAGE_PRECLEAR = 1;\n    /**\n     * Called before opaque object are rendered.\n     * This stage will be fired only if there's 3D Opaque content to render\n     */\n    RenderingGroupInfo.STAGE_PREOPAQUE = 2;\n    /**\n     * Called after the opaque objects are rendered and before the transparent ones\n     * This stage will be fired only if there's 3D transparent content to render\n     */\n    RenderingGroupInfo.STAGE_PRETRANSPARENT = 3;\n    /**\n     * Called after the transparent object are rendered, last hook of the renderingGroup phase\n     * This stage will be fired no matter what\n     */\n    RenderingGroupInfo.STAGE_POSTTRANSPARENT = 4;\n    BABYLON.RenderingGroupInfo = RenderingGroupInfo;\n    /**\n     * Represents a scene to be rendered by the engine.\n     * @see http://doc.babylonjs.com/page.php?p=21911\n     */\n    var Scene = (function () {\n        /**\n         * @constructor\n         * @param {BABYLON.Engine} engine - the engine to be used to render this scene.\n         */\n        function Scene(engine) {\n            // Members\n            this.autoClear = true;\n            this.autoClearDepthAndStencil = true;\n            this.clearColor = new BABYLON.Color4(0.2, 0.2, 0.3, 1.0);\n            this.ambientColor = new BABYLON.Color3(0, 0, 0);\n            this.forceWireframe = false;\n            this._forcePointsCloud = false;\n            this.forceShowBoundingBoxes = false;\n            this.animationsEnabled = true;\n            this.constantlyUpdateMeshUnderPointer = false;\n            this.hoverCursor = \"pointer\";\n            // Metadata\n            this.metadata = null;\n            // Events\n            /**\n            * An event triggered when the scene is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before rendering the scene\n            * @type {BABYLON.Observable}\n            */\n            this.onBeforeRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering the scene\n            * @type {BABYLON.Observable}\n            */\n            this.onAfterRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the scene is ready\n            * @type {BABYLON.Observable}\n            */\n            this.onReadyObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before rendering a camera\n            * @type {BABYLON.Observable}\n            */\n            this.onBeforeCameraRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering a camera\n            * @type {BABYLON.Observable}\n            */\n            this.onAfterCameraRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a camera is created\n            * @type {BABYLON.Observable}\n            */\n            this.onNewCameraAddedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a camera is removed\n            * @type {BABYLON.Observable}\n            */\n            this.onCameraRemovedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a light is created\n            * @type {BABYLON.Observable}\n            */\n            this.onNewLightAddedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a light is removed\n            * @type {BABYLON.Observable}\n            */\n            this.onLightRemovedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a geometry is created\n            * @type {BABYLON.Observable}\n            */\n            this.onNewGeometryAddedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a geometry is removed\n            * @type {BABYLON.Observable}\n            */\n            this.onGeometryRemovedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a mesh is created\n            * @type {BABYLON.Observable}\n            */\n            this.onNewMeshAddedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when a mesh is removed\n            * @type {BABYLON.Observable}\n            */\n            this.onMeshRemovedObservable = new BABYLON.Observable();\n            /**\n             * This Observable will be triggered for each stage of each renderingGroup of each rendered camera.\n             * The RenderinGroupInfo class contains all the information about the context in which the observable is called\n             * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n             */\n            this.onRenderingGroupObservable = new BABYLON.Observable();\n            // Animations\n            this.animations = [];\n            /**\n             * This observable event is triggered when any mouse event registered during Scene.attach() is called BEFORE the 3D engine to process anything (mesh/sprite picking for instance).\n             * You have the possibility to skip the 3D Engine process and the call to onPointerObservable by setting PointerInfoBase.skipOnPointerObservable to true\n             */\n            this.onPrePointerObservable = new BABYLON.Observable();\n            /**\n             * Observable event triggered each time an input event is received from the rendering canvas\n             */\n            this.onPointerObservable = new BABYLON.Observable();\n            this._meshPickProceed = false;\n            this._previousHasSwiped = false;\n            this._currentPickResult = null;\n            this._previousPickResult = null;\n            this._isButtonPressed = false;\n            this._doubleClickOccured = false;\n            this.cameraToUseForPointers = null; // Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position\n            this._startingPointerPosition = new BABYLON.Vector2(0, 0);\n            this._previousStartingPointerPosition = new BABYLON.Vector2(0, 0);\n            this._startingPointerTime = 0;\n            this._previousStartingPointerTime = 0;\n            // Coordinate system\n            /**\n            * use right-handed coordinate system on this scene.\n            * @type {boolean}\n            */\n            this._useRightHandedSystem = false;\n            // Fog\n            /**\n            * is fog enabled on this scene.\n            * @type {boolean}\n            */\n            this._fogEnabled = true;\n            this._fogMode = Scene.FOGMODE_NONE;\n            this.fogColor = new BABYLON.Color3(0.2, 0.2, 0.3);\n            this.fogDensity = 0.1;\n            this.fogStart = 0;\n            this.fogEnd = 1000.0;\n            // Lights\n            /**\n            * is shadow enabled on this scene.\n            * @type {boolean}\n            */\n            this._shadowsEnabled = true;\n            /**\n            * is light enabled on this scene.\n            * @type {boolean}\n            */\n            this._lightsEnabled = true;\n            /**\n            * All of the lights added to this scene.\n            * @see BABYLON.Light\n            * @type {BABYLON.Light[]}\n            */\n            this.lights = new Array();\n            // Cameras\n            /**\n            * All of the cameras added to this scene.\n            * @see BABYLON.Camera\n            * @type {BABYLON.Camera[]}\n            */\n            this.cameras = new Array();\n            this.activeCameras = new Array();\n            // Meshes\n            /**\n            * All of the (abstract) meshes added to this scene.\n            * @see BABYLON.AbstractMesh\n            * @type {BABYLON.AbstractMesh[]}\n            */\n            this.meshes = new Array();\n            // Geometries\n            this._geometries = new Array();\n            this.materials = new Array();\n            this.multiMaterials = new Array();\n            // Textures\n            this._texturesEnabled = true;\n            this.textures = new Array();\n            // Particles\n            this.particlesEnabled = true;\n            this.particleSystems = new Array();\n            // Sprites\n            this.spritesEnabled = true;\n            this.spriteManagers = new Array();\n            // Layers\n            this.layers = new Array();\n            this.highlightLayers = new Array();\n            // Skeletons\n            this._skeletonsEnabled = true;\n            this.skeletons = new Array();\n            // Morph targets\n            this.morphTargetManagers = new Array();\n            // Lens flares\n            this.lensFlaresEnabled = true;\n            this.lensFlareSystems = new Array();\n            // Collisions\n            this.collisionsEnabled = true;\n            this.gravity = new BABYLON.Vector3(0, -9.807, 0);\n            // Postprocesses\n            this.postProcessesEnabled = true;\n            // Customs render targets\n            this.renderTargetsEnabled = true;\n            this.dumpNextRenderTargets = false;\n            this.customRenderTargets = new Array();\n            // Imported meshes\n            this.importedMeshesFiles = new Array();\n            // Probes\n            this.probesEnabled = true;\n            this.reflectionProbes = new Array();\n            this._actionManagers = new Array();\n            this._meshesForIntersections = new BABYLON.SmartArray(256);\n            // Procedural textures\n            this.proceduralTexturesEnabled = true;\n            this._proceduralTextures = new Array();\n            this.soundTracks = new Array();\n            this._audioEnabled = true;\n            this._headphone = false;\n            // Performance counters\n            this._totalMeshesCounter = new BABYLON.PerfCounter();\n            this._totalLightsCounter = new BABYLON.PerfCounter();\n            this._totalMaterialsCounter = new BABYLON.PerfCounter();\n            this._totalTexturesCounter = new BABYLON.PerfCounter();\n            this._totalVertices = new BABYLON.PerfCounter();\n            this._activeIndices = new BABYLON.PerfCounter();\n            this._activeParticles = new BABYLON.PerfCounter();\n            this._lastFrameDuration = new BABYLON.PerfCounter();\n            this._evaluateActiveMeshesDuration = new BABYLON.PerfCounter();\n            this._renderTargetsDuration = new BABYLON.PerfCounter();\n            this._particlesDuration = new BABYLON.PerfCounter();\n            this._renderDuration = new BABYLON.PerfCounter();\n            this._spritesDuration = new BABYLON.PerfCounter();\n            this._activeBones = new BABYLON.PerfCounter();\n            this._animationTime = 0;\n            this.animationTimeScale = 1;\n            this._renderId = 0;\n            this._executeWhenReadyTimeoutId = -1;\n            this._intermediateRendering = false;\n            this._viewUpdateFlag = -1;\n            this._projectionUpdateFlag = -1;\n            this._toBeDisposed = new BABYLON.SmartArray(256);\n            this._pendingData = []; //ANY\n            this._activeMeshes = new BABYLON.SmartArray(256);\n            this._processedMaterials = new BABYLON.SmartArray(256);\n            this._renderTargets = new BABYLON.SmartArray(256);\n            this._activeParticleSystems = new BABYLON.SmartArray(256);\n            this._activeSkeletons = new BABYLON.SmartArray(32);\n            this._softwareSkinnedMeshes = new BABYLON.SmartArray(32);\n            this._activeAnimatables = new Array();\n            this._transformMatrix = BABYLON.Matrix.Zero();\n            this.requireLightSorting = false;\n            this._uniqueIdCounter = 0;\n            this._engine = engine || BABYLON.Engine.LastCreatedEngine;\n            this._engine.scenes.push(this);\n            this._uid = null;\n            this._renderingManager = new BABYLON.RenderingManager(this);\n            this.postProcessManager = new BABYLON.PostProcessManager(this);\n            if (BABYLON.OutlineRenderer) {\n                this._outlineRenderer = new BABYLON.OutlineRenderer(this);\n            }\n            this.attachControl();\n            if (BABYLON.SoundTrack) {\n                this.mainSoundTrack = new BABYLON.SoundTrack(this, { mainTrack: true });\n            }\n            //simplification queue\n            if (BABYLON.SimplificationQueue) {\n                this.simplificationQueue = new BABYLON.SimplificationQueue();\n            }\n            //collision coordinator initialization. For now legacy per default.\n            this.workerCollisions = false; //(!!Worker && (!!BABYLON.CollisionWorker || BABYLON.WorkerIncluded));\n            // Uniform Buffer\n            this._createUbo();\n            // Default Image processing definition.\n            this._imageProcessingConfiguration = new BABYLON.ImageProcessingConfiguration();\n        }\n        Object.defineProperty(Scene, \"FOGMODE_NONE\", {\n            get: function () {\n                return Scene._FOGMODE_NONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene, \"FOGMODE_EXP\", {\n            get: function () {\n                return Scene._FOGMODE_EXP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene, \"FOGMODE_EXP2\", {\n            get: function () {\n                return Scene._FOGMODE_EXP2;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene, \"FOGMODE_LINEAR\", {\n            get: function () {\n                return Scene._FOGMODE_LINEAR;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"environmentTexture\", {\n            /**\n             * Texture used in all pbr material as the reflection texture.\n             * As in the majority of the scene they are the same (exception for multi room and so on),\n             * this is easier to reference from here than from all the materials.\n             */\n            get: function () {\n                return this._environmentTexture;\n            },\n            /**\n             * Texture used in all pbr material as the reflection texture.\n             * As in the majority of the scene they are the same (exception for multi room and so on),\n             * this is easier to set here than in all the materials.\n             */\n            set: function (value) {\n                this._environmentTexture = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"imageProcessingConfiguration\", {\n            /**\n             * Default image processing configuration used either in the rendering\n             * Forward main pass or through the imageProcessingPostProcess if present.\n             * As in the majority of the scene they are the same (exception for multi camera),\n             * this is easier to reference from here than from all the materials and post process.\n             *\n             * No setter as we it is a shared configuration, you can set the values instead.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"forcePointsCloud\", {\n            get: function () {\n                return this._forcePointsCloud;\n            },\n            set: function (value) {\n                if (this._forcePointsCloud === value) {\n                    return;\n                }\n                this._forcePointsCloud = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"beforeRender\", {\n            set: function (callback) {\n                if (this._onBeforeRenderObserver) {\n                    this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n                }\n                this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"afterRender\", {\n            set: function (callback) {\n                if (this._onAfterRenderObserver) {\n                    this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n                }\n                this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"beforeCameraRender\", {\n            set: function (callback) {\n                if (this._onBeforeCameraRenderObserver) {\n                    this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n                }\n                this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"afterCameraRender\", {\n            set: function (callback) {\n                if (this._onAfterCameraRenderObserver) {\n                    this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n                }\n                this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"unTranslatedPointer\", {\n            get: function () {\n                return new BABYLON.Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"useRightHandedSystem\", {\n            get: function () {\n                return this._useRightHandedSystem;\n            },\n            set: function (value) {\n                if (this._useRightHandedSystem === value) {\n                    return;\n                }\n                this._useRightHandedSystem = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"fogEnabled\", {\n            get: function () {\n                return this._fogEnabled;\n            },\n            set: function (value) {\n                if (this._fogEnabled === value) {\n                    return;\n                }\n                this._fogEnabled = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"fogMode\", {\n            get: function () {\n                return this._fogMode;\n            },\n            set: function (value) {\n                if (this._fogMode === value) {\n                    return;\n                }\n                this._fogMode = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"shadowsEnabled\", {\n            get: function () {\n                return this._shadowsEnabled;\n            },\n            set: function (value) {\n                if (this._shadowsEnabled === value) {\n                    return;\n                }\n                this._shadowsEnabled = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.LightDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"lightsEnabled\", {\n            get: function () {\n                return this._lightsEnabled;\n            },\n            set: function (value) {\n                if (this._lightsEnabled === value) {\n                    return;\n                }\n                this._lightsEnabled = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.LightDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"defaultMaterial\", {\n            get: function () {\n                if (!this._defaultMaterial) {\n                    this._defaultMaterial = new BABYLON.StandardMaterial(\"default material\", this);\n                }\n                return this._defaultMaterial;\n            },\n            set: function (value) {\n                this._defaultMaterial = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"texturesEnabled\", {\n            get: function () {\n                return this._texturesEnabled;\n            },\n            set: function (value) {\n                if (this._texturesEnabled === value) {\n                    return;\n                }\n                this._texturesEnabled = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"skeletonsEnabled\", {\n            get: function () {\n                return this._skeletonsEnabled;\n            },\n            set: function (value) {\n                if (this._skeletonsEnabled === value) {\n                    return;\n                }\n                this._skeletonsEnabled = value;\n                this.markAllMaterialsAsDirty(BABYLON.Material.AttributesDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"postProcessRenderPipelineManager\", {\n            get: function () {\n                if (!this._postProcessRenderPipelineManager) {\n                    this._postProcessRenderPipelineManager = new BABYLON.PostProcessRenderPipelineManager();\n                }\n                return this._postProcessRenderPipelineManager;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"frustumPlanes\", {\n            get: function () {\n                return this._frustumPlanes;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"debugLayer\", {\n            // Properties\n            get: function () {\n                if (!this._debugLayer) {\n                    this._debugLayer = new BABYLON.DebugLayer(this);\n                }\n                return this._debugLayer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"workerCollisions\", {\n            get: function () {\n                return this._workerCollisions;\n            },\n            set: function (enabled) {\n                if (!BABYLON.CollisionCoordinatorLegacy) {\n                    return;\n                }\n                enabled = (enabled && !!Worker);\n                this._workerCollisions = enabled;\n                if (this.collisionCoordinator) {\n                    this.collisionCoordinator.destroy();\n                }\n                this.collisionCoordinator = enabled ? new BABYLON.CollisionCoordinatorWorker() : new BABYLON.CollisionCoordinatorLegacy();\n                this.collisionCoordinator.init(this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"selectionOctree\", {\n            get: function () {\n                return this._selectionOctree;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"meshUnderPointer\", {\n            /**\n             * The mesh that is currently under the pointer.\n             * @return {BABYLON.AbstractMesh} mesh under the pointer/mouse cursor or null if none.\n             */\n            get: function () {\n                return this._pointerOverMesh;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"pointerX\", {\n            /**\n             * Current on-screen X position of the pointer\n             * @return {number} X position of the pointer\n             */\n            get: function () {\n                return this._pointerX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Scene.prototype, \"pointerY\", {\n            /**\n             * Current on-screen Y position of the pointer\n             * @return {number} Y position of the pointer\n             */\n            get: function () {\n                return this._pointerY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getCachedMaterial = function () {\n            return this._cachedMaterial;\n        };\n        Scene.prototype.getCachedEffect = function () {\n            return this._cachedEffect;\n        };\n        Scene.prototype.getCachedVisibility = function () {\n            return this._cachedVisibility;\n        };\n        Scene.prototype.isCachedMaterialValid = function (material, effect, visibility) {\n            if (visibility === void 0) { visibility = 0; }\n            return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n        };\n        Scene.prototype.getBoundingBoxRenderer = function () {\n            if (!this._boundingBoxRenderer) {\n                this._boundingBoxRenderer = new BABYLON.BoundingBoxRenderer(this);\n            }\n            return this._boundingBoxRenderer;\n        };\n        Scene.prototype.getOutlineRenderer = function () {\n            return this._outlineRenderer;\n        };\n        Scene.prototype.getEngine = function () {\n            return this._engine;\n        };\n        Scene.prototype.getTotalVertices = function () {\n            return this._totalVertices.current;\n        };\n        Object.defineProperty(Scene.prototype, \"totalVerticesPerfCounter\", {\n            get: function () {\n                return this._totalVertices;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getActiveIndices = function () {\n            return this._activeIndices.current;\n        };\n        Object.defineProperty(Scene.prototype, \"totalActiveIndicesPerfCounter\", {\n            get: function () {\n                return this._activeIndices;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getActiveParticles = function () {\n            return this._activeParticles.current;\n        };\n        Object.defineProperty(Scene.prototype, \"activeParticlesPerfCounter\", {\n            get: function () {\n                return this._activeParticles;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getActiveBones = function () {\n            return this._activeBones.current;\n        };\n        Object.defineProperty(Scene.prototype, \"activeBonesPerfCounter\", {\n            get: function () {\n                return this._activeBones;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Stats\n        Scene.prototype.getLastFrameDuration = function () {\n            return this._lastFrameDuration.current;\n        };\n        Object.defineProperty(Scene.prototype, \"lastFramePerfCounter\", {\n            get: function () {\n                return this._lastFrameDuration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getEvaluateActiveMeshesDuration = function () {\n            return this._evaluateActiveMeshesDuration.current;\n        };\n        Object.defineProperty(Scene.prototype, \"evaluateActiveMeshesDurationPerfCounter\", {\n            get: function () {\n                return this._evaluateActiveMeshesDuration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getActiveMeshes = function () {\n            return this._activeMeshes;\n        };\n        Scene.prototype.getRenderTargetsDuration = function () {\n            return this._renderTargetsDuration.current;\n        };\n        Scene.prototype.getRenderDuration = function () {\n            return this._renderDuration.current;\n        };\n        Object.defineProperty(Scene.prototype, \"renderDurationPerfCounter\", {\n            get: function () {\n                return this._renderDuration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getParticlesDuration = function () {\n            return this._particlesDuration.current;\n        };\n        Object.defineProperty(Scene.prototype, \"particlesDurationPerfCounter\", {\n            get: function () {\n                return this._particlesDuration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getSpritesDuration = function () {\n            return this._spritesDuration.current;\n        };\n        Object.defineProperty(Scene.prototype, \"spriteDuractionPerfCounter\", {\n            get: function () {\n                return this._spritesDuration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype.getAnimationRatio = function () {\n            return this._animationRatio;\n        };\n        Scene.prototype.getRenderId = function () {\n            return this._renderId;\n        };\n        Scene.prototype.incrementRenderId = function () {\n            this._renderId++;\n        };\n        Scene.prototype._updatePointerPosition = function (evt) {\n            var canvasRect = this._engine.getRenderingCanvasClientRect();\n            this._pointerX = evt.clientX - canvasRect.left;\n            this._pointerY = evt.clientY - canvasRect.top;\n            this._unTranslatedPointerX = this._pointerX;\n            this._unTranslatedPointerY = this._pointerY;\n            if (this.cameraToUseForPointers) {\n                this._pointerX = this._pointerX - this.cameraToUseForPointers.viewport.x * this._engine.getRenderWidth();\n                this._pointerY = this._pointerY - this.cameraToUseForPointers.viewport.y * this._engine.getRenderHeight();\n            }\n        };\n        Scene.prototype._createUbo = function () {\n            this._sceneUbo = new BABYLON.UniformBuffer(this._engine, null, true);\n            this._sceneUbo.addUniform(\"viewProjection\", 16);\n            this._sceneUbo.addUniform(\"view\", 16);\n        };\n        // Pointers handling\n        /**\n        * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n        * @param attachUp defines if you want to attach events to pointerup\n        * @param attachDown defines if you want to attach events to pointerdown\n        * @param attachMove defines if you want to attach events to pointermove\n        */\n        Scene.prototype.attachControl = function (attachUp, attachDown, attachMove) {\n            var _this = this;\n            if (attachUp === void 0) { attachUp = true; }\n            if (attachDown === void 0) { attachDown = true; }\n            if (attachMove === void 0) { attachMove = true; }\n            this._initActionManager = function (act, clickInfo) {\n                if (!_this._meshPickProceed) {\n                    var pickResult = _this.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, _this.pointerDownPredicate, false, _this.cameraToUseForPointers);\n                    _this._currentPickResult = pickResult;\n                    if (pickResult) {\n                        act = (pickResult.hit && pickResult.pickedMesh) ? pickResult.pickedMesh.actionManager : null;\n                    }\n                    _this._meshPickProceed = true;\n                }\n                return act;\n            };\n            this._delayedSimpleClick = function (btn, clickInfo, cb) {\n                // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n                if ((new Date().getTime() - _this._previousStartingPointerTime > Scene.DoubleClickDelay && !_this._doubleClickOccured) ||\n                    btn !== _this._previousButtonPressed) {\n                    _this._doubleClickOccured = false;\n                    clickInfo.singleClick = true;\n                    clickInfo.ignore = false;\n                    cb(clickInfo, _this._currentPickResult);\n                }\n            };\n            this._initClickEvent = function (obs1, obs2, evt, cb) {\n                var clickInfo = new ClickInfo();\n                _this._currentPickResult = null;\n                var act;\n                var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK)\n                    || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP)\n                    || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n                if (!checkPicking && BABYLON.ActionManager && BABYLON.ActionManager.HasPickTriggers) {\n                    act = _this._initActionManager(act, clickInfo);\n                    if (act)\n                        checkPicking = act.hasPickTriggers;\n                }\n                if (checkPicking) {\n                    var btn = evt.button;\n                    clickInfo.hasSwiped = Math.abs(_this._startingPointerPosition.x - _this._pointerX) > Scene.DragMovementThreshold ||\n                        Math.abs(_this._startingPointerPosition.y - _this._pointerY) > Scene.DragMovementThreshold;\n                    if (!clickInfo.hasSwiped) {\n                        var checkSingleClickImmediately = !Scene.ExclusiveDoubleClickMode;\n                        if (!checkSingleClickImmediately) {\n                            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) &&\n                                !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n                            if (checkSingleClickImmediately && !BABYLON.ActionManager.HasSpecificTrigger(BABYLON.ActionManager.OnDoublePickTrigger)) {\n                                act = _this._initActionManager(act, clickInfo);\n                                if (act)\n                                    checkSingleClickImmediately = !act.hasSpecificTrigger(BABYLON.ActionManager.OnDoublePickTrigger);\n                            }\n                        }\n                        if (checkSingleClickImmediately) {\n                            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n                            if (new Date().getTime() - _this._previousStartingPointerTime > Scene.DoubleClickDelay ||\n                                btn !== _this._previousButtonPressed) {\n                                clickInfo.singleClick = true;\n                                cb(clickInfo, _this._currentPickResult);\n                            }\n                        }\n                        else {\n                            // wait that no double click has been raised during the double click delay\n                            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), Scene.DoubleClickDelay);\n                        }\n                        var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) ||\n                            obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);\n                        if (!checkDoubleClick && BABYLON.ActionManager.HasSpecificTrigger(BABYLON.ActionManager.OnDoublePickTrigger)) {\n                            act = _this._initActionManager(act, clickInfo);\n                            if (act)\n                                checkDoubleClick = act.hasSpecificTrigger(BABYLON.ActionManager.OnDoublePickTrigger);\n                        }\n                        if (checkDoubleClick) {\n                            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n                            if (btn === _this._previousButtonPressed &&\n                                new Date().getTime() - _this._previousStartingPointerTime < Scene.DoubleClickDelay &&\n                                !_this._doubleClickOccured) {\n                                // pointer has not moved for 2 clicks, it's a double click\n                                if (!clickInfo.hasSwiped &&\n                                    Math.abs(_this._previousStartingPointerPosition.x - _this._startingPointerPosition.x) < Scene.DragMovementThreshold &&\n                                    Math.abs(_this._previousStartingPointerPosition.y - _this._startingPointerPosition.y) < Scene.DragMovementThreshold) {\n                                    _this._previousStartingPointerTime = 0;\n                                    _this._doubleClickOccured = true;\n                                    clickInfo.doubleClick = true;\n                                    clickInfo.ignore = false;\n                                    if (Scene.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout && _this._previousDelayedSimpleClickTimeout.clearTimeout)\n                                        _this._previousDelayedSimpleClickTimeout.clearTimeout();\n                                    _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                                    cb(clickInfo, _this._currentPickResult);\n                                }\n                                else {\n                                    _this._doubleClickOccured = false;\n                                    _this._previousStartingPointerTime = _this._startingPointerTime;\n                                    _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                                    _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                                    _this._previousButtonPressed = btn;\n                                    _this._previousHasSwiped = clickInfo.hasSwiped;\n                                    if (Scene.ExclusiveDoubleClickMode) {\n                                        if (_this._previousDelayedSimpleClickTimeout && _this._previousDelayedSimpleClickTimeout.clearTimeout) {\n                                            _this._previousDelayedSimpleClickTimeout.clearTimeout();\n                                        }\n                                        _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;\n                                        cb(clickInfo, _this._previousPickResult);\n                                    }\n                                    else {\n                                        cb(clickInfo, _this._currentPickResult);\n                                    }\n                                }\n                            }\n                            else {\n                                _this._doubleClickOccured = false;\n                                _this._previousStartingPointerTime = _this._startingPointerTime;\n                                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;\n                                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;\n                                _this._previousButtonPressed = btn;\n                                _this._previousHasSwiped = clickInfo.hasSwiped;\n                            }\n                        }\n                    }\n                }\n                clickInfo.ignore = true;\n                cb(clickInfo, _this._currentPickResult);\n            };\n            var spritePredicate = function (sprite) {\n                return sprite.isPickable && sprite.actionManager && sprite.actionManager.hasPointerTriggers;\n            };\n            this._onPointerMove = function (evt) {\n                _this._updatePointerPosition(evt);\n                // PreObservable support\n                if (_this.onPrePointerObservable.hasObservers()) {\n                    var type = evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n                    var pi = new PointerInfoPre(type, evt, _this._unTranslatedPointerX, _this._unTranslatedPointerY);\n                    _this.onPrePointerObservable.notifyObservers(pi, type);\n                    if (pi.skipOnPointerObservable) {\n                        return;\n                    }\n                }\n                if (!_this.cameraToUseForPointers && !_this.activeCamera) {\n                    return;\n                }\n                var canvas = _this._engine.getRenderingCanvas();\n                if (!_this.pointerMovePredicate) {\n                    _this.pointerMovePredicate = function (mesh) { return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (_this.constantlyUpdateMeshUnderPointer || (mesh.actionManager !== null && mesh.actionManager !== undefined)); };\n                }\n                // Meshes\n                var pickResult = _this.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, _this.pointerMovePredicate, false, _this.cameraToUseForPointers);\n                if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n                    _this.setPointerOverSprite(null);\n                    _this.setPointerOverMesh(pickResult.pickedMesh);\n                    if (_this._pointerOverMesh.actionManager && _this._pointerOverMesh.actionManager.hasPointerTriggers) {\n                        if (_this._pointerOverMesh.actionManager.hoverCursor) {\n                            canvas.style.cursor = _this._pointerOverMesh.actionManager.hoverCursor;\n                        }\n                        else {\n                            canvas.style.cursor = _this.hoverCursor;\n                        }\n                    }\n                    else {\n                        canvas.style.cursor = \"\";\n                    }\n                }\n                else {\n                    _this.setPointerOverMesh(null);\n                    // Sprites\n                    pickResult = _this.pickSprite(_this._unTranslatedPointerX, _this._unTranslatedPointerY, spritePredicate, false, _this.cameraToUseForPointers);\n                    if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                        _this.setPointerOverSprite(pickResult.pickedSprite);\n                        if (_this._pointerOverSprite.actionManager && _this._pointerOverSprite.actionManager.hoverCursor) {\n                            canvas.style.cursor = _this._pointerOverSprite.actionManager.hoverCursor;\n                        }\n                        else {\n                            canvas.style.cursor = _this.hoverCursor;\n                        }\n                    }\n                    else {\n                        _this.setPointerOverSprite(null);\n                        // Restore pointer\n                        canvas.style.cursor = \"\";\n                    }\n                }\n                if (_this.onPointerMove) {\n                    _this.onPointerMove(evt, pickResult);\n                }\n                if (_this.onPointerObservable.hasObservers()) {\n                    var type = evt.type === \"mousewheel\" || evt.type === \"DOMMouseScroll\" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;\n                    var pi = new PointerInfo(type, evt, pickResult);\n                    _this.onPointerObservable.notifyObservers(pi, type);\n                }\n            };\n            this._onPointerDown = function (evt) {\n                _this._isButtonPressed = true;\n                _this._pickedDownMesh = null;\n                _this._meshPickProceed = false;\n                _this._updatePointerPosition(evt);\n                // PreObservable support\n                if (_this.onPrePointerObservable.hasObservers()) {\n                    var type = PointerEventTypes.POINTERDOWN;\n                    var pi = new PointerInfoPre(type, evt, _this._unTranslatedPointerX, _this._unTranslatedPointerY);\n                    _this.onPrePointerObservable.notifyObservers(pi, type);\n                    if (pi.skipOnPointerObservable) {\n                        return;\n                    }\n                }\n                if (!_this.cameraToUseForPointers && !_this.activeCamera) {\n                    return;\n                }\n                _this._startingPointerPosition.x = _this._pointerX;\n                _this._startingPointerPosition.y = _this._pointerY;\n                _this._startingPointerTime = new Date().getTime();\n                if (!_this.pointerDownPredicate) {\n                    _this.pointerDownPredicate = function (mesh) {\n                        return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled();\n                    };\n                }\n                // Meshes\n                _this._pickedDownMesh = null;\n                var pickResult = _this.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, _this.pointerDownPredicate, false, _this.cameraToUseForPointers);\n                if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n                    _this._pickedDownMesh = pickResult.pickedMesh;\n                    var actionManager = pickResult.pickedMesh.actionManager;\n                    if (actionManager) {\n                        if (actionManager.hasPickTriggers) {\n                            actionManager.processTrigger(BABYLON.ActionManager.OnPickDownTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                            switch (evt.button) {\n                                case 0:\n                                    actionManager.processTrigger(BABYLON.ActionManager.OnLeftPickTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                                    break;\n                                case 1:\n                                    actionManager.processTrigger(BABYLON.ActionManager.OnCenterPickTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                                    break;\n                                case 2:\n                                    actionManager.processTrigger(BABYLON.ActionManager.OnRightPickTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                                    break;\n                            }\n                        }\n                        if (actionManager.hasSpecificTrigger(BABYLON.ActionManager.OnLongPressTrigger)) {\n                            window.setTimeout((function () {\n                                var _this = this;\n                                var pickResult = this.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, function (mesh) { return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(BABYLON.ActionManager.OnLongPressTrigger) && mesh == _this._pickedDownMesh; }, false, this.cameraToUseForPointers);\n                                if (pickResult && pickResult.hit && pickResult.pickedMesh) {\n                                    if (this._isButtonPressed &&\n                                        ((new Date().getTime() - this._startingPointerTime) > Scene.LongPressDelay) &&\n                                        (Math.abs(this._startingPointerPosition.x - this._pointerX) < Scene.DragMovementThreshold &&\n                                            Math.abs(this._startingPointerPosition.y - this._pointerY) < Scene.DragMovementThreshold)) {\n                                        this._startingPointerTime = 0;\n                                        actionManager.processTrigger(BABYLON.ActionManager.OnLongPressTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                                    }\n                                }\n                            }).bind(_this), Scene.LongPressDelay);\n                        }\n                    }\n                }\n                if (_this.onPointerDown) {\n                    _this.onPointerDown(evt, pickResult);\n                }\n                if (_this.onPointerObservable.hasObservers()) {\n                    var type = PointerEventTypes.POINTERDOWN;\n                    var pi = new PointerInfo(type, evt, pickResult);\n                    _this.onPointerObservable.notifyObservers(pi, type);\n                }\n                // Sprites\n                _this._pickedDownSprite = null;\n                if (_this.spriteManagers.length > 0) {\n                    pickResult = _this.pickSprite(_this._unTranslatedPointerX, _this._unTranslatedPointerY, spritePredicate, false, _this.cameraToUseForPointers);\n                    if (pickResult && pickResult.hit && pickResult.pickedSprite) {\n                        if (pickResult.pickedSprite.actionManager) {\n                            _this._pickedDownSprite = pickResult.pickedSprite;\n                            switch (evt.button) {\n                                case 0:\n                                    pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnLeftPickTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, _this, evt));\n                                    break;\n                                case 1:\n                                    pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnCenterPickTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, _this, evt));\n                                    break;\n                                case 2:\n                                    pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnRightPickTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, _this, evt));\n                                    break;\n                            }\n                            if (pickResult.pickedSprite.actionManager) {\n                                pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPickDownTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, _this, evt));\n                            }\n                        }\n                    }\n                }\n            };\n            this._onPointerUp = function (evt) {\n                _this._isButtonPressed = false;\n                _this._pickedUpMesh = null;\n                _this._meshPickProceed = false;\n                _this._updatePointerPosition(evt);\n                _this._initClickEvent(_this.onPrePointerObservable, _this.onPointerObservable, evt, (function (clickInfo, pickResult) {\n                    // PreObservable support\n                    if (this.onPrePointerObservable.hasObservers()) {\n                        if (!clickInfo.ignore) {\n                            if (!clickInfo.hasSwiped) {\n                                if (clickInfo.singleClick && this.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                                    var type = PointerEventTypes.POINTERTAP;\n                                    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n                                    this.onPrePointerObservable.notifyObservers(pi, type);\n                                    if (pi.skipOnPointerObservable) {\n                                        return;\n                                    }\n                                }\n                                if (clickInfo.doubleClick && this.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                                    var type = PointerEventTypes.POINTERDOUBLETAP;\n                                    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n                                    this.onPrePointerObservable.notifyObservers(pi, type);\n                                    if (pi.skipOnPointerObservable) {\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            var type = PointerEventTypes.POINTERUP;\n                            var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n                            this.onPrePointerObservable.notifyObservers(pi, type);\n                            if (pi.skipOnPointerObservable) {\n                                return;\n                            }\n                        }\n                    }\n                    if (!this.cameraToUseForPointers && !this.activeCamera) {\n                        return;\n                    }\n                    if (!this.pointerUpPredicate) {\n                        this.pointerUpPredicate = function (mesh) {\n                            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled();\n                        };\n                    }\n                    // Meshes\n                    if (!this._meshPickProceed && (BABYLON.ActionManager && BABYLON.ActionManager.HasTriggers || this.onPointerObservable.hasObservers())) {\n                        this._initActionManager(null, clickInfo);\n                    }\n                    if (!pickResult) {\n                        pickResult = this._currentPickResult;\n                    }\n                    if (pickResult && pickResult && pickResult.pickedMesh) {\n                        this._pickedUpMesh = pickResult.pickedMesh;\n                        if (this._pickedDownMesh === this._pickedUpMesh) {\n                            if (this.onPointerPick) {\n                                this.onPointerPick(evt, pickResult);\n                            }\n                            if (clickInfo.singleClick && !clickInfo.ignore && this.onPointerObservable.hasObservers()) {\n                                var type = PointerEventTypes.POINTERPICK;\n                                var pi = new PointerInfo(type, evt, pickResult);\n                                this.onPointerObservable.notifyObservers(pi, type);\n                            }\n                        }\n                        if (pickResult.pickedMesh.actionManager) {\n                            if (clickInfo.ignore) {\n                                pickResult.pickedMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPickUpTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                            }\n                            if (!clickInfo.hasSwiped && !clickInfo.ignore && clickInfo.singleClick) {\n                                pickResult.pickedMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPickTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                            }\n                            if (clickInfo.doubleClick && !clickInfo.ignore && pickResult.pickedMesh.actionManager.hasSpecificTrigger(BABYLON.ActionManager.OnDoublePickTrigger)) {\n                                pickResult.pickedMesh.actionManager.processTrigger(BABYLON.ActionManager.OnDoublePickTrigger, BABYLON.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n                            }\n                        }\n                    }\n                    if (this._pickedDownMesh &&\n                        this._pickedDownMesh.actionManager &&\n                        this._pickedDownMesh.actionManager.hasSpecificTrigger(BABYLON.ActionManager.OnPickOutTrigger) &&\n                        this._pickedDownMesh !== this._pickedUpMesh) {\n                        this._pickedDownMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPickOutTrigger, BABYLON.ActionEvent.CreateNew(this._pickedDownMesh, evt));\n                    }\n                    if (this.onPointerUp) {\n                        this.onPointerUp(evt, pickResult);\n                    }\n                    if (this.onPointerObservable.hasObservers()) {\n                        if (!clickInfo.ignore) {\n                            if (!clickInfo.hasSwiped) {\n                                if (clickInfo.singleClick && this.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {\n                                    var type = PointerEventTypes.POINTERTAP;\n                                    var pi = new PointerInfo(type, evt, pickResult);\n                                    this.onPointerObservable.notifyObservers(pi, type);\n                                }\n                                if (clickInfo.doubleClick && this.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {\n                                    var type = PointerEventTypes.POINTERDOUBLETAP;\n                                    var pi = new PointerInfo(type, evt, pickResult);\n                                    this.onPointerObservable.notifyObservers(pi, type);\n                                }\n                            }\n                        }\n                        else {\n                            var type = PointerEventTypes.POINTERUP;\n                            var pi = new PointerInfo(type, evt, pickResult);\n                            this.onPointerObservable.notifyObservers(pi, type);\n                        }\n                    }\n                    // Sprites\n                    if (this.spriteManagers.length > 0) {\n                        pickResult = this.pickSprite(this._unTranslatedPointerX, this._unTranslatedPointerY, spritePredicate, false, this.cameraToUseForPointers);\n                        if (pickResult.hit && pickResult.pickedSprite) {\n                            if (pickResult.pickedSprite.actionManager) {\n                                pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPickUpTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, this, evt));\n                                if (pickResult.pickedSprite.actionManager) {\n                                    if (Math.abs(this._startingPointerPosition.x - this._pointerX) < Scene.DragMovementThreshold && Math.abs(this._startingPointerPosition.y - this._pointerY) < Scene.DragMovementThreshold) {\n                                        pickResult.pickedSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPickTrigger, BABYLON.ActionEvent.CreateNewFromSprite(pickResult.pickedSprite, this, evt));\n                                    }\n                                }\n                            }\n                        }\n                        if (this._pickedDownSprite && this._pickedDownSprite.actionManager && this._pickedDownSprite !== pickResult.pickedSprite) {\n                            this._pickedDownSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPickOutTrigger, BABYLON.ActionEvent.CreateNewFromSprite(this._pickedDownSprite, this, evt));\n                        }\n                    }\n                    this._previousPickResult = this._currentPickResult;\n                }).bind(_this));\n            };\n            this._onKeyDown = function (evt) {\n                if (_this.actionManager) {\n                    _this.actionManager.processTrigger(BABYLON.ActionManager.OnKeyDownTrigger, BABYLON.ActionEvent.CreateNewFromScene(_this, evt));\n                }\n            };\n            this._onKeyUp = function (evt) {\n                if (_this.actionManager) {\n                    _this.actionManager.processTrigger(BABYLON.ActionManager.OnKeyUpTrigger, BABYLON.ActionEvent.CreateNewFromScene(_this, evt));\n                }\n            };\n            var eventPrefix = BABYLON.Tools.GetPointerPrefix();\n            var canvas = this._engine.getRenderingCanvas();\n            if (attachMove) {\n                canvas.addEventListener(eventPrefix + \"move\", this._onPointerMove, false);\n                // Wheel\n                canvas.addEventListener('mousewheel', this._onPointerMove, false);\n                canvas.addEventListener('DOMMouseScroll', this._onPointerMove, false);\n            }\n            if (attachDown) {\n                canvas.addEventListener(eventPrefix + \"down\", this._onPointerDown, false);\n            }\n            if (attachUp) {\n                canvas.addEventListener(eventPrefix + \"up\", this._onPointerUp, false);\n            }\n            canvas.tabIndex = 1;\n            canvas.addEventListener(\"keydown\", this._onKeyDown, false);\n            canvas.addEventListener(\"keyup\", this._onKeyUp, false);\n        };\n        Scene.prototype.detachControl = function () {\n            var eventPrefix = BABYLON.Tools.GetPointerPrefix();\n            var canvas = this._engine.getRenderingCanvas();\n            canvas.removeEventListener(eventPrefix + \"move\", this._onPointerMove);\n            canvas.removeEventListener(eventPrefix + \"down\", this._onPointerDown);\n            canvas.removeEventListener(eventPrefix + \"up\", this._onPointerUp);\n            // Wheel\n            canvas.removeEventListener('mousewheel', this._onPointerMove);\n            canvas.removeEventListener('DOMMouseScroll', this._onPointerMove);\n            canvas.removeEventListener(\"keydown\", this._onKeyDown);\n            canvas.removeEventListener(\"keyup\", this._onKeyUp);\n        };\n        // Ready\n        Scene.prototype.isReady = function () {\n            if (this._pendingData.length > 0) {\n                return false;\n            }\n            var index;\n            // Geometries\n            for (index = 0; index < this._geometries.length; index++) {\n                var geometry = this._geometries[index];\n                if (geometry.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADING) {\n                    return false;\n                }\n            }\n            // Meshes\n            for (index = 0; index < this.meshes.length; index++) {\n                var mesh = this.meshes[index];\n                if (!mesh.isEnabled()) {\n                    continue;\n                }\n                if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n                    continue;\n                }\n                if (!mesh.isReady()) {\n                    return false;\n                }\n                var mat = mesh.material;\n                if (mat) {\n                    if (!mat.isReady(mesh)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        Scene.prototype.resetCachedMaterial = function () {\n            this._cachedMaterial = null;\n            this._cachedEffect = null;\n            this._cachedVisibility = null;\n        };\n        Scene.prototype.registerBeforeRender = function (func) {\n            this.onBeforeRenderObservable.add(func);\n        };\n        Scene.prototype.unregisterBeforeRender = function (func) {\n            this.onBeforeRenderObservable.removeCallback(func);\n        };\n        Scene.prototype.registerAfterRender = function (func) {\n            this.onAfterRenderObservable.add(func);\n        };\n        Scene.prototype.unregisterAfterRender = function (func) {\n            this.onAfterRenderObservable.removeCallback(func);\n        };\n        Scene.prototype._addPendingData = function (data) {\n            this._pendingData.push(data);\n        };\n        Scene.prototype._removePendingData = function (data) {\n            var index = this._pendingData.indexOf(data);\n            if (index !== -1) {\n                this._pendingData.splice(index, 1);\n            }\n        };\n        Scene.prototype.getWaitingItemsCount = function () {\n            return this._pendingData.length;\n        };\n        /**\n         * Registers a function to be executed when the scene is ready.\n         * @param {Function} func - the function to be executed.\n         */\n        Scene.prototype.executeWhenReady = function (func) {\n            var _this = this;\n            this.onReadyObservable.add(func);\n            if (this._executeWhenReadyTimeoutId !== -1) {\n                return;\n            }\n            this._executeWhenReadyTimeoutId = setTimeout(function () {\n                _this._checkIsReady();\n            }, 150);\n        };\n        Scene.prototype._checkIsReady = function () {\n            var _this = this;\n            if (this.isReady()) {\n                this.onReadyObservable.notifyObservers(this);\n                this.onReadyObservable.clear();\n                this._executeWhenReadyTimeoutId = -1;\n                return;\n            }\n            this._executeWhenReadyTimeoutId = setTimeout(function () {\n                _this._checkIsReady();\n            }, 150);\n        };\n        // Animations\n        /**\n         * Will start the animation sequence of a given target\n         * @param target - the target\n         * @param {number} from - from which frame should animation start\n         * @param {number} to - till which frame should animation run.\n         * @param {boolean} [loop] - should the animation loop\n         * @param {number} [speedRatio] - the speed in which to run the animation\n         * @param {Function} [onAnimationEnd] function to be executed when the animation ended.\n         * @param {BABYLON.Animatable} [animatable] an animatable object. If not provided a new one will be created from the given params.\n         * @return {BABYLON.Animatable} the animatable object created for this animation\n         * @see BABYLON.Animatable\n         * @see http://doc.babylonjs.com/page.php?p=22081\n         */\n        Scene.prototype.beginAnimation = function (target, from, to, loop, speedRatio, onAnimationEnd, animatable) {\n            if (speedRatio === void 0) { speedRatio = 1.0; }\n            if (from > to && speedRatio > 0) {\n                speedRatio *= -1;\n            }\n            this.stopAnimation(target);\n            if (!animatable) {\n                animatable = new BABYLON.Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd);\n            }\n            // Local animations\n            if (target.animations) {\n                animatable.appendAnimations(target, target.animations);\n            }\n            // Children animations\n            if (target.getAnimatables) {\n                var animatables = target.getAnimatables();\n                for (var index = 0; index < animatables.length; index++) {\n                    this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable);\n                }\n            }\n            animatable.reset();\n            return animatable;\n        };\n        Scene.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio, onAnimationEnd) {\n            if (speedRatio === undefined) {\n                speedRatio = 1.0;\n            }\n            var animatable = new BABYLON.Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations);\n            return animatable;\n        };\n        Scene.prototype.getAnimatableByTarget = function (target) {\n            for (var index = 0; index < this._activeAnimatables.length; index++) {\n                if (this._activeAnimatables[index].target === target) {\n                    return this._activeAnimatables[index];\n                }\n            }\n            return null;\n        };\n        Object.defineProperty(Scene.prototype, \"Animatables\", {\n            get: function () {\n                return this._activeAnimatables;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Will stop the animation of the given target\n         * @param target - the target\n         * @param animationName - the name of the animation to stop (all animations will be stopped is empty)\n         * @see beginAnimation\n         */\n        Scene.prototype.stopAnimation = function (target, animationName) {\n            var animatable = this.getAnimatableByTarget(target);\n            if (animatable) {\n                animatable.stop(animationName);\n            }\n        };\n        Scene.prototype._animate = function () {\n            if (!this.animationsEnabled || this._activeAnimatables.length === 0) {\n                return;\n            }\n            // Getting time\n            var now = BABYLON.Tools.Now;\n            if (!this._animationTimeLast) {\n                if (this._pendingData.length > 0) {\n                    return;\n                }\n                this._animationTimeLast = now;\n            }\n            var deltaTime = (now - this._animationTimeLast) * this.animationTimeScale;\n            this._animationTime += deltaTime;\n            this._animationTimeLast = now;\n            for (var index = 0; index < this._activeAnimatables.length; index++) {\n                this._activeAnimatables[index]._animate(this._animationTime);\n            }\n        };\n        // Matrix\n        Scene.prototype.getViewMatrix = function () {\n            return this._viewMatrix;\n        };\n        Scene.prototype.getProjectionMatrix = function () {\n            return this._projectionMatrix;\n        };\n        Scene.prototype.getTransformMatrix = function () {\n            return this._transformMatrix;\n        };\n        Scene.prototype.setTransformMatrix = function (view, projection) {\n            if (this._viewUpdateFlag === view.updateFlag && this._projectionUpdateFlag === projection.updateFlag) {\n                return;\n            }\n            this._viewUpdateFlag = view.updateFlag;\n            this._projectionUpdateFlag = projection.updateFlag;\n            this._viewMatrix = view;\n            this._projectionMatrix = projection;\n            this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n            // Update frustum\n            if (!this._frustumPlanes) {\n                this._frustumPlanes = BABYLON.Frustum.GetPlanes(this._transformMatrix);\n            }\n            else {\n                BABYLON.Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n            }\n            if (this._sceneUbo.useUbo) {\n                this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n                this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n                this._sceneUbo.update();\n            }\n        };\n        Scene.prototype.getSceneUniformBuffer = function () {\n            return this._sceneUbo;\n        };\n        // Methods\n        Scene.prototype.getUniqueId = function () {\n            var result = this._uniqueIdCounter;\n            this._uniqueIdCounter++;\n            return result;\n        };\n        Scene.prototype.addMesh = function (newMesh) {\n            newMesh.uniqueId = this.getUniqueId();\n            var position = this.meshes.push(newMesh);\n            //notify the collision coordinator\n            if (this.collisionCoordinator) {\n                this.collisionCoordinator.onMeshAdded(newMesh);\n            }\n            this.onNewMeshAddedObservable.notifyObservers(newMesh);\n        };\n        Scene.prototype.removeMesh = function (toRemove) {\n            var index = this.meshes.indexOf(toRemove);\n            if (index !== -1) {\n                // Remove from the scene if mesh found \n                this.meshes.splice(index, 1);\n            }\n            //notify the collision coordinator\n            if (this.collisionCoordinator) {\n                this.collisionCoordinator.onMeshRemoved(toRemove);\n            }\n            this.onMeshRemovedObservable.notifyObservers(toRemove);\n            return index;\n        };\n        Scene.prototype.removeSkeleton = function (toRemove) {\n            var index = this.skeletons.indexOf(toRemove);\n            if (index !== -1) {\n                // Remove from the scene if found \n                this.skeletons.splice(index, 1);\n            }\n            return index;\n        };\n        Scene.prototype.removeMorphTargetManager = function (toRemove) {\n            var index = this.morphTargetManagers.indexOf(toRemove);\n            if (index !== -1) {\n                // Remove from the scene if found \n                this.morphTargetManagers.splice(index, 1);\n            }\n            return index;\n        };\n        Scene.prototype.removeLight = function (toRemove) {\n            var index = this.lights.indexOf(toRemove);\n            if (index !== -1) {\n                // Remove from the scene if mesh found \n                this.lights.splice(index, 1);\n                this.sortLightsByPriority();\n            }\n            this.onLightRemovedObservable.notifyObservers(toRemove);\n            return index;\n        };\n        Scene.prototype.removeCamera = function (toRemove) {\n            var index = this.cameras.indexOf(toRemove);\n            if (index !== -1) {\n                // Remove from the scene if mesh found \n                this.cameras.splice(index, 1);\n            }\n            // Remove from activeCameras\n            var index2 = this.activeCameras.indexOf(toRemove);\n            if (index2 !== -1) {\n                // Remove from the scene if mesh found\n                this.activeCameras.splice(index2, 1);\n            }\n            // Reset the activeCamera\n            if (this.activeCamera === toRemove) {\n                if (this.cameras.length > 0) {\n                    this.activeCamera = this.cameras[0];\n                }\n                else {\n                    this.activeCamera = null;\n                }\n            }\n            this.onCameraRemovedObservable.notifyObservers(toRemove);\n            return index;\n        };\n        Scene.prototype.addLight = function (newLight) {\n            newLight.uniqueId = this.getUniqueId();\n            this.lights.push(newLight);\n            this.sortLightsByPriority();\n            this.onNewLightAddedObservable.notifyObservers(newLight);\n        };\n        Scene.prototype.sortLightsByPriority = function () {\n            if (this.requireLightSorting) {\n                this.lights.sort(BABYLON.Light.compareLightsPriority);\n            }\n        };\n        Scene.prototype.addCamera = function (newCamera) {\n            newCamera.uniqueId = this.getUniqueId();\n            var position = this.cameras.push(newCamera);\n            this.onNewCameraAddedObservable.notifyObservers(newCamera);\n        };\n        /**\n         * Switch active camera\n         * @param {Camera} newCamera - new active camera\n         * @param {boolean} attachControl - call attachControl for the new active camera (default: true)\n         */\n        Scene.prototype.switchActiveCamera = function (newCamera, attachControl) {\n            if (attachControl === void 0) { attachControl = true; }\n            var canvas = this._engine.getRenderingCanvas();\n            this.activeCamera.detachControl(canvas);\n            this.activeCamera = newCamera;\n            if (attachControl) {\n                newCamera.attachControl(canvas);\n            }\n        };\n        /**\n         * sets the active camera of the scene using its ID\n         * @param {string} id - the camera's ID\n         * @return {BABYLON.Camera|null} the new active camera or null if none found.\n         * @see activeCamera\n         */\n        Scene.prototype.setActiveCameraByID = function (id) {\n            var camera = this.getCameraByID(id);\n            if (camera) {\n                this.activeCamera = camera;\n                return camera;\n            }\n            return null;\n        };\n        /**\n         * sets the active camera of the scene using its name\n         * @param {string} name - the camera's name\n         * @return {BABYLON.Camera|null} the new active camera or null if none found.\n         * @see activeCamera\n         */\n        Scene.prototype.setActiveCameraByName = function (name) {\n            var camera = this.getCameraByName(name);\n            if (camera) {\n                this.activeCamera = camera;\n                return camera;\n            }\n            return null;\n        };\n        /**\n         * get a material using its id\n         * @param {string} the material's ID\n         * @return {BABYLON.Material|null} the material or null if none found.\n         */\n        Scene.prototype.getMaterialByID = function (id) {\n            for (var index = 0; index < this.materials.length; index++) {\n                if (this.materials[index].id === id) {\n                    return this.materials[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a material using its name\n         * @param {string} the material's name\n         * @return {BABYLON.Material|null} the material or null if none found.\n         */\n        Scene.prototype.getMaterialByName = function (name) {\n            for (var index = 0; index < this.materials.length; index++) {\n                if (this.materials[index].name === name) {\n                    return this.materials[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getLensFlareSystemByName = function (name) {\n            for (var index = 0; index < this.lensFlareSystems.length; index++) {\n                if (this.lensFlareSystems[index].name === name) {\n                    return this.lensFlareSystems[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getLensFlareSystemByID = function (id) {\n            for (var index = 0; index < this.lensFlareSystems.length; index++) {\n                if (this.lensFlareSystems[index].id === id) {\n                    return this.lensFlareSystems[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getCameraByID = function (id) {\n            for (var index = 0; index < this.cameras.length; index++) {\n                if (this.cameras[index].id === id) {\n                    return this.cameras[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getCameraByUniqueID = function (uniqueId) {\n            for (var index = 0; index < this.cameras.length; index++) {\n                if (this.cameras[index].uniqueId === uniqueId) {\n                    return this.cameras[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a camera using its name\n         * @param {string} the camera's name\n         * @return {BABYLON.Camera|null} the camera or null if none found.\n         */\n        Scene.prototype.getCameraByName = function (name) {\n            for (var index = 0; index < this.cameras.length; index++) {\n                if (this.cameras[index].name === name) {\n                    return this.cameras[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a bone using its id\n         * @param {string} the bone's id\n         * @return {BABYLON.Bone|null} the bone or null if not found\n         */\n        Scene.prototype.getBoneByID = function (id) {\n            for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n                var skeleton = this.skeletons[skeletonIndex];\n                for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                    if (skeleton.bones[boneIndex].id === id) {\n                        return skeleton.bones[boneIndex];\n                    }\n                }\n            }\n            return null;\n        };\n        /**\n        * get a bone using its id\n        * @param {string} the bone's name\n        * @return {BABYLON.Bone|null} the bone or null if not found\n        */\n        Scene.prototype.getBoneByName = function (name) {\n            for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n                var skeleton = this.skeletons[skeletonIndex];\n                for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n                    if (skeleton.bones[boneIndex].name === name) {\n                        return skeleton.bones[boneIndex];\n                    }\n                }\n            }\n            return null;\n        };\n        /**\n         * get a light node using its name\n         * @param {string} the light's name\n         * @return {BABYLON.Light|null} the light or null if none found.\n         */\n        Scene.prototype.getLightByName = function (name) {\n            for (var index = 0; index < this.lights.length; index++) {\n                if (this.lights[index].name === name) {\n                    return this.lights[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a light node using its ID\n         * @param {string} the light's id\n         * @return {BABYLON.Light|null} the light or null if none found.\n         */\n        Scene.prototype.getLightByID = function (id) {\n            for (var index = 0; index < this.lights.length; index++) {\n                if (this.lights[index].id === id) {\n                    return this.lights[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a light node using its scene-generated unique ID\n         * @param {number} the light's unique id\n         * @return {BABYLON.Light|null} the light or null if none found.\n         */\n        Scene.prototype.getLightByUniqueID = function (uniqueId) {\n            for (var index = 0; index < this.lights.length; index++) {\n                if (this.lights[index].uniqueId === uniqueId) {\n                    return this.lights[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a particle system by id\n         * @param id {number} the particle system id\n         * @return {BABYLON.ParticleSystem|null} the corresponding system or null if none found.\n         */\n        Scene.prototype.getParticleSystemByID = function (id) {\n            for (var index = 0; index < this.particleSystems.length; index++) {\n                if (this.particleSystems[index].id === id) {\n                    return this.particleSystems[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * get a geometry using its ID\n         * @param {string} the geometry's id\n         * @return {BABYLON.Geometry|null} the geometry or null if none found.\n         */\n        Scene.prototype.getGeometryByID = function (id) {\n            for (var index = 0; index < this._geometries.length; index++) {\n                if (this._geometries[index].id === id) {\n                    return this._geometries[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * add a new geometry to this scene.\n         * @param {BABYLON.Geometry} geometry - the geometry to be added to the scene.\n         * @param {boolean} [force] - force addition, even if a geometry with this ID already exists\n         * @return {boolean} was the geometry added or not\n         */\n        Scene.prototype.pushGeometry = function (geometry, force) {\n            if (!force && this.getGeometryByID(geometry.id)) {\n                return false;\n            }\n            this._geometries.push(geometry);\n            //notify the collision coordinator\n            if (this.collisionCoordinator) {\n                this.collisionCoordinator.onGeometryAdded(geometry);\n            }\n            this.onNewGeometryAddedObservable.notifyObservers(geometry);\n            return true;\n        };\n        /**\n         * Removes an existing geometry\n         * @param {BABYLON.Geometry} geometry - the geometry to be removed from the scene.\n         * @return {boolean} was the geometry removed or not\n         */\n        Scene.prototype.removeGeometry = function (geometry) {\n            var index = this._geometries.indexOf(geometry);\n            if (index > -1) {\n                this._geometries.splice(index, 1);\n                //notify the collision coordinator\n                if (this.collisionCoordinator) {\n                    this.collisionCoordinator.onGeometryDeleted(geometry);\n                }\n                this.onGeometryRemovedObservable.notifyObservers(geometry);\n                return true;\n            }\n            return false;\n        };\n        Scene.prototype.getGeometries = function () {\n            return this._geometries;\n        };\n        /**\n         * Get the first added mesh found of a given ID\n         * @param {string} id - the id to search for\n         * @return {BABYLON.AbstractMesh|null} the mesh found or null if not found at all.\n         */\n        Scene.prototype.getMeshByID = function (id) {\n            for (var index = 0; index < this.meshes.length; index++) {\n                if (this.meshes[index].id === id) {\n                    return this.meshes[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getMeshesByID = function (id) {\n            return this.meshes.filter(function (m) {\n                return m.id === id;\n            });\n        };\n        /**\n         * Get a mesh with its auto-generated unique id\n         * @param {number} uniqueId - the unique id to search for\n         * @return {BABYLON.AbstractMesh|null} the mesh found or null if not found at all.\n         */\n        Scene.prototype.getMeshByUniqueID = function (uniqueId) {\n            for (var index = 0; index < this.meshes.length; index++) {\n                if (this.meshes[index].uniqueId === uniqueId) {\n                    return this.meshes[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * Get a the last added mesh found of a given ID\n         * @param {string} id - the id to search for\n         * @return {BABYLON.AbstractMesh|null} the mesh found or null if not found at all.\n         */\n        Scene.prototype.getLastMeshByID = function (id) {\n            for (var index = this.meshes.length - 1; index >= 0; index--) {\n                if (this.meshes[index].id === id) {\n                    return this.meshes[index];\n                }\n            }\n            return null;\n        };\n        /**\n         * Get a the last added node (Mesh, Camera, Light) found of a given ID\n         * @param {string} id - the id to search for\n         * @return {BABYLON.Node|null} the node found or null if not found at all.\n         */\n        Scene.prototype.getLastEntryByID = function (id) {\n            var index;\n            for (index = this.meshes.length - 1; index >= 0; index--) {\n                if (this.meshes[index].id === id) {\n                    return this.meshes[index];\n                }\n            }\n            for (index = this.cameras.length - 1; index >= 0; index--) {\n                if (this.cameras[index].id === id) {\n                    return this.cameras[index];\n                }\n            }\n            for (index = this.lights.length - 1; index >= 0; index--) {\n                if (this.lights[index].id === id) {\n                    return this.lights[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getNodeByID = function (id) {\n            var mesh = this.getMeshByID(id);\n            if (mesh) {\n                return mesh;\n            }\n            var light = this.getLightByID(id);\n            if (light) {\n                return light;\n            }\n            var camera = this.getCameraByID(id);\n            if (camera) {\n                return camera;\n            }\n            var bone = this.getBoneByID(id);\n            return bone;\n        };\n        Scene.prototype.getNodeByName = function (name) {\n            var mesh = this.getMeshByName(name);\n            if (mesh) {\n                return mesh;\n            }\n            var light = this.getLightByName(name);\n            if (light) {\n                return light;\n            }\n            var camera = this.getCameraByName(name);\n            if (camera) {\n                return camera;\n            }\n            var bone = this.getBoneByName(name);\n            return bone;\n        };\n        Scene.prototype.getMeshByName = function (name) {\n            for (var index = 0; index < this.meshes.length; index++) {\n                if (this.meshes[index].name === name) {\n                    return this.meshes[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getSoundByName = function (name) {\n            var index;\n            if (BABYLON.AudioEngine) {\n                for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\n                    if (this.mainSoundTrack.soundCollection[index].name === name) {\n                        return this.mainSoundTrack.soundCollection[index];\n                    }\n                }\n                for (var sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\n                    for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\n                        if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\n                            return this.soundTracks[sdIndex].soundCollection[index];\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getLastSkeletonByID = function (id) {\n            for (var index = this.skeletons.length - 1; index >= 0; index--) {\n                if (this.skeletons[index].id === id) {\n                    return this.skeletons[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getSkeletonById = function (id) {\n            for (var index = 0; index < this.skeletons.length; index++) {\n                if (this.skeletons[index].id === id) {\n                    return this.skeletons[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getSkeletonByName = function (name) {\n            for (var index = 0; index < this.skeletons.length; index++) {\n                if (this.skeletons[index].name === name) {\n                    return this.skeletons[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.getMorphTargetManagerById = function (id) {\n            for (var index = 0; index < this.morphTargetManagers.length; index++) {\n                if (this.morphTargetManagers[index].uniqueId === id) {\n                    return this.morphTargetManagers[index];\n                }\n            }\n            return null;\n        };\n        Scene.prototype.isActiveMesh = function (mesh) {\n            return (this._activeMeshes.indexOf(mesh) !== -1);\n        };\n        /**\n         * Return a the first highlight layer of the scene with a given name.\n         * @param name The name of the highlight layer to look for.\n         * @return The highlight layer if found otherwise null.\n         */\n        Scene.prototype.getHighlightLayerByName = function (name) {\n            for (var index = 0; index < this.highlightLayers.length; index++) {\n                if (this.highlightLayers[index].name === name) {\n                    return this.highlightLayers[index];\n                }\n            }\n            return null;\n        };\n        Object.defineProperty(Scene.prototype, \"uid\", {\n            /**\n             * Return a unique id as a string which can serve as an identifier for the scene\n             */\n            get: function () {\n                if (!this._uid) {\n                    this._uid = BABYLON.Tools.RandomId();\n                }\n                return this._uid;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Add an externaly attached data from its key.\n         * This method call will fail and return false, if such key already exists.\n         * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n         * @param key the unique key that identifies the data\n         * @param data the data object to associate to the key for this Engine instance\n         * @return true if no such key were already present and the data was added successfully, false otherwise\n         */\n        Scene.prototype.addExternalData = function (key, data) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.add(key, data);\n        };\n        /**\n         * Get an externaly attached data from its key\n         * @param key the unique key that identifies the data\n         * @return the associated data, if present (can be null), or undefined if not present\n         */\n        Scene.prototype.getExternalData = function (key) {\n            if (!this._externalData) {\n                return null;\n            }\n            return this._externalData.get(key);\n        };\n        /**\n         * Get an externaly attached data from its key, create it using a factory if it's not already present\n         * @param key the unique key that identifies the data\n         * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n         * @return the associated data, can be null if the factory returned null.\n         */\n        Scene.prototype.getOrAddExternalDataWithFactory = function (key, factory) {\n            if (!this._externalData) {\n                this._externalData = new BABYLON.StringDictionary();\n            }\n            return this._externalData.getOrAddWithFactory(key, factory);\n        };\n        /**\n         * Remove an externaly attached data from the Engine instance\n         * @param key the unique key that identifies the data\n         * @return true if the data was successfully removed, false if it doesn't exist\n         */\n        Scene.prototype.removeExternalData = function (key) {\n            return this._externalData.remove(key);\n        };\n        Scene.prototype._evaluateSubMesh = function (subMesh, mesh) {\n            if (mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\n                var material = subMesh.getMaterial();\n                if (mesh.showSubMeshesBoundingBox) {\n                    this.getBoundingBoxRenderer().renderList.push(subMesh.getBoundingInfo().boundingBox);\n                }\n                if (material) {\n                    // Render targets\n                    if (material.getRenderTargetTextures) {\n                        if (this._processedMaterials.indexOf(material) === -1) {\n                            this._processedMaterials.push(material);\n                            this._renderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                        }\n                    }\n                    // Dispatch\n                    this._activeIndices.addCount(subMesh.indexCount, false);\n                    this._renderingManager.dispatch(subMesh);\n                }\n            }\n        };\n        Scene.prototype._isInIntermediateRendering = function () {\n            return this._intermediateRendering;\n        };\n        Scene.prototype._evaluateActiveMeshes = function () {\n            this.activeCamera._activeMeshes.reset();\n            this._activeMeshes.reset();\n            this._renderingManager.reset();\n            this._processedMaterials.reset();\n            this._activeParticleSystems.reset();\n            this._activeSkeletons.reset();\n            this._softwareSkinnedMeshes.reset();\n            if (this._boundingBoxRenderer) {\n                this._boundingBoxRenderer.reset();\n            }\n            // Meshes\n            var meshes;\n            var len;\n            if (this._selectionOctree) {\n                var selection = this._selectionOctree.select(this._frustumPlanes);\n                meshes = selection.data;\n                len = selection.length;\n            }\n            else {\n                len = this.meshes.length;\n                meshes = this.meshes;\n            }\n            for (var meshIndex = 0; meshIndex < len; meshIndex++) {\n                var mesh = meshes[meshIndex];\n                if (mesh.isBlocked) {\n                    continue;\n                }\n                this._totalVertices.addCount(mesh.getTotalVertices(), false);\n                if (!mesh.isReady() || !mesh.isEnabled()) {\n                    continue;\n                }\n                mesh.computeWorldMatrix();\n                // Intersections\n                if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers([BABYLON.ActionManager.OnIntersectionEnterTrigger, BABYLON.ActionManager.OnIntersectionExitTrigger])) {\n                    this._meshesForIntersections.pushNoDuplicate(mesh);\n                }\n                // Switch to current LOD\n                var meshLOD = mesh.getLOD(this.activeCamera);\n                if (!meshLOD) {\n                    continue;\n                }\n                mesh._preActivate();\n                if (mesh.alwaysSelectAsActiveMesh || mesh.isVisible && mesh.visibility > 0 && ((mesh.layerMask & this.activeCamera.layerMask) !== 0) && mesh.isInFrustum(this._frustumPlanes)) {\n                    this._activeMeshes.push(mesh);\n                    this.activeCamera._activeMeshes.push(mesh);\n                    mesh._activate(this._renderId);\n                    this._activeMesh(mesh, meshLOD);\n                }\n            }\n            // Particle systems\n            this._particlesDuration.beginMonitoring();\n            var beforeParticlesDate = BABYLON.Tools.Now;\n            if (this.particlesEnabled) {\n                BABYLON.Tools.StartPerformanceCounter(\"Particles\", this.particleSystems.length > 0);\n                for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n                    var particleSystem = this.particleSystems[particleIndex];\n                    if (!particleSystem.isStarted()) {\n                        continue;\n                    }\n                    if (!particleSystem.emitter.position || (particleSystem.emitter && particleSystem.emitter.isEnabled())) {\n                        this._activeParticleSystems.push(particleSystem);\n                        particleSystem.animate();\n                        this._renderingManager.dispatchParticles(particleSystem);\n                    }\n                }\n                BABYLON.Tools.EndPerformanceCounter(\"Particles\", this.particleSystems.length > 0);\n            }\n            this._particlesDuration.endMonitoring(false);\n        };\n        Scene.prototype._activeMesh = function (sourceMesh, mesh) {\n            if (mesh.skeleton && this.skeletonsEnabled) {\n                if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n                    mesh.skeleton.prepare();\n                }\n                if (!mesh.computeBonesUsingShaders) {\n                    this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n                }\n            }\n            if (sourceMesh.showBoundingBox || this.forceShowBoundingBoxes) {\n                this.getBoundingBoxRenderer().renderList.push(sourceMesh.getBoundingInfo().boundingBox);\n            }\n            if (mesh && mesh.subMeshes) {\n                // Submeshes Octrees\n                var len;\n                var subMeshes;\n                if (mesh._submeshesOctree && mesh.useOctreeForRenderingSelection) {\n                    var intersections = mesh._submeshesOctree.select(this._frustumPlanes);\n                    len = intersections.length;\n                    subMeshes = intersections.data;\n                }\n                else {\n                    subMeshes = mesh.subMeshes;\n                    len = subMeshes.length;\n                }\n                for (var subIndex = 0; subIndex < len; subIndex++) {\n                    var subMesh = subMeshes[subIndex];\n                    this._evaluateSubMesh(subMesh, mesh);\n                }\n            }\n        };\n        Scene.prototype.updateTransformMatrix = function (force) {\n            this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n        };\n        Scene.prototype._renderForCamera = function (camera) {\n            var engine = this._engine;\n            var startTime = BABYLON.Tools.Now;\n            this.activeCamera = camera;\n            if (!this.activeCamera)\n                throw new Error(\"Active camera not set\");\n            BABYLON.Tools.StartPerformanceCounter(\"Rendering camera \" + this.activeCamera.name);\n            // Viewport\n            engine.setViewport(this.activeCamera.viewport);\n            // Camera\n            this.resetCachedMaterial();\n            this._renderId++;\n            this.updateTransformMatrix();\n            this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);\n            // Meshes\n            this._evaluateActiveMeshesDuration.beginMonitoring();\n            BABYLON.Tools.StartPerformanceCounter(\"Active meshes evaluation\");\n            this._evaluateActiveMeshes();\n            this._evaluateActiveMeshesDuration.endMonitoring(false);\n            BABYLON.Tools.EndPerformanceCounter(\"Active meshes evaluation\");\n            // Software skinning\n            for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n                var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n                mesh.applySkeleton(mesh.skeleton);\n            }\n            // Render targets\n            this._renderTargetsDuration.beginMonitoring();\n            var needsRestoreFrameBuffer = false;\n            var beforeRenderTargetDate = BABYLON.Tools.Now;\n            if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n                this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n            }\n            if (this.renderTargetsEnabled && this._renderTargets.length > 0) {\n                this._intermediateRendering = true;\n                BABYLON.Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n                    var renderTarget = this._renderTargets.data[renderIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n                        renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n                    }\n                }\n                BABYLON.Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n                this._intermediateRendering = false;\n                this._renderId++;\n                needsRestoreFrameBuffer = true; // Restore back buffer\n            }\n            // Render HighlightLayer Texture\n            var stencilState = this._engine.getStencilBuffer();\n            var renderhighlights = false;\n            if (this.renderTargetsEnabled && this.highlightLayers && this.highlightLayers.length > 0) {\n                this._intermediateRendering = true;\n                for (var i = 0; i < this.highlightLayers.length; i++) {\n                    var highlightLayer = this.highlightLayers[i];\n                    if (highlightLayer.shouldRender() &&\n                        (!highlightLayer.camera ||\n                            (highlightLayer.camera.cameraRigMode === BABYLON.Camera.RIG_MODE_NONE && camera === highlightLayer.camera) ||\n                            (highlightLayer.camera.cameraRigMode !== BABYLON.Camera.RIG_MODE_NONE && highlightLayer.camera._rigCameras.indexOf(camera) > -1))) {\n                        renderhighlights = true;\n                        var renderTarget = highlightLayer._mainTexture;\n                        if (renderTarget._shouldRender()) {\n                            this._renderId++;\n                            renderTarget.render(false, false);\n                            needsRestoreFrameBuffer = true;\n                        }\n                    }\n                }\n                this._intermediateRendering = false;\n                this._renderId++;\n            }\n            if (needsRestoreFrameBuffer) {\n                engine.restoreDefaultFramebuffer(); // Restore back buffer\n            }\n            this._renderTargetsDuration.endMonitoring(false);\n            // Prepare Frame\n            this.postProcessManager._prepareFrame();\n            this._renderDuration.beginMonitoring();\n            // Backgrounds\n            var layerIndex;\n            var layer;\n            if (this.layers.length) {\n                engine.setDepthBuffer(false);\n                for (layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n                    layer = this.layers[layerIndex];\n                    if (layer.isBackground && ((layer.layerMask & this.activeCamera.layerMask) !== 0)) {\n                        layer.render();\n                    }\n                }\n                engine.setDepthBuffer(true);\n            }\n            // Render\n            BABYLON.Tools.StartPerformanceCounter(\"Main render\");\n            // Activate HighlightLayer stencil\n            if (renderhighlights) {\n                this._engine.setStencilBuffer(true);\n            }\n            this._renderingManager.render(null, null, true, true);\n            // Restore HighlightLayer stencil\n            if (renderhighlights) {\n                this._engine.setStencilBuffer(stencilState);\n            }\n            BABYLON.Tools.EndPerformanceCounter(\"Main render\");\n            // Bounding boxes\n            if (this._boundingBoxRenderer) {\n                this._boundingBoxRenderer.render();\n            }\n            // Lens flares\n            if (this.lensFlaresEnabled) {\n                BABYLON.Tools.StartPerformanceCounter(\"Lens flares\", this.lensFlareSystems.length > 0);\n                for (var lensFlareSystemIndex = 0; lensFlareSystemIndex < this.lensFlareSystems.length; lensFlareSystemIndex++) {\n                    var lensFlareSystem = this.lensFlareSystems[lensFlareSystemIndex];\n                    if ((camera.layerMask & lensFlareSystem.layerMask) !== 0) {\n                        lensFlareSystem.render();\n                    }\n                }\n                BABYLON.Tools.EndPerformanceCounter(\"Lens flares\", this.lensFlareSystems.length > 0);\n            }\n            // Foregrounds\n            if (this.layers.length) {\n                engine.setDepthBuffer(false);\n                for (layerIndex = 0; layerIndex < this.layers.length; layerIndex++) {\n                    layer = this.layers[layerIndex];\n                    if (!layer.isBackground && ((layer.layerMask & this.activeCamera.layerMask) !== 0)) {\n                        layer.render();\n                    }\n                }\n                engine.setDepthBuffer(true);\n            }\n            // Highlight Layer\n            if (renderhighlights) {\n                engine.setDepthBuffer(false);\n                for (var i = 0; i < this.highlightLayers.length; i++) {\n                    if (this.highlightLayers[i].shouldRender()) {\n                        this.highlightLayers[i].render();\n                    }\n                }\n                engine.setDepthBuffer(true);\n            }\n            this._renderDuration.endMonitoring(false);\n            // Finalize frame\n            this.postProcessManager._finalizeFrame(camera.isIntermediate);\n            // Update camera\n            this.activeCamera._updateFromScene();\n            // Reset some special arrays\n            this._renderTargets.reset();\n            this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n            BABYLON.Tools.EndPerformanceCounter(\"Rendering camera \" + this.activeCamera.name);\n        };\n        Scene.prototype._processSubCameras = function (camera) {\n            if (camera.cameraRigMode === BABYLON.Camera.RIG_MODE_NONE) {\n                this._renderForCamera(camera);\n                return;\n            }\n            // rig cameras\n            for (var index = 0; index < camera._rigCameras.length; index++) {\n                this._renderForCamera(camera._rigCameras[index]);\n            }\n            this.activeCamera = camera;\n            this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix());\n            // Update camera\n            this.activeCamera._updateFromScene();\n        };\n        Scene.prototype._checkIntersections = function () {\n            for (var index = 0; index < this._meshesForIntersections.length; index++) {\n                var sourceMesh = this._meshesForIntersections.data[index];\n                for (var actionIndex = 0; actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n                    var action = sourceMesh.actionManager.actions[actionIndex];\n                    if (action.trigger === BABYLON.ActionManager.OnIntersectionEnterTrigger || action.trigger === BABYLON.ActionManager.OnIntersectionExitTrigger) {\n                        var parameters = action.getTriggerParameter();\n                        var otherMesh = parameters instanceof BABYLON.AbstractMesh ? parameters : parameters.mesh;\n                        var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n                        var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n                        if (areIntersecting && currentIntersectionInProgress === -1) {\n                            if (action.trigger === BABYLON.ActionManager.OnIntersectionEnterTrigger) {\n                                action._executeCurrent(BABYLON.ActionEvent.CreateNew(sourceMesh, null, otherMesh));\n                                sourceMesh._intersectionsInProgress.push(otherMesh);\n                            }\n                            else if (action.trigger === BABYLON.ActionManager.OnIntersectionExitTrigger) {\n                                sourceMesh._intersectionsInProgress.push(otherMesh);\n                            }\n                        }\n                        else if (!areIntersecting && currentIntersectionInProgress > -1) {\n                            //They intersected, and now they don't.\n                            //is this trigger an exit trigger? execute an event.\n                            if (action.trigger === BABYLON.ActionManager.OnIntersectionExitTrigger) {\n                                action._executeCurrent(BABYLON.ActionEvent.CreateNew(sourceMesh, null, otherMesh));\n                            }\n                            //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n                            if (!sourceMesh.actionManager.hasSpecificTrigger(BABYLON.ActionManager.OnIntersectionExitTrigger) || action.trigger === BABYLON.ActionManager.OnIntersectionExitTrigger) {\n                                sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        Scene.prototype.render = function () {\n            if (this.isDisposed) {\n                return;\n            }\n            this._lastFrameDuration.beginMonitoring();\n            this._particlesDuration.fetchNewFrame();\n            this._spritesDuration.fetchNewFrame();\n            this._activeParticles.fetchNewFrame();\n            this._renderDuration.fetchNewFrame();\n            this._renderTargetsDuration.fetchNewFrame();\n            this._evaluateActiveMeshesDuration.fetchNewFrame();\n            this._totalVertices.fetchNewFrame();\n            this._activeIndices.fetchNewFrame();\n            this._activeBones.fetchNewFrame();\n            this.getEngine().drawCallsPerfCounter.fetchNewFrame();\n            this._meshesForIntersections.reset();\n            this.resetCachedMaterial();\n            BABYLON.Tools.StartPerformanceCounter(\"Scene rendering\");\n            // Actions\n            if (this.actionManager) {\n                this.actionManager.processTrigger(BABYLON.ActionManager.OnEveryFrameTrigger, null);\n            }\n            //Simplification Queue\n            if (this.simplificationQueue && !this.simplificationQueue.running) {\n                this.simplificationQueue.executeNext();\n            }\n            // Animations\n            var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n            this._animationRatio = deltaTime * (60.0 / 1000.0);\n            this._animate();\n            // Physics\n            if (this._physicsEngine) {\n                BABYLON.Tools.StartPerformanceCounter(\"Physics\");\n                this._physicsEngine._step(deltaTime / 1000.0);\n                BABYLON.Tools.EndPerformanceCounter(\"Physics\");\n            }\n            // Before render\n            this.onBeforeRenderObservable.notifyObservers(this);\n            // Customs render targets\n            this._renderTargetsDuration.beginMonitoring();\n            var beforeRenderTargetDate = BABYLON.Tools.Now;\n            var engine = this.getEngine();\n            var currentActiveCamera = this.activeCamera;\n            if (this.renderTargetsEnabled) {\n                BABYLON.Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n                for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n                    var renderTarget = this.customRenderTargets[customIndex];\n                    if (renderTarget._shouldRender()) {\n                        this._renderId++;\n                        this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n                        if (!this.activeCamera)\n                            throw new Error(\"Active camera not set\");\n                        // Viewport\n                        engine.setViewport(this.activeCamera.viewport);\n                        // Camera\n                        this.updateTransformMatrix();\n                        renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n                    }\n                }\n                BABYLON.Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n                this._renderId++;\n            }\n            // Restore back buffer\n            if (this.customRenderTargets.length > 0) {\n                engine.restoreDefaultFramebuffer();\n            }\n            this._renderTargetsDuration.endMonitoring();\n            this.activeCamera = currentActiveCamera;\n            // Procedural textures\n            if (this.proceduralTexturesEnabled) {\n                BABYLON.Tools.StartPerformanceCounter(\"Procedural textures\", this._proceduralTextures.length > 0);\n                for (var proceduralIndex = 0; proceduralIndex < this._proceduralTextures.length; proceduralIndex++) {\n                    var proceduralTexture = this._proceduralTextures[proceduralIndex];\n                    if (proceduralTexture._shouldRender()) {\n                        proceduralTexture.render();\n                    }\n                }\n                BABYLON.Tools.EndPerformanceCounter(\"Procedural textures\", this._proceduralTextures.length > 0);\n            }\n            // Clear\n            if (this.autoClearDepthAndStencil || this.autoClear) {\n                this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n            }\n            // Shadows\n            if (this.shadowsEnabled) {\n                for (var lightIndex = 0; lightIndex < this.lights.length; lightIndex++) {\n                    var light = this.lights[lightIndex];\n                    var shadowGenerator = light.getShadowGenerator();\n                    if (light.isEnabled() && light.shadowEnabled && shadowGenerator) {\n                        var shadowMap = shadowGenerator.getShadowMap();\n                        if (shadowMap.getScene().textures.indexOf(shadowMap) !== -1) {\n                            this._renderTargets.push(shadowMap);\n                        }\n                    }\n                }\n            }\n            // Depth renderer\n            if (this._depthRenderer) {\n                this._renderTargets.push(this._depthRenderer.getDepthMap());\n            }\n            // Geometry renderer\n            if (this._geometryBufferRenderer) {\n                this._renderTargets.push(this._geometryBufferRenderer.getGBuffer());\n            }\n            // RenderPipeline\n            if (this._postProcessRenderPipelineManager) {\n                this._postProcessRenderPipelineManager.update();\n            }\n            // Multi-cameras?\n            if (this.activeCameras.length > 0) {\n                for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n                    if (cameraIndex > 0) {\n                        this._engine.clear(null, false, true, true);\n                    }\n                    this._processSubCameras(this.activeCameras[cameraIndex]);\n                }\n            }\n            else {\n                if (!this.activeCamera) {\n                    throw new Error(\"No camera defined\");\n                }\n                this._processSubCameras(this.activeCamera);\n            }\n            // Intersection checks\n            this._checkIntersections();\n            // Update the audio listener attached to the camera\n            if (BABYLON.AudioEngine) {\n                this._updateAudioParameters();\n            }\n            // After render\n            if (this.afterRender) {\n                this.afterRender();\n            }\n            this.onAfterRenderObservable.notifyObservers(this);\n            // Cleaning\n            for (var index = 0; index < this._toBeDisposed.length; index++) {\n                this._toBeDisposed.data[index].dispose();\n                this._toBeDisposed[index] = null;\n            }\n            this._toBeDisposed.reset();\n            if (this.dumpNextRenderTargets) {\n                this.dumpNextRenderTargets = false;\n            }\n            BABYLON.Tools.EndPerformanceCounter(\"Scene rendering\");\n            this._lastFrameDuration.endMonitoring();\n            this._totalMeshesCounter.addCount(this.meshes.length, true);\n            this._totalLightsCounter.addCount(this.lights.length, true);\n            this._totalMaterialsCounter.addCount(this.materials.length, true);\n            this._totalTexturesCounter.addCount(this.textures.length, true);\n            this._activeBones.addCount(0, true);\n            this._activeIndices.addCount(0, true);\n            this._activeParticles.addCount(0, true);\n        };\n        Scene.prototype._updateAudioParameters = function () {\n            if (!this.audioEnabled || (this.mainSoundTrack.soundCollection.length === 0 && this.soundTracks.length === 1)) {\n                return;\n            }\n            var listeningCamera;\n            var audioEngine = BABYLON.Engine.audioEngine;\n            if (this.activeCameras.length > 0) {\n                listeningCamera = this.activeCameras[0];\n            }\n            else {\n                listeningCamera = this.activeCamera;\n            }\n            if (listeningCamera && audioEngine.canUseWebAudio) {\n                audioEngine.audioContext.listener.setPosition(listeningCamera.position.x, listeningCamera.position.y, listeningCamera.position.z);\n                // for VR cameras\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\n                    listeningCamera = listeningCamera.rigCameras[0];\n                }\n                var mat = BABYLON.Matrix.Invert(listeningCamera.getViewMatrix());\n                var cameraDirection = BABYLON.Vector3.TransformNormal(new BABYLON.Vector3(0, 0, -1), mat);\n                cameraDirection.normalize();\n                audioEngine.audioContext.listener.setOrientation(cameraDirection.x, cameraDirection.y, cameraDirection.z, 0, 1, 0);\n                var i;\n                for (i = 0; i < this.mainSoundTrack.soundCollection.length; i++) {\n                    var sound = this.mainSoundTrack.soundCollection[i];\n                    if (sound.useCustomAttenuation) {\n                        sound.updateDistanceFromListener();\n                    }\n                }\n                for (i = 0; i < this.soundTracks.length; i++) {\n                    for (var j = 0; j < this.soundTracks[i].soundCollection.length; j++) {\n                        sound = this.soundTracks[i].soundCollection[j];\n                        if (sound.useCustomAttenuation) {\n                            sound.updateDistanceFromListener();\n                        }\n                    }\n                }\n            }\n        };\n        Object.defineProperty(Scene.prototype, \"audioEnabled\", {\n            // Audio\n            get: function () {\n                return this._audioEnabled;\n            },\n            set: function (value) {\n                this._audioEnabled = value;\n                if (BABYLON.AudioEngine) {\n                    if (this._audioEnabled) {\n                        this._enableAudio();\n                    }\n                    else {\n                        this._disableAudio();\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype._disableAudio = function () {\n            var i;\n            for (i = 0; i < this.mainSoundTrack.soundCollection.length; i++) {\n                this.mainSoundTrack.soundCollection[i].pause();\n            }\n            for (i = 0; i < this.soundTracks.length; i++) {\n                for (var j = 0; j < this.soundTracks[i].soundCollection.length; j++) {\n                    this.soundTracks[i].soundCollection[j].pause();\n                }\n            }\n        };\n        Scene.prototype._enableAudio = function () {\n            var i;\n            for (i = 0; i < this.mainSoundTrack.soundCollection.length; i++) {\n                if (this.mainSoundTrack.soundCollection[i].isPaused) {\n                    this.mainSoundTrack.soundCollection[i].play();\n                }\n            }\n            for (i = 0; i < this.soundTracks.length; i++) {\n                for (var j = 0; j < this.soundTracks[i].soundCollection.length; j++) {\n                    if (this.soundTracks[i].soundCollection[j].isPaused) {\n                        this.soundTracks[i].soundCollection[j].play();\n                    }\n                }\n            }\n        };\n        Object.defineProperty(Scene.prototype, \"headphone\", {\n            get: function () {\n                return this._headphone;\n            },\n            set: function (value) {\n                this._headphone = value;\n                if (BABYLON.AudioEngine) {\n                    if (this._headphone) {\n                        this._switchAudioModeForHeadphones();\n                    }\n                    else {\n                        this._switchAudioModeForNormalSpeakers();\n                    }\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Scene.prototype._switchAudioModeForHeadphones = function () {\n            this.mainSoundTrack.switchPanningModelToHRTF();\n            for (var i = 0; i < this.soundTracks.length; i++) {\n                this.soundTracks[i].switchPanningModelToHRTF();\n            }\n        };\n        Scene.prototype._switchAudioModeForNormalSpeakers = function () {\n            this.mainSoundTrack.switchPanningModelToEqualPower();\n            for (var i = 0; i < this.soundTracks.length; i++) {\n                this.soundTracks[i].switchPanningModelToEqualPower();\n            }\n        };\n        Scene.prototype.enableDepthRenderer = function () {\n            if (this._depthRenderer) {\n                return this._depthRenderer;\n            }\n            this._depthRenderer = new BABYLON.DepthRenderer(this);\n            return this._depthRenderer;\n        };\n        Scene.prototype.disableDepthRenderer = function () {\n            if (!this._depthRenderer) {\n                return;\n            }\n            this._depthRenderer.dispose();\n            this._depthRenderer = null;\n        };\n        Scene.prototype.enableGeometryBufferRenderer = function (ratio) {\n            if (ratio === void 0) { ratio = 1; }\n            if (this._geometryBufferRenderer) {\n                return this._geometryBufferRenderer;\n            }\n            this._geometryBufferRenderer = new BABYLON.GeometryBufferRenderer(this, ratio);\n            if (!this._geometryBufferRenderer.isSupported) {\n                this._geometryBufferRenderer = null;\n            }\n            return this._geometryBufferRenderer;\n        };\n        Scene.prototype.disableGeometryBufferRenderer = function () {\n            if (!this._geometryBufferRenderer) {\n                return;\n            }\n            this._geometryBufferRenderer.dispose();\n            this._geometryBufferRenderer = null;\n        };\n        Scene.prototype.freezeMaterials = function () {\n            for (var i = 0; i < this.materials.length; i++) {\n                this.materials[i].freeze();\n            }\n        };\n        Scene.prototype.unfreezeMaterials = function () {\n            for (var i = 0; i < this.materials.length; i++) {\n                this.materials[i].unfreeze();\n            }\n        };\n        Scene.prototype.dispose = function () {\n            this.beforeRender = null;\n            this.afterRender = null;\n            this.skeletons = [];\n            this.morphTargetManagers = [];\n            this.importedMeshesFiles = new Array();\n            if (this._depthRenderer) {\n                this._depthRenderer.dispose();\n            }\n            // Smart arrays            \n            if (this.activeCamera) {\n                this.activeCamera._activeMeshes.dispose();\n                this.activeCamera = null;\n            }\n            this._activeMeshes.dispose();\n            this._renderingManager.dispose();\n            this._processedMaterials.dispose();\n            this._activeParticleSystems.dispose();\n            this._activeSkeletons.dispose();\n            this._softwareSkinnedMeshes.dispose();\n            if (this._boundingBoxRenderer) {\n                this._boundingBoxRenderer.dispose();\n            }\n            this._meshesForIntersections.dispose();\n            this._toBeDisposed.dispose();\n            // Debug layer\n            if (this._debugLayer) {\n                this._debugLayer.hide();\n            }\n            // Events\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n            this.onBeforeRenderObservable.clear();\n            this.onAfterRenderObservable.clear();\n            this.detachControl();\n            // Release sounds & sounds tracks\n            if (BABYLON.AudioEngine) {\n                this.disposeSounds();\n            }\n            // Detach cameras\n            var canvas = this._engine.getRenderingCanvas();\n            var index;\n            for (index = 0; index < this.cameras.length; index++) {\n                this.cameras[index].detachControl(canvas);\n            }\n            // Release lights\n            while (this.lights.length) {\n                this.lights[0].dispose();\n            }\n            // Release meshes\n            while (this.meshes.length) {\n                this.meshes[0].dispose(true);\n            }\n            // Release cameras\n            while (this.cameras.length) {\n                this.cameras[0].dispose();\n            }\n            // Release materials\n            while (this.materials.length) {\n                this.materials[0].dispose();\n            }\n            // Release particles\n            while (this.particleSystems.length) {\n                this.particleSystems[0].dispose();\n            }\n            // Release sprites\n            while (this.spriteManagers.length) {\n                this.spriteManagers[0].dispose();\n            }\n            // Release layers\n            while (this.layers.length) {\n                this.layers[0].dispose();\n            }\n            while (this.highlightLayers.length) {\n                this.highlightLayers[0].dispose();\n            }\n            // Release textures\n            while (this.textures.length) {\n                this.textures[0].dispose();\n            }\n            // Release UBO\n            this._sceneUbo.dispose();\n            // Post-processes\n            this.postProcessManager.dispose();\n            // Physics\n            if (this._physicsEngine) {\n                this.disablePhysicsEngine();\n            }\n            // Remove from engine\n            index = this._engine.scenes.indexOf(this);\n            if (index > -1) {\n                this._engine.scenes.splice(index, 1);\n            }\n            this._engine.wipeCaches();\n            this._engine = null;\n        };\n        Object.defineProperty(Scene.prototype, \"isDisposed\", {\n            get: function () {\n                return !this._engine;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Release sounds & sounds tracks\n        Scene.prototype.disposeSounds = function () {\n            this.mainSoundTrack.dispose();\n            for (var scIndex = 0; scIndex < this.soundTracks.length; scIndex++) {\n                this.soundTracks[scIndex].dispose();\n            }\n        };\n        // Octrees\n        Scene.prototype.getWorldExtends = function () {\n            var min = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            var max = new BABYLON.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n            for (var index = 0; index < this.meshes.length; index++) {\n                var mesh = this.meshes[index];\n                mesh.computeWorldMatrix(true);\n                var minBox = mesh.getBoundingInfo().boundingBox.minimumWorld;\n                var maxBox = mesh.getBoundingInfo().boundingBox.maximumWorld;\n                BABYLON.Tools.CheckExtends(minBox, min, max);\n                BABYLON.Tools.CheckExtends(maxBox, min, max);\n            }\n            return {\n                min: min,\n                max: max\n            };\n        };\n        Scene.prototype.createOrUpdateSelectionOctree = function (maxCapacity, maxDepth) {\n            if (maxCapacity === void 0) { maxCapacity = 64; }\n            if (maxDepth === void 0) { maxDepth = 2; }\n            if (!this._selectionOctree) {\n                this._selectionOctree = new BABYLON.Octree(BABYLON.Octree.CreationFuncForMeshes, maxCapacity, maxDepth);\n            }\n            var worldExtends = this.getWorldExtends();\n            // Update octree\n            this._selectionOctree.update(worldExtends.min, worldExtends.max, this.meshes);\n            return this._selectionOctree;\n        };\n        // Picking\n        Scene.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace) {\n            if (cameraViewSpace === void 0) { cameraViewSpace = false; }\n            var engine = this._engine;\n            if (!camera) {\n                if (!this.activeCamera)\n                    throw new Error(\"Active camera not set\");\n                camera = this.activeCamera;\n            }\n            var cameraViewport = camera.viewport;\n            var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n            // Moving coordinates to local viewport world\n            x = x / this._engine.getHardwareScalingLevel() - viewport.x;\n            y = y / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - viewport.y - viewport.height);\n            return BABYLON.Ray.CreateNew(x, y, viewport.width, viewport.height, world ? world : BABYLON.Matrix.Identity(), cameraViewSpace ? BABYLON.Matrix.Identity() : camera.getViewMatrix(), camera.getProjectionMatrix());\n            //       return BABYLON.Ray.CreateNew(x / window.devicePixelRatio, y / window.devicePixelRatio, viewport.width, viewport.height, world ? world : BABYLON.Matrix.Identity(), camera.getViewMatrix(), camera.getProjectionMatrix());\n        };\n        Scene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n            if (!BABYLON.PickingInfo) {\n                return null;\n            }\n            var engine = this._engine;\n            if (!camera) {\n                if (!this.activeCamera)\n                    throw new Error(\"Active camera not set\");\n                camera = this.activeCamera;\n            }\n            var cameraViewport = camera.viewport;\n            var viewport = cameraViewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n            var identity = BABYLON.Matrix.Identity();\n            // Moving coordinates to local viewport world\n            x = x / this._engine.getHardwareScalingLevel() - viewport.x;\n            y = y / this._engine.getHardwareScalingLevel() - (this._engine.getRenderHeight() - viewport.y - viewport.height);\n            return BABYLON.Ray.CreateNew(x, y, viewport.width, viewport.height, identity, identity, camera.getProjectionMatrix());\n        };\n        Scene.prototype._internalPick = function (rayFunction, predicate, fastCheck) {\n            if (!BABYLON.PickingInfo) {\n                return null;\n            }\n            var pickingInfo = null;\n            for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n                var mesh = this.meshes[meshIndex];\n                if (predicate) {\n                    if (!predicate(mesh)) {\n                        continue;\n                    }\n                }\n                else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n                    continue;\n                }\n                var world = mesh.getWorldMatrix();\n                var ray = rayFunction(world);\n                var result = mesh.intersects(ray, fastCheck);\n                if (!result || !result.hit)\n                    continue;\n                if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance)\n                    continue;\n                pickingInfo = result;\n                if (fastCheck) {\n                    break;\n                }\n            }\n            return pickingInfo || new BABYLON.PickingInfo();\n        };\n        Scene.prototype._internalMultiPick = function (rayFunction, predicate) {\n            if (!BABYLON.PickingInfo) {\n                return null;\n            }\n            var pickingInfos = new Array();\n            for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n                var mesh = this.meshes[meshIndex];\n                if (predicate) {\n                    if (!predicate(mesh)) {\n                        continue;\n                    }\n                }\n                else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n                    continue;\n                }\n                var world = mesh.getWorldMatrix();\n                var ray = rayFunction(world);\n                var result = mesh.intersects(ray, false);\n                if (!result || !result.hit)\n                    continue;\n                pickingInfos.push(result);\n            }\n            return pickingInfos;\n        };\n        Scene.prototype._internalPickSprites = function (ray, predicate, fastCheck, camera) {\n            if (!BABYLON.PickingInfo) {\n                return null;\n            }\n            var pickingInfo = null;\n            camera = camera || this.activeCamera;\n            if (this.spriteManagers.length > 0) {\n                for (var spriteIndex = 0; spriteIndex < this.spriteManagers.length; spriteIndex++) {\n                    var spriteManager = this.spriteManagers[spriteIndex];\n                    if (!spriteManager.isPickable) {\n                        continue;\n                    }\n                    var result = spriteManager.intersects(ray, camera, predicate, fastCheck);\n                    if (!result || !result.hit)\n                        continue;\n                    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance)\n                        continue;\n                    pickingInfo = result;\n                    if (fastCheck) {\n                        break;\n                    }\n                }\n            }\n            return pickingInfo || new BABYLON.PickingInfo();\n        };\n        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>\n        /// <param name=\"x\">X position on screen</param>\n        /// <param name=\"y\">Y position on screen</param>\n        /// <param name=\"predicate\">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>\n        /// <param name=\"fastCheck\">Launch a fast check only using the bounding boxes. Can be set to null.</param>\n        /// <param name=\"camera\">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>\n        Scene.prototype.pick = function (x, y, predicate, fastCheck, camera) {\n            var _this = this;\n            return this._internalPick(function (world) { return _this.createPickingRay(x, y, world, camera); }, predicate, fastCheck);\n        };\n        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>\n        /// <param name=\"x\">X position on screen</param>\n        /// <param name=\"y\">Y position on screen</param>\n        /// <param name=\"predicate\">Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true</param>\n        /// <param name=\"fastCheck\">Launch a fast check only using the bounding boxes. Can be set to null.</param>\n        /// <param name=\"camera\">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>\n        Scene.prototype.pickSprite = function (x, y, predicate, fastCheck, camera) {\n            return this._internalPickSprites(this.createPickingRayInCameraSpace(x, y, camera), predicate, fastCheck, camera);\n        };\n        Scene.prototype.pickWithRay = function (ray, predicate, fastCheck) {\n            var _this = this;\n            return this._internalPick(function (world) {\n                if (!_this._pickWithRayInverseMatrix) {\n                    _this._pickWithRayInverseMatrix = BABYLON.Matrix.Identity();\n                }\n                world.invertToRef(_this._pickWithRayInverseMatrix);\n                return BABYLON.Ray.Transform(ray, _this._pickWithRayInverseMatrix);\n            }, predicate, fastCheck);\n        };\n        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>\n        /// <param name=\"x\">X position on screen</param>\n        /// <param name=\"y\">Y position on screen</param>\n        /// <param name=\"predicate\">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>\n        /// <param name=\"camera\">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>\n        Scene.prototype.multiPick = function (x, y, predicate, camera) {\n            var _this = this;\n            return this._internalMultiPick(function (world) { return _this.createPickingRay(x, y, world, camera); }, predicate);\n        };\n        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>\n        /// <param name=\"ray\">Ray to use</param>\n        /// <param name=\"predicate\">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>\n        Scene.prototype.multiPickWithRay = function (ray, predicate) {\n            var _this = this;\n            return this._internalMultiPick(function (world) {\n                if (!_this._pickWithRayInverseMatrix) {\n                    _this._pickWithRayInverseMatrix = BABYLON.Matrix.Identity();\n                }\n                world.invertToRef(_this._pickWithRayInverseMatrix);\n                return BABYLON.Ray.Transform(ray, _this._pickWithRayInverseMatrix);\n            }, predicate);\n        };\n        Scene.prototype.setPointerOverMesh = function (mesh) {\n            if (this._pointerOverMesh === mesh) {\n                return;\n            }\n            if (this._pointerOverMesh && this._pointerOverMesh.actionManager) {\n                this._pointerOverMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPointerOutTrigger, BABYLON.ActionEvent.CreateNew(this._pointerOverMesh));\n            }\n            this._pointerOverMesh = mesh;\n            if (this._pointerOverMesh && this._pointerOverMesh.actionManager) {\n                this._pointerOverMesh.actionManager.processTrigger(BABYLON.ActionManager.OnPointerOverTrigger, BABYLON.ActionEvent.CreateNew(this._pointerOverMesh));\n            }\n        };\n        Scene.prototype.getPointerOverMesh = function () {\n            return this._pointerOverMesh;\n        };\n        Scene.prototype.setPointerOverSprite = function (sprite) {\n            if (this._pointerOverSprite === sprite) {\n                return;\n            }\n            if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n                this._pointerOverSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPointerOutTrigger, BABYLON.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n            }\n            this._pointerOverSprite = sprite;\n            if (this._pointerOverSprite && this._pointerOverSprite.actionManager) {\n                this._pointerOverSprite.actionManager.processTrigger(BABYLON.ActionManager.OnPointerOverTrigger, BABYLON.ActionEvent.CreateNewFromSprite(this._pointerOverSprite, this));\n            }\n        };\n        Scene.prototype.getPointerOverSprite = function () {\n            return this._pointerOverSprite;\n        };\n        // Physics\n        Scene.prototype.getPhysicsEngine = function () {\n            return this._physicsEngine;\n        };\n        /**\n         * Enables physics to the current scene\n         * @param {BABYLON.Vector3} [gravity] - the scene's gravity for the physics engine\n         * @param {BABYLON.IPhysicsEnginePlugin} [plugin] - The physics engine to be used. defaults to OimoJS.\n         * @return {boolean} was the physics engine initialized\n         */\n        Scene.prototype.enablePhysics = function (gravity, plugin) {\n            if (this._physicsEngine) {\n                return true;\n            }\n            try {\n                this._physicsEngine = new BABYLON.PhysicsEngine(gravity, plugin);\n                return true;\n            }\n            catch (e) {\n                BABYLON.Tools.Error(e.message);\n                return false;\n            }\n        };\n        Scene.prototype.disablePhysicsEngine = function () {\n            if (!this._physicsEngine) {\n                return;\n            }\n            this._physicsEngine.dispose();\n            this._physicsEngine = undefined;\n        };\n        Scene.prototype.isPhysicsEnabled = function () {\n            return this._physicsEngine !== undefined;\n        };\n        Scene.prototype.deleteCompoundImpostor = function (compound) {\n            var mesh = compound.parts[0].mesh;\n            mesh.physicsImpostor.dispose();\n            mesh.physicsImpostor = null;\n        };\n        // Misc.\n        Scene.prototype.createDefaultCameraOrLight = function (createArcRotateCamera, replace, attachCameraControls) {\n            if (createArcRotateCamera === void 0) { createArcRotateCamera = false; }\n            if (replace === void 0) { replace = false; }\n            if (attachCameraControls === void 0) { attachCameraControls = false; }\n            // Dispose existing camera or light in replace mode.\n            if (replace) {\n                if (this.activeCamera) {\n                    this.activeCamera.dispose();\n                    this.activeCamera = null;\n                }\n                if (this.lights) {\n                    for (var i = 0; i < this.lights.length; i++) {\n                        this.lights[i].dispose();\n                    }\n                }\n            }\n            // Light\n            if (this.lights.length === 0) {\n                new BABYLON.HemisphericLight(\"default light\", BABYLON.Vector3.Up(), this);\n            }\n            // Camera\n            if (!this.activeCamera) {\n                var worldExtends = this.getWorldExtends();\n                var worldSize = worldExtends.max.subtract(worldExtends.min);\n                var worldCenter = worldExtends.min.add(worldSize.scale(0.5));\n                var camera;\n                var radius = worldSize.length() * 1.5;\n                if (createArcRotateCamera) {\n                    var arcRotateCamera = new BABYLON.ArcRotateCamera(\"default camera\", 4.712, 1.571, radius, worldCenter, this);\n                    arcRotateCamera.lowerRadiusLimit = radius * 0.01;\n                    arcRotateCamera.wheelPrecision = 100 / radius;\n                    camera = arcRotateCamera;\n                }\n                else {\n                    var freeCamera = new BABYLON.FreeCamera(\"default camera\", new BABYLON.Vector3(worldCenter.x, worldCenter.y, this.useRightHandedSystem ? -radius : radius), this);\n                    freeCamera.setTarget(worldCenter);\n                    camera = freeCamera;\n                }\n                camera.minZ = radius * 0.01;\n                camera.maxZ = radius * 100;\n                camera.speed = radius * 0.2;\n                this.activeCamera = camera;\n                if (attachCameraControls) {\n                    camera.attachControl(this.getEngine().getRenderingCanvas());\n                }\n            }\n        };\n        Scene.prototype.createDefaultSkybox = function (environmentTexture, pbr, scale, blur) {\n            if (pbr === void 0) { pbr = false; }\n            if (scale === void 0) { scale = 1000; }\n            if (blur === void 0) { blur = 0; }\n            if (environmentTexture) {\n                this.environmentTexture = environmentTexture;\n            }\n            if (!this.environmentTexture) {\n                BABYLON.Tools.Warn(\"Can not create default skybox without environment texture.\");\n                return;\n            }\n            // Skybox\n            var hdrSkybox = BABYLON.Mesh.CreateBox(\"hdrSkyBox\", scale, this);\n            if (pbr) {\n                var hdrSkyboxMaterial = new BABYLON.PBRMaterial(\"skyBox\", this);\n                hdrSkyboxMaterial.backFaceCulling = false;\n                hdrSkyboxMaterial.reflectionTexture = environmentTexture.clone();\n                hdrSkyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n                hdrSkyboxMaterial.microSurface = 1.0 - blur;\n                hdrSkyboxMaterial.disableLighting = true;\n                hdrSkyboxMaterial.twoSidedLighting = true;\n                hdrSkybox.infiniteDistance = true;\n                hdrSkybox.material = hdrSkyboxMaterial;\n            }\n            else {\n                var skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", this);\n                skyboxMaterial.backFaceCulling = false;\n                skyboxMaterial.reflectionTexture = environmentTexture.clone();\n                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n                skyboxMaterial.disableLighting = true;\n                hdrSkybox.infiniteDistance = true;\n                hdrSkybox.material = skyboxMaterial;\n            }\n            return hdrSkybox;\n        };\n        // Tags\n        Scene.prototype._getByTags = function (list, tagsQuery, forEach) {\n            if (tagsQuery === undefined) {\n                // returns the complete list (could be done with BABYLON.Tags.MatchesQuery but no need to have a for-loop here)\n                return list;\n            }\n            var listByTags = [];\n            forEach = forEach || (function (item) { return; });\n            for (var i in list) {\n                var item = list[i];\n                if (BABYLON.Tags.MatchesQuery(item, tagsQuery)) {\n                    listByTags.push(item);\n                    forEach(item);\n                }\n            }\n            return listByTags;\n        };\n        Scene.prototype.getMeshesByTags = function (tagsQuery, forEach) {\n            return this._getByTags(this.meshes, tagsQuery, forEach);\n        };\n        Scene.prototype.getCamerasByTags = function (tagsQuery, forEach) {\n            return this._getByTags(this.cameras, tagsQuery, forEach);\n        };\n        Scene.prototype.getLightsByTags = function (tagsQuery, forEach) {\n            return this._getByTags(this.lights, tagsQuery, forEach);\n        };\n        Scene.prototype.getMaterialByTags = function (tagsQuery, forEach) {\n            return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n        };\n        /**\n         * Overrides the default sort function applied in the renderging group to prepare the meshes.\n         * This allowed control for front to back rendering or reversly depending of the special needs.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n         * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n         */\n        Scene.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n            if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n            if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n            if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n            this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n        };\n        /**\n         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n         * @param depth Automatically clears depth between groups if true and autoClear is true.\n         * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n         */\n        Scene.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil, depth, stencil) {\n            if (depth === void 0) { depth = true; }\n            if (stencil === void 0) { stencil = true; }\n            this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n        };\n        /**\n         * Will flag all materials as dirty to trigger new shader compilation\n         * @param predicate If not null, it will be used to specifiy if a material has to be marked as dirty\n         */\n        Scene.prototype.markAllMaterialsAsDirty = function (flag, predicate) {\n            for (var _i = 0, _a = this.materials; _i < _a.length; _i++) {\n                var material = _a[_i];\n                if (predicate && !predicate(material)) {\n                    continue;\n                }\n                material.markAsDirty(flag);\n            }\n        };\n        return Scene;\n    }());\n    // Statics\n    Scene._FOGMODE_NONE = 0;\n    Scene._FOGMODE_EXP = 1;\n    Scene._FOGMODE_EXP2 = 2;\n    Scene._FOGMODE_LINEAR = 3;\n    Scene.MinDeltaTime = 1.0;\n    Scene.MaxDeltaTime = 1000.0;\n    Scene.DragMovementThreshold = 10; // in pixels\n    Scene.LongPressDelay = 500; // in milliseconds\n    Scene.DoubleClickDelay = 300; // in milliseconds\n    Scene.ExclusiveDoubleClickMode = false; // If you need to check double click without raising a single click at first click, enable this flag\n    BABYLON.Scene = Scene;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.scene.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Buffer = (function () {\n        function Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced) {\n            if (engine instanceof BABYLON.Mesh) {\n                this._engine = engine.getScene().getEngine();\n            }\n            else {\n                this._engine = engine;\n            }\n            this._updatable = updatable;\n            this._data = data;\n            this._strideSize = stride;\n            if (!postponeInternalCreation) {\n                this.create();\n            }\n            this._instanced = instanced;\n            this._instanceDivisor = instanced ? 1 : 0;\n        }\n        Buffer.prototype.createVertexBuffer = function (kind, offset, size, stride) {\n            // a lot of these parameters are ignored as they are overriden by the buffer\n            return new BABYLON.VertexBuffer(this._engine, this, kind, this._updatable, true, stride ? stride : this._strideSize, this._instanced, offset, size);\n        };\n        // Properties\n        Buffer.prototype.isUpdatable = function () {\n            return this._updatable;\n        };\n        Buffer.prototype.getData = function () {\n            return this._data;\n        };\n        Buffer.prototype.getBuffer = function () {\n            return this._buffer;\n        };\n        Buffer.prototype.getStrideSize = function () {\n            return this._strideSize;\n        };\n        Buffer.prototype.getIsInstanced = function () {\n            return this._instanced;\n        };\n        Object.defineProperty(Buffer.prototype, \"instanceDivisor\", {\n            get: function () {\n                return this._instanceDivisor;\n            },\n            set: function (value) {\n                this._instanceDivisor = value;\n                if (value == 0) {\n                    this._instanced = false;\n                }\n                else {\n                    this._instanced = true;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        Buffer.prototype.create = function (data) {\n            if (!data && this._buffer) {\n                return; // nothing to do\n            }\n            data = data || this._data;\n            if (!this._buffer) {\n                if (this._updatable) {\n                    this._buffer = this._engine.createDynamicVertexBuffer(data);\n                    this._data = data;\n                }\n                else {\n                    this._buffer = this._engine.createVertexBuffer(data);\n                }\n            }\n            else if (this._updatable) {\n                this._engine.updateDynamicVertexBuffer(this._buffer, data);\n                this._data = data;\n            }\n        };\n        Buffer.prototype.update = function (data) {\n            this.create(data);\n        };\n        Buffer.prototype.updateDirectly = function (data, offset, vertexCount) {\n            if (!this._buffer) {\n                return;\n            }\n            if (this._updatable) {\n                this._engine.updateDynamicVertexBuffer(this._buffer, data, offset, (vertexCount ? vertexCount * this.getStrideSize() : undefined));\n                this._data = null;\n            }\n        };\n        Buffer.prototype.dispose = function () {\n            if (!this._buffer) {\n                return;\n            }\n            if (this._engine._releaseBuffer(this._buffer)) {\n                this._buffer = null;\n            }\n        };\n        return Buffer;\n    }());\n    BABYLON.Buffer = Buffer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.buffer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var VertexBuffer = (function () {\n        function VertexBuffer(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size) {\n            if (!stride) {\n                // Deduce stride from kind\n                switch (kind) {\n                    case VertexBuffer.PositionKind:\n                        stride = 3;\n                        break;\n                    case VertexBuffer.NormalKind:\n                        stride = 3;\n                        break;\n                    case VertexBuffer.UVKind:\n                    case VertexBuffer.UV2Kind:\n                    case VertexBuffer.UV3Kind:\n                    case VertexBuffer.UV4Kind:\n                    case VertexBuffer.UV5Kind:\n                    case VertexBuffer.UV6Kind:\n                        stride = 2;\n                        break;\n                    case VertexBuffer.TangentKind:\n                    case VertexBuffer.ColorKind:\n                        stride = 4;\n                        break;\n                    case VertexBuffer.MatricesIndicesKind:\n                    case VertexBuffer.MatricesIndicesExtraKind:\n                        stride = 4;\n                        break;\n                    case VertexBuffer.MatricesWeightsKind:\n                    case VertexBuffer.MatricesWeightsExtraKind:\n                        stride = 4;\n                        break;\n                }\n            }\n            if (data instanceof BABYLON.Buffer) {\n                if (!stride) {\n                    stride = data.getStrideSize();\n                }\n                this._buffer = data;\n                this._ownsBuffer = false;\n            }\n            else {\n                this._buffer = new BABYLON.Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced);\n                this._ownsBuffer = true;\n            }\n            this._stride = stride;\n            this._offset = offset ? offset : 0;\n            this._size = size ? size : stride;\n            this._kind = kind;\n        }\n        /**\n         * Returns the kind of the VertexBuffer (string).\n         */\n        VertexBuffer.prototype.getKind = function () {\n            return this._kind;\n        };\n        // Properties\n        /**\n         * Boolean : is the VertexBuffer updatable ?\n         */\n        VertexBuffer.prototype.isUpdatable = function () {\n            return this._buffer.isUpdatable();\n        };\n        /**\n         * Returns an array of numbers or a Float32Array containing the VertexBuffer data.\n         */\n        VertexBuffer.prototype.getData = function () {\n            return this._buffer.getData();\n        };\n        /**\n         * Returns the WebGLBuffer associated to the VertexBuffer.\n         */\n        VertexBuffer.prototype.getBuffer = function () {\n            return this._buffer.getBuffer();\n        };\n        /**\n         * Returns the stride of the VertexBuffer (integer).\n         */\n        VertexBuffer.prototype.getStrideSize = function () {\n            return this._stride;\n        };\n        /**\n         * Returns the offset (integer).\n         */\n        VertexBuffer.prototype.getOffset = function () {\n            return this._offset;\n        };\n        /**\n         * Returns the VertexBuffer total size (integer).\n         */\n        VertexBuffer.prototype.getSize = function () {\n            return this._size;\n        };\n        /**\n         * Boolean : is the WebGLBuffer of the VertexBuffer instanced now ?\n         */\n        VertexBuffer.prototype.getIsInstanced = function () {\n            return this._buffer.getIsInstanced();\n        };\n        /**\n         * Returns the instancing divisor, zero for non-instanced (integer).\n         */\n        VertexBuffer.prototype.getInstanceDivisor = function () {\n            return this._buffer.instanceDivisor;\n        };\n        // Methods\n        /**\n         * Creates the underlying WebGLBuffer from the passed numeric array or Float32Array.\n         * Returns the created WebGLBuffer.\n         */\n        VertexBuffer.prototype.create = function (data) {\n            return this._buffer.create(data);\n        };\n        /**\n         * Updates the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n         * Returns the updated WebGLBuffer.\n         */\n        VertexBuffer.prototype.update = function (data) {\n            return this._buffer.update(data);\n        };\n        /**\n         * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n         * Returns the directly updated WebGLBuffer.\n         */\n        VertexBuffer.prototype.updateDirectly = function (data, offset) {\n            return this._buffer.updateDirectly(data, offset);\n        };\n        /**\n         * Disposes the VertexBuffer and the underlying WebGLBuffer.\n         */\n        VertexBuffer.prototype.dispose = function () {\n            if (this._ownsBuffer) {\n                this._buffer.dispose();\n            }\n        };\n        Object.defineProperty(VertexBuffer, \"PositionKind\", {\n            get: function () {\n                return VertexBuffer._PositionKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"NormalKind\", {\n            get: function () {\n                return VertexBuffer._NormalKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"TangentKind\", {\n            get: function () {\n                return VertexBuffer._TangentKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UVKind\", {\n            get: function () {\n                return VertexBuffer._UVKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UV2Kind\", {\n            get: function () {\n                return VertexBuffer._UV2Kind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UV3Kind\", {\n            get: function () {\n                return VertexBuffer._UV3Kind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UV4Kind\", {\n            get: function () {\n                return VertexBuffer._UV4Kind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UV5Kind\", {\n            get: function () {\n                return VertexBuffer._UV5Kind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"UV6Kind\", {\n            get: function () {\n                return VertexBuffer._UV6Kind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"ColorKind\", {\n            get: function () {\n                return VertexBuffer._ColorKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"MatricesIndicesKind\", {\n            get: function () {\n                return VertexBuffer._MatricesIndicesKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"MatricesWeightsKind\", {\n            get: function () {\n                return VertexBuffer._MatricesWeightsKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"MatricesIndicesExtraKind\", {\n            get: function () {\n                return VertexBuffer._MatricesIndicesExtraKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VertexBuffer, \"MatricesWeightsExtraKind\", {\n            get: function () {\n                return VertexBuffer._MatricesWeightsExtraKind;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return VertexBuffer;\n    }());\n    // Enums\n    VertexBuffer._PositionKind = \"position\";\n    VertexBuffer._NormalKind = \"normal\";\n    VertexBuffer._TangentKind = \"tangent\";\n    VertexBuffer._UVKind = \"uv\";\n    VertexBuffer._UV2Kind = \"uv2\";\n    VertexBuffer._UV3Kind = \"uv3\";\n    VertexBuffer._UV4Kind = \"uv4\";\n    VertexBuffer._UV5Kind = \"uv5\";\n    VertexBuffer._UV6Kind = \"uv6\";\n    VertexBuffer._ColorKind = \"color\";\n    VertexBuffer._MatricesIndicesKind = \"matricesIndices\";\n    VertexBuffer._MatricesWeightsKind = \"matricesWeights\";\n    VertexBuffer._MatricesIndicesExtraKind = \"matricesIndicesExtra\";\n    VertexBuffer._MatricesWeightsExtraKind = \"matricesWeightsExtra\";\n    BABYLON.VertexBuffer = VertexBuffer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.vertexBuffer.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var BaseTexture = (function () {\n        function BaseTexture(scene) {\n            this._hasAlpha = false;\n            this.getAlphaFromRGB = false;\n            this.level = 1;\n            this.coordinatesIndex = 0;\n            this._coordinatesMode = BABYLON.Texture.EXPLICIT_MODE;\n            this.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;\n            this.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;\n            this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;\n            this.isCube = false;\n            this.gammaSpace = true;\n            this.invertZ = false;\n            this.lodLevelInAlpha = false;\n            this.lodGenerationOffset = 0.0;\n            this.lodGenerationScale = 0.8;\n            this.isRenderTarget = false;\n            this.animations = new Array();\n            /**\n            * An event triggered when the texture is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NONE;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._scene.textures.push(this);\n            this._uid = null;\n        }\n        Object.defineProperty(BaseTexture.prototype, \"hasAlpha\", {\n            get: function () {\n                return this._hasAlpha;\n            },\n            set: function (value) {\n                if (this._hasAlpha === value) {\n                    return;\n                }\n                this._hasAlpha = value;\n                this._scene.markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"coordinatesMode\", {\n            get: function () {\n                return this._coordinatesMode;\n            },\n            set: function (value) {\n                if (this._coordinatesMode === value) {\n                    return;\n                }\n                this._coordinatesMode = value;\n                this._scene.markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"uid\", {\n            get: function () {\n                if (!this._uid) {\n                    this._uid = BABYLON.Tools.RandomId();\n                }\n                return this._uid;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseTexture.prototype.toString = function () {\n            return this.name;\n        };\n        Object.defineProperty(BaseTexture.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"isBlocking\", {\n            get: function () {\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseTexture.prototype.getScene = function () {\n            return this._scene;\n        };\n        BaseTexture.prototype.getTextureMatrix = function () {\n            return null;\n        };\n        BaseTexture.prototype.getReflectionTextureMatrix = function () {\n            return null;\n        };\n        BaseTexture.prototype.getInternalTexture = function () {\n            return this._texture;\n        };\n        BaseTexture.prototype.isReadyOrNotBlocking = function () {\n            return !this.isBlocking || this.isReady();\n        };\n        BaseTexture.prototype.isReady = function () {\n            if (this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                this.delayLoad();\n                return false;\n            }\n            if (this._texture) {\n                return this._texture.isReady;\n            }\n            return false;\n        };\n        BaseTexture.prototype.getSize = function () {\n            if (this._texture._width) {\n                return new BABYLON.Size(this._texture._width, this._texture._height);\n            }\n            if (this._texture._size) {\n                return new BABYLON.Size(this._texture._size, this._texture._size);\n            }\n            return BABYLON.Size.Zero();\n        };\n        BaseTexture.prototype.getBaseSize = function () {\n            if (!this.isReady() || !this._texture)\n                return BABYLON.Size.Zero();\n            if (this._texture._size) {\n                return new BABYLON.Size(this._texture._size, this._texture._size);\n            }\n            return new BABYLON.Size(this._texture._baseWidth, this._texture._baseHeight);\n        };\n        BaseTexture.prototype.scale = function (ratio) {\n        };\n        Object.defineProperty(BaseTexture.prototype, \"canRescale\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseTexture.prototype._removeFromCache = function (url, noMipmap) {\n            var texturesCache = this._scene.getEngine().getLoadedTexturesCache();\n            for (var index = 0; index < texturesCache.length; index++) {\n                var texturesCacheEntry = texturesCache[index];\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n                    texturesCache.splice(index, 1);\n                    return;\n                }\n            }\n        };\n        BaseTexture.prototype._getFromCache = function (url, noMipmap, sampling) {\n            var texturesCache = this._scene.getEngine().getLoadedTexturesCache();\n            for (var index = 0; index < texturesCache.length; index++) {\n                var texturesCacheEntry = texturesCache[index];\n                if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {\n                    if (!sampling || sampling === texturesCacheEntry.samplingMode) {\n                        texturesCacheEntry.references++;\n                        return texturesCacheEntry;\n                    }\n                }\n            }\n            return null;\n        };\n        BaseTexture.prototype.delayLoad = function () {\n        };\n        BaseTexture.prototype.clone = function () {\n            return null;\n        };\n        Object.defineProperty(BaseTexture.prototype, \"textureType\", {\n            get: function () {\n                if (!this._texture) {\n                    return BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                }\n                return (this._texture.type !== undefined) ? this._texture.type : BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"textureFormat\", {\n            get: function () {\n                if (!this._texture) {\n                    return BABYLON.Engine.TEXTUREFORMAT_RGBA;\n                }\n                return (this._texture.format !== undefined) ? this._texture.format : BABYLON.Engine.TEXTUREFORMAT_RGBA;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseTexture.prototype.readPixels = function (faceIndex) {\n            if (faceIndex === void 0) { faceIndex = 0; }\n            if (!this._texture) {\n                return null;\n            }\n            var size = this.getSize();\n            var engine = this.getScene().getEngine();\n            if (this._texture.isCube) {\n                return engine._readTexturePixels(this._texture, size.width, size.height, faceIndex);\n            }\n            return engine._readTexturePixels(this._texture, size.width, size.height, -1);\n        };\n        BaseTexture.prototype.releaseInternalTexture = function () {\n            if (this._texture) {\n                this._scene.getEngine().releaseInternalTexture(this._texture);\n                delete this._texture;\n            }\n        };\n        Object.defineProperty(BaseTexture.prototype, \"sphericalPolynomial\", {\n            get: function () {\n                if (!this._texture || !BABYLON.Internals.CubeMapToSphericalPolynomialTools || !this.isReady()) {\n                    return null;\n                }\n                if (!this._texture._sphericalPolynomial) {\n                    this._texture._sphericalPolynomial =\n                        BABYLON.Internals.CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);\n                }\n                return this._texture._sphericalPolynomial;\n            },\n            set: function (value) {\n                if (this._texture) {\n                    this._texture._sphericalPolynomial = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"_lodTextureHigh\", {\n            get: function () {\n                if (this._texture) {\n                    return this._texture._lodTextureHigh;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"_lodTextureMid\", {\n            get: function () {\n                if (this._texture) {\n                    return this._texture._lodTextureMid;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BaseTexture.prototype, \"_lodTextureLow\", {\n            get: function () {\n                if (this._texture) {\n                    return this._texture._lodTextureLow;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseTexture.prototype.dispose = function () {\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Remove from scene\n            this._scene._removePendingData(this);\n            var index = this._scene.textures.indexOf(this);\n            if (index >= 0) {\n                this._scene.textures.splice(index, 1);\n            }\n            if (this._texture === undefined) {\n                return;\n            }\n            // Release\n            this.releaseInternalTexture();\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n        };\n        BaseTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            // Animations\n            BABYLON.Animation.AppendSerializedAnimations(this, serializationObject);\n            return serializationObject;\n        };\n        BaseTexture.WhenAllReady = function (textures, onLoad) {\n            var numReady = 0;\n            var _loop_1 = function () {\n                texture = textures[i];\n                if (texture.isReady()) {\n                    if (++numReady === textures.length) {\n                        onLoad();\n                    }\n                }\n                else {\n                    observable = texture.onLoadObservable;\n                    var callback_1 = function () {\n                        observable.removeCallback(callback_1);\n                        if (++numReady === textures.length) {\n                            onLoad();\n                        }\n                    };\n                    observable.add(callback_1);\n                }\n            };\n            var texture, observable;\n            for (var i = 0; i < textures.length; i++) {\n                _loop_1();\n            }\n        };\n        return BaseTexture;\n    }());\n    BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"name\", void 0);\n    __decorate([\n        BABYLON.serialize(\"hasAlpha\")\n    ], BaseTexture.prototype, \"_hasAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"getAlphaFromRGB\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"level\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"coordinatesIndex\", void 0);\n    __decorate([\n        BABYLON.serialize(\"coordinatesMode\")\n    ], BaseTexture.prototype, \"_coordinatesMode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"wrapU\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"wrapV\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"anisotropicFilteringLevel\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"isCube\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"gammaSpace\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"invertZ\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"lodLevelInAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"lodGenerationOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"lodGenerationScale\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], BaseTexture.prototype, \"isRenderTarget\", void 0);\n    BABYLON.BaseTexture = BaseTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.baseTexture.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Texture = (function (_super) {\n        __extends(Texture, _super);\n        function Texture(url, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format) {\n            if (noMipmap === void 0) { noMipmap = false; }\n            if (invertY === void 0) { invertY = true; }\n            if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (buffer === void 0) { buffer = null; }\n            if (deleteBuffer === void 0) { deleteBuffer = false; }\n            var _this = _super.call(this, scene) || this;\n            _this.uOffset = 0;\n            _this.vOffset = 0;\n            _this.uScale = 1.0;\n            _this.vScale = 1.0;\n            _this.uAng = 0;\n            _this.vAng = 0;\n            _this.wAng = 0;\n            _this._isBlocking = true;\n            _this.name = url;\n            _this.url = url;\n            _this._noMipmap = noMipmap;\n            _this._invertY = invertY;\n            _this._samplingMode = samplingMode;\n            _this._buffer = buffer;\n            _this._deleteBuffer = deleteBuffer;\n            _this._format = format;\n            scene = _this.getScene();\n            var load = function () {\n                if (_this._onLoadObservable && _this._onLoadObservable.hasObservers()) {\n                    _this.onLoadObservable.notifyObservers(_this);\n                }\n                if (onLoad) {\n                    onLoad();\n                }\n                if (!_this.isBlocking) {\n                    scene.resetCachedMaterial();\n                }\n            };\n            if (!url) {\n                _this._delayedOnLoad = load;\n                _this._delayedOnError = onError;\n                return _this;\n            }\n            _this._texture = _this._getFromCache(url, noMipmap, samplingMode);\n            if (!_this._texture) {\n                if (!scene.useDelayedTextureLoading) {\n                    _this._texture = scene.getEngine().createTexture(url, noMipmap, invertY, scene, _this._samplingMode, load, onError, _this._buffer, null, _this._format);\n                    if (deleteBuffer) {\n                        delete _this._buffer;\n                    }\n                }\n                else {\n                    _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                    _this._delayedOnLoad = load;\n                    _this._delayedOnError = onError;\n                }\n            }\n            else {\n                if (_this._texture.isReady) {\n                    BABYLON.Tools.SetImmediate(function () { return load(); });\n                }\n                else {\n                    _this._texture.onLoadedCallbacks.push(load);\n                }\n            }\n            return _this;\n        }\n        Object.defineProperty(Texture.prototype, \"noMipmap\", {\n            get: function () {\n                return this._noMipmap;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Texture.prototype, \"isBlocking\", {\n            get: function () {\n                return this._isBlocking;\n            },\n            set: function (value) {\n                this._isBlocking = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Texture.prototype.updateURL = function (url) {\n            this.url = url;\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n            this.delayLoad();\n        };\n        Texture.prototype.delayLoad = function () {\n            var _this = this;\n            if (this.delayLoadState !== BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                return;\n            }\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n            this._texture = this._getFromCache(this.url, this._noMipmap, this._samplingMode);\n            if (!this._texture) {\n                this._texture = this.getScene().getEngine().createTexture(this.url, this._noMipmap, this._invertY, this.getScene(), this._samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format);\n                if (this._deleteBuffer) {\n                    delete this._buffer;\n                }\n            }\n            else {\n                if (this._texture.isReady) {\n                    BABYLON.Tools.SetImmediate(function () { return _this._delayedOnLoad(); });\n                }\n                else {\n                    this._texture.onLoadedCallbacks.push(this._delayedOnLoad);\n                }\n            }\n        };\n        Texture.prototype.updateSamplingMode = function (samplingMode) {\n            if (!this._texture) {\n                return;\n            }\n            this._samplingMode = samplingMode;\n            this.getScene().getEngine().updateTextureSamplingMode(samplingMode, this._texture);\n        };\n        Texture.prototype._prepareRowForTextureGeneration = function (x, y, z, t) {\n            x *= this.uScale;\n            y *= this.vScale;\n            x -= 0.5 * this.uScale;\n            y -= 0.5 * this.vScale;\n            z -= 0.5;\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);\n            t.x += 0.5 * this.uScale + this.uOffset;\n            t.y += 0.5 * this.vScale + this.vOffset;\n            t.z += 0.5;\n        };\n        Texture.prototype.getTextureMatrix = function () {\n            var _this = this;\n            if (this.uOffset === this._cachedUOffset &&\n                this.vOffset === this._cachedVOffset &&\n                this.uScale === this._cachedUScale &&\n                this.vScale === this._cachedVScale &&\n                this.uAng === this._cachedUAng &&\n                this.vAng === this._cachedVAng &&\n                this.wAng === this._cachedWAng) {\n                return this._cachedTextureMatrix;\n            }\n            this._cachedUOffset = this.uOffset;\n            this._cachedVOffset = this.vOffset;\n            this._cachedUScale = this.uScale;\n            this._cachedVScale = this.vScale;\n            this._cachedUAng = this.uAng;\n            this._cachedVAng = this.vAng;\n            this._cachedWAng = this.wAng;\n            if (!this._cachedTextureMatrix) {\n                this._cachedTextureMatrix = BABYLON.Matrix.Zero();\n                this._rowGenerationMatrix = new BABYLON.Matrix();\n                this._t0 = BABYLON.Vector3.Zero();\n                this._t1 = BABYLON.Vector3.Zero();\n                this._t2 = BABYLON.Vector3.Zero();\n            }\n            BABYLON.Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);\n            this._prepareRowForTextureGeneration(0, 0, 0, this._t0);\n            this._prepareRowForTextureGeneration(1.0, 0, 0, this._t1);\n            this._prepareRowForTextureGeneration(0, 1.0, 0, this._t2);\n            this._t1.subtractInPlace(this._t0);\n            this._t2.subtractInPlace(this._t0);\n            BABYLON.Matrix.IdentityToRef(this._cachedTextureMatrix);\n            this._cachedTextureMatrix.m[0] = this._t1.x;\n            this._cachedTextureMatrix.m[1] = this._t1.y;\n            this._cachedTextureMatrix.m[2] = this._t1.z;\n            this._cachedTextureMatrix.m[4] = this._t2.x;\n            this._cachedTextureMatrix.m[5] = this._t2.y;\n            this._cachedTextureMatrix.m[6] = this._t2.z;\n            this._cachedTextureMatrix.m[8] = this._t0.x;\n            this._cachedTextureMatrix.m[9] = this._t0.y;\n            this._cachedTextureMatrix.m[10] = this._t0.z;\n            this.getScene().markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag, function (mat) {\n                return mat.hasTexture(_this);\n            });\n            return this._cachedTextureMatrix;\n        };\n        Texture.prototype.getReflectionTextureMatrix = function () {\n            var _this = this;\n            if (this.uOffset === this._cachedUOffset &&\n                this.vOffset === this._cachedVOffset &&\n                this.uScale === this._cachedUScale &&\n                this.vScale === this._cachedVScale &&\n                this.coordinatesMode === this._cachedCoordinatesMode) {\n                return this._cachedTextureMatrix;\n            }\n            if (!this._cachedTextureMatrix) {\n                this._cachedTextureMatrix = BABYLON.Matrix.Zero();\n                this._projectionModeMatrix = BABYLON.Matrix.Zero();\n            }\n            this._cachedCoordinatesMode = this.coordinatesMode;\n            switch (this.coordinatesMode) {\n                case Texture.PLANAR_MODE:\n                    BABYLON.Matrix.IdentityToRef(this._cachedTextureMatrix);\n                    this._cachedTextureMatrix[0] = this.uScale;\n                    this._cachedTextureMatrix[5] = this.vScale;\n                    this._cachedTextureMatrix[12] = this.uOffset;\n                    this._cachedTextureMatrix[13] = this.vOffset;\n                    break;\n                case Texture.PROJECTION_MODE:\n                    BABYLON.Matrix.IdentityToRef(this._projectionModeMatrix);\n                    this._projectionModeMatrix.m[0] = 0.5;\n                    this._projectionModeMatrix.m[5] = -0.5;\n                    this._projectionModeMatrix.m[10] = 0.0;\n                    this._projectionModeMatrix.m[12] = 0.5;\n                    this._projectionModeMatrix.m[13] = 0.5;\n                    this._projectionModeMatrix.m[14] = 1.0;\n                    this._projectionModeMatrix.m[15] = 1.0;\n                    this.getScene().getProjectionMatrix().multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);\n                    break;\n                default:\n                    BABYLON.Matrix.IdentityToRef(this._cachedTextureMatrix);\n                    break;\n            }\n            this.getScene().markAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag, function (mat) {\n                return (mat.getActiveTextures().indexOf(_this) !== -1);\n            });\n            return this._cachedTextureMatrix;\n        };\n        Texture.prototype.clone = function () {\n            var _this = this;\n            return BABYLON.SerializationHelper.Clone(function () {\n                return new Texture(_this._texture.url, _this.getScene(), _this._noMipmap, _this._invertY, _this._samplingMode);\n            }, this);\n        };\n        Object.defineProperty(Texture.prototype, \"onLoadObservable\", {\n            get: function () {\n                if (!this._onLoadObservable) {\n                    this._onLoadObservable = new BABYLON.Observable();\n                }\n                return this._onLoadObservable;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Statics\n        Texture.CreateFromBase64String = function (data, name, scene, noMipmap, invertY, samplingMode, onLoad, onError, format) {\n            if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (format === void 0) { format = BABYLON.Engine.TEXTUREFORMAT_RGBA; }\n            return new Texture(\"data:\" + name, scene, noMipmap, invertY, samplingMode, onLoad, onError, data, false, format);\n        };\n        Texture.Parse = function (parsedTexture, scene, rootUrl) {\n            if (parsedTexture.customType) {\n                var customTexture = BABYLON.Tools.Instantiate(parsedTexture.customType);\n                // Update Sampling Mode\n                var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);\n                if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {\n                    if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {\n                        parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);\n                    }\n                }\n                return parsedCustomTexture;\n            }\n            if (parsedTexture.isCube) {\n                return BABYLON.CubeTexture.Parse(parsedTexture, scene, rootUrl);\n            }\n            if (!parsedTexture.name && !parsedTexture.isRenderTarget) {\n                return null;\n            }\n            var texture = BABYLON.SerializationHelper.Parse(function () {\n                if (parsedTexture.mirrorPlane) {\n                    var mirrorTexture = new BABYLON.MirrorTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene);\n                    mirrorTexture._waitingRenderList = parsedTexture.renderList;\n                    mirrorTexture.mirrorPlane = BABYLON.Plane.FromArray(parsedTexture.mirrorPlane);\n                    return mirrorTexture;\n                }\n                else if (parsedTexture.isRenderTarget) {\n                    var renderTargetTexture = new BABYLON.RenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene);\n                    renderTargetTexture._waitingRenderList = parsedTexture.renderList;\n                    return renderTargetTexture;\n                }\n                else {\n                    var texture;\n                    if (parsedTexture.base64String) {\n                        texture = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene);\n                    }\n                    else {\n                        texture = new Texture(rootUrl + parsedTexture.name, scene);\n                    }\n                    return texture;\n                }\n            }, parsedTexture, scene);\n            // Update Sampling Mode\n            if (parsedTexture.samplingMode) {\n                var sampling = parsedTexture.samplingMode;\n                if (texture._samplingMode !== sampling) {\n                    texture.updateSamplingMode(sampling);\n                }\n            }\n            // Animations\n            if (parsedTexture.animations) {\n                for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedTexture.animations[animationIndex];\n                    texture.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n            }\n            return texture;\n        };\n        Texture.LoadFromDataString = function (name, buffer, scene, deleteBuffer, noMipmap, invertY, samplingMode, onLoad, onError, format) {\n            if (deleteBuffer === void 0) { deleteBuffer = false; }\n            if (noMipmap === void 0) { noMipmap = false; }\n            if (invertY === void 0) { invertY = true; }\n            if (samplingMode === void 0) { samplingMode = Texture.TRILINEAR_SAMPLINGMODE; }\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (format === void 0) { format = BABYLON.Engine.TEXTUREFORMAT_RGBA; }\n            if (name.substr(0, 5) !== \"data:\") {\n                name = \"data:\" + name;\n            }\n            return new Texture(name, scene, noMipmap, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format);\n        };\n        return Texture;\n    }(BABYLON.BaseTexture));\n    // Constants\n    Texture.NEAREST_SAMPLINGMODE = 1;\n    Texture.BILINEAR_SAMPLINGMODE = 2;\n    Texture.TRILINEAR_SAMPLINGMODE = 3;\n    Texture.EXPLICIT_MODE = 0;\n    Texture.SPHERICAL_MODE = 1;\n    Texture.PLANAR_MODE = 2;\n    Texture.CUBIC_MODE = 3;\n    Texture.PROJECTION_MODE = 4;\n    Texture.SKYBOX_MODE = 5;\n    Texture.INVCUBIC_MODE = 6;\n    Texture.EQUIRECTANGULAR_MODE = 7;\n    Texture.FIXED_EQUIRECTANGULAR_MODE = 8;\n    Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\n    Texture.CLAMP_ADDRESSMODE = 0;\n    Texture.WRAP_ADDRESSMODE = 1;\n    Texture.MIRROR_ADDRESSMODE = 2;\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"url\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"uOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"vOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"uScale\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"vScale\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"uAng\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"vAng\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"wAng\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Texture.prototype, \"isBlocking\", null);\n    BABYLON.Texture = Texture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.texture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var _InstancesBatch = (function () {\n        function _InstancesBatch() {\n            this.mustReturn = false;\n            this.visibleInstances = new Array();\n            this.renderSelf = new Array();\n        }\n        return _InstancesBatch;\n    }());\n    BABYLON._InstancesBatch = _InstancesBatch;\n    var Mesh = (function (_super) {\n        __extends(Mesh, _super);\n        /**\n         * @constructor\n         * @param {string} name The value used by scene.getMeshByName() to do a lookup.\n         * @param {Scene} scene The scene to add this mesh to.\n         * @param {Node} parent The parent of this mesh, if it has one\n         * @param {Mesh} source An optional Mesh from which geometry is shared, cloned.\n         * @param {boolean} doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n         *                  When false, achieved by calling a clone(), also passing False.\n         *                  This will make creation of children, recursive.\n         * @param {boolean} clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n         */\n        function Mesh(name, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {\n            if (parent === void 0) { parent = null; }\n            if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\n            var _this = _super.call(this, name, scene) || this;\n            // Events \n            /**\n             * An event triggered before rendering the mesh\n             * @type {BABYLON.Observable}\n             */\n            _this.onBeforeRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering the mesh\n            * @type {BABYLON.Observable}\n            */\n            _this.onAfterRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before drawing the mesh\n            * @type {BABYLON.Observable}\n            */\n            _this.onBeforeDrawObservable = new BABYLON.Observable();\n            // Members\n            _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NONE;\n            _this.instances = new Array();\n            _this._LODLevels = new Array();\n            _this._visibleInstances = {};\n            _this._renderIdForInstances = new Array();\n            _this._batchCache = new _InstancesBatch();\n            _this._instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n            _this._sideOrientation = Mesh._DEFAULTSIDE;\n            _this._areNormalsFrozen = false; // Will be used by ribbons mainly\n            // Will be used to save a source mesh reference, If any\n            _this._source = null;\n            if (source) {\n                // Source mesh\n                _this._source = source;\n                // Geometry\n                if (source._geometry) {\n                    source._geometry.applyToMesh(_this);\n                }\n                // Deep copy\n                BABYLON.Tools.DeepCopy(source, _this, [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\"], [\"_poseMatrix\"]);\n                // Parent\n                _this.parent = source.parent;\n                // Pivot\n                _this.setPivotMatrix(source.getPivotMatrix());\n                _this.id = name + \".\" + source.id;\n                // Material\n                _this.material = source.material;\n                var index;\n                if (!doNotCloneChildren) {\n                    // Children\n                    for (index = 0; index < scene.meshes.length; index++) {\n                        var mesh = scene.meshes[index];\n                        if (mesh.parent === source) {\n                            // doNotCloneChildren is always going to be False\n                            var newChild = mesh.clone(name + \".\" + mesh.name, _this, doNotCloneChildren);\n                        }\n                    }\n                }\n                // Physics clone  \n                var physicsEngine = _this.getScene().getPhysicsEngine();\n                if (clonePhysicsImpostor && physicsEngine) {\n                    var impostor = physicsEngine.getImpostorForPhysicsObject(source);\n                    if (impostor) {\n                        _this.physicsImpostor = impostor.clone(_this);\n                    }\n                }\n                // Particles\n                for (index = 0; index < scene.particleSystems.length; index++) {\n                    var system = scene.particleSystems[index];\n                    if (system.emitter === source) {\n                        system.clone(system.name, _this);\n                    }\n                }\n                _this.computeWorldMatrix(true);\n            }\n            // Parent\n            if (parent !== null) {\n                _this.parent = parent;\n            }\n            return _this;\n        }\n        Object.defineProperty(Mesh, \"FRONTSIDE\", {\n            /**\n             * Mesh side orientation : usually the external or front surface\n             */\n            get: function () {\n                return Mesh._FRONTSIDE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"BACKSIDE\", {\n            /**\n             * Mesh side orientation : usually the internal or back surface\n             */\n            get: function () {\n                return Mesh._BACKSIDE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"DOUBLESIDE\", {\n            /**\n             * Mesh side orientation : both internal and external or front and back surfaces\n             */\n            get: function () {\n                return Mesh._DOUBLESIDE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"DEFAULTSIDE\", {\n            /**\n             * Mesh side orientation : by default, `FRONTSIDE`\n             */\n            get: function () {\n                return Mesh._DEFAULTSIDE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"NO_CAP\", {\n            /**\n             * Mesh cap setting : no cap\n             */\n            get: function () {\n                return Mesh._NO_CAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"CAP_START\", {\n            /**\n             * Mesh cap setting : one cap at the beginning of the mesh\n             */\n            get: function () {\n                return Mesh._CAP_START;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"CAP_END\", {\n            /**\n             * Mesh cap setting : one cap at the end of the mesh\n             */\n            get: function () {\n                return Mesh._CAP_END;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh, \"CAP_ALL\", {\n            /**\n             * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n             */\n            get: function () {\n                return Mesh._CAP_ALL;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh.prototype, \"onBeforeDraw\", {\n            set: function (callback) {\n                if (this._onBeforeDrawObserver) {\n                    this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n                }\n                this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh.prototype, \"morphTargetManager\", {\n            get: function () {\n                return this._morphTargetManager;\n            },\n            set: function (value) {\n                if (this._morphTargetManager === value) {\n                    return;\n                }\n                this._morphTargetManager = value;\n                this._syncGeometryWithMorphTargetManager();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh.prototype, \"source\", {\n            get: function () {\n                return this._source;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        /**\n         * Returns the string \"Mesh\".\n         */\n        Mesh.prototype.getClassName = function () {\n            return \"Mesh\";\n        };\n        /**\n         * Returns a string.\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        Mesh.prototype.toString = function (fullDetails) {\n            var ret = _super.prototype.toString.call(this, fullDetails);\n            ret += \", n vertices: \" + this.getTotalVertices();\n            ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : (this.parent ? this.parent.name : \"NONE\"));\n            if (this.animations) {\n                for (var i = 0; i < this.animations.length; i++) {\n                    ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n                }\n            }\n            if (fullDetails) {\n                ret += \", flat shading: \" + (this._geometry ? (this.getVerticesData(BABYLON.VertexBuffer.PositionKind).length / 3 === this.getIndices().length ? \"YES\" : \"NO\") : \"UNKNOWN\");\n            }\n            return ret;\n        };\n        Object.defineProperty(Mesh.prototype, \"hasLODLevels\", {\n            /**\n             * True if the mesh has some Levels Of Details (LOD).\n             * Returns a boolean.\n             */\n            get: function () {\n                return this._LODLevels.length > 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Mesh.prototype._sortLODLevels = function () {\n            this._LODLevels.sort(function (a, b) {\n                if (a.distance < b.distance) {\n                    return 1;\n                }\n                if (a.distance > b.distance) {\n                    return -1;\n                }\n                return 0;\n            });\n        };\n        /**\n         * Add a mesh as LOD level triggered at the given distance.\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD\n         * @param {number} distance The distance from the center of the object to show this level\n         * @param {Mesh} mesh The mesh to be added as LOD level\n         * @return {Mesh} This mesh (for chaining)\n         */\n        Mesh.prototype.addLODLevel = function (distance, mesh) {\n            if (mesh && mesh._masterMesh) {\n                BABYLON.Tools.Warn(\"You cannot use a mesh as LOD level twice\");\n                return this;\n            }\n            var level = new BABYLON.Internals.MeshLODLevel(distance, mesh);\n            this._LODLevels.push(level);\n            if (mesh) {\n                mesh._masterMesh = this;\n            }\n            this._sortLODLevels();\n            return this;\n        };\n        /**\n         * Returns the LOD level mesh at the passed distance or null if not found.\n         * It is related to the method `addLODLevel(distance, mesh)`.\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD\n         * Returns an object Mesh or `null`.\n         */\n        Mesh.prototype.getLODLevelAtDistance = function (distance) {\n            for (var index = 0; index < this._LODLevels.length; index++) {\n                var level = this._LODLevels[index];\n                if (level.distance === distance) {\n                    return level.mesh;\n                }\n            }\n            return null;\n        };\n        /**\n         * Remove a mesh from the LOD array\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD\n         * @param {Mesh} mesh The mesh to be removed.\n         * @return {Mesh} This mesh (for chaining)\n         */\n        Mesh.prototype.removeLODLevel = function (mesh) {\n            for (var index = 0; index < this._LODLevels.length; index++) {\n                if (this._LODLevels[index].mesh === mesh) {\n                    this._LODLevels.splice(index, 1);\n                    if (mesh) {\n                        mesh._masterMesh = null;\n                    }\n                }\n            }\n            this._sortLODLevels();\n            return this;\n        };\n        /**\n         * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD\n         */\n        Mesh.prototype.getLOD = function (camera, boundingSphere) {\n            if (!this._LODLevels || this._LODLevels.length === 0) {\n                return this;\n            }\n            var distanceToCamera = (boundingSphere ? boundingSphere : this.getBoundingInfo().boundingSphere).centerWorld.subtract(camera.globalPosition).length();\n            if (this._LODLevels[this._LODLevels.length - 1].distance > distanceToCamera) {\n                if (this.onLODLevelSelection) {\n                    this.onLODLevelSelection(distanceToCamera, this, this._LODLevels[this._LODLevels.length - 1].mesh);\n                }\n                return this;\n            }\n            for (var index = 0; index < this._LODLevels.length; index++) {\n                var level = this._LODLevels[index];\n                if (level.distance < distanceToCamera) {\n                    if (level.mesh) {\n                        level.mesh._preActivate();\n                        level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n                    }\n                    if (this.onLODLevelSelection) {\n                        this.onLODLevelSelection(distanceToCamera, this, level.mesh);\n                    }\n                    return level.mesh;\n                }\n            }\n            if (this.onLODLevelSelection) {\n                this.onLODLevelSelection(distanceToCamera, this, this);\n            }\n            return this;\n        };\n        Object.defineProperty(Mesh.prototype, \"geometry\", {\n            /**\n             * Returns the mesh internal Geometry object.\n             */\n            get: function () {\n                return this._geometry;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns a positive integer : the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n         */\n        Mesh.prototype.getTotalVertices = function () {\n            if (!this._geometry) {\n                return 0;\n            }\n            return this._geometry.getTotalVertices();\n        };\n        /**\n         * Returns an array of integers or floats, or a Float32Array, depending on the requested `kind` (positions, indices, normals, etc).\n         * If `copywhenShared` is true (default false) and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n         * You can force the copy with forceCopy === true\n         * Returns null if the mesh has no geometry or no vertex buffer.\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         */\n        Mesh.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n            if (!this._geometry) {\n                return null;\n            }\n            return this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n        };\n        /**\n         * Returns the mesh VertexBuffer object from the requested `kind` : positions, indices, normals, etc.\n         * Returns `undefined` if the mesh has no geometry.\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         */\n        Mesh.prototype.getVertexBuffer = function (kind) {\n            if (!this._geometry) {\n                return undefined;\n            }\n            return this._geometry.getVertexBuffer(kind);\n        };\n        /**\n         * Returns a boolean depending on the existence of the Vertex Data for the requested `kind`.\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         */\n        Mesh.prototype.isVerticesDataPresent = function (kind) {\n            if (!this._geometry) {\n                if (this._delayInfo) {\n                    return this._delayInfo.indexOf(kind) !== -1;\n                }\n                return false;\n            }\n            return this._geometry.isVerticesDataPresent(kind);\n        };\n        /**\n         * Returns a string : the list of existing `kinds` of Vertex Data for this mesh.\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         */\n        Mesh.prototype.getVerticesDataKinds = function () {\n            if (!this._geometry) {\n                var result = [];\n                if (this._delayInfo) {\n                    this._delayInfo.forEach(function (kind, index, array) {\n                        result.push(kind);\n                    });\n                }\n                return result;\n            }\n            return this._geometry.getVerticesDataKinds();\n        };\n        /**\n         * Returns a positive integer : the total number of indices in this mesh geometry.\n         * Returns zero if the mesh has no geometry.\n         */\n        Mesh.prototype.getTotalIndices = function () {\n            if (!this._geometry) {\n                return 0;\n            }\n            return this._geometry.getTotalIndices();\n        };\n        /**\n         * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n         * If the parameter `copyWhenShared` is true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n         * Returns an empty array if the mesh has no geometry.\n         */\n        Mesh.prototype.getIndices = function (copyWhenShared) {\n            if (!this._geometry) {\n                return [];\n            }\n            return this._geometry.getIndices(copyWhenShared);\n        };\n        Object.defineProperty(Mesh.prototype, \"isBlocked\", {\n            get: function () {\n                return this._masterMesh !== null && this._masterMesh !== undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Boolean : true once the mesh is ready after all the delayed process (loading, etc) are complete.\n         */\n        Mesh.prototype.isReady = function () {\n            if (this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADING) {\n                return false;\n            }\n            return _super.prototype.isReady.call(this);\n        };\n        /**\n         * Boolean : true if the mesh has been disposed.\n         */\n        Mesh.prototype.isDisposed = function () {\n            return this._isDisposed;\n        };\n        Object.defineProperty(Mesh.prototype, \"sideOrientation\", {\n            get: function () {\n                return this._sideOrientation;\n            },\n            /**\n             * Sets the mesh side orientation : BABYLON.Mesh.FRONTSIDE, BABYLON.Mesh.BACKSIDE, BABYLON.Mesh.DOUBLESIDE or BABYLON.Mesh.DEFAULTSIDE\n             * tuto : http://doc.babylonjs.com/tutorials/Discover_Basic_Elements#side-orientation\n             */\n            set: function (sideO) {\n                this._sideOrientation = sideO;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Mesh.prototype, \"areNormalsFrozen\", {\n            /**\n             * Boolean : true if the normals aren't to be recomputed on next mesh `positions` array update.\n             * This property is pertinent only for updatable parametric shapes.\n             */\n            get: function () {\n                return this._areNormalsFrozen;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.\n         * It has no effect at all on other shapes.\n         * It prevents the mesh normals from being recomputed on next `positions` array update.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.freezeNormals = function () {\n            this._areNormalsFrozen = true;\n            return this;\n        };\n        /**\n         * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.\n         * It has no effect at all on other shapes.\n         * It reactivates the mesh normals computation if it was previously frozen.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.unfreezeNormals = function () {\n            this._areNormalsFrozen = false;\n            return this;\n        };\n        Object.defineProperty(Mesh.prototype, \"overridenInstanceCount\", {\n            /**\n             * Overrides instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n             */\n            set: function (count) {\n                this._overridenInstanceCount = count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        Mesh.prototype._preActivate = function () {\n            var sceneRenderId = this.getScene().getRenderId();\n            if (this._preActivateId === sceneRenderId) {\n                return this;\n            }\n            this._preActivateId = sceneRenderId;\n            this._visibleInstances = null;\n            return this;\n        };\n        Mesh.prototype._preActivateForIntermediateRendering = function (renderId) {\n            if (this._visibleInstances) {\n                this._visibleInstances.intermediateDefaultRenderId = renderId;\n            }\n            return this;\n        };\n        Mesh.prototype._registerInstanceForRenderId = function (instance, renderId) {\n            if (!this._visibleInstances) {\n                this._visibleInstances = {};\n                this._visibleInstances.defaultRenderId = renderId;\n                this._visibleInstances.selfDefaultRenderId = this._renderId;\n            }\n            if (!this._visibleInstances[renderId]) {\n                this._visibleInstances[renderId] = new Array();\n            }\n            this._visibleInstances[renderId].push(instance);\n            return this;\n        };\n        /**\n         * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n         * This means the mesh underlying bounding box and sphere are recomputed.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.refreshBoundingInfo = function () {\n            if (this._boundingInfo.isLocked) {\n                return;\n            }\n            var data = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            if (data) {\n                var extend = BABYLON.Tools.ExtractMinAndMax(data, 0, this.getTotalVertices());\n                this._boundingInfo = new BABYLON.BoundingInfo(extend.minimum, extend.maximum);\n            }\n            if (this.subMeshes) {\n                for (var index = 0; index < this.subMeshes.length; index++) {\n                    this.subMeshes[index].refreshBoundingInfo();\n                }\n            }\n            this._updateBoundingInfo();\n            return this;\n        };\n        Mesh.prototype._createGlobalSubMesh = function () {\n            var totalVertices = this.getTotalVertices();\n            if (!totalVertices || !this.getIndices()) {\n                return null;\n            }\n            // Check if we need to recreate the submeshes\n            if (this.subMeshes && this.subMeshes.length > 0) {\n                var totalIndices = this.getIndices().length;\n                var needToRecreate = false;\n                for (var _i = 0, _a = this.subMeshes; _i < _a.length; _i++) {\n                    var submesh = _a[_i];\n                    if (submesh.indexStart + submesh.indexCount >= totalIndices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                    if (submesh.verticesStart + submesh.verticesCount >= totalVertices) {\n                        needToRecreate = true;\n                        break;\n                    }\n                }\n                if (!needToRecreate) {\n                    return;\n                }\n            }\n            this.releaseSubMeshes();\n            return new BABYLON.SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n        };\n        Mesh.prototype.subdivide = function (count) {\n            if (count < 1) {\n                return;\n            }\n            var totalIndices = this.getTotalIndices();\n            var subdivisionSize = (totalIndices / count) | 0;\n            var offset = 0;\n            // Ensure that subdivisionSize is a multiple of 3\n            while (subdivisionSize % 3 !== 0) {\n                subdivisionSize++;\n            }\n            this.releaseSubMeshes();\n            for (var index = 0; index < count; index++) {\n                if (offset >= totalIndices) {\n                    break;\n                }\n                BABYLON.SubMesh.CreateFromIndices(0, offset, Math.min(subdivisionSize, totalIndices - offset), this);\n                offset += subdivisionSize;\n            }\n            this.synchronizeInstances();\n        };\n        /**\n         * Sets the vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n         * The `data` are either a numeric array either a Float32Array.\n         * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\n         * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n         * Note that a new underlying VertexBuffer object is created each call.\n         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        Mesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n            if (!this._geometry) {\n                var vertexData = new BABYLON.VertexData();\n                vertexData.set(data, kind);\n                var scene = this.getScene();\n                new BABYLON.Geometry(BABYLON.Geometry.RandomId(), scene, vertexData, updatable, this);\n            }\n            else {\n                this._geometry.setVerticesData(kind, data, updatable, stride);\n            }\n            return this;\n        };\n        Mesh.prototype.markVerticesDataAsUpdatable = function (kind, updatable) {\n            if (updatable === void 0) { updatable = true; }\n            if (this.getVertexBuffer(kind).isUpdatable() === updatable) {\n                return;\n            }\n            this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n        };\n        /**\n         * Sets the mesh VertexBuffer.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.setVerticesBuffer = function (buffer) {\n            if (!this._geometry) {\n                var scene = this.getScene();\n                new BABYLON.Geometry(BABYLON.Geometry.RandomId(), scene).applyToMesh(this);\n            }\n            this._geometry.setVerticesBuffer(buffer);\n            return this;\n        };\n        /**\n         * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, it is simply returned as it is.\n         * The `data` are either a numeric array either a Float32Array.\n         * No new underlying VertexBuffer object is created.\n         * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        Mesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n            if (!this._geometry) {\n                return;\n            }\n            if (!makeItUnique) {\n                this._geometry.updateVerticesData(kind, data, updateExtends);\n            }\n            else {\n                this.makeGeometryUnique();\n                this.updateVerticesData(kind, data, updateExtends, false);\n            }\n            return this;\n        };\n        /**\n         * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions\n         * The parameter `positionFunction` is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything.\n         * The parameter `computeNormals` is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.updateMeshPositions = function (positionFunction, computeNormals) {\n            if (computeNormals === void 0) { computeNormals = true; }\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            positionFunction(positions);\n            this.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions, false, false);\n            if (computeNormals) {\n                var indices = this.getIndices();\n                var normals = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n                BABYLON.VertexData.ComputeNormals(positions, indices, normals);\n                this.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals, false, false);\n            }\n            return this;\n        };\n        /**\n         * Creates a un-shared specific occurence of the geometry for the mesh.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.makeGeometryUnique = function () {\n            if (!this._geometry) {\n                return;\n            }\n            var oldGeometry = this._geometry;\n            var geometry = this._geometry.copy(BABYLON.Geometry.RandomId());\n            oldGeometry.releaseForMesh(this, true);\n            geometry.applyToMesh(this);\n            return this;\n        };\n        /**\n         * Sets the mesh indices.\n         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n         * This method creates a new index buffer each call.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.setIndices = function (indices, totalVertices) {\n            if (!this._geometry) {\n                var vertexData = new BABYLON.VertexData();\n                vertexData.indices = indices;\n                var scene = this.getScene();\n                new BABYLON.Geometry(BABYLON.Geometry.RandomId(), scene, vertexData, false, this);\n            }\n            else {\n                this._geometry.setIndices(indices, totalVertices);\n            }\n            return this;\n        };\n        /**\n         * Invert the geometry to move from a right handed system to a left handed one.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.toLeftHanded = function () {\n            if (!this._geometry) {\n                return;\n            }\n            this._geometry.toLeftHanded();\n            return this;\n        };\n        Mesh.prototype._bind = function (subMesh, effect, fillMode) {\n            var engine = this.getScene().getEngine();\n            // Wireframe\n            var indexToBind;\n            if (this._unIndexed) {\n                indexToBind = null;\n            }\n            else {\n                switch (fillMode) {\n                    case BABYLON.Material.PointFillMode:\n                        indexToBind = null;\n                        break;\n                    case BABYLON.Material.WireFrameFillMode:\n                        indexToBind = subMesh.getLinesIndexBuffer(this.getIndices(), engine);\n                        break;\n                    default:\n                    case BABYLON.Material.TriangleFillMode:\n                        indexToBind = this._unIndexed ? null : this._geometry.getIndexBuffer();\n                        break;\n                }\n            }\n            // VBOs\n            this._geometry._bind(effect, indexToBind);\n            return this;\n        };\n        Mesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n            if (!this._geometry || !this._geometry.getVertexBuffers() || !this._geometry.getIndexBuffer()) {\n                return this;\n            }\n            this.onBeforeDrawObservable.notifyObservers(this);\n            var engine = this.getScene().getEngine();\n            // Draw order\n            switch (fillMode) {\n                case BABYLON.Material.PointFillMode:\n                    engine.drawPointClouds(subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n                    break;\n                case BABYLON.Material.WireFrameFillMode:\n                    if (this._unIndexed) {\n                        engine.drawUnIndexed(false, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n                    }\n                    else {\n                        engine.draw(false, 0, instancesCount > 0 ? subMesh.linesIndexCount / 2 : subMesh.linesIndexCount, instancesCount);\n                    }\n                    break;\n                default:\n                    if (this._unIndexed) {\n                        engine.drawUnIndexed(true, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\n                    }\n                    else {\n                        engine.draw(true, subMesh.indexStart, subMesh.indexCount, instancesCount);\n                    }\n            }\n            return this;\n        };\n        /**\n         * Registers for this mesh a javascript function called just before the rendering process.\n         * This function is passed the current mesh.\n         * Return the Mesh.\n         */\n        Mesh.prototype.registerBeforeRender = function (func) {\n            this.onBeforeRenderObservable.add(func);\n            return this;\n        };\n        /**\n         * Disposes a previously registered javascript function called before the rendering.\n         * This function is passed the current mesh.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.unregisterBeforeRender = function (func) {\n            this.onBeforeRenderObservable.removeCallback(func);\n            return this;\n        };\n        /**\n         * Registers for this mesh a javascript function called just after the rendering is complete.\n         * This function is passed the current mesh.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.registerAfterRender = function (func) {\n            this.onAfterRenderObservable.add(func);\n            return this;\n        };\n        /**\n         * Disposes a previously registered javascript function called after the rendering.\n         * This function is passed the current mesh.\n         * Return the Mesh.\n         */\n        Mesh.prototype.unregisterAfterRender = function (func) {\n            this.onAfterRenderObservable.removeCallback(func);\n            return this;\n        };\n        Mesh.prototype._getInstancesRenderList = function (subMeshId) {\n            var scene = this.getScene();\n            this._batchCache.mustReturn = false;\n            this._batchCache.renderSelf[subMeshId] = this.isEnabled() && this.isVisible;\n            this._batchCache.visibleInstances[subMeshId] = null;\n            if (this._visibleInstances) {\n                var currentRenderId = scene.getRenderId();\n                var defaultRenderId = (scene._isInIntermediateRendering() ? this._visibleInstances.intermediateDefaultRenderId : this._visibleInstances.defaultRenderId);\n                this._batchCache.visibleInstances[subMeshId] = this._visibleInstances[currentRenderId];\n                var selfRenderId = this._renderId;\n                if (!this._batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n                    this._batchCache.visibleInstances[subMeshId] = this._visibleInstances[defaultRenderId];\n                    currentRenderId = Math.max(defaultRenderId, currentRenderId);\n                    selfRenderId = Math.max(this._visibleInstances.selfDefaultRenderId, currentRenderId);\n                }\n                if (this._batchCache.visibleInstances[subMeshId] && this._batchCache.visibleInstances[subMeshId].length) {\n                    if (this._renderIdForInstances[subMeshId] === currentRenderId) {\n                        this._batchCache.mustReturn = true;\n                        return this._batchCache;\n                    }\n                    if (currentRenderId !== selfRenderId) {\n                        this._batchCache.renderSelf[subMeshId] = false;\n                    }\n                }\n                this._renderIdForInstances[subMeshId] = currentRenderId;\n            }\n            return this._batchCache;\n        };\n        Mesh.prototype._renderWithInstances = function (subMesh, fillMode, batch, effect, engine) {\n            var visibleInstances = batch.visibleInstances[subMesh._id];\n            var matricesCount = visibleInstances.length + 1;\n            var bufferSize = matricesCount * 16 * 4;\n            var currentInstancesBufferSize = this._instancesBufferSize;\n            var instancesBuffer = this._instancesBuffer;\n            while (this._instancesBufferSize < bufferSize) {\n                this._instancesBufferSize *= 2;\n            }\n            if (!this._instancesData || currentInstancesBufferSize != this._instancesBufferSize) {\n                this._instancesData = new Float32Array(this._instancesBufferSize / 4);\n            }\n            var offset = 0;\n            var instancesCount = 0;\n            var world = this.getWorldMatrix();\n            if (batch.renderSelf[subMesh._id]) {\n                world.copyToArray(this._instancesData, offset);\n                offset += 16;\n                instancesCount++;\n            }\n            if (visibleInstances) {\n                for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n                    var instance = visibleInstances[instanceIndex];\n                    instance.getWorldMatrix().copyToArray(this._instancesData, offset);\n                    offset += 16;\n                    instancesCount++;\n                }\n            }\n            if (!instancesBuffer || currentInstancesBufferSize != this._instancesBufferSize) {\n                if (instancesBuffer) {\n                    instancesBuffer.dispose();\n                }\n                instancesBuffer = new BABYLON.Buffer(engine, this._instancesData, true, 16, false, true);\n                this._instancesBuffer = instancesBuffer;\n                this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world0\", 0, 4));\n                this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world1\", 4, 4));\n                this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world2\", 8, 4));\n                this.setVerticesBuffer(instancesBuffer.createVertexBuffer(\"world3\", 12, 4));\n            }\n            else {\n                instancesBuffer.updateDirectly(this._instancesData, 0, instancesCount);\n            }\n            this.geometry._bind(effect);\n            this._draw(subMesh, fillMode, instancesCount);\n            engine.unbindInstanceAttributes();\n            return this;\n        };\n        Mesh.prototype._processRendering = function (subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            if (hardwareInstancedRendering) {\n                this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n            }\n            else {\n                if (batch.renderSelf[subMesh._id]) {\n                    // Draw\n                    if (onBeforeDraw) {\n                        onBeforeDraw(false, this.getWorldMatrix(), effectiveMaterial);\n                    }\n                    this._draw(subMesh, fillMode, this._overridenInstanceCount);\n                }\n                if (batch.visibleInstances[subMesh._id]) {\n                    for (var instanceIndex = 0; instanceIndex < batch.visibleInstances[subMesh._id].length; instanceIndex++) {\n                        var instance = batch.visibleInstances[subMesh._id][instanceIndex];\n                        // World\n                        var world = instance.getWorldMatrix();\n                        if (onBeforeDraw) {\n                            onBeforeDraw(true, world, effectiveMaterial);\n                        }\n                        // Draw\n                        this._draw(subMesh, fillMode);\n                    }\n                }\n            }\n            return this;\n        };\n        /**\n         * Triggers the draw call for the mesh.\n         * Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.render = function (subMesh, enableAlphaMode) {\n            var scene = this.getScene();\n            // Managing instances\n            var batch = this._getInstancesRenderList(subMesh._id);\n            if (batch.mustReturn) {\n                return this;\n            }\n            // Checking geometry state\n            if (!this._geometry || !this._geometry.getVertexBuffers() || !this._geometry.getIndexBuffer()) {\n                return this;\n            }\n            var callbackIndex;\n            this.onBeforeRenderObservable.notifyObservers(this);\n            var engine = scene.getEngine();\n            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);\n            // Material\n            var effectiveMaterial = subMesh.getMaterial();\n            if (!effectiveMaterial) {\n                return this;\n            }\n            if (effectiveMaterial.storeEffectOnSubMeshes) {\n                if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                    return this;\n                }\n            }\n            else if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                return this;\n            }\n            // Alpha mode\n            if (enableAlphaMode) {\n                engine.setAlphaMode(effectiveMaterial.alphaMode);\n            }\n            // Outline - step 1\n            var savedDepthWrite = engine.getDepthWrite();\n            if (this.renderOutline) {\n                engine.setDepthWrite(false);\n                scene.getOutlineRenderer().render(subMesh, batch);\n                engine.setDepthWrite(savedDepthWrite);\n            }\n            var effect;\n            if (effectiveMaterial.storeEffectOnSubMeshes) {\n                effect = subMesh.effect;\n            }\n            else {\n                effect = effectiveMaterial.getEffect();\n            }\n            effectiveMaterial._preBind(effect);\n            // Bind\n            var fillMode = scene.forcePointsCloud ? BABYLON.Material.PointFillMode : (scene.forceWireframe ? BABYLON.Material.WireFrameFillMode : effectiveMaterial.fillMode);\n            this._bind(subMesh, effect, fillMode);\n            var world = this.getWorldMatrix();\n            if (effectiveMaterial.storeEffectOnSubMeshes) {\n                effectiveMaterial.bindForSubMesh(world, this, subMesh);\n            }\n            else {\n                effectiveMaterial.bind(world, this);\n            }\n            // Draw\n            this._processRendering(subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, effectiveMaterial);\n            // Unbind\n            effectiveMaterial.unbind();\n            // Outline - step 2\n            if (this.renderOutline && savedDepthWrite) {\n                engine.setDepthWrite(true);\n                engine.setColorWrite(false);\n                scene.getOutlineRenderer().render(subMesh, batch);\n                engine.setColorWrite(true);\n            }\n            // Overlay\n            if (this.renderOverlay) {\n                var currentMode = engine.getAlphaMode();\n                engine.setAlphaMode(BABYLON.Engine.ALPHA_COMBINE);\n                scene.getOutlineRenderer().render(subMesh, batch, true);\n                engine.setAlphaMode(currentMode);\n            }\n            this.onAfterRenderObservable.notifyObservers(this);\n            return this;\n        };\n        Mesh.prototype._onBeforeDraw = function (isInstance, world, effectiveMaterial) {\n            if (isInstance) {\n                effectiveMaterial.bindOnlyWorldMatrix(world);\n            }\n            return this;\n        };\n        /**\n         * Returns an array populated with ParticleSystem objects whose the mesh is the emitter.\n         */\n        Mesh.prototype.getEmittedParticleSystems = function () {\n            var results = new Array();\n            for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n                var particleSystem = this.getScene().particleSystems[index];\n                if (particleSystem.emitter === this) {\n                    results.push(particleSystem);\n                }\n            }\n            return results;\n        };\n        /**\n         * Returns an array populated with ParticleSystem objects whose the mesh or its children are the emitter.\n         */\n        Mesh.prototype.getHierarchyEmittedParticleSystems = function () {\n            var results = new Array();\n            var descendants = this.getDescendants();\n            descendants.push(this);\n            for (var index = 0; index < this.getScene().particleSystems.length; index++) {\n                var particleSystem = this.getScene().particleSystems[index];\n                if (descendants.indexOf(particleSystem.emitter) !== -1) {\n                    results.push(particleSystem);\n                }\n            }\n            return results;\n        };\n        Mesh.prototype._checkDelayState = function () {\n            var scene = this.getScene();\n            if (this._geometry) {\n                this._geometry.load(scene);\n            }\n            else if (this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADING;\n                this._queueLoad(this, scene);\n            }\n            return this;\n        };\n        Mesh.prototype._queueLoad = function (mesh, scene) {\n            var _this = this;\n            scene._addPendingData(mesh);\n            var getBinaryData = (this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1);\n            BABYLON.Tools.LoadFile(this.delayLoadingFile, function (data) {\n                if (data instanceof ArrayBuffer) {\n                    _this._delayLoadingFunction(data, _this);\n                }\n                else {\n                    _this._delayLoadingFunction(JSON.parse(data), _this);\n                }\n                _this.instances.forEach(function (instance) {\n                    instance._syncSubMeshes();\n                });\n                _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n                scene._removePendingData(_this);\n            }, function () { }, scene.database, getBinaryData);\n            return this;\n        };\n        /**\n         * Boolean, true is the mesh in the frustum defined by the Plane objects from the `frustumPlanes` array parameter.\n         */\n        Mesh.prototype.isInFrustum = function (frustumPlanes) {\n            if (this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADING) {\n                return false;\n            }\n            if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {\n                return false;\n            }\n            this._checkDelayState();\n            return true;\n        };\n        /**\n         * Sets the mesh material by the material or multiMaterial `id` property.\n         * The material `id` is a string identifying the material or the multiMaterial.\n         * This method returns the Mesh.\n         */\n        Mesh.prototype.setMaterialByID = function (id) {\n            var materials = this.getScene().materials;\n            var index;\n            for (index = materials.length - 1; index > -1; index--) {\n                if (materials[index].id === id) {\n                    this.material = materials[index];\n                    return this;\n                }\n            }\n            // Multi\n            var multiMaterials = this.getScene().multiMaterials;\n            for (index = multiMaterials.length - 1; index > -1; index--) {\n                if (multiMaterials[index].id === id) {\n                    this.material = multiMaterials[index];\n                    return this;\n                }\n            }\n            return this;\n        };\n        /**\n         * Returns as a new array populated with the mesh material and/or skeleton, if any.\n         */\n        Mesh.prototype.getAnimatables = function () {\n            var results = [];\n            if (this.material) {\n                results.push(this.material);\n            }\n            if (this.skeleton) {\n                results.push(this.skeleton);\n            }\n            return results;\n        };\n        /**\n         * Modifies the mesh geometry according to the passed transformation matrix.\n         * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.\n         * The mesh normals are modified accordingly the same transformation.\n         * tuto : http://doc.babylonjs.com/tutorials/How_Rotations_and_Translations_Work#baking-transform\n         * Note that, under the hood, this method sets a new VertexBuffer each call.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.bakeTransformIntoVertices = function (transform) {\n            // Position\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind)) {\n                return this;\n            }\n            var submeshes = this.subMeshes.splice(0);\n            this._resetPointsArrayCache();\n            var data = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var temp = [];\n            var index;\n            for (index = 0; index < data.length; index += 3) {\n                BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.FromArray(data, index), transform).toArray(temp, index);\n            }\n            this.setVerticesData(BABYLON.VertexBuffer.PositionKind, temp, this.getVertexBuffer(BABYLON.VertexBuffer.PositionKind).isUpdatable());\n            // Normals\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                return this;\n            }\n            data = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            temp = [];\n            for (index = 0; index < data.length; index += 3) {\n                BABYLON.Vector3.TransformNormal(BABYLON.Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);\n            }\n            this.setVerticesData(BABYLON.VertexBuffer.NormalKind, temp, this.getVertexBuffer(BABYLON.VertexBuffer.NormalKind).isUpdatable());\n            // flip faces?\n            if (transform.m[0] * transform.m[5] * transform.m[10] < 0) {\n                this.flipFaces();\n            }\n            // Restore submeshes\n            this.releaseSubMeshes();\n            this.subMeshes = submeshes;\n            return this;\n        };\n        /**\n         * Modifies the mesh geometry according to its own current World Matrix.\n         * The mesh World Matrix is then reset.\n         * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n         * tuto : tuto : http://doc.babylonjs.com/tutorials/How_Rotations_and_Translations_Work#baking-transform\n         * Note that, under the hood, this method sets a new VertexBuffer each call.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.bakeCurrentTransformIntoVertices = function () {\n            this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n            this.scaling.copyFromFloats(1, 1, 1);\n            this.position.copyFromFloats(0, 0, 0);\n            this.rotation.copyFromFloats(0, 0, 0);\n            //only if quaternion is already set\n            if (this.rotationQuaternion) {\n                this.rotationQuaternion = BABYLON.Quaternion.Identity();\n            }\n            this._worldMatrix = BABYLON.Matrix.Identity();\n            return this;\n        };\n        Object.defineProperty(Mesh.prototype, \"_positions\", {\n            // Cache\n            get: function () {\n                if (this._geometry) {\n                    return this._geometry._positions;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Mesh.prototype._resetPointsArrayCache = function () {\n            if (this._geometry) {\n                this._geometry._resetPointsArrayCache();\n            }\n            return this;\n        };\n        Mesh.prototype._generatePointsArray = function () {\n            if (this._geometry) {\n                return this._geometry._generatePointsArray();\n            }\n            return false;\n        };\n        /**\n         * Returns a new Mesh object generated from the current mesh properties.\n         * This method must not get confused with createInstance().\n         * The parameter `name` is a string, the name given to the new mesh.\n         * The optional parameter `newParent` can be any Node object (default `null`).\n         * The optional parameter `doNotCloneChildren` (default `false`) allows/denies the recursive cloning of the original mesh children if any.\n         * The parameter `clonePhysicsImpostor` (default `true`)  allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any.\n         */\n        Mesh.prototype.clone = function (name, newParent, doNotCloneChildren, clonePhysicsImpostor) {\n            if (clonePhysicsImpostor === void 0) { clonePhysicsImpostor = true; }\n            return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n        };\n        /**\n         * Disposes the mesh.\n         * This also frees the memory allocated under the hood to all the buffers used by WebGL.\n         */\n        Mesh.prototype.dispose = function (doNotRecurse) {\n            var _this = this;\n            this.morphTargetManager = undefined;\n            if (this._geometry) {\n                this._geometry.releaseForMesh(this, true);\n            }\n            // Sources\n            var meshes = this.getScene().meshes;\n            meshes.forEach(function (mesh) {\n                if (mesh._source && mesh._source === _this) {\n                    mesh._source = null;\n                }\n            });\n            this._source = null;\n            // Instances\n            if (this._instancesBuffer) {\n                this._instancesBuffer.dispose();\n                this._instancesBuffer = null;\n            }\n            while (this.instances.length) {\n                this.instances[0].dispose();\n            }\n            // Highlight layers.\n            var highlightLayers = this.getScene().highlightLayers;\n            for (var i = 0; i < highlightLayers.length; i++) {\n                var highlightLayer = highlightLayers[i];\n                if (highlightLayer) {\n                    highlightLayer.removeMesh(this);\n                    highlightLayer.removeExcludedMesh(this);\n                }\n            }\n            _super.prototype.dispose.call(this, doNotRecurse);\n        };\n        /**\n         * Modifies the mesh geometry according to a displacement map.\n         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n         * This method returns nothing.\n         * The parameter `url` is a string, the URL from the image file is to be downloaded.\n         * The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.\n         * The parameter `onSuccess` is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n         * The parameter `uvOffset` is an optional vector2 used to offset UV.\n         * The parameter `uvScale` is an optional vector2 used to scale UV.\n         *\n         * Returns the Mesh.\n         */\n        Mesh.prototype.applyDisplacementMap = function (url, minHeight, maxHeight, onSuccess, uvOffset, uvScale) {\n            var _this = this;\n            var scene = this.getScene();\n            var onload = function (img) {\n                // Getting height map data\n                var canvas = document.createElement(\"canvas\");\n                var context = canvas.getContext(\"2d\");\n                var heightMapWidth = img.width;\n                var heightMapHeight = img.height;\n                canvas.width = heightMapWidth;\n                canvas.height = heightMapHeight;\n                context.drawImage(img, 0, 0);\n                // Create VertexData from map data\n                //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n                var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n                _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale);\n                //execute success callback, if set\n                if (onSuccess) {\n                    onSuccess(_this);\n                }\n            };\n            BABYLON.Tools.LoadImage(url, onload, function () { }, scene.database);\n            return this;\n        };\n        /**\n         * Modifies the mesh geometry according to a displacementMap buffer.\n         * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n         * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n         * This method returns nothing.\n         * The parameter `buffer` is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n         * The parameters `heightMapWidth` and `heightMapHeight` are positive integers to set the width and height of the buffer image.\n         * The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.\n         * The parameter `uvOffset` is an optional vector2 used to offset UV.\n         * The parameter `uvScale` is an optional vector2 used to scale UV.\n         *\n         * Returns the Mesh.\n         */\n        Mesh.prototype.applyDisplacementMapFromBuffer = function (buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale) {\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind)\n                || !this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)\n                || !this.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                BABYLON.Tools.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n                return this;\n            }\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var normals = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var uvs = this.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var position = BABYLON.Vector3.Zero();\n            var normal = BABYLON.Vector3.Zero();\n            var uv = BABYLON.Vector2.Zero();\n            uvOffset = uvOffset || BABYLON.Vector2.Zero();\n            uvScale = uvScale || new BABYLON.Vector2(1, 1);\n            for (var index = 0; index < positions.length; index += 3) {\n                BABYLON.Vector3.FromArrayToRef(positions, index, position);\n                BABYLON.Vector3.FromArrayToRef(normals, index, normal);\n                BABYLON.Vector2.FromArrayToRef(uvs, (index / 3) * 2, uv);\n                // Compute height\n                var u = ((Math.abs(uv.x * uvScale.x + uvOffset.x) * heightMapWidth) % heightMapWidth) | 0;\n                var v = ((Math.abs(uv.y * uvScale.y + uvOffset.y) * heightMapHeight) % heightMapHeight) | 0;\n                var pos = (u + v * heightMapWidth) * 4;\n                var r = buffer[pos] / 255.0;\n                var g = buffer[pos + 1] / 255.0;\n                var b = buffer[pos + 2] / 255.0;\n                var gradient = r * 0.3 + g * 0.59 + b * 0.11;\n                normal.normalize();\n                normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n                position = position.add(normal);\n                position.toArray(positions, index);\n            }\n            BABYLON.VertexData.ComputeNormals(positions, this.getIndices(), normals);\n            this.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);\n            this.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);\n            return this;\n        };\n        /**\n         * Modify the mesh to get a flat shading rendering.\n         * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n         * This method returns the Mesh.\n         * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n         */\n        Mesh.prototype.convertToFlatShadedMesh = function () {\n            /// <summary>Update normals and vertices to get a flat shading rendering.</summary>\n            /// <summary>Warning: This may imply adding vertices to the mesh in order to get exactly 3 vertices per face</summary>\n            var kinds = this.getVerticesDataKinds();\n            var vbs = [];\n            var data = [];\n            var newdata = [];\n            var updatableNormals = false;\n            var kindIndex;\n            var kind;\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                var vertexBuffer = this.getVertexBuffer(kind);\n                if (kind === BABYLON.VertexBuffer.NormalKind) {\n                    updatableNormals = vertexBuffer.isUpdatable();\n                    kinds.splice(kindIndex, 1);\n                    kindIndex--;\n                    continue;\n                }\n                vbs[kind] = vertexBuffer;\n                data[kind] = vbs[kind].getData();\n                newdata[kind] = [];\n            }\n            // Save previous submeshes\n            var previousSubmeshes = this.subMeshes.slice(0);\n            var indices = this.getIndices();\n            var totalIndices = this.getTotalIndices();\n            // Generating unique vertices per face\n            var index;\n            for (index = 0; index < totalIndices; index++) {\n                var vertexIndex = indices[index];\n                for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                    kind = kinds[kindIndex];\n                    var stride = vbs[kind].getStrideSize();\n                    for (var offset = 0; offset < stride; offset++) {\n                        newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                    }\n                }\n            }\n            // Updating faces & normal\n            var normals = [];\n            var positions = newdata[BABYLON.VertexBuffer.PositionKind];\n            for (index = 0; index < totalIndices; index += 3) {\n                indices[index] = index;\n                indices[index + 1] = index + 1;\n                indices[index + 2] = index + 2;\n                var p1 = BABYLON.Vector3.FromArray(positions, index * 3);\n                var p2 = BABYLON.Vector3.FromArray(positions, (index + 1) * 3);\n                var p3 = BABYLON.Vector3.FromArray(positions, (index + 2) * 3);\n                var p1p2 = p1.subtract(p2);\n                var p3p2 = p3.subtract(p2);\n                var normal = BABYLON.Vector3.Normalize(BABYLON.Vector3.Cross(p1p2, p3p2));\n                // Store same normals for every vertex\n                for (var localIndex = 0; localIndex < 3; localIndex++) {\n                    normals.push(normal.x);\n                    normals.push(normal.y);\n                    normals.push(normal.z);\n                }\n            }\n            this.setIndices(indices);\n            this.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatableNormals);\n            // Updating vertex buffers\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n            }\n            // Updating submeshes\n            this.releaseSubMeshes();\n            for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n                var previousOne = previousSubmeshes[submeshIndex];\n                var subMesh = new BABYLON.SubMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n            }\n            this.synchronizeInstances();\n            return this;\n        };\n        /**\n         * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n         * In other words, more vertices, no more indices and a single bigger VBO.\n         * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n         * Returns the Mesh.\n         */\n        Mesh.prototype.convertToUnIndexedMesh = function () {\n            /// <summary>Remove indices by unfolding faces into buffers</summary>\n            /// <summary>Warning: This implies adding vertices to the mesh in order to get exactly 3 vertices per face</summary>\n            var kinds = this.getVerticesDataKinds();\n            var vbs = [];\n            var data = [];\n            var newdata = [];\n            var updatableNormals = false;\n            var kindIndex;\n            var kind;\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                var vertexBuffer = this.getVertexBuffer(kind);\n                vbs[kind] = vertexBuffer;\n                data[kind] = vbs[kind].getData();\n                newdata[kind] = [];\n            }\n            // Save previous submeshes\n            var previousSubmeshes = this.subMeshes.slice(0);\n            var indices = this.getIndices();\n            var totalIndices = this.getTotalIndices();\n            // Generating unique vertices per face\n            var index;\n            for (index = 0; index < totalIndices; index++) {\n                var vertexIndex = indices[index];\n                for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                    kind = kinds[kindIndex];\n                    var stride = vbs[kind].getStrideSize();\n                    for (var offset = 0; offset < stride; offset++) {\n                        newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n                    }\n                }\n            }\n            // Updating indices\n            for (index = 0; index < totalIndices; index += 3) {\n                indices[index] = index;\n                indices[index + 1] = index + 1;\n                indices[index + 2] = index + 2;\n            }\n            this.setIndices(indices);\n            // Updating vertex buffers\n            for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n                kind = kinds[kindIndex];\n                this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n            }\n            // Updating submeshes\n            this.releaseSubMeshes();\n            for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n                var previousOne = previousSubmeshes[submeshIndex];\n                var subMesh = new BABYLON.SubMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n            }\n            this._unIndexed = true;\n            this.synchronizeInstances();\n            return this;\n        };\n        /**\n         * Inverses facet orientations and inverts also the normals with `flipNormals` (default `false`) if true.\n         * This method returns the Mesh.\n         * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n         */\n        Mesh.prototype.flipFaces = function (flipNormals) {\n            if (flipNormals === void 0) { flipNormals = false; }\n            var vertex_data = BABYLON.VertexData.ExtractFromMesh(this);\n            var i;\n            if (flipNormals && this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                for (i = 0; i < vertex_data.normals.length; i++) {\n                    vertex_data.normals[i] *= -1;\n                }\n            }\n            var temp;\n            for (i = 0; i < vertex_data.indices.length; i += 3) {\n                // reassign indices\n                temp = vertex_data.indices[i + 1];\n                vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n                vertex_data.indices[i + 2] = temp;\n            }\n            vertex_data.applyToMesh(this);\n            return this;\n        };\n        // Instances\n        /**\n         * Creates a new InstancedMesh object from the mesh model.\n         * An instance shares the same properties and the same material than its model.\n         * Only these properties of each instance can then be set individually :\n         * - position\n         * - rotation\n         * - rotationQuaternion\n         * - setPivotMatrix\n         * - scaling\n         * tuto : http://doc.babylonjs.com/tutorials/How_to_use_Instances\n         * Warning : this method is not supported for Line mesh and LineSystem\n         */\n        Mesh.prototype.createInstance = function (name) {\n            return new BABYLON.InstancedMesh(name, this);\n        };\n        /**\n         * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n         * After this call, all the mesh instances have the same submeshes than the current mesh.\n         * This method returns the Mesh.\n         */\n        Mesh.prototype.synchronizeInstances = function () {\n            for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n                var instance = this.instances[instanceIndex];\n                instance._syncSubMeshes();\n            }\n            return this;\n        };\n        /**\n         * Simplify the mesh according to the given array of settings.\n         * Function will return immediately and will simplify async. It returns the Mesh.\n         * @param settings a collection of simplification settings.\n         * @param parallelProcessing should all levels calculate parallel or one after the other.\n         * @param type the type of simplification to run.\n         * @param successCallback optional success callback to be called after the simplification finished processing all settings.\n         */\n        Mesh.prototype.simplify = function (settings, parallelProcessing, simplificationType, successCallback) {\n            if (parallelProcessing === void 0) { parallelProcessing = true; }\n            if (simplificationType === void 0) { simplificationType = BABYLON.SimplificationType.QUADRATIC; }\n            this.getScene().simplificationQueue.addTask({\n                settings: settings,\n                parallelProcessing: parallelProcessing,\n                mesh: this,\n                simplificationType: simplificationType,\n                successCallback: successCallback\n            });\n            return this;\n        };\n        /**\n         * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n         * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n         * This should be used together with the simplification to avoid disappearing triangles.\n         * Returns the Mesh.\n         * @param successCallback an optional success callback to be called after the optimization finished.\n         */\n        Mesh.prototype.optimizeIndices = function (successCallback) {\n            var _this = this;\n            var indices = this.getIndices();\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var vectorPositions = [];\n            for (var pos = 0; pos < positions.length; pos = pos + 3) {\n                vectorPositions.push(BABYLON.Vector3.FromArray(positions, pos));\n            }\n            var dupes = [];\n            BABYLON.AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function (iteration) {\n                var realPos = vectorPositions.length - 1 - iteration;\n                var testedPosition = vectorPositions[realPos];\n                for (var j = 0; j < realPos; ++j) {\n                    var againstPosition = vectorPositions[j];\n                    if (testedPosition.equals(againstPosition)) {\n                        dupes[realPos] = j;\n                        break;\n                    }\n                }\n            }, function () {\n                for (var i = 0; i < indices.length; ++i) {\n                    indices[i] = dupes[indices[i]] || indices[i];\n                }\n                //indices are now reordered\n                var originalSubMeshes = _this.subMeshes.slice(0);\n                _this.setIndices(indices);\n                _this.subMeshes = originalSubMeshes;\n                if (successCallback) {\n                    successCallback(_this);\n                }\n            });\n            return this;\n        };\n        Mesh.prototype.serialize = function (serializationObject) {\n            serializationObject.name = this.name;\n            serializationObject.id = this.id;\n            serializationObject.type = this.getClassName();\n            if (BABYLON.Tags && BABYLON.Tags.HasTags(this)) {\n                serializationObject.tags = BABYLON.Tags.GetTags(this);\n            }\n            serializationObject.position = this.position.asArray();\n            if (this.rotationQuaternion) {\n                serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n            }\n            else if (this.rotation) {\n                serializationObject.rotation = this.rotation.asArray();\n            }\n            serializationObject.scaling = this.scaling.asArray();\n            serializationObject.localMatrix = this.getPivotMatrix().asArray();\n            serializationObject.isEnabled = this.isEnabled();\n            serializationObject.isVisible = this.isVisible;\n            serializationObject.infiniteDistance = this.infiniteDistance;\n            serializationObject.pickable = this.isPickable;\n            serializationObject.receiveShadows = this.receiveShadows;\n            serializationObject.billboardMode = this.billboardMode;\n            serializationObject.visibility = this.visibility;\n            serializationObject.checkCollisions = this.checkCollisions;\n            serializationObject.isBlocker = this.isBlocker;\n            // Parent\n            if (this.parent) {\n                serializationObject.parentId = this.parent.id;\n            }\n            // Geometry\n            var geometry = this._geometry;\n            if (geometry) {\n                var geometryId = geometry.id;\n                serializationObject.geometryId = geometryId;\n                // SubMeshes\n                serializationObject.subMeshes = [];\n                for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n                    var subMesh = this.subMeshes[subIndex];\n                    serializationObject.subMeshes.push({\n                        materialIndex: subMesh.materialIndex,\n                        verticesStart: subMesh.verticesStart,\n                        verticesCount: subMesh.verticesCount,\n                        indexStart: subMesh.indexStart,\n                        indexCount: subMesh.indexCount\n                    });\n                }\n            }\n            // Material\n            if (this.material) {\n                serializationObject.materialId = this.material.id;\n            }\n            else {\n                this.material = null;\n            }\n            // Morph targets\n            if (this.morphTargetManager) {\n                serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n            }\n            // Skeleton\n            if (this.skeleton) {\n                serializationObject.skeletonId = this.skeleton.id;\n            }\n            // Physics\n            //TODO implement correct serialization for physics impostors.\n            if (this.getPhysicsImpostor()) {\n                var impostor = this.getPhysicsImpostor();\n                serializationObject.physicsMass = impostor.getParam(\"mass\");\n                serializationObject.physicsFriction = impostor.getParam(\"friction\");\n                serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n                serializationObject.physicsImpostor = this.getPhysicsImpostor().type;\n            }\n            // Metadata\n            if (this.metadata) {\n                serializationObject.metadata = this.metadata;\n            }\n            // Instances\n            serializationObject.instances = [];\n            for (var index = 0; index < this.instances.length; index++) {\n                var instance = this.instances[index];\n                var serializationInstance = {\n                    name: instance.name,\n                    position: instance.position.asArray(),\n                    scaling: instance.scaling.asArray()\n                };\n                if (instance.rotationQuaternion) {\n                    serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n                }\n                else if (instance.rotation) {\n                    serializationInstance.rotation = instance.rotation.asArray();\n                }\n                serializationObject.instances.push(serializationInstance);\n                // Animations\n                BABYLON.Animation.AppendSerializedAnimations(instance, serializationInstance);\n                serializationInstance.ranges = instance.serializeAnimationRanges();\n            }\n            // \n            // Animations\n            BABYLON.Animation.AppendSerializedAnimations(this, serializationObject);\n            serializationObject.ranges = this.serializeAnimationRanges();\n            // Layer mask\n            serializationObject.layerMask = this.layerMask;\n            // Alpha\n            serializationObject.alphaIndex = this.alphaIndex;\n            serializationObject.hasVertexAlpha = this.hasVertexAlpha;\n            // Overlay\n            serializationObject.overlayAlpha = this.overlayAlpha;\n            serializationObject.overlayColor = this.overlayColor.asArray();\n            serializationObject.renderOverlay = this.renderOverlay;\n            // Fog\n            serializationObject.applyFog = this.applyFog;\n            // Action Manager\n            if (this.actionManager) {\n                serializationObject.actions = this.actionManager.serialize(this.name);\n            }\n        };\n        Mesh.prototype._syncGeometryWithMorphTargetManager = function () {\n            if (!this.geometry) {\n                return;\n            }\n            this._markSubMeshesAsAttributesDirty();\n            if (this._morphTargetManager && this._morphTargetManager.vertexCount) {\n                if (this._morphTargetManager.vertexCount !== this.getTotalVertices()) {\n                    BABYLON.Tools.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n                    this.morphTargetManager = undefined;\n                    return;\n                }\n                for (var index = 0; index < this.morphTargetManager.numInfluencers; index++) {\n                    var morphTarget = this.morphTargetManager.getActiveTarget(index);\n                    this.geometry.setVerticesData(BABYLON.VertexBuffer.PositionKind + index, morphTarget.getPositions(), false, 3);\n                    if (morphTarget.hasNormals) {\n                        this.geometry.setVerticesData(BABYLON.VertexBuffer.NormalKind + index, morphTarget.getNormals(), false, 3);\n                    }\n                    if (morphTarget.hasTangents) {\n                        this.geometry.setVerticesData(BABYLON.VertexBuffer.TangentKind + index, morphTarget.getTangents(), false, 3);\n                    }\n                }\n            }\n            else {\n                var index = 0;\n                // Positions\n                while (this.geometry.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind + index)) {\n                    this.geometry.removeVerticesData(BABYLON.VertexBuffer.PositionKind + index);\n                    if (this.geometry.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind + index)) {\n                        this.geometry.removeVerticesData(BABYLON.VertexBuffer.NormalKind + index);\n                    }\n                    if (this.geometry.isVerticesDataPresent(BABYLON.VertexBuffer.TangentKind + index)) {\n                        this.geometry.removeVerticesData(BABYLON.VertexBuffer.TangentKind + index);\n                    }\n                    index++;\n                }\n            }\n        };\n        // Statics\n        /**\n         * Returns a new Mesh object what is a deep copy of the passed mesh.\n         * The parameter `parsedMesh` is the mesh to be copied.\n         * The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with\n         */\n        Mesh.Parse = function (parsedMesh, scene, rootUrl) {\n            var mesh;\n            if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n                mesh = BABYLON.GroundMesh.Parse(parsedMesh, scene);\n            }\n            else {\n                mesh = new Mesh(parsedMesh.name, scene);\n            }\n            mesh.id = parsedMesh.id;\n            if (BABYLON.Tags) {\n                BABYLON.Tags.AddTagsTo(mesh, parsedMesh.tags);\n            }\n            mesh.position = BABYLON.Vector3.FromArray(parsedMesh.position);\n            if (parsedMesh.metadata !== undefined) {\n                mesh.metadata = parsedMesh.metadata;\n            }\n            if (parsedMesh.rotationQuaternion) {\n                mesh.rotationQuaternion = BABYLON.Quaternion.FromArray(parsedMesh.rotationQuaternion);\n            }\n            else if (parsedMesh.rotation) {\n                mesh.rotation = BABYLON.Vector3.FromArray(parsedMesh.rotation);\n            }\n            mesh.scaling = BABYLON.Vector3.FromArray(parsedMesh.scaling);\n            if (parsedMesh.localMatrix) {\n                mesh.setPivotMatrix(BABYLON.Matrix.FromArray(parsedMesh.localMatrix));\n            }\n            else if (parsedMesh.pivotMatrix) {\n                mesh.setPivotMatrix(BABYLON.Matrix.FromArray(parsedMesh.pivotMatrix));\n            }\n            mesh.setEnabled(parsedMesh.isEnabled);\n            mesh.isVisible = parsedMesh.isVisible;\n            mesh.infiniteDistance = parsedMesh.infiniteDistance;\n            mesh.showBoundingBox = parsedMesh.showBoundingBox;\n            mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n            if (parsedMesh.applyFog !== undefined) {\n                mesh.applyFog = parsedMesh.applyFog;\n            }\n            if (parsedMesh.pickable !== undefined) {\n                mesh.isPickable = parsedMesh.pickable;\n            }\n            if (parsedMesh.alphaIndex !== undefined) {\n                mesh.alphaIndex = parsedMesh.alphaIndex;\n            }\n            mesh.receiveShadows = parsedMesh.receiveShadows;\n            mesh.billboardMode = parsedMesh.billboardMode;\n            if (parsedMesh.visibility !== undefined) {\n                mesh.visibility = parsedMesh.visibility;\n            }\n            mesh.checkCollisions = parsedMesh.checkCollisions;\n            if (parsedMesh.isBlocker !== undefined) {\n                mesh.isBlocker = parsedMesh.isBlocker;\n            }\n            mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;\n            // freezeWorldMatrix\n            if (parsedMesh.freezeWorldMatrix) {\n                mesh._waitingFreezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n            }\n            // Parent\n            if (parsedMesh.parentId) {\n                mesh._waitingParentId = parsedMesh.parentId;\n            }\n            // Actions\n            if (parsedMesh.actions !== undefined) {\n                mesh._waitingActions = parsedMesh.actions;\n            }\n            // Overlay\n            if (parsedMesh.overlayAlpha !== undefined) {\n                mesh.overlayAlpha = parsedMesh.overlayAlpha;\n            }\n            if (parsedMesh.overlayColor !== undefined) {\n                mesh.overlayColor = BABYLON.Color3.FromArray(parsedMesh.overlayColor);\n            }\n            if (parsedMesh.renderOverlay !== undefined) {\n                mesh.renderOverlay = parsedMesh.renderOverlay;\n            }\n            // Geometry\n            mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n            if (parsedMesh.delayLoadingFile) {\n                mesh.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n                mesh._boundingInfo = new BABYLON.BoundingInfo(BABYLON.Vector3.FromArray(parsedMesh.boundingBoxMinimum), BABYLON.Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n                if (parsedMesh._binaryInfo) {\n                    mesh._binaryInfo = parsedMesh._binaryInfo;\n                }\n                mesh._delayInfo = [];\n                if (parsedMesh.hasUVs) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UVKind);\n                }\n                if (parsedMesh.hasUVs2) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UV2Kind);\n                }\n                if (parsedMesh.hasUVs3) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UV3Kind);\n                }\n                if (parsedMesh.hasUVs4) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UV4Kind);\n                }\n                if (parsedMesh.hasUVs5) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UV5Kind);\n                }\n                if (parsedMesh.hasUVs6) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.UV6Kind);\n                }\n                if (parsedMesh.hasColors) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.ColorKind);\n                }\n                if (parsedMesh.hasMatricesIndices) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                }\n                if (parsedMesh.hasMatricesWeights) {\n                    mesh._delayInfo.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                }\n                mesh._delayLoadingFunction = BABYLON.Geometry.ImportGeometry;\n                if (BABYLON.SceneLoader.ForceFullSceneLoadingForIncremental) {\n                    mesh._checkDelayState();\n                }\n            }\n            else {\n                BABYLON.Geometry.ImportGeometry(parsedMesh, mesh);\n            }\n            // Material\n            if (parsedMesh.materialId) {\n                mesh.setMaterialByID(parsedMesh.materialId);\n            }\n            else {\n                mesh.material = null;\n            }\n            // Morph targets\n            if (parsedMesh.morphTargetManagerId > -1) {\n                mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n            }\n            // Skeleton\n            if (parsedMesh.skeletonId > -1) {\n                mesh.skeleton = scene.getLastSkeletonByID(parsedMesh.skeletonId);\n                if (parsedMesh.numBoneInfluencers) {\n                    mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n                }\n            }\n            // Animations\n            if (parsedMesh.animations) {\n                for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedMesh.animations[animationIndex];\n                    mesh.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n                BABYLON.Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n            }\n            if (parsedMesh.autoAnimate) {\n                scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n            }\n            // Layer Mask\n            if (parsedMesh.layerMask && (!isNaN(parsedMesh.layerMask))) {\n                mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n            }\n            else {\n                mesh.layerMask = 0x0FFFFFFF;\n            }\n            // Physics\n            if (parsedMesh.physicsImpostor) {\n                mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, parsedMesh.physicsImpostor, {\n                    mass: parsedMesh.physicsMass,\n                    friction: parsedMesh.physicsFriction,\n                    restitution: parsedMesh.physicsRestitution\n                }, scene);\n            }\n            // Instances\n            if (parsedMesh.instances) {\n                for (var index = 0; index < parsedMesh.instances.length; index++) {\n                    var parsedInstance = parsedMesh.instances[index];\n                    var instance = mesh.createInstance(parsedInstance.name);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(instance, parsedInstance.tags);\n                    }\n                    instance.position = BABYLON.Vector3.FromArray(parsedInstance.position);\n                    if (parsedInstance.parentId) {\n                        instance._waitingParentId = parsedInstance.parentId;\n                    }\n                    if (parsedInstance.rotationQuaternion) {\n                        instance.rotationQuaternion = BABYLON.Quaternion.FromArray(parsedInstance.rotationQuaternion);\n                    }\n                    else if (parsedInstance.rotation) {\n                        instance.rotation = BABYLON.Vector3.FromArray(parsedInstance.rotation);\n                    }\n                    instance.scaling = BABYLON.Vector3.FromArray(parsedInstance.scaling);\n                    instance.checkCollisions = mesh.checkCollisions;\n                    if (parsedMesh.animations) {\n                        for (animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n                            parsedAnimation = parsedMesh.animations[animationIndex];\n                            instance.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                        }\n                        BABYLON.Node.ParseAnimationRanges(instance, parsedMesh, scene);\n                    }\n                }\n            }\n            return mesh;\n        };\n        /**\n         * Creates a ribbon mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The ribbon is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         *\n         * Please read this full tutorial to understand how to design a ribbon : http://doc.babylonjs.com/tutorials/Ribbon_Tutorial\n         * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.\n         * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array.\n         * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array.\n         * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path.\n         * It's the offset to join together the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11.\n         * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\n            return BABYLON.MeshBuilder.CreateRibbon(name, {\n                pathArray: pathArray,\n                closeArray: closeArray,\n                closePath: closePath,\n                offset: offset,\n                updatable: updatable,\n                sideOrientation: sideOrientation,\n                instance: instance\n            }, scene);\n        };\n        /**\n         * Creates a plane polygonal mesh.  By default, this is a disc.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `radius` sets the radius size (float) of the polygon (default 0.5).\n         * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\n            var options = {\n                radius: radius,\n                tessellation: tessellation,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateDisc(name, options, scene);\n        };\n        /**\n         * Creates a box mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `size` sets the size (float) of each box side (default 1).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateBox = function (name, size, scene, updatable, sideOrientation) {\n            var options = {\n                size: size,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateBox(name, options, scene);\n        };\n        /**\n         * Creates a sphere mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `diameter` sets the diameter size (float) of the sphere (default 1).\n         * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\n            var options = {\n                segments: segments,\n                diameterX: diameter,\n                diameterY: diameter,\n                diameterZ: diameter,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateSphere(name, options, scene);\n        };\n        /**\n         * Creates a cylinder or a cone mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n         * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n         * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n         * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n         * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\n            if (scene === undefined || !(scene instanceof BABYLON.Scene)) {\n                if (scene !== undefined) {\n                    sideOrientation = updatable || Mesh.DEFAULTSIDE;\n                    updatable = scene;\n                }\n                scene = subdivisions;\n                subdivisions = 1;\n            }\n            var options = {\n                height: height,\n                diameterTop: diameterTop,\n                diameterBottom: diameterBottom,\n                tessellation: tessellation,\n                subdivisions: subdivisions,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateCylinder(name, options, scene);\n        };\n        // Torus  (Code from SharpDX.org)\n        /**\n         * Creates a torus mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `diameter` sets the diameter size (float) of the torus (default 1).\n         * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5).\n         * The parameter `tessellation` sets the number of torus sides (postive integer, default 16).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateTorus = function (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {\n            var options = {\n                diameter: diameter,\n                thickness: thickness,\n                tessellation: tessellation,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateTorus(name, options, scene);\n        };\n        /**\n         * Creates a torus knot mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `radius` sets the global radius size (float) of the torus knot (default 2).\n         * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32).\n         * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32).\n         * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\n            var options = {\n                radius: radius,\n                tube: tube,\n                radialSegments: radialSegments,\n                tubularSegments: tubularSegments,\n                p: p,\n                q: q,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateTorusKnot(name, options, scene);\n        };\n        /**\n         * Creates a line mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.\n         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.\n         * The parameter `points` is an array successive Vector3.\n         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n         * When updating an instance, remember that only point positions can change, not the number of points.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateLines = function (name, points, scene, updatable, instance) {\n            var options = {\n                points: points,\n                updatable: updatable,\n                instance: instance\n            };\n            return BABYLON.MeshBuilder.CreateLines(name, options, scene);\n        };\n        /**\n         * Creates a dashed line mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.\n         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.\n         * The parameter `points` is an array successive Vector3.\n         * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200).\n         * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3).\n         * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1).\n         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n         * When updating an instance, remember that only point positions can change, not the number of points.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\n            var options = {\n                points: points,\n                dashSize: dashSize,\n                gapSize: gapSize,\n                dashNb: dashNb,\n                updatable: updatable,\n                instance: instance\n            };\n            return BABYLON.MeshBuilder.CreateDashedLines(name, options, scene);\n        };\n        /**\n         * Creates a polygon mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.\n         * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.\n         * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         * Remember you can only change the shape positions, not their number when updating a polygon.\n         */\n        Mesh.CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation) {\n            var options = {\n                shape: shape,\n                holes: holes,\n                updatable: updatable,\n                sideOrientation: sideOrientation\n            };\n            return BABYLON.MeshBuilder.CreatePolygon(name, options, scene);\n        };\n        /**\n          * Creates an extruded polygon mesh, with depth in the Y direction.\n          * Please consider using the same method from the MeshBuilder class instead.\n         */\n        Mesh.ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation) {\n            var options = {\n                shape: shape,\n                holes: holes,\n                depth: depth,\n                updatable: updatable,\n                sideOrientation: sideOrientation\n            };\n            return BABYLON.MeshBuilder.ExtrudePolygon(name, options, scene);\n        };\n        /**\n         * Creates an extruded shape mesh.\n         * The extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         * Please consider using the same method from the MeshBuilder class instead.\n         *\n         * Please read this full tutorial to understand how to design an extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be\n         * extruded along the Z axis.\n         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n         * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\n         * The parameter `scale` (float, default 1) is the value to scale the shape.\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape\n         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\n            var options = {\n                shape: shape,\n                path: path,\n                scale: scale,\n                rotation: rotation,\n                cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\n                sideOrientation: sideOrientation,\n                instance: instance,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.ExtrudeShape(name, options, scene);\n        };\n        /**\n         * Creates an custom extruded shape mesh.\n         * The custom extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         * Please consider using the same method from the MeshBuilder class instead.\n         *\n         * Please read this full tutorial to understand how to design a custom extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be\n         * extruded along the Z axis.\n         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n         * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path\n         * and the distance of this point from the begining of the path :\n         * ```javascript\n         * var rotationFunction = function(i, distance) {\n         *     // do things\n         *     return rotationValue; }\n         * ```\n         * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\n         * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path\n         * and the distance of this point from the begining of the path :\n         * ```javascript\n         * var scaleFunction = function(i, distance) {\n         *     // do things\n         *    return scaleValue;}\n         * ```\n         * It must returns a float value that will be the scale value applied to the shape on each path point.\n         * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`.\n         * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`.\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape\n         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\n            var options = {\n                shape: shape,\n                path: path,\n                scaleFunction: scaleFunction,\n                rotationFunction: rotationFunction,\n                ribbonCloseArray: ribbonCloseArray,\n                ribbonClosePath: ribbonClosePath,\n                cap: (cap === 0) ? 0 : cap || Mesh.NO_CAP,\n                sideOrientation: sideOrientation,\n                instance: instance,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.ExtrudeShapeCustom(name, options, scene);\n        };\n        /**\n         * Creates lathe mesh.\n         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be\n         * rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero.\n         * The parameter `radius` (positive float, default 1) is the radius value of the lathe.\n         * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\n            var options = {\n                shape: shape,\n                radius: radius,\n                tessellation: tessellation,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateLathe(name, options, scene);\n        };\n        /**\n         * Creates a plane mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `size` sets the size (float) of both sides of the plane at once (default 1).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreatePlane = function (name, size, scene, updatable, sideOrientation) {\n            var options = {\n                size: size,\n                width: size,\n                height: size,\n                sideOrientation: sideOrientation,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreatePlane(name, options, scene);\n        };\n        /**\n         * Creates a ground mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground.\n         * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateGround = function (name, width, height, subdivisions, scene, updatable) {\n            var options = {\n                width: width,\n                height: height,\n                subdivisions: subdivisions,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateGround(name, options, scene);\n        };\n        /**\n         * Creates a tiled ground mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates.\n         * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates.\n         * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the\n         * numbers of subdivisions on the ground width and height. Each subdivision is called a tile.\n         * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the\n         * numbers of subdivisions on the ground width and height of each tile.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\n            var options = {\n                xmin: xmin,\n                zmin: zmin,\n                xmax: xmax,\n                zmax: zmax,\n                subdivisions: subdivisions,\n                precision: precision,\n                updatable: updatable\n            };\n            return BABYLON.MeshBuilder.CreateTiledGround(name, options, scene);\n        };\n        /**\n         * Creates a ground mesh from a height map.\n         * tuto : http://doc.babylonjs.com/tutorials/14._Height_Map\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `url` sets the URL of the height map image resource.\n         * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n         * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n         * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n         * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n         * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n         * This function is passed the newly built mesh :\n         * ```javascript\n         * function(mesh) { // do things\n         *     return; }\n         * ```\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady) {\n            var options = {\n                width: width,\n                height: height,\n                subdivisions: subdivisions,\n                minHeight: minHeight,\n                maxHeight: maxHeight,\n                updatable: updatable,\n                onReady: onReady\n            };\n            return BABYLON.MeshBuilder.CreateGroundFromHeightMap(name, url, options, scene);\n        };\n        /**\n         * Creates a tube mesh.\n         * The tube is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube.\n         * The parameter `radius` (positive float, default 1) sets the tube radius size.\n         * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface.\n         * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`.\n         * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path.\n         * It must return a radius value (positive float) :\n         * ```javascript\n         * var radiusFunction = function(i, distance) {\n         *     // do things\n         *     return radius; }\n         * ```\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\n            var options = {\n                path: path,\n                radius: radius,\n                tessellation: tessellation,\n                radiusFunction: radiusFunction,\n                arc: 1,\n                cap: cap,\n                updatable: updatable,\n                sideOrientation: sideOrientation,\n                instance: instance\n            };\n            return BABYLON.MeshBuilder.CreateTube(name, options, scene);\n        };\n        /**\n         * Creates a polyhedron mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial\n         *  to choose the wanted type.\n         * The parameter `size` (positive float, default 1) sets the polygon size.\n         * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value).\n         * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`.\n         * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\n         * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`).\n         * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n         * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreatePolyhedron = function (name, options, scene) {\n            return BABYLON.MeshBuilder.CreatePolyhedron(name, options, scene);\n        };\n        /**\n         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * The parameter `radius` sets the radius size (float) of the icosphere (default 1).\n         * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`).\n         * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size.\n         * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        Mesh.CreateIcoSphere = function (name, options, scene) {\n            return BABYLON.MeshBuilder.CreateIcoSphere(name, options, scene);\n        };\n        /**\n         * Creates a decal mesh.\n         * Please consider using the same method from the MeshBuilder class instead.\n         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal.\n         * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates.\n         * The parameter `normal` (Vector3, default Vector3.Up) sets the normal of the mesh where the decal is applied onto in World coordinates.\n         * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling.\n         * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal.\n         */\n        Mesh.CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\n            var options = {\n                position: position,\n                normal: normal,\n                size: size,\n                angle: angle\n            };\n            return BABYLON.MeshBuilder.CreateDecal(name, sourceMesh, options);\n        };\n        // Skeletons\n        /**\n         * @returns original positions used for CPU skinning.  Useful for integrating Morphing with skeletons in same mesh.\n         */\n        Mesh.prototype.setPositionsForCPUSkinning = function () {\n            var source;\n            if (!this._sourcePositions) {\n                source = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n                this._sourcePositions = new Float32Array(source);\n                if (!this.getVertexBuffer(BABYLON.VertexBuffer.PositionKind).isUpdatable()) {\n                    this.setVerticesData(BABYLON.VertexBuffer.PositionKind, source, true);\n                }\n            }\n            return this._sourcePositions;\n        };\n        /**\n         * @returns original normals used for CPU skinning.  Useful for integrating Morphing with skeletons in same mesh.\n         */\n        Mesh.prototype.setNormalsForCPUSkinning = function () {\n            var source;\n            if (!this._sourceNormals) {\n                source = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n                this._sourceNormals = new Float32Array(source);\n                if (!this.getVertexBuffer(BABYLON.VertexBuffer.NormalKind).isUpdatable()) {\n                    this.setVerticesData(BABYLON.VertexBuffer.NormalKind, source, true);\n                }\n            }\n            return this._sourceNormals;\n        };\n        /**\n         * Updates the vertex buffer by applying transformation from the bones.\n         * Returns the Mesh.\n         *\n         * @param {skeleton} skeleton to apply\n         */\n        Mesh.prototype.applySkeleton = function (skeleton) {\n            if (!this.geometry) {\n                return this;\n            }\n            if (this.geometry._softwareSkinningRenderId == this.getScene().getRenderId()) {\n                return this;\n            }\n            this.geometry._softwareSkinningRenderId = this.getScene().getRenderId();\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind)) {\n                return this;\n            }\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                return this;\n            }\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesIndicesKind)) {\n                return this;\n            }\n            if (!this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesWeightsKind)) {\n                return this;\n            }\n            if (!this._sourcePositions) {\n                var submeshes = this.subMeshes.slice();\n                this.setPositionsForCPUSkinning();\n                this.subMeshes = submeshes;\n            }\n            if (!this._sourceNormals) {\n                this.setNormalsForCPUSkinning();\n            }\n            // positionsData checks for not being Float32Array will only pass at most once\n            var positionsData = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            if (!(positionsData instanceof Float32Array)) {\n                positionsData = new Float32Array(positionsData);\n            }\n            // normalsData checks for not being Float32Array will only pass at most once\n            var normalsData = this.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            if (!(normalsData instanceof Float32Array)) {\n                normalsData = new Float32Array(normalsData);\n            }\n            var matricesIndicesData = this.getVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind);\n            var matricesWeightsData = this.getVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind);\n            var needExtras = this.numBoneInfluencers > 4;\n            var matricesIndicesExtraData = needExtras ? this.getVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind) : null;\n            var matricesWeightsExtraData = needExtras ? this.getVerticesData(BABYLON.VertexBuffer.MatricesWeightsExtraKind) : null;\n            var skeletonMatrices = skeleton.getTransformMatrices(this);\n            var tempVector3 = BABYLON.Vector3.Zero();\n            var finalMatrix = new BABYLON.Matrix();\n            var tempMatrix = new BABYLON.Matrix();\n            var matWeightIdx = 0;\n            var inf;\n            for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n                var weight;\n                for (inf = 0; inf < 4; inf++) {\n                    weight = matricesWeightsData[matWeightIdx + inf];\n                    if (weight > 0) {\n                        BABYLON.Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, matricesIndicesData[matWeightIdx + inf] * 16, weight, tempMatrix);\n                        finalMatrix.addToSelf(tempMatrix);\n                    }\n                    else\n                        break;\n                }\n                if (needExtras) {\n                    for (inf = 0; inf < 4; inf++) {\n                        weight = matricesWeightsExtraData[matWeightIdx + inf];\n                        if (weight > 0) {\n                            BABYLON.Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, matricesIndicesExtraData[matWeightIdx + inf] * 16, weight, tempMatrix);\n                            finalMatrix.addToSelf(tempMatrix);\n                        }\n                        else\n                            break;\n                    }\n                }\n                BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(this._sourcePositions[index], this._sourcePositions[index + 1], this._sourcePositions[index + 2], finalMatrix, tempVector3);\n                tempVector3.toArray(positionsData, index);\n                BABYLON.Vector3.TransformNormalFromFloatsToRef(this._sourceNormals[index], this._sourceNormals[index + 1], this._sourceNormals[index + 2], finalMatrix, tempVector3);\n                tempVector3.toArray(normalsData, index);\n                finalMatrix.reset();\n            }\n            this.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positionsData);\n            this.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normalsData);\n            return this;\n        };\n        // Tools\n        /**\n         * Returns an object `{min:` Vector3`, max:` Vector3`}`\n         * This min and max Vector3 are the minimum and maximum vectors of each mesh bounding box from the passed array, in the World system\n         */\n        Mesh.MinMax = function (meshes) {\n            var minVector = null;\n            var maxVector = null;\n            meshes.forEach(function (mesh, index, array) {\n                var boundingBox = mesh.getBoundingInfo().boundingBox;\n                if (!minVector) {\n                    minVector = boundingBox.minimumWorld;\n                    maxVector = boundingBox.maximumWorld;\n                }\n                else {\n                    minVector.MinimizeInPlace(boundingBox.minimumWorld);\n                    maxVector.MaximizeInPlace(boundingBox.maximumWorld);\n                }\n            });\n            return {\n                min: minVector,\n                max: maxVector\n            };\n        };\n        /**\n         * Returns a Vector3, the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array.\n         */\n        Mesh.Center = function (meshesOrMinMaxVector) {\n            var minMaxVector = (meshesOrMinMaxVector instanceof Array) ? BABYLON.Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n            return BABYLON.Vector3.Center(minMaxVector.min, minMaxVector.max);\n        };\n        /**\n         * Merge the array of meshes into a single mesh for performance reasons.\n         * @param {Array<Mesh>} meshes - The vertices source.  They should all be of the same material.  Entries can empty\n         * @param {boolean} disposeSource - When true (default), dispose of the vertices from the source meshes\n         * @param {boolean} allow32BitsIndices - When the sum of the vertices > 64k, this must be set to true.\n         * @param {Mesh} meshSubclass - When set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.\n         * @param {boolean} subdivideWithSubMeshes - When true (false default), subdivide mesh to his subMesh array with meshes source.\n         */\n        Mesh.MergeMeshes = function (meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes) {\n            if (disposeSource === void 0) { disposeSource = true; }\n            var index;\n            if (!allow32BitsIndices) {\n                var totalVertices = 0;\n                // Counting vertices\n                for (index = 0; index < meshes.length; index++) {\n                    if (meshes[index]) {\n                        totalVertices += meshes[index].getTotalVertices();\n                        if (totalVertices > 65536) {\n                            BABYLON.Tools.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Merge\n            var vertexData;\n            var otherVertexData;\n            var indiceArray = new Array();\n            var source;\n            for (index = 0; index < meshes.length; index++) {\n                if (meshes[index]) {\n                    meshes[index].computeWorldMatrix(true);\n                    otherVertexData = BABYLON.VertexData.ExtractFromMesh(meshes[index], true);\n                    otherVertexData.transform(meshes[index].getWorldMatrix());\n                    if (vertexData) {\n                        vertexData.merge(otherVertexData);\n                    }\n                    else {\n                        vertexData = otherVertexData;\n                        source = meshes[index];\n                    }\n                    if (subdivideWithSubMeshes) {\n                        indiceArray.push(meshes[index].getTotalIndices());\n                    }\n                }\n            }\n            if (!meshSubclass) {\n                meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n            }\n            vertexData.applyToMesh(meshSubclass);\n            // Setting properties\n            meshSubclass.material = source.material;\n            meshSubclass.checkCollisions = source.checkCollisions;\n            // Cleaning\n            if (disposeSource) {\n                for (index = 0; index < meshes.length; index++) {\n                    if (meshes[index]) {\n                        meshes[index].dispose();\n                    }\n                }\n            }\n            // Subdivide\n            if (subdivideWithSubMeshes) {\n                //-- Suppresions du submesh global\n                meshSubclass.releaseSubMeshes();\n                index = 0;\n                var offset = 0;\n                //-- aplique la subdivision en fonction du tableau d'indices\n                while (index < indiceArray.length) {\n                    BABYLON.SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass);\n                    offset += indiceArray[index];\n                    index++;\n                }\n            }\n            return meshSubclass;\n        };\n        return Mesh;\n    }(BABYLON.AbstractMesh));\n    // Consts\n    Mesh._FRONTSIDE = 0;\n    Mesh._BACKSIDE = 1;\n    Mesh._DOUBLESIDE = 2;\n    Mesh._DEFAULTSIDE = 0;\n    Mesh._NO_CAP = 0;\n    Mesh._CAP_START = 1;\n    Mesh._CAP_END = 2;\n    Mesh._CAP_ALL = 3;\n    BABYLON.Mesh = Mesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.mesh.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var BaseSubMesh = (function () {\n        function BaseSubMesh() {\n        }\n        Object.defineProperty(BaseSubMesh.prototype, \"effect\", {\n            get: function () {\n                return this._materialEffect;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BaseSubMesh.prototype.setEffect = function (effect, defines) {\n            if (this._materialEffect === effect) {\n                return;\n            }\n            this._materialDefines = defines;\n            this._materialEffect = effect;\n        };\n        return BaseSubMesh;\n    }());\n    BABYLON.BaseSubMesh = BaseSubMesh;\n    var SubMesh = (function (_super) {\n        __extends(SubMesh, _super);\n        function SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {\n            if (createBoundingBox === void 0) { createBoundingBox = true; }\n            var _this = _super.call(this) || this;\n            _this.materialIndex = materialIndex;\n            _this.verticesStart = verticesStart;\n            _this.verticesCount = verticesCount;\n            _this.indexStart = indexStart;\n            _this.indexCount = indexCount;\n            _this._renderId = 0;\n            _this._mesh = mesh;\n            _this._renderingMesh = renderingMesh || mesh;\n            mesh.subMeshes.push(_this);\n            _this._trianglePlanes = [];\n            _this._id = mesh.subMeshes.length - 1;\n            if (createBoundingBox) {\n                _this.refreshBoundingInfo();\n                mesh.computeWorldMatrix(true);\n            }\n            return _this;\n        }\n        Object.defineProperty(SubMesh.prototype, \"IsGlobal\", {\n            get: function () {\n                return (this.verticesStart === 0 && this.verticesCount == this._mesh.getTotalVertices());\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the submesh BoudingInfo object.\n         */\n        SubMesh.prototype.getBoundingInfo = function () {\n            if (this.IsGlobal) {\n                return this._mesh.getBoundingInfo();\n            }\n            return this._boundingInfo;\n        };\n        /**\n         * Sets the submesh BoundingInfo.\n         * Return the SubMesh.\n         */\n        SubMesh.prototype.setBoundingInfo = function (boundingInfo) {\n            this._boundingInfo = boundingInfo;\n            return this;\n        };\n        /**\n         * Returns the mesh of the current submesh.\n         */\n        SubMesh.prototype.getMesh = function () {\n            return this._mesh;\n        };\n        /**\n         * Returns the rendering mesh of the submesh.\n         */\n        SubMesh.prototype.getRenderingMesh = function () {\n            return this._renderingMesh;\n        };\n        /**\n         * Returns the submesh material.\n         */\n        SubMesh.prototype.getMaterial = function () {\n            var rootMaterial = this._renderingMesh.material;\n            if (rootMaterial && rootMaterial.getSubMaterial) {\n                var multiMaterial = rootMaterial;\n                var effectiveMaterial = multiMaterial.getSubMaterial(this.materialIndex);\n                if (this._currentMaterial !== effectiveMaterial) {\n                    this._currentMaterial = effectiveMaterial;\n                    if (this._materialDefines) {\n                        this._materialDefines.markAllAsDirty();\n                    }\n                }\n                return effectiveMaterial;\n            }\n            if (!rootMaterial) {\n                return this._mesh.getScene().defaultMaterial;\n            }\n            return rootMaterial;\n        };\n        // Methods\n        /**\n         * Sets a new updated BoundingInfo object to the submesh.\n         * Returns the SubMesh.\n         */\n        SubMesh.prototype.refreshBoundingInfo = function () {\n            this._lastColliderWorldVertices = null;\n            if (this.IsGlobal) {\n                return;\n            }\n            var data = this._renderingMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            if (!data) {\n                this._boundingInfo = this._mesh._boundingInfo;\n                return;\n            }\n            var indices = this._renderingMesh.getIndices();\n            var extend;\n            //is this the only submesh?\n            if (this.indexStart === 0 && this.indexCount === indices.length) {\n                //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n                extend = { minimum: this._renderingMesh.getBoundingInfo().minimum.clone(), maximum: this._renderingMesh.getBoundingInfo().maximum.clone() };\n            }\n            else {\n                extend = BABYLON.Tools.ExtractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n            }\n            this._boundingInfo = new BABYLON.BoundingInfo(extend.minimum, extend.maximum);\n            return this;\n        };\n        SubMesh.prototype._checkCollision = function (collider) {\n            return this.getBoundingInfo()._checkCollision(collider);\n        };\n        /**\n         * Updates the submesh BoundingInfo.\n         * Returns the Submesh.\n         */\n        SubMesh.prototype.updateBoundingInfo = function (world) {\n            if (!this.getBoundingInfo()) {\n                this.refreshBoundingInfo();\n            }\n            this.getBoundingInfo().update(world);\n            return this;\n        };\n        /**\n         * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n         * Boolean returned.\n         */\n        SubMesh.prototype.isInFrustum = function (frustumPlanes) {\n            return this.getBoundingInfo().isInFrustum(frustumPlanes);\n        };\n        /**\n         * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes.\n         * Boolean returned.\n         */\n        SubMesh.prototype.isCompletelyInFrustum = function (frustumPlanes) {\n            return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);\n        };\n        /**\n         * Renders the submesh.\n         * Returns it.\n         */\n        SubMesh.prototype.render = function (enableAlphaMode) {\n            this._renderingMesh.render(this, enableAlphaMode);\n            return this;\n        };\n        /**\n         * Returns a new Index Buffer.\n         * Type returned : WebGLBuffer.\n         */\n        SubMesh.prototype.getLinesIndexBuffer = function (indices, engine) {\n            if (!this._linesIndexBuffer) {\n                var linesIndices = [];\n                for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n                    linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n                }\n                this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n                this.linesIndexCount = linesIndices.length;\n            }\n            return this._linesIndexBuffer;\n        };\n        /**\n         * True is the passed Ray intersects the submesh bounding box.\n         * Boolean returned.\n         */\n        SubMesh.prototype.canIntersects = function (ray) {\n            return ray.intersectsBox(this.getBoundingInfo().boundingBox);\n        };\n        /**\n         * Returns an object IntersectionInfo.\n         */\n        SubMesh.prototype.intersects = function (ray, positions, indices, fastCheck) {\n            var intersectInfo = null;\n            // LineMesh first as it's also a Mesh...\n            if (this._mesh instanceof BABYLON.LinesMesh) {\n                var lineMesh = this._mesh;\n                // Line test\n                for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n                    var p0 = positions[indices[index]];\n                    var p1 = positions[indices[index + 1]];\n                    var length = ray.intersectionSegment(p0, p1, lineMesh.intersectionThreshold);\n                    if (length < 0) {\n                        continue;\n                    }\n                    if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n                        intersectInfo = new BABYLON.IntersectionInfo(null, null, length);\n                        if (fastCheck) {\n                            break;\n                        }\n                    }\n                }\n            }\n            else {\n                // Triangles test\n                for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n                    var p0 = positions[indices[index]];\n                    var p1 = positions[indices[index + 1]];\n                    var p2 = positions[indices[index + 2]];\n                    var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n                    if (currentIntersectInfo) {\n                        if (currentIntersectInfo.distance < 0) {\n                            continue;\n                        }\n                        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n                            intersectInfo = currentIntersectInfo;\n                            intersectInfo.faceId = index / 3;\n                            if (fastCheck) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return intersectInfo;\n        };\n        // Clone    \n        /**\n         * Creates a new Submesh from the passed Mesh.\n         */\n        SubMesh.prototype.clone = function (newMesh, newRenderingMesh) {\n            var result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n            if (!this.IsGlobal) {\n                result._boundingInfo = new BABYLON.BoundingInfo(this.getBoundingInfo().minimum, this.getBoundingInfo().maximum);\n            }\n            return result;\n        };\n        // Dispose\n        /**\n         * Disposes the Submesh.\n         * Returns nothing.\n         */\n        SubMesh.prototype.dispose = function () {\n            if (this._linesIndexBuffer) {\n                this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n                this._linesIndexBuffer = null;\n            }\n            // Remove from mesh\n            var index = this._mesh.subMeshes.indexOf(this);\n            this._mesh.subMeshes.splice(index, 1);\n        };\n        // Statics\n        /**\n         * Creates a new Submesh from the passed parameters :\n         * - materialIndex (integer) : the index of the main mesh material.\n         * - startIndex (integer) : the index where to start the copy in the mesh indices array.\n         * - indexCount (integer) : the number of indices to copy then from the startIndex.\n         * - mesh (Mesh) : the main mesh to create the submesh from.\n         * - renderingMesh (optional Mesh) : rendering mesh.\n         */\n        SubMesh.CreateFromIndices = function (materialIndex, startIndex, indexCount, mesh, renderingMesh) {\n            var minVertexIndex = Number.MAX_VALUE;\n            var maxVertexIndex = -Number.MAX_VALUE;\n            renderingMesh = renderingMesh || mesh;\n            var indices = renderingMesh.getIndices();\n            for (var index = startIndex; index < startIndex + indexCount; index++) {\n                var vertexIndex = indices[index];\n                if (vertexIndex < minVertexIndex)\n                    minVertexIndex = vertexIndex;\n                if (vertexIndex > maxVertexIndex)\n                    maxVertexIndex = vertexIndex;\n            }\n            return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh);\n        };\n        return SubMesh;\n    }(BaseSubMesh));\n    BABYLON.SubMesh = SubMesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.subMesh.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var EffectFallbacks = (function () {\n        function EffectFallbacks() {\n            this._defines = {};\n            this._currentRank = 32;\n            this._maxRank = -1;\n        }\n        EffectFallbacks.prototype.addFallback = function (rank, define) {\n            if (!this._defines[rank]) {\n                if (rank < this._currentRank) {\n                    this._currentRank = rank;\n                }\n                if (rank > this._maxRank) {\n                    this._maxRank = rank;\n                }\n                this._defines[rank] = new Array();\n            }\n            this._defines[rank].push(define);\n        };\n        EffectFallbacks.prototype.addCPUSkinningFallback = function (rank, mesh) {\n            this._meshRank = rank;\n            this._mesh = mesh;\n            if (rank < this._currentRank) {\n                this._currentRank = rank;\n            }\n            if (rank > this._maxRank) {\n                this._maxRank = rank;\n            }\n        };\n        Object.defineProperty(EffectFallbacks.prototype, \"isMoreFallbacks\", {\n            get: function () {\n                return this._currentRank <= this._maxRank;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        EffectFallbacks.prototype.reduce = function (currentDefines) {\n            // First we try to switch to CPU skinning\n            if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {\n                this._mesh.computeBonesUsingShaders = false;\n                currentDefines = currentDefines.replace(\"#define NUM_BONE_INFLUENCERS \" + this._mesh.numBoneInfluencers, \"#define NUM_BONE_INFLUENCERS 0\");\n                BABYLON.Tools.Log(\"Falling back to CPU skinning for \" + this._mesh.name);\n                var scene = this._mesh.getScene();\n                for (var index = 0; index < scene.meshes.length; index++) {\n                    var otherMesh = scene.meshes[index];\n                    if (otherMesh.material === this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {\n                        otherMesh.computeBonesUsingShaders = false;\n                    }\n                }\n            }\n            else {\n                var currentFallbacks = this._defines[this._currentRank];\n                if (currentFallbacks) {\n                    for (var index = 0; index < currentFallbacks.length; index++) {\n                        currentDefines = currentDefines.replace(\"#define \" + currentFallbacks[index], \"\");\n                    }\n                }\n                this._currentRank++;\n            }\n            return currentDefines;\n        };\n        return EffectFallbacks;\n    }());\n    BABYLON.EffectFallbacks = EffectFallbacks;\n    var EffectCreationOptions = (function () {\n        function EffectCreationOptions() {\n        }\n        return EffectCreationOptions;\n    }());\n    BABYLON.EffectCreationOptions = EffectCreationOptions;\n    var Effect = (function () {\n        function Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters) {\n            var _this = this;\n            this.uniqueId = 0;\n            this.onCompileObservable = new BABYLON.Observable();\n            this.onErrorObservable = new BABYLON.Observable();\n            this.onBindObservable = new BABYLON.Observable();\n            this._uniformBuffersNames = {};\n            this._isReady = false;\n            this._compilationError = \"\";\n            this._valueCache = {};\n            this.name = baseName;\n            if (attributesNamesOrOptions.attributes) {\n                var options = attributesNamesOrOptions;\n                this._engine = uniformsNamesOrEngine;\n                this._attributesNames = options.attributes;\n                this._uniformsNames = options.uniformsNames.concat(options.samplers);\n                this._samplers = options.samplers;\n                this.defines = options.defines;\n                this.onError = options.onError;\n                this.onCompiled = options.onCompiled;\n                this._fallbacks = options.fallbacks;\n                this._indexParameters = options.indexParameters;\n                if (options.uniformBuffersNames) {\n                    for (var i = 0; i < options.uniformBuffersNames.length; i++) {\n                        this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;\n                    }\n                }\n            }\n            else {\n                this._engine = engine;\n                this.defines = defines;\n                this._uniformsNames = uniformsNamesOrEngine.concat(samplers);\n                this._samplers = samplers;\n                this._attributesNames = attributesNamesOrOptions;\n                this.onError = onError;\n                this.onCompiled = onCompiled;\n                this._indexParameters = indexParameters;\n                this._fallbacks = fallbacks;\n            }\n            this.uniqueId = Effect._uniqueIdSeed++;\n            var vertexSource;\n            var fragmentSource;\n            if (baseName.vertexElement) {\n                vertexSource = document.getElementById(baseName.vertexElement);\n                if (!vertexSource) {\n                    vertexSource = baseName.vertexElement;\n                }\n            }\n            else {\n                vertexSource = baseName.vertex || baseName;\n            }\n            if (baseName.fragmentElement) {\n                fragmentSource = document.getElementById(baseName.fragmentElement);\n                if (!fragmentSource) {\n                    fragmentSource = baseName.fragmentElement;\n                }\n            }\n            else {\n                fragmentSource = baseName.fragment || baseName;\n            }\n            this._loadVertexShader(vertexSource, function (vertexCode) {\n                _this._processIncludes(vertexCode, function (vertexCodeWithIncludes) {\n                    _this._processShaderConversion(vertexCodeWithIncludes, false, function (migratedVertexCode) {\n                        _this._loadFragmentShader(fragmentSource, function (fragmentCode) {\n                            _this._processIncludes(fragmentCode, function (fragmentCodeWithIncludes) {\n                                _this._processShaderConversion(fragmentCodeWithIncludes, true, function (migratedFragmentCode) {\n                                    _this._prepareEffect(migratedVertexCode, migratedFragmentCode, _this._attributesNames, _this.defines, _this._fallbacks);\n                                });\n                            });\n                        });\n                    });\n                });\n            });\n        }\n        Object.defineProperty(Effect.prototype, \"key\", {\n            get: function () {\n                return this._key;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Properties\n        Effect.prototype.isReady = function () {\n            return this._isReady;\n        };\n        Effect.prototype.getEngine = function () {\n            return this._engine;\n        };\n        Effect.prototype.getProgram = function () {\n            return this._program;\n        };\n        Effect.prototype.getAttributesNames = function () {\n            return this._attributesNames;\n        };\n        Effect.prototype.getAttributeLocation = function (index) {\n            return this._attributes[index];\n        };\n        Effect.prototype.getAttributeLocationByName = function (name) {\n            var index = this._attributesNames.indexOf(name);\n            return this._attributes[index];\n        };\n        Effect.prototype.getAttributesCount = function () {\n            return this._attributes.length;\n        };\n        Effect.prototype.getUniformIndex = function (uniformName) {\n            return this._uniformsNames.indexOf(uniformName);\n        };\n        Effect.prototype.getUniform = function (uniformName) {\n            return this._uniforms[this._uniformsNames.indexOf(uniformName)];\n        };\n        Effect.prototype.getSamplers = function () {\n            return this._samplers;\n        };\n        Effect.prototype.getCompilationError = function () {\n            return this._compilationError;\n        };\n        Effect.prototype.getVertexShaderSource = function () {\n            return this._evaluateDefinesOnString(this._engine.getVertexShaderSource(this._program));\n        };\n        Effect.prototype.getFragmentShaderSource = function () {\n            return this._evaluateDefinesOnString(this._engine.getFragmentShaderSource(this._program));\n        };\n        // Methods\n        Effect.prototype.executeWhenCompiled = function (func) {\n            var _this = this;\n            if (this.isReady()) {\n                func(this);\n                return;\n            }\n            var observer = this.onCompileObservable.add(function (effect) {\n                _this.onCompileObservable.remove(observer);\n                func(effect);\n            });\n        };\n        Effect.prototype._loadVertexShader = function (vertex, callback) {\n            // DOM element ?\n            if (vertex instanceof HTMLElement) {\n                var vertexCode = BABYLON.Tools.GetDOMTextContent(vertex);\n                callback(vertexCode);\n                return;\n            }\n            // Base64 encoded ?\n            if (vertex.substr(0, 7) === \"base64:\") {\n                var vertexBinary = window.atob(vertex.substr(7));\n                callback(vertexBinary);\n                return;\n            }\n            // Is in local store ?\n            if (Effect.ShadersStore[vertex + \"VertexShader\"]) {\n                callback(Effect.ShadersStore[vertex + \"VertexShader\"]);\n                return;\n            }\n            var vertexShaderUrl;\n            if (vertex[0] === \".\" || vertex[0] === \"/\" || vertex.indexOf(\"http\") > -1) {\n                vertexShaderUrl = vertex;\n            }\n            else {\n                vertexShaderUrl = BABYLON.Engine.ShadersRepository + vertex;\n            }\n            // Vertex shader\n            BABYLON.Tools.LoadFile(vertexShaderUrl + \".vertex.fx\", callback);\n        };\n        Effect.prototype._loadFragmentShader = function (fragment, callback) {\n            // DOM element ?\n            if (fragment instanceof HTMLElement) {\n                var fragmentCode = BABYLON.Tools.GetDOMTextContent(fragment);\n                callback(fragmentCode);\n                return;\n            }\n            // Base64 encoded ?\n            if (fragment.substr(0, 7) === \"base64:\") {\n                var fragmentBinary = window.atob(fragment.substr(7));\n                callback(fragmentBinary);\n                return;\n            }\n            // Is in local store ?\n            if (Effect.ShadersStore[fragment + \"PixelShader\"]) {\n                callback(Effect.ShadersStore[fragment + \"PixelShader\"]);\n                return;\n            }\n            if (Effect.ShadersStore[fragment + \"FragmentShader\"]) {\n                callback(Effect.ShadersStore[fragment + \"FragmentShader\"]);\n                return;\n            }\n            var fragmentShaderUrl;\n            if (fragment[0] === \".\" || fragment[0] === \"/\" || fragment.indexOf(\"http\") > -1) {\n                fragmentShaderUrl = fragment;\n            }\n            else {\n                fragmentShaderUrl = BABYLON.Engine.ShadersRepository + fragment;\n            }\n            // Fragment shader\n            BABYLON.Tools.LoadFile(fragmentShaderUrl + \".fragment.fx\", callback);\n        };\n        Effect.prototype._dumpShadersSource = function (vertexCode, fragmentCode, defines) {\n            // Rebuild shaders source code\n            var shaderVersion = (this._engine.webGLVersion > 1) ? \"#version 300 es\\n\" : \"\";\n            var prefix = shaderVersion + (defines ? defines + \"\\n\" : \"\");\n            vertexCode = prefix + vertexCode;\n            fragmentCode = prefix + fragmentCode;\n            // Number lines of shaders source code\n            var i = 2;\n            var regex = /\\n/gm;\n            var formattedVertexCode = \"\\n1\\t\" + vertexCode.replace(regex, function () { return \"\\n\" + (i++) + \"\\t\"; });\n            i = 2;\n            var formattedFragmentCode = \"\\n1\\t\" + fragmentCode.replace(regex, function () { return \"\\n\" + (i++) + \"\\t\"; });\n            // Dump shaders name and formatted source code\n            if (this.name.vertexElement) {\n                BABYLON.Tools.Error(\"Vertex shader: \" + this.name.vertexElement + formattedVertexCode);\n                BABYLON.Tools.Error(\"Fragment shader: \" + this.name.fragmentElement + formattedFragmentCode);\n            }\n            else if (this.name.vertex) {\n                BABYLON.Tools.Error(\"Vertex shader: \" + this.name.vertex + formattedVertexCode);\n                BABYLON.Tools.Error(\"Fragment shader: \" + this.name.fragment + formattedFragmentCode);\n            }\n            else {\n                BABYLON.Tools.Error(\"Vertex shader: \" + this.name + formattedVertexCode);\n                BABYLON.Tools.Error(\"Fragment shader: \" + this.name + formattedFragmentCode);\n            }\n        };\n        ;\n        Effect.prototype._processShaderConversion = function (sourceCode, isFragment, callback) {\n            var preparedSourceCode = this._processPrecision(sourceCode);\n            if (this._engine.webGLVersion == 1) {\n                callback(preparedSourceCode);\n                return;\n            }\n            // Already converted\n            if (preparedSourceCode.indexOf(\"#version 3\") !== -1) {\n                callback(preparedSourceCode.replace(\"#version 300 es\", \"\"));\n                return;\n            }\n            // Remove extensions \n            // #extension GL_OES_standard_derivatives : enable\n            // #extension GL_EXT_shader_texture_lod : enable\n            // #extension GL_EXT_frag_depth : enable\n            var regex = /#extension.+(GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth).+enable/g;\n            var result = preparedSourceCode.replace(regex, \"\");\n            // Migrate to GLSL v300\n            result = result.replace(/varying(?![\\n\\r])\\s/g, isFragment ? \"in \" : \"out \");\n            result = result.replace(/attribute[ \\t]/g, \"in \");\n            result = result.replace(/[ \\t]attribute/g, \" in\");\n            if (isFragment) {\n                result = result.replace(/texture2DLodEXT\\(/g, \"textureLod(\");\n                result = result.replace(/textureCubeLodEXT\\(/g, \"textureLod(\");\n                result = result.replace(/texture2D\\(/g, \"texture(\");\n                result = result.replace(/textureCube\\(/g, \"texture(\");\n                result = result.replace(/gl_FragDepthEXT/g, \"gl_FragDepth\");\n                result = result.replace(/gl_FragColor/g, \"glFragColor\");\n                result = result.replace(/void\\s+?main\\(/g, \"out vec4 glFragColor;\\nvoid main(\");\n            }\n            callback(result);\n        };\n        Effect.prototype._processIncludes = function (sourceCode, callback) {\n            var _this = this;\n            var regex = /#include<(.+)>(\\((.*)\\))*(\\[(.*)\\])*/g;\n            var match = regex.exec(sourceCode);\n            var returnValue = new String(sourceCode);\n            while (match != null) {\n                var includeFile = match[1];\n                // Uniform declaration\n                if (includeFile.indexOf(\"__decl__\") !== -1) {\n                    includeFile = includeFile.replace(/__decl__/, \"\");\n                    if (this._engine.webGLVersion != 1) {\n                        includeFile = includeFile.replace(/Vertex/, \"Ubo\");\n                        includeFile = includeFile.replace(/Fragment/, \"Ubo\");\n                    }\n                    includeFile = includeFile + \"Declaration\";\n                }\n                if (Effect.IncludesShadersStore[includeFile]) {\n                    // Substitution\n                    var includeContent = Effect.IncludesShadersStore[includeFile];\n                    if (match[2]) {\n                        var splits = match[3].split(\",\");\n                        for (var index = 0; index < splits.length; index += 2) {\n                            var source = new RegExp(splits[index], \"g\");\n                            var dest = splits[index + 1];\n                            includeContent = includeContent.replace(source, dest);\n                        }\n                    }\n                    if (match[4]) {\n                        var indexString = match[5];\n                        if (indexString.indexOf(\"..\") !== -1) {\n                            var indexSplits = indexString.split(\"..\");\n                            var minIndex = parseInt(indexSplits[0]);\n                            var maxIndex = parseInt(indexSplits[1]);\n                            var sourceIncludeContent = includeContent.slice(0);\n                            includeContent = \"\";\n                            if (isNaN(maxIndex)) {\n                                maxIndex = this._indexParameters[indexSplits[1]];\n                            }\n                            for (var i = minIndex; i < maxIndex; i++) {\n                                if (this._engine.webGLVersion === 1) {\n                                    // Ubo replacement\n                                    sourceIncludeContent = sourceIncludeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                                        return p1 + \"{X}\";\n                                    });\n                                }\n                                includeContent += sourceIncludeContent.replace(/\\{X\\}/g, i) + \"\\n\";\n                            }\n                        }\n                        else {\n                            if (this._engine.webGLVersion === 1) {\n                                // Ubo replacement\n                                includeContent = includeContent.replace(/light\\{X\\}.(\\w*)/g, function (str, p1) {\n                                    return p1 + \"{X}\";\n                                });\n                            }\n                            includeContent = includeContent.replace(/\\{X\\}/g, indexString);\n                        }\n                    }\n                    // Replace\n                    returnValue = returnValue.replace(match[0], includeContent);\n                }\n                else {\n                    var includeShaderUrl = BABYLON.Engine.ShadersRepository + \"ShadersInclude/\" + includeFile + \".fx\";\n                    BABYLON.Tools.LoadFile(includeShaderUrl, function (fileContent) {\n                        Effect.IncludesShadersStore[includeFile] = fileContent;\n                        _this._processIncludes(returnValue, callback);\n                    });\n                    return;\n                }\n                match = regex.exec(sourceCode);\n            }\n            callback(returnValue);\n        };\n        Effect.prototype._processPrecision = function (source) {\n            if (source.indexOf(\"precision highp float\") === -1) {\n                if (!this._engine.getCaps().highPrecisionShaderSupported) {\n                    source = \"precision mediump float;\\n\" + source;\n                }\n                else {\n                    source = \"precision highp float;\\n\" + source;\n                }\n            }\n            else {\n                if (!this._engine.getCaps().highPrecisionShaderSupported) {\n                    source = source.replace(\"precision highp float\", \"precision mediump float\");\n                }\n            }\n            return source;\n        };\n        Effect.prototype._prepareEffect = function (vertexSourceCode, fragmentSourceCode, attributesNames, defines, fallbacks) {\n            try {\n                var engine = this._engine;\n                this._program = engine.createShaderProgram(vertexSourceCode, fragmentSourceCode, defines);\n                if (engine.webGLVersion > 1) {\n                    for (var name in this._uniformBuffersNames) {\n                        this.bindUniformBlock(name, this._uniformBuffersNames[name]);\n                    }\n                }\n                this._uniforms = engine.getUniforms(this._program, this._uniformsNames);\n                this._attributes = engine.getAttributes(this._program, attributesNames);\n                var index;\n                for (index = 0; index < this._samplers.length; index++) {\n                    var sampler = this.getUniform(this._samplers[index]);\n                    if (sampler == null) {\n                        this._samplers.splice(index, 1);\n                        index--;\n                    }\n                }\n                engine.bindSamplers(this);\n                this._compilationError = \"\";\n                this._isReady = true;\n                if (this.onCompiled) {\n                    this.onCompiled(this);\n                }\n                this.onCompileObservable.notifyObservers(this);\n            }\n            catch (e) {\n                this._compilationError = e.message;\n                // Let's go through fallbacks then\n                BABYLON.Tools.Error(\"Unable to compile effect:\");\n                BABYLON.Tools.Error(\"Uniforms: \" + this._uniformsNames.map(function (uniform) {\n                    return \" \" + uniform;\n                }));\n                BABYLON.Tools.Error(\"Attributes: \" + attributesNames.map(function (attribute) {\n                    return \" \" + attribute;\n                }));\n                this._dumpShadersSource(vertexSourceCode, fragmentSourceCode, defines);\n                BABYLON.Tools.Error(\"Error: \" + this._compilationError);\n                if (fallbacks && fallbacks.isMoreFallbacks) {\n                    BABYLON.Tools.Error(\"Trying next fallback.\");\n                    defines = fallbacks.reduce(defines);\n                    this._prepareEffect(vertexSourceCode, fragmentSourceCode, attributesNames, defines, fallbacks);\n                }\n                else {\n                    if (this.onError) {\n                        this.onError(this, this._compilationError);\n                    }\n                    this.onErrorObservable.notifyObservers(this);\n                }\n            }\n        };\n        Object.defineProperty(Effect.prototype, \"isSupported\", {\n            get: function () {\n                return this._compilationError === \"\";\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Effect.prototype._bindTexture = function (channel, texture) {\n            this._engine._bindTexture(this._samplers.indexOf(channel), texture);\n        };\n        Effect.prototype.setTexture = function (channel, texture) {\n            this._engine.setTexture(this._samplers.indexOf(channel), this.getUniform(channel), texture);\n        };\n        Effect.prototype.setTextureArray = function (channel, textures) {\n            if (this._samplers.indexOf(channel + \"Ex\") === -1) {\n                var initialPos = this._samplers.indexOf(channel);\n                for (var index = 1; index < textures.length; index++) {\n                    this._samplers.splice(initialPos + index, 0, channel + \"Ex\");\n                }\n            }\n            this._engine.setTextureArray(this._samplers.indexOf(channel), this.getUniform(channel), textures);\n        };\n        Effect.prototype.setTextureFromPostProcess = function (channel, postProcess) {\n            this._engine.setTextureFromPostProcess(this._samplers.indexOf(channel), postProcess);\n        };\n        Effect.prototype._cacheMatrix = function (uniformName, matrix) {\n            var cache = this._valueCache[uniformName];\n            var flag = matrix.updateFlag;\n            if (cache !== undefined && cache === flag) {\n                return false;\n            }\n            this._valueCache[uniformName] = flag;\n            return true;\n        };\n        Effect.prototype._cacheFloat2 = function (uniformName, x, y) {\n            var cache = this._valueCache[uniformName];\n            if (!cache) {\n                cache = [x, y];\n                this._valueCache[uniformName] = cache;\n                return true;\n            }\n            var changed = false;\n            if (cache[0] !== x) {\n                cache[0] = x;\n                changed = true;\n            }\n            if (cache[1] !== y) {\n                cache[1] = y;\n                changed = true;\n            }\n            return changed;\n        };\n        Effect.prototype._cacheFloat3 = function (uniformName, x, y, z) {\n            var cache = this._valueCache[uniformName];\n            if (!cache) {\n                cache = [x, y, z];\n                this._valueCache[uniformName] = cache;\n                return true;\n            }\n            var changed = false;\n            if (cache[0] !== x) {\n                cache[0] = x;\n                changed = true;\n            }\n            if (cache[1] !== y) {\n                cache[1] = y;\n                changed = true;\n            }\n            if (cache[2] !== z) {\n                cache[2] = z;\n                changed = true;\n            }\n            return changed;\n        };\n        Effect.prototype._cacheFloat4 = function (uniformName, x, y, z, w) {\n            var cache = this._valueCache[uniformName];\n            if (!cache) {\n                cache = [x, y, z, w];\n                this._valueCache[uniformName] = cache;\n                return true;\n            }\n            var changed = false;\n            if (cache[0] !== x) {\n                cache[0] = x;\n                changed = true;\n            }\n            if (cache[1] !== y) {\n                cache[1] = y;\n                changed = true;\n            }\n            if (cache[2] !== z) {\n                cache[2] = z;\n                changed = true;\n            }\n            if (cache[3] !== w) {\n                cache[3] = w;\n                changed = true;\n            }\n            return changed;\n        };\n        Effect.prototype.bindUniformBuffer = function (buffer, name) {\n            if (Effect._baseCache[this._uniformBuffersNames[name]] === buffer) {\n                return;\n            }\n            Effect._baseCache[this._uniformBuffersNames[name]] = buffer;\n            this._engine.bindUniformBufferBase(buffer, this._uniformBuffersNames[name]);\n        };\n        Effect.prototype.bindUniformBlock = function (blockName, index) {\n            this._engine.bindUniformBlock(this._program, blockName, index);\n        };\n        Effect.prototype.setIntArray = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setIntArray(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setIntArray2 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setIntArray2(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setIntArray3 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setIntArray3(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setIntArray4 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setIntArray4(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setFloatArray = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setFloatArray(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setFloatArray2 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setFloatArray2(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setFloatArray3 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setFloatArray3(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setFloatArray4 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setFloatArray4(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setArray = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setArray(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setArray2 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setArray2(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setArray3 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setArray3(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setArray4 = function (uniformName, array) {\n            this._valueCache[uniformName] = null;\n            this._engine.setArray4(this.getUniform(uniformName), array);\n            return this;\n        };\n        Effect.prototype.setMatrices = function (uniformName, matrices) {\n            if (!matrices) {\n                return;\n            }\n            this._valueCache[uniformName] = null;\n            this._engine.setMatrices(this.getUniform(uniformName), matrices);\n            return this;\n        };\n        Effect.prototype.setMatrix = function (uniformName, matrix) {\n            if (this._cacheMatrix(uniformName, matrix)) {\n                this._engine.setMatrix(this.getUniform(uniformName), matrix);\n            }\n            return this;\n        };\n        Effect.prototype.setMatrix3x3 = function (uniformName, matrix) {\n            this._valueCache[uniformName] = null;\n            this._engine.setMatrix3x3(this.getUniform(uniformName), matrix);\n            return this;\n        };\n        Effect.prototype.setMatrix2x2 = function (uniformName, matrix) {\n            this._valueCache[uniformName] = null;\n            this._engine.setMatrix2x2(this.getUniform(uniformName), matrix);\n            return this;\n        };\n        Effect.prototype.setFloat = function (uniformName, value) {\n            var cache = this._valueCache[uniformName];\n            if (cache !== undefined && cache === value)\n                return this;\n            this._valueCache[uniformName] = value;\n            this._engine.setFloat(this.getUniform(uniformName), value);\n            return this;\n        };\n        Effect.prototype.setBool = function (uniformName, bool) {\n            var cache = this._valueCache[uniformName];\n            if (cache !== undefined && cache === bool)\n                return this;\n            this._valueCache[uniformName] = bool;\n            this._engine.setBool(this.getUniform(uniformName), bool ? 1 : 0);\n            return this;\n        };\n        Effect.prototype.setVector2 = function (uniformName, vector2) {\n            if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {\n                this._engine.setFloat2(this.getUniform(uniformName), vector2.x, vector2.y);\n            }\n            return this;\n        };\n        Effect.prototype.setFloat2 = function (uniformName, x, y) {\n            if (this._cacheFloat2(uniformName, x, y)) {\n                this._engine.setFloat2(this.getUniform(uniformName), x, y);\n            }\n            return this;\n        };\n        Effect.prototype.setVector3 = function (uniformName, vector3) {\n            if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {\n                this._engine.setFloat3(this.getUniform(uniformName), vector3.x, vector3.y, vector3.z);\n            }\n            return this;\n        };\n        Effect.prototype.setFloat3 = function (uniformName, x, y, z) {\n            if (this._cacheFloat3(uniformName, x, y, z)) {\n                this._engine.setFloat3(this.getUniform(uniformName), x, y, z);\n            }\n            return this;\n        };\n        Effect.prototype.setVector4 = function (uniformName, vector4) {\n            if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {\n                this._engine.setFloat4(this.getUniform(uniformName), vector4.x, vector4.y, vector4.z, vector4.w);\n            }\n            return this;\n        };\n        Effect.prototype.setFloat4 = function (uniformName, x, y, z, w) {\n            if (this._cacheFloat4(uniformName, x, y, z, w)) {\n                this._engine.setFloat4(this.getUniform(uniformName), x, y, z, w);\n            }\n            return this;\n        };\n        Effect.prototype.setColor3 = function (uniformName, color3) {\n            if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {\n                this._engine.setColor3(this.getUniform(uniformName), color3);\n            }\n            return this;\n        };\n        Effect.prototype.setColor4 = function (uniformName, color3, alpha) {\n            if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {\n                this._engine.setColor4(this.getUniform(uniformName), color3, alpha);\n            }\n            return this;\n        };\n        Effect.prototype._recombineShader = function (node) {\n            if (node.define) {\n                if (node.condition) {\n                    var defineIndex = this.defines.indexOf(\"#define \" + node.define);\n                    if (defineIndex === -1) {\n                        return null;\n                    }\n                    var nextComma = this.defines.indexOf(\"\\n\", defineIndex);\n                    var defineValue = this.defines.substr(defineIndex + 7, nextComma - defineIndex - 7).replace(node.define, \"\").trim();\n                    var condition = defineValue + node.condition;\n                    if (!eval(condition)) {\n                        return null;\n                    }\n                }\n                else if (node.ndef) {\n                    if (this.defines.indexOf(\"#define \" + node.define) !== -1) {\n                        return null;\n                    }\n                }\n                else if (this.defines.indexOf(\"#define \" + node.define) === -1) {\n                    return null;\n                }\n            }\n            var result = \"\";\n            for (var index = 0; index < node.children.length; index++) {\n                var line = node.children[index];\n                if (line.children) {\n                    var combined = this._recombineShader(line);\n                    if (combined !== null) {\n                        result += combined + \"\\r\\n\";\n                    }\n                    continue;\n                }\n                if (line.length > 0) {\n                    result += line + \"\\r\\n\";\n                }\n            }\n            return result;\n        };\n        Effect.prototype._evaluateDefinesOnString = function (shaderString) {\n            var root = {\n                children: []\n            };\n            var currentNode = root;\n            var lines = shaderString.split(\"\\n\");\n            for (var index = 0; index < lines.length; index++) {\n                var line = lines[index].trim();\n                // #ifdef\n                var pos = line.indexOf(\"#ifdef \");\n                if (pos !== -1) {\n                    var define = line.substr(pos + 7);\n                    var newNode = {\n                        condition: null,\n                        ndef: false,\n                        define: define,\n                        children: [],\n                        parent: currentNode\n                    };\n                    currentNode.children.push(newNode);\n                    currentNode = newNode;\n                    continue;\n                }\n                // #ifndef\n                var pos = line.indexOf(\"#ifndef \");\n                if (pos !== -1) {\n                    var define = line.substr(pos + 8);\n                    newNode = {\n                        condition: null,\n                        define: define,\n                        ndef: true,\n                        children: [],\n                        parent: currentNode\n                    };\n                    currentNode.children.push(newNode);\n                    currentNode = newNode;\n                    continue;\n                }\n                // #if\n                var pos = line.indexOf(\"#if \");\n                if (pos !== -1) {\n                    var define = line.substr(pos + 4).trim();\n                    var conditionPos = define.indexOf(\" \");\n                    newNode = {\n                        condition: define.substr(conditionPos + 1),\n                        define: define.substr(0, conditionPos),\n                        ndef: false,\n                        children: [],\n                        parent: currentNode\n                    };\n                    currentNode.children.push(newNode);\n                    currentNode = newNode;\n                    continue;\n                }\n                // #endif\n                pos = line.indexOf(\"#endif\");\n                if (pos !== -1) {\n                    currentNode = currentNode.parent;\n                    continue;\n                }\n                currentNode.children.push(line);\n            }\n            // Recombine\n            return this._recombineShader(root);\n        };\n        return Effect;\n    }());\n    Effect._uniqueIdSeed = 0;\n    Effect._baseCache = {};\n    // Statics\n    Effect.ShadersStore = {};\n    Effect.IncludesShadersStore = {};\n    BABYLON.Effect = Effect;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.effect.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var MaterialHelper = (function () {\n        function MaterialHelper() {\n        }\n        MaterialHelper.PrepareDefinesForMergedUV = function (texture, defines, key) {\n            defines._needUVs = true;\n            defines[key] = true;\n            if (texture.getTextureMatrix().isIdentity(true)) {\n                defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n                if (texture.coordinatesIndex === 0) {\n                    defines[\"MAINUV1\"] = true;\n                }\n                else {\n                    defines[\"MAINUV2\"] = true;\n                }\n            }\n            else {\n                defines[key + \"DIRECTUV\"] = 0;\n            }\n        };\n        MaterialHelper.BindTextureMatrix = function (texture, uniformBuffer, key) {\n            var matrix = texture.getTextureMatrix();\n            if (!matrix.isIdentity(true)) {\n                uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n            }\n        };\n        MaterialHelper.PrepareDefinesForMisc = function (mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, defines) {\n            if (defines._areMiscDirty) {\n                defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n                defines[\"POINTSIZE\"] = (pointsCloud || scene.forcePointsCloud);\n                defines[\"FOG\"] = (scene.fogEnabled && mesh.applyFog && scene.fogMode !== BABYLON.Scene.FOGMODE_NONE && fogEnabled);\n                defines[\"USERIGHTHANDEDSYSTEM\"] = scene.useRightHandedSystem;\n            }\n        };\n        MaterialHelper.PrepareDefinesForFrameBoundValues = function (scene, engine, defines, useInstances, forceAlphaTest) {\n            if (forceAlphaTest === void 0) { forceAlphaTest = false; }\n            var changed = false;\n            if (defines[\"CLIPPLANE\"] !== (scene.clipPlane !== undefined && scene.clipPlane !== null)) {\n                defines[\"CLIPPLANE\"] = !defines[\"CLIPPLANE\"];\n                changed = true;\n            }\n            if (defines[\"ALPHATEST\"] !== (engine.getAlphaTesting() || forceAlphaTest)) {\n                defines[\"ALPHATEST\"] = !defines[\"ALPHATEST\"];\n                changed = true;\n            }\n            if (defines[\"INSTANCES\"] !== useInstances) {\n                defines[\"INSTANCES\"] = useInstances;\n                changed = true;\n            }\n            if (changed) {\n                defines.markAsUnprocessed();\n            }\n        };\n        MaterialHelper.PrepareDefinesForAttributes = function (mesh, defines, useVertexColor, useBones, useMorphTargets) {\n            if (useMorphTargets === void 0) { useMorphTargets = false; }\n            if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n                return false;\n            }\n            defines._normals = defines._needNormals;\n            defines._uvs = defines._needUVs;\n            defines[\"NORMAL\"] = (defines._needNormals && mesh.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind));\n            if (defines._needNormals && mesh.isVerticesDataPresent(BABYLON.VertexBuffer.TangentKind)) {\n                defines[\"TANGENT\"] = true;\n            }\n            if (defines._needUVs) {\n                defines[\"UV1\"] = mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind);\n                defines[\"UV2\"] = mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind);\n            }\n            else {\n                defines[\"UV1\"] = false;\n                defines[\"UV2\"] = false;\n            }\n            if (useVertexColor) {\n                defines[\"VERTEXCOLOR\"] = mesh.useVertexColors && mesh.isVerticesDataPresent(BABYLON.VertexBuffer.ColorKind);\n                defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha;\n            }\n            if (useBones) {\n                if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                    defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n                    defines[\"BonesPerMesh\"] = (mesh.skeleton.bones.length + 1);\n                }\n                else {\n                    defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n                    defines[\"BonesPerMesh\"] = 0;\n                }\n            }\n            if (useMorphTargets) {\n                if (mesh.morphTargetManager) {\n                    var manager = mesh.morphTargetManager;\n                    defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n                    defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n                    defines[\"MORPHTARGETS\"] = (manager.numInfluencers > 0);\n                    defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n                }\n                else {\n                    defines[\"MORPHTARGETS_TANGENT\"] = false;\n                    defines[\"MORPHTARGETS_NORMAL\"] = false;\n                    defines[\"MORPHTARGETS\"] = false;\n                    defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n                }\n            }\n            return true;\n        };\n        MaterialHelper.PrepareDefinesForLights = function (scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {\n            if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\n            if (disableLighting === void 0) { disableLighting = false; }\n            if (!defines._areLightsDirty) {\n                return defines._needNormals;\n            }\n            var lightIndex = 0;\n            var needNormals = false;\n            var needRebuild = false;\n            var lightmapMode = false;\n            var shadowEnabled = false;\n            var specularEnabled = false;\n            if (scene.lightsEnabled && !disableLighting) {\n                for (var _i = 0, _a = mesh._lightSources; _i < _a.length; _i++) {\n                    var light = _a[_i];\n                    needNormals = true;\n                    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n                        needRebuild = true;\n                    }\n                    defines[\"LIGHT\" + lightIndex] = true;\n                    defines[\"SPOTLIGHT\" + lightIndex] = false;\n                    defines[\"HEMILIGHT\" + lightIndex] = false;\n                    defines[\"POINTLIGHT\" + lightIndex] = false;\n                    defines[\"DIRLIGHT\" + lightIndex] = false;\n                    var type;\n                    if (light.getTypeID() === BABYLON.Light.LIGHTTYPEID_SPOTLIGHT) {\n                        type = \"SPOTLIGHT\" + lightIndex;\n                    }\n                    else if (light.getTypeID() === BABYLON.Light.LIGHTTYPEID_HEMISPHERICLIGHT) {\n                        type = \"HEMILIGHT\" + lightIndex;\n                    }\n                    else if (light.getTypeID() === BABYLON.Light.LIGHTTYPEID_POINTLIGHT) {\n                        type = \"POINTLIGHT\" + lightIndex;\n                    }\n                    else {\n                        type = \"DIRLIGHT\" + lightIndex;\n                    }\n                    defines[type] = true;\n                    // Specular\n                    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n                        specularEnabled = true;\n                    }\n                    // Shadows\n                    defines[\"SHADOW\" + lightIndex] = false;\n                    defines[\"SHADOWPCF\" + lightIndex] = false;\n                    defines[\"SHADOWESM\" + lightIndex] = false;\n                    defines[\"SHADOWCUBE\" + lightIndex] = false;\n                    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n                        var shadowGenerator = light.getShadowGenerator();\n                        if (shadowGenerator) {\n                            shadowEnabled = true;\n                            shadowGenerator.prepareDefines(defines, lightIndex);\n                        }\n                    }\n                    if (light.lightmapMode != BABYLON.Light.LIGHTMAP_DEFAULT) {\n                        lightmapMode = true;\n                        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n                        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = (light.lightmapMode == BABYLON.Light.LIGHTMAP_SHADOWSONLY);\n                    }\n                    else {\n                        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n                        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n                    }\n                    lightIndex++;\n                    if (lightIndex === maxSimultaneousLights)\n                        break;\n                }\n            }\n            defines[\"SPECULARTERM\"] = specularEnabled;\n            defines[\"SHADOWS\"] = shadowEnabled;\n            // Resetting all other lights if any\n            for (var index = lightIndex; index < maxSimultaneousLights; index++) {\n                if (defines[\"LIGHT\" + index] !== undefined) {\n                    defines[\"LIGHT\" + index] = false;\n                    defines[\"HEMILIGHT\" + lightIndex] = false;\n                    defines[\"POINTLIGHT\" + lightIndex] = false;\n                    defines[\"DIRLIGHT\" + lightIndex] = false;\n                    defines[\"SPOTLIGHT\" + lightIndex] = false;\n                    defines[\"SHADOW\" + lightIndex] = false;\n                }\n            }\n            var caps = scene.getEngine().getCaps();\n            if (defines[\"SHADOWFLOAT\"] === undefined) {\n                needRebuild = true;\n            }\n            defines[\"SHADOWFLOAT\"] = shadowEnabled &&\n                ((caps.textureFloatRender && caps.textureFloatLinearFiltering) ||\n                    (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\n            defines[\"LIGHTMAPEXCLUDED\"] = lightmapMode;\n            if (needRebuild) {\n                defines.rebuild();\n            }\n            return needNormals;\n        };\n        MaterialHelper.PrepareUniformsAndSamplersList = function (uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {\n            if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\n            var uniformsList, uniformBuffersList, samplersList, defines;\n            if (uniformsListOrOptions.uniformsNames) {\n                var options = uniformsListOrOptions;\n                uniformsList = options.uniformsNames;\n                uniformBuffersList = options.uniformBuffersNames;\n                samplersList = options.samplers;\n                defines = options.defines;\n                maxSimultaneousLights = options.maxSimultaneousLights;\n            }\n            else {\n                uniformsList = uniformsListOrOptions;\n            }\n            for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n                if (!defines[\"LIGHT\" + lightIndex]) {\n                    break;\n                }\n                uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n                if (uniformBuffersList) {\n                    uniformBuffersList.push(\"Light\" + lightIndex);\n                }\n                samplersList.push(\"shadowSampler\" + lightIndex);\n            }\n            if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n                uniformsList.push(\"morphTargetInfluences\");\n            }\n        };\n        MaterialHelper.HandleFallbacksForShadows = function (defines, fallbacks, maxSimultaneousLights) {\n            if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\n            if (!defines[\"SHADOWS\"]) {\n                return;\n            }\n            for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n                if (!defines[\"LIGHT\" + lightIndex]) {\n                    break;\n                }\n                if (lightIndex > 0) {\n                    fallbacks.addFallback(lightIndex, \"LIGHT\" + lightIndex);\n                }\n                if (defines[\"SHADOW\" + lightIndex]) {\n                    fallbacks.addFallback(0, \"SHADOW\" + lightIndex);\n                }\n                if (defines[\"SHADOWPCF\" + lightIndex]) {\n                    fallbacks.addFallback(0, \"SHADOWPCF\" + lightIndex);\n                }\n                if (defines[\"SHADOWESM\" + lightIndex]) {\n                    fallbacks.addFallback(0, \"SHADOWESM\" + lightIndex);\n                }\n            }\n        };\n        MaterialHelper.PrepareAttributesForMorphTargets = function (attribs, mesh, defines) {\n            var influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n            if (influencers > 0) {\n                var maxAttributesCount = BABYLON.Engine.LastCreatedEngine.getCaps().maxVertexAttribs;\n                var manager = mesh.morphTargetManager;\n                var normal = manager.supportsNormals && defines[\"NORMAL\"];\n                var tangent = manager.supportsTangents && defines[\"TANGENT\"];\n                for (var index = 0; index < influencers; index++) {\n                    attribs.push(BABYLON.VertexBuffer.PositionKind + index);\n                    if (normal) {\n                        attribs.push(BABYLON.VertexBuffer.NormalKind + index);\n                    }\n                    if (tangent) {\n                        attribs.push(BABYLON.VertexBuffer.TangentKind + index);\n                    }\n                    if (attribs.length > maxAttributesCount) {\n                        BABYLON.Tools.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n                    }\n                }\n            }\n        };\n        MaterialHelper.PrepareAttributesForBones = function (attribs, mesh, defines, fallbacks) {\n            if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n            }\n        };\n        MaterialHelper.PrepareAttributesForInstances = function (attribs, defines) {\n            if (defines[\"INSTANCES\"]) {\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n        };\n        // Bindings\n        MaterialHelper.BindLightShadow = function (light, scene, mesh, lightIndex, effect) {\n            if (light.shadowEnabled && mesh.receiveShadows) {\n                var shadowGenerator = light.getShadowGenerator();\n                if (shadowGenerator) {\n                    shadowGenerator.bindShadowLight(lightIndex, effect);\n                }\n            }\n        };\n        MaterialHelper.BindLightProperties = function (light, effect, lightIndex) {\n            light.transferToEffect(effect, lightIndex + \"\");\n        };\n        MaterialHelper.BindLights = function (scene, mesh, effect, defines, maxSimultaneousLights, usePhysicalLightFalloff) {\n            if (maxSimultaneousLights === void 0) { maxSimultaneousLights = 4; }\n            if (usePhysicalLightFalloff === void 0) { usePhysicalLightFalloff = false; }\n            var lightIndex = 0;\n            for (var _i = 0, _a = mesh._lightSources; _i < _a.length; _i++) {\n                var light = _a[_i];\n                var scaledIntensity = light.getScaledIntensity();\n                light._uniformBuffer.bindToEffect(effect, \"Light\" + lightIndex);\n                MaterialHelper.BindLightProperties(light, effect, lightIndex);\n                light.diffuse.scaleToRef(scaledIntensity, BABYLON.Tmp.Color3[0]);\n                light._uniformBuffer.updateColor4(\"vLightDiffuse\", BABYLON.Tmp.Color3[0], usePhysicalLightFalloff ? light.radius : light.range, lightIndex + \"\");\n                if (defines[\"SPECULARTERM\"]) {\n                    light.specular.scaleToRef(scaledIntensity, BABYLON.Tmp.Color3[1]);\n                    light._uniformBuffer.updateColor3(\"vLightSpecular\", BABYLON.Tmp.Color3[1], lightIndex + \"\");\n                }\n                // Shadows\n                if (scene.shadowsEnabled) {\n                    this.BindLightShadow(light, scene, mesh, lightIndex + \"\", effect);\n                }\n                light._uniformBuffer.update();\n                lightIndex++;\n                if (lightIndex === maxSimultaneousLights)\n                    break;\n            }\n        };\n        MaterialHelper.BindFogParameters = function (scene, mesh, effect) {\n            if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== BABYLON.Scene.FOGMODE_NONE) {\n                effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n                effect.setColor3(\"vFogColor\", scene.fogColor);\n            }\n        };\n        MaterialHelper.BindBonesParameters = function (mesh, effect) {\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders) {\n                var matrices = mesh.skeleton.getTransformMatrices(mesh);\n                if (matrices) {\n                    effect.setMatrices(\"mBones\", matrices);\n                }\n            }\n        };\n        MaterialHelper.BindMorphTargetParameters = function (abstractMesh, effect) {\n            if (!abstractMesh || !abstractMesh.morphTargetManager) {\n                return;\n            }\n            effect.setFloatArray(\"morphTargetInfluences\", abstractMesh.morphTargetManager.influences);\n        };\n        MaterialHelper.BindLogDepth = function (defines, effect, scene) {\n            if (defines[\"LOGARITHMICDEPTH\"]) {\n                effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(scene.activeCamera.maxZ + 1.0) / Math.LN2));\n            }\n        };\n        MaterialHelper.BindClipPlane = function (effect, scene) {\n            if (scene.clipPlane) {\n                var clipPlane = scene.clipPlane;\n                effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\n            }\n        };\n        return MaterialHelper;\n    }());\n    BABYLON.MaterialHelper = MaterialHelper;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.materialHelper.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var MaterialDefines = (function () {\n        function MaterialDefines() {\n            this._isDirty = true;\n            this._areLightsDirty = true;\n            this._areAttributesDirty = true;\n            this._areTexturesDirty = true;\n            this._areFresnelDirty = true;\n            this._areMiscDirty = true;\n            this._areImageProcessingDirty = true;\n            this._normals = false;\n            this._uvs = false;\n            this._needNormals = false;\n            this._needUVs = false;\n        }\n        Object.defineProperty(MaterialDefines.prototype, \"isDirty\", {\n            get: function () {\n                return this._isDirty;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MaterialDefines.prototype.markAsProcessed = function () {\n            this._isDirty = false;\n            this._areAttributesDirty = false;\n            this._areTexturesDirty = false;\n            this._areFresnelDirty = false;\n            this._areLightsDirty = false;\n            this._areMiscDirty = false;\n            this._areImageProcessingDirty = false;\n        };\n        MaterialDefines.prototype.markAsUnprocessed = function () {\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAllAsDirty = function () {\n            this._areTexturesDirty = true;\n            this._areAttributesDirty = true;\n            this._areLightsDirty = true;\n            this._areFresnelDirty = true;\n            this._areMiscDirty = true;\n            this._areImageProcessingDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsImageProcessingDirty = function () {\n            this._areImageProcessingDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsLightDirty = function () {\n            this._areLightsDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsAttributesDirty = function () {\n            this._areAttributesDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsTexturesDirty = function () {\n            this._areTexturesDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsFresnelDirty = function () {\n            this._areFresnelDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.markAsMiscDirty = function () {\n            this._areMiscDirty = true;\n            this._isDirty = true;\n        };\n        MaterialDefines.prototype.rebuild = function () {\n            if (this._keys) {\n                delete this._keys;\n            }\n            this._keys = [];\n            for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (key[0] === \"_\") {\n                    continue;\n                }\n                this._keys.push(key);\n            }\n        };\n        MaterialDefines.prototype.isEqual = function (other) {\n            if (this._keys.length !== other._keys.length) {\n                return false;\n            }\n            for (var index = 0; index < this._keys.length; index++) {\n                var prop = this._keys[index];\n                if (this[prop] !== other[prop]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        MaterialDefines.prototype.cloneTo = function (other) {\n            if (this._keys.length !== other._keys.length) {\n                other._keys = this._keys.slice(0);\n            }\n            for (var index = 0; index < this._keys.length; index++) {\n                var prop = this._keys[index];\n                other[prop] = this[prop];\n            }\n        };\n        MaterialDefines.prototype.reset = function () {\n            for (var index = 0; index < this._keys.length; index++) {\n                var prop = this._keys[index];\n                if (typeof (this[prop]) === \"number\") {\n                    this[prop] = 0;\n                }\n                else {\n                    this[prop] = false;\n                }\n            }\n        };\n        MaterialDefines.prototype.toString = function () {\n            var result = \"\";\n            for (var index = 0; index < this._keys.length; index++) {\n                var prop = this._keys[index];\n                var value = this[prop];\n                if (typeof (value) === \"number\") {\n                    result += \"#define \" + prop + \" \" + this[prop] + \"\\n\";\n                }\n                else if (value) {\n                    result += \"#define \" + prop + \"\\n\";\n                }\n            }\n            return result;\n        };\n        return MaterialDefines;\n    }());\n    BABYLON.MaterialDefines = MaterialDefines;\n    var Material = (function () {\n        function Material(name, scene, doNotAdd) {\n            this.checkReadyOnEveryCall = false;\n            this.checkReadyOnlyOnce = false;\n            this.state = \"\";\n            this.alpha = 1.0;\n            this._backFaceCulling = true;\n            this.doNotSerialize = false;\n            this.storeEffectOnSubMeshes = false;\n            /**\n            * An event triggered when the material is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the material is bound.\n            * @type {BABYLON.Observable}\n            */\n            this.onBindObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the material is unbound.\n            * @type {BABYLON.Observable}\n            */\n            this.onUnBindObservable = new BABYLON.Observable();\n            this.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n            this.disableDepthWrite = false;\n            this._fogEnabled = true;\n            this.pointSize = 1.0;\n            this.zOffset = 0;\n            this._wasPreviouslyReady = false;\n            this._fillMode = Material.TriangleFillMode;\n            this.name = name;\n            this.id = name;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            if (this._scene.useRightHandedSystem) {\n                this.sideOrientation = Material.ClockWiseSideOrientation;\n            }\n            else {\n                this.sideOrientation = Material.CounterClockWiseSideOrientation;\n            }\n            this._uniformBuffer = new BABYLON.UniformBuffer(this._scene.getEngine());\n            this._useUBO = this.getScene().getEngine().webGLVersion > 1;\n            if (!doNotAdd) {\n                this._scene.materials.push(this);\n            }\n        }\n        Object.defineProperty(Material, \"TriangleFillMode\", {\n            get: function () {\n                return Material._TriangleFillMode;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"WireFrameFillMode\", {\n            get: function () {\n                return Material._WireFrameFillMode;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"PointFillMode\", {\n            get: function () {\n                return Material._PointFillMode;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"ClockWiseSideOrientation\", {\n            get: function () {\n                return Material._ClockWiseSideOrientation;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"CounterClockWiseSideOrientation\", {\n            get: function () {\n                return Material._CounterClockWiseSideOrientation;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"TextureDirtyFlag\", {\n            get: function () {\n                return Material._TextureDirtyFlag;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"LightDirtyFlag\", {\n            get: function () {\n                return Material._LightDirtyFlag;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"FresnelDirtyFlag\", {\n            get: function () {\n                return Material._FresnelDirtyFlag;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"AttributesDirtyFlag\", {\n            get: function () {\n                return Material._AttributesDirtyFlag;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material, \"MiscDirtyFlag\", {\n            get: function () {\n                return Material._MiscDirtyFlag;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"backFaceCulling\", {\n            get: function () {\n                return this._backFaceCulling;\n            },\n            set: function (value) {\n                if (this._backFaceCulling === value) {\n                    return;\n                }\n                this._backFaceCulling = value;\n                this.markAsDirty(Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"onBind\", {\n            set: function (callback) {\n                if (this._onBindObserver) {\n                    this.onBindObservable.remove(this._onBindObserver);\n                }\n                this._onBindObserver = this.onBindObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"fogEnabled\", {\n            get: function () {\n                return this._fogEnabled;\n            },\n            set: function (value) {\n                if (this._fogEnabled === value) {\n                    return;\n                }\n                this._fogEnabled = value;\n                this.markAsDirty(Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"wireframe\", {\n            get: function () {\n                return this._fillMode === Material.WireFrameFillMode;\n            },\n            set: function (value) {\n                this._fillMode = (value ? Material.WireFrameFillMode : Material.TriangleFillMode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"pointsCloud\", {\n            get: function () {\n                return this._fillMode === Material.PointFillMode;\n            },\n            set: function (value) {\n                this._fillMode = (value ? Material.PointFillMode : Material.TriangleFillMode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Material.prototype, \"fillMode\", {\n            get: function () {\n                return this._fillMode;\n            },\n            set: function (value) {\n                if (this._fillMode === value) {\n                    return;\n                }\n                this._fillMode = value;\n                this.markAsDirty(Material.MiscDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         * subclasses should override adding information pertainent to themselves\n         */\n        Material.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name;\n            if (fullDetails) {\n            }\n            return ret;\n        };\n        /**\n         * Child classes can use it to update shaders\n         */\n        Material.prototype.getClassName = function () {\n            return \"Material\";\n        };\n        Object.defineProperty(Material.prototype, \"isFrozen\", {\n            get: function () {\n                return this.checkReadyOnlyOnce;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Material.prototype.freeze = function () {\n            this.checkReadyOnlyOnce = true;\n        };\n        Material.prototype.unfreeze = function () {\n            this.checkReadyOnlyOnce = false;\n        };\n        Material.prototype.isReady = function (mesh, useInstances) {\n            return true;\n        };\n        Material.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n            return false;\n        };\n        Material.prototype.getEffect = function () {\n            return this._effect;\n        };\n        Material.prototype.getScene = function () {\n            return this._scene;\n        };\n        Material.prototype.needAlphaBlending = function () {\n            return (this.alpha < 1.0);\n        };\n        Material.prototype.needAlphaTesting = function () {\n            return false;\n        };\n        Material.prototype.getAlphaTestTexture = function () {\n            return null;\n        };\n        Material.prototype.markDirty = function () {\n            this._wasPreviouslyReady = false;\n        };\n        Material.prototype._preBind = function (effect) {\n            var engine = this._scene.getEngine();\n            var reverse = this.sideOrientation === Material.ClockWiseSideOrientation;\n            engine.enableEffect(effect ? effect : this._effect);\n            engine.setState(this.backFaceCulling, this.zOffset, false, reverse);\n        };\n        Material.prototype.bind = function (world, mesh) {\n        };\n        Material.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n        };\n        Material.prototype.bindOnlyWorldMatrix = function (world) {\n        };\n        Material.prototype.bindSceneUniformBuffer = function (effect, sceneUbo) {\n            sceneUbo.bindToEffect(effect, \"Scene\");\n        };\n        Material.prototype.bindView = function (effect) {\n            if (!this._useUBO) {\n                effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n            }\n            else {\n                this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n            }\n        };\n        Material.prototype.bindViewProjection = function (effect) {\n            if (!this._useUBO) {\n                effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n            }\n            else {\n                this.bindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());\n            }\n        };\n        Material.prototype._afterBind = function (mesh) {\n            this._scene._cachedMaterial = this;\n            this.onBindObservable.notifyObservers(mesh);\n            if (this.disableDepthWrite) {\n                var engine = this._scene.getEngine();\n                this._cachedDepthWriteState = engine.getDepthWrite();\n                engine.setDepthWrite(false);\n            }\n        };\n        Material.prototype.unbind = function () {\n            this.onUnBindObservable.notifyObservers(this);\n            if (this.disableDepthWrite) {\n                var engine = this._scene.getEngine();\n                engine.setDepthWrite(this._cachedDepthWriteState);\n            }\n        };\n        Material.prototype.getActiveTextures = function () {\n            return [];\n        };\n        Material.prototype.hasTexture = function (texture) {\n            return false;\n        };\n        Material.prototype.clone = function (name) {\n            return null;\n        };\n        Material.prototype.getBindedMeshes = function () {\n            var result = new Array();\n            for (var index = 0; index < this._scene.meshes.length; index++) {\n                var mesh = this._scene.meshes[index];\n                if (mesh.material === this) {\n                    result.push(mesh);\n                }\n            }\n            return result;\n        };\n        // Force shader compilation including textures ready check\n        Material.prototype.forceCompilation = function (mesh, onCompiled, options) {\n            var _this = this;\n            var subMesh = new BABYLON.BaseSubMesh();\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            var beforeRenderCallback = function () {\n                if (subMesh._materialDefines) {\n                    subMesh._materialDefines._renderId = -1;\n                }\n                var alphaTestState = engine.getAlphaTesting();\n                engine.setAlphaTesting(options ? options.alphaTest : _this.needAlphaTesting());\n                if (_this.isReadyForSubMesh(mesh, subMesh)) {\n                    scene.unregisterBeforeRender(beforeRenderCallback);\n                    if (onCompiled) {\n                        onCompiled(_this);\n                    }\n                }\n                engine.setAlphaTesting(alphaTestState);\n            };\n            scene.registerBeforeRender(beforeRenderCallback);\n        };\n        Material.prototype.markAsDirty = function (flag) {\n            if (flag & Material.TextureDirtyFlag) {\n                this._markAllSubMeshesAsTexturesDirty();\n            }\n            if (flag & Material.LightDirtyFlag) {\n                this._markAllSubMeshesAsLightsDirty();\n            }\n            if (flag & Material.FresnelDirtyFlag) {\n                this._markAllSubMeshesAsFresnelDirty();\n            }\n            if (flag & Material.AttributesDirtyFlag) {\n                this._markAllSubMeshesAsAttributesDirty();\n            }\n            if (flag & Material.MiscDirtyFlag) {\n                this._markAllSubMeshesAsMiscDirty();\n            }\n            this.getScene().resetCachedMaterial();\n        };\n        Material.prototype._markAllSubMeshesAsDirty = function (func) {\n            for (var _i = 0, _a = this.getScene().meshes; _i < _a.length; _i++) {\n                var mesh = _a[_i];\n                if (!mesh.subMeshes) {\n                    continue;\n                }\n                for (var _b = 0, _c = mesh.subMeshes; _b < _c.length; _b++) {\n                    var subMesh = _c[_b];\n                    if (subMesh.getMaterial() !== this) {\n                        continue;\n                    }\n                    if (!subMesh._materialDefines) {\n                        return;\n                    }\n                    func(subMesh._materialDefines);\n                }\n            }\n        };\n        Material.prototype._markAllSubMeshesAsImageProcessingDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsImageProcessingDirty(); });\n        };\n        Material.prototype._markAllSubMeshesAsTexturesDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsTexturesDirty(); });\n        };\n        Material.prototype._markAllSubMeshesAsFresnelDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsFresnelDirty(); });\n        };\n        Material.prototype._markAllSubMeshesAsLightsDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsLightDirty(); });\n        };\n        Material.prototype._markAllSubMeshesAsAttributesDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsAttributesDirty(); });\n        };\n        Material.prototype._markAllSubMeshesAsMiscDirty = function () {\n            this._markAllSubMeshesAsDirty(function (defines) { return defines.markAsMiscDirty(); });\n        };\n        Material.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Remove from scene\n            var index = this._scene.materials.indexOf(this);\n            if (index >= 0) {\n                this._scene.materials.splice(index, 1);\n            }\n            // Remove from meshes\n            for (index = 0; index < this._scene.meshes.length; index++) {\n                var mesh = this._scene.meshes[index];\n                if (mesh.material === this) {\n                    mesh.material = null;\n                    if (mesh.geometry) {\n                        var geometry = mesh.geometry;\n                        if (this.storeEffectOnSubMeshes) {\n                            for (var _i = 0, _a = mesh.subMeshes; _i < _a.length; _i++) {\n                                var subMesh = _a[_i];\n                                geometry._releaseVertexArrayObject(subMesh._materialEffect);\n                            }\n                        }\n                        else {\n                            geometry._releaseVertexArrayObject(this._effect);\n                        }\n                    }\n                }\n            }\n            this._uniformBuffer.dispose();\n            // Shader are kept in cache for further use but we can get rid of this by using forceDisposeEffect\n            if (forceDisposeEffect && this._effect) {\n                if (this.storeEffectOnSubMeshes) {\n                    for (var _b = 0, _c = mesh.subMeshes; _b < _c.length; _b++) {\n                        var subMesh = _c[_b];\n                        this._scene.getEngine()._releaseEffect(subMesh._materialEffect);\n                    }\n                }\n                else {\n                    this._scene.getEngine()._releaseEffect(this._effect);\n                }\n                this._effect = null;\n            }\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n            this.onBindObservable.clear();\n            this.onUnBindObservable.clear();\n        };\n        Material.prototype.serialize = function () {\n            return BABYLON.SerializationHelper.Serialize(this);\n        };\n        Material.ParseMultiMaterial = function (parsedMultiMaterial, scene) {\n            var multiMaterial = new BABYLON.MultiMaterial(parsedMultiMaterial.name, scene);\n            multiMaterial.id = parsedMultiMaterial.id;\n            if (BABYLON.Tags) {\n                BABYLON.Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);\n            }\n            for (var matIndex = 0; matIndex < parsedMultiMaterial.materials.length; matIndex++) {\n                var subMatId = parsedMultiMaterial.materials[matIndex];\n                if (subMatId) {\n                    multiMaterial.subMaterials.push(scene.getMaterialByID(subMatId));\n                }\n                else {\n                    multiMaterial.subMaterials.push(null);\n                }\n            }\n            return multiMaterial;\n        };\n        Material.Parse = function (parsedMaterial, scene, rootUrl) {\n            if (!parsedMaterial.customType) {\n                return BABYLON.StandardMaterial.Parse(parsedMaterial, scene, rootUrl);\n            }\n            if (parsedMaterial.customType === \"BABYLON.PBRMaterial\" && parsedMaterial.overloadedAlbedo) {\n                parsedMaterial.customType = \"BABYLON.LegacyPBRMaterial\";\n                if (!BABYLON.LegacyPBRMaterial) {\n                    BABYLON.Tools.Error(\"Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.\");\n                    return;\n                }\n            }\n            var materialType = BABYLON.Tools.Instantiate(parsedMaterial.customType);\n            return materialType.Parse(parsedMaterial, scene, rootUrl);\n            ;\n        };\n        return Material;\n    }());\n    Material._TriangleFillMode = 0;\n    Material._WireFrameFillMode = 1;\n    Material._PointFillMode = 2;\n    Material._ClockWiseSideOrientation = 0;\n    Material._CounterClockWiseSideOrientation = 1;\n    Material._TextureDirtyFlag = 1;\n    Material._LightDirtyFlag = 2;\n    Material._FresnelDirtyFlag = 4;\n    Material._AttributesDirtyFlag = 8;\n    Material._MiscDirtyFlag = 16;\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"id\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"name\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"checkReadyOnEveryCall\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"checkReadyOnlyOnce\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"state\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"alpha\", void 0);\n    __decorate([\n        BABYLON.serialize(\"backFaceCulling\")\n    ], Material.prototype, \"_backFaceCulling\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"sideOrientation\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"alphaMode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"disableDepthWrite\", void 0);\n    __decorate([\n        BABYLON.serialize(\"fogEnabled\")\n    ], Material.prototype, \"_fogEnabled\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"pointSize\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"zOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"wireframe\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"pointsCloud\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], Material.prototype, \"fillMode\", null);\n    BABYLON.Material = Material;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.material.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var UniformBuffer = (function () {\n        /**\n         * Uniform buffer objects.\n         *\n         * Handles blocks of uniform on the GPU.\n         *\n         * If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.\n         *\n         * For more information, please refer to :\n         * https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object\n         */\n        function UniformBuffer(engine, data, dynamic) {\n            this._engine = engine;\n            this._noUBO = engine.webGLVersion === 1;\n            this._dynamic = dynamic;\n            this._data = data || [];\n            this._uniformLocations = {};\n            this._uniformSizes = {};\n            this._uniformLocationPointer = 0;\n            this._needSync = false;\n            if (this._noUBO) {\n                this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;\n                this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;\n                this.updateFloat = this._updateFloatForEffect;\n                this.updateFloat2 = this._updateFloat2ForEffect;\n                this.updateFloat3 = this._updateFloat3ForEffect;\n                this.updateFloat4 = this._updateFloat4ForEffect;\n                this.updateMatrix = this._updateMatrixForEffect;\n                this.updateVector3 = this._updateVector3ForEffect;\n                this.updateVector4 = this._updateVector4ForEffect;\n                this.updateColor3 = this._updateColor3ForEffect;\n                this.updateColor4 = this._updateColor4ForEffect;\n            }\n            else {\n                this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;\n                this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;\n                this.updateFloat = this._updateFloatForUniform;\n                this.updateFloat2 = this._updateFloat2ForUniform;\n                this.updateFloat3 = this._updateFloat3ForUniform;\n                this.updateFloat4 = this._updateFloat4ForUniform;\n                this.updateMatrix = this._updateMatrixForUniform;\n                this.updateVector3 = this._updateVector3ForUniform;\n                this.updateVector4 = this._updateVector4ForUniform;\n                this.updateColor3 = this._updateColor3ForUniform;\n                this.updateColor4 = this._updateColor4ForUniform;\n            }\n        }\n        Object.defineProperty(UniformBuffer.prototype, \"useUbo\", {\n            // Properties\n            /**\n             * Indicates if the buffer is using the WebGL2 UBO implementation,\n             * or just falling back on setUniformXXX calls.\n             */\n            get: function () {\n                return !this._noUBO;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(UniformBuffer.prototype, \"isSync\", {\n            /**\n             * Indicates if the WebGL underlying uniform buffer is in sync\n             * with the javascript cache data.\n             */\n            get: function () {\n                return !this._needSync;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Indicates if the WebGL underlying uniform buffer is dynamic.\n         * Also, a dynamic UniformBuffer will disable cache verification and always\n         * update the underlying WebGL uniform buffer to the GPU.\n         */\n        UniformBuffer.prototype.isDynamic = function () {\n            return this._dynamic;\n        };\n        /**\n         * The data cache on JS side.\n         */\n        UniformBuffer.prototype.getData = function () {\n            return this._bufferData;\n        };\n        /**\n         * The underlying WebGL Uniform buffer.\n         */\n        UniformBuffer.prototype.getBuffer = function () {\n            return this._buffer;\n        };\n        /**\n         * std140 layout specifies how to align data within an UBO structure.\n         * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\n         * for specs.\n         */\n        UniformBuffer.prototype._fillAlignment = function (size) {\n            // This code has been simplified because we only use floats, vectors of 1, 2, 3, 4 components\n            // and 4x4 matrices\n            // TODO : change if other types are used\n            var alignment;\n            if (size <= 2) {\n                alignment = size;\n            }\n            else {\n                alignment = 4;\n            }\n            if ((this._uniformLocationPointer % alignment) !== 0) {\n                var oldPointer = this._uniformLocationPointer;\n                this._uniformLocationPointer += alignment - (this._uniformLocationPointer % alignment);\n                var diff = this._uniformLocationPointer - oldPointer;\n                for (var i = 0; i < diff; i++) {\n                    this._data.push(0);\n                }\n            }\n        };\n        /**\n         * Adds an uniform in the buffer.\n         * Warning : the subsequents calls of this function must be in the same order as declared in the shader\n         * for the layout to be correct !\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {number|number[]} size Data size, or data directly.\n         */\n        UniformBuffer.prototype.addUniform = function (name, size) {\n            if (this._noUBO) {\n                return;\n            }\n            if (this._uniformLocations[name] !== undefined) {\n                // Already existing uniform\n                return;\n            }\n            // This function must be called in the order of the shader layout !\n            // size can be the size of the uniform, or data directly\n            var data;\n            if (size instanceof Array) {\n                data = size;\n                size = data.length;\n            }\n            else {\n                size = size;\n                data = [];\n                // Fill with zeros\n                for (var i = 0; i < size; i++) {\n                    data.push(0);\n                }\n            }\n            this._fillAlignment(size);\n            this._uniformSizes[name] = size;\n            this._uniformLocations[name] = this._uniformLocationPointer;\n            this._uniformLocationPointer += size;\n            for (var i = 0; i < size; i++) {\n                this._data.push(data[i]);\n            }\n            this._needSync = true;\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {Matrix} mat A 4x4 matrix.\n         */\n        UniformBuffer.prototype.addMatrix = function (name, mat) {\n            this.addUniform(name, Array.prototype.slice.call(mat.toArray()));\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {number} x\n         * @param {number} y\n         */\n        UniformBuffer.prototype.addFloat2 = function (name, x, y) {\n            var temp = [x, y];\n            this.addUniform(name, temp);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {number} x\n         * @param {number} y\n         * @param {number} z\n         */\n        UniformBuffer.prototype.addFloat3 = function (name, x, y, z) {\n            var temp = [x, y, z];\n            this.addUniform(name, temp);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {Color3} color\n         */\n        UniformBuffer.prototype.addColor3 = function (name, color) {\n            var temp = [];\n            color.toArray(temp);\n            this.addUniform(name, temp);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {Color3} color\n         * @param {number} alpha\n         */\n        UniformBuffer.prototype.addColor4 = function (name, color, alpha) {\n            var temp = [];\n            color.toArray(temp);\n            temp.push(alpha);\n            this.addUniform(name, temp);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         * @param {Vector3} vector\n         */\n        UniformBuffer.prototype.addVector3 = function (name, vector) {\n            var temp = [];\n            vector.toArray(temp);\n            this.addUniform(name, temp);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         */\n        UniformBuffer.prototype.addMatrix3x3 = function (name) {\n            this.addUniform(name, 12);\n        };\n        /**\n         * Wrapper for addUniform.\n         * @param {string} name Name of the uniform, as used in the uniform block in the shader.\n         */\n        UniformBuffer.prototype.addMatrix2x2 = function (name) {\n            this.addUniform(name, 8);\n        };\n        /**\n         * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.\n         */\n        UniformBuffer.prototype.create = function () {\n            if (this._noUBO) {\n                return;\n            }\n            if (this._buffer) {\n                return; // nothing to do\n            }\n            // See spec, alignment must be filled as a vec4\n            this._fillAlignment(4);\n            this._bufferData = new Float32Array(this._data);\n            if (this._dynamic) {\n                this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);\n            }\n            else {\n                this._buffer = this._engine.createUniformBuffer(this._bufferData);\n            }\n            this._needSync = true;\n        };\n        /**\n         * Updates the WebGL Uniform Buffer on the GPU.\n         * If the `dynamic` flag is set to true, no cache comparison is done.\n         * Otherwise, the buffer will be updated only if the cache differs.\n         */\n        UniformBuffer.prototype.update = function () {\n            if (!this._buffer) {\n                this.create();\n                return;\n            }\n            if (!this._dynamic && !this._needSync) {\n                return;\n            }\n            this._engine.updateUniformBuffer(this._buffer, this._bufferData);\n            this._needSync = false;\n        };\n        /**\n         * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.\n         * @param {string} uniformName Name of the uniform, as used in the uniform block in the shader.\n         * @param {number[]|Float32Array} data Flattened data\n         * @param {number} size Size of the data.\n         */\n        UniformBuffer.prototype.updateUniform = function (uniformName, data, size) {\n            var location = this._uniformLocations[uniformName];\n            if (location === undefined) {\n                if (this._buffer) {\n                    // Cannot add an uniform if the buffer is already created\n                    BABYLON.Tools.Error(\"Cannot add an uniform after UBO has been created.\");\n                    return;\n                }\n                this.addUniform(uniformName, size);\n                location = this._uniformLocations[uniformName];\n            }\n            if (!this._buffer) {\n                this.create();\n            }\n            if (!this._dynamic) {\n                // Cache for static uniform buffers\n                var changed = false;\n                for (var i = 0; i < size; i++) {\n                    if (this._bufferData[location + i] !== data[i]) {\n                        changed = true;\n                        this._bufferData[location + i] = data[i];\n                    }\n                }\n                this._needSync = this._needSync || changed;\n            }\n            else {\n                // No cache for dynamic\n                for (var i = 0; i < size; i++) {\n                    this._bufferData[location + i] = data[i];\n                }\n            }\n        };\n        // Update methods\n        UniformBuffer.prototype._updateMatrix3x3ForUniform = function (name, matrix) {\n            // To match std140, matrix must be realigned\n            for (var i = 0; i < 3; i++) {\n                UniformBuffer._tempBuffer[i * 4] = matrix[i * 3];\n                UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 3 + 1];\n                UniformBuffer._tempBuffer[i * 4 + 2] = matrix[i * 3 + 2];\n                UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n            }\n            this.updateUniform(name, UniformBuffer._tempBuffer, 12);\n        };\n        UniformBuffer.prototype._updateMatrix3x3ForEffect = function (name, matrix) {\n            this._currentEffect.setMatrix3x3(name, matrix);\n        };\n        UniformBuffer.prototype._updateMatrix2x2ForEffect = function (name, matrix) {\n            this._currentEffect.setMatrix2x2(name, matrix);\n        };\n        UniformBuffer.prototype._updateMatrix2x2ForUniform = function (name, matrix) {\n            // To match std140, matrix must be realigned\n            for (var i = 0; i < 2; i++) {\n                UniformBuffer._tempBuffer[i * 4] = matrix[i * 2];\n                UniformBuffer._tempBuffer[i * 4 + 1] = matrix[i * 2 + 1];\n                UniformBuffer._tempBuffer[i * 4 + 2] = 0.0;\n                UniformBuffer._tempBuffer[i * 4 + 3] = 0.0;\n            }\n            this.updateUniform(name, UniformBuffer._tempBuffer, 8);\n        };\n        UniformBuffer.prototype._updateFloatForEffect = function (name, x) {\n            this._currentEffect.setFloat(name, x);\n        };\n        UniformBuffer.prototype._updateFloatForUniform = function (name, x) {\n            UniformBuffer._tempBuffer[0] = x;\n            this.updateUniform(name, UniformBuffer._tempBuffer, 1);\n        };\n        UniformBuffer.prototype._updateFloat2ForEffect = function (name, x, y, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            this._currentEffect.setFloat2(name + suffix, x, y);\n        };\n        UniformBuffer.prototype._updateFloat2ForUniform = function (name, x, y, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            UniformBuffer._tempBuffer[0] = x;\n            UniformBuffer._tempBuffer[1] = y;\n            this.updateUniform(name, UniformBuffer._tempBuffer, 2);\n        };\n        UniformBuffer.prototype._updateFloat3ForEffect = function (name, x, y, z, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            this._currentEffect.setFloat3(name + suffix, x, y, z);\n        };\n        UniformBuffer.prototype._updateFloat3ForUniform = function (name, x, y, z, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            UniformBuffer._tempBuffer[0] = x;\n            UniformBuffer._tempBuffer[1] = y;\n            UniformBuffer._tempBuffer[2] = z;\n            this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n        };\n        UniformBuffer.prototype._updateFloat4ForEffect = function (name, x, y, z, w, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            this._currentEffect.setFloat4(name + suffix, x, y, z, w);\n        };\n        UniformBuffer.prototype._updateFloat4ForUniform = function (name, x, y, z, w, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            UniformBuffer._tempBuffer[0] = x;\n            UniformBuffer._tempBuffer[1] = y;\n            UniformBuffer._tempBuffer[2] = z;\n            UniformBuffer._tempBuffer[3] = w;\n            this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n        };\n        UniformBuffer.prototype._updateMatrixForEffect = function (name, mat) {\n            this._currentEffect.setMatrix(name, mat);\n        };\n        UniformBuffer.prototype._updateMatrixForUniform = function (name, mat) {\n            this.updateUniform(name, mat.toArray(), 16);\n        };\n        UniformBuffer.prototype._updateVector3ForEffect = function (name, vector) {\n            this._currentEffect.setVector3(name, vector);\n        };\n        UniformBuffer.prototype._updateVector3ForUniform = function (name, vector) {\n            vector.toArray(UniformBuffer._tempBuffer);\n            this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n        };\n        UniformBuffer.prototype._updateVector4ForEffect = function (name, vector) {\n            this._currentEffect.setVector4(name, vector);\n        };\n        UniformBuffer.prototype._updateVector4ForUniform = function (name, vector) {\n            vector.toArray(UniformBuffer._tempBuffer);\n            this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n        };\n        UniformBuffer.prototype._updateColor3ForEffect = function (name, color, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            this._currentEffect.setColor3(name + suffix, color);\n        };\n        UniformBuffer.prototype._updateColor3ForUniform = function (name, color, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            color.toArray(UniformBuffer._tempBuffer);\n            this.updateUniform(name, UniformBuffer._tempBuffer, 3);\n        };\n        UniformBuffer.prototype._updateColor4ForEffect = function (name, color, alpha, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            this._currentEffect.setColor4(name + suffix, color, alpha);\n        };\n        UniformBuffer.prototype._updateColor4ForUniform = function (name, color, alpha, suffix) {\n            if (suffix === void 0) { suffix = \"\"; }\n            color.toArray(UniformBuffer._tempBuffer);\n            UniformBuffer._tempBuffer[3] = alpha;\n            this.updateUniform(name, UniformBuffer._tempBuffer, 4);\n        };\n        /**\n         * Sets a sampler uniform on the effect.\n         * @param {string} name Name of the sampler.\n         * @param {Texture} texture\n         */\n        UniformBuffer.prototype.setTexture = function (name, texture) {\n            this._currentEffect.setTexture(name, texture);\n        };\n        /**\n         * Directly updates the value of the uniform in the cache AND on the GPU.\n         * @param {string} uniformName Name of the uniform, as used in the uniform block in the shader.\n         * @param {number[]|Float32Array} data Flattened data\n         */\n        UniformBuffer.prototype.updateUniformDirectly = function (uniformName, data) {\n            this.updateUniform(uniformName, data, data.length);\n            this.update();\n        };\n        /**\n         * Binds this uniform buffer to an effect.\n         * @param {Effect} effect\n         * @param {string} name Name of the uniform block in the shader.\n         */\n        UniformBuffer.prototype.bindToEffect = function (effect, name) {\n            this._currentEffect = effect;\n            if (this._noUBO) {\n                return;\n            }\n            effect.bindUniformBuffer(this._buffer, name);\n        };\n        /**\n         * Disposes the uniform buffer.\n         */\n        UniformBuffer.prototype.dispose = function () {\n            if (!this._buffer) {\n                return;\n            }\n            if (this._engine._releaseBuffer(this._buffer)) {\n                this._buffer = null;\n            }\n        };\n        return UniformBuffer;\n    }());\n    // Pool for avoiding memory leaks\n    UniformBuffer._MAX_UNIFORM_SIZE = 256;\n    UniformBuffer._tempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);\n    BABYLON.UniformBuffer = UniformBuffer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.uniformBuffer.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PushMaterial = (function (_super) {\n        __extends(PushMaterial, _super);\n        function PushMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.storeEffectOnSubMeshes = true;\n            return _this;\n        }\n        PushMaterial.prototype.getEffect = function () {\n            return this._activeEffect;\n        };\n        PushMaterial.prototype.isReady = function (mesh, useInstances) {\n            if (!mesh) {\n                return false;\n            }\n            if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n                return true;\n            }\n            return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);\n        };\n        PushMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n            this._activeEffect.setMatrix(\"world\", world);\n        };\n        PushMaterial.prototype.bind = function (world, mesh) {\n            if (!mesh) {\n                return;\n            }\n            this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);\n        };\n        PushMaterial.prototype._afterBind = function (mesh, effect) {\n            _super.prototype._afterBind.call(this, mesh);\n            this.getScene()._cachedEffect = effect;\n        };\n        PushMaterial.prototype._mustRebind = function (scene, effect, visibility) {\n            if (visibility === void 0) { visibility = 0; }\n            return scene.isCachedMaterialValid(this, effect, visibility);\n        };\n        return PushMaterial;\n    }(BABYLON.Material));\n    BABYLON.PushMaterial = PushMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pushMaterial.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var VertexData = (function () {\n        function VertexData() {\n        }\n        VertexData.prototype.set = function (data, kind) {\n            switch (kind) {\n                case BABYLON.VertexBuffer.PositionKind:\n                    this.positions = data;\n                    break;\n                case BABYLON.VertexBuffer.NormalKind:\n                    this.normals = data;\n                    break;\n                case BABYLON.VertexBuffer.TangentKind:\n                    this.tangents = data;\n                    break;\n                case BABYLON.VertexBuffer.UVKind:\n                    this.uvs = data;\n                    break;\n                case BABYLON.VertexBuffer.UV2Kind:\n                    this.uvs2 = data;\n                    break;\n                case BABYLON.VertexBuffer.UV3Kind:\n                    this.uvs3 = data;\n                    break;\n                case BABYLON.VertexBuffer.UV4Kind:\n                    this.uvs4 = data;\n                    break;\n                case BABYLON.VertexBuffer.UV5Kind:\n                    this.uvs5 = data;\n                    break;\n                case BABYLON.VertexBuffer.UV6Kind:\n                    this.uvs6 = data;\n                    break;\n                case BABYLON.VertexBuffer.ColorKind:\n                    this.colors = data;\n                    break;\n                case BABYLON.VertexBuffer.MatricesIndicesKind:\n                    this.matricesIndices = data;\n                    break;\n                case BABYLON.VertexBuffer.MatricesWeightsKind:\n                    this.matricesWeights = data;\n                    break;\n                case BABYLON.VertexBuffer.MatricesIndicesExtraKind:\n                    this.matricesIndicesExtra = data;\n                    break;\n                case BABYLON.VertexBuffer.MatricesWeightsExtraKind:\n                    this.matricesWeightsExtra = data;\n                    break;\n            }\n        };\n        /**\n         * Associates the vertexData to the passed Mesh.\n         * Sets it as updatable or not (default `false`).\n         * Returns the VertexData.\n         */\n        VertexData.prototype.applyToMesh = function (mesh, updatable) {\n            this._applyTo(mesh, updatable);\n            return this;\n        };\n        /**\n         * Associates the vertexData to the passed Geometry.\n         * Sets it as updatable or not (default `false`).\n         * Returns the VertexData.\n         */\n        VertexData.prototype.applyToGeometry = function (geometry, updatable) {\n            this._applyTo(geometry, updatable);\n            return this;\n        };\n        /**\n         * Updates the associated mesh.\n         * Returns the VertexData.\n         */\n        VertexData.prototype.updateMesh = function (mesh, updateExtends, makeItUnique) {\n            this._update(mesh);\n            return this;\n        };\n        /**\n         * Updates the associated geometry.\n         * Returns the VertexData.\n         */\n        VertexData.prototype.updateGeometry = function (geometry, updateExtends, makeItUnique) {\n            this._update(geometry);\n            return this;\n        };\n        VertexData.prototype._applyTo = function (meshOrGeometry, updatable) {\n            if (this.positions) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.PositionKind, this.positions, updatable);\n            }\n            if (this.normals) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.NormalKind, this.normals, updatable);\n            }\n            if (this.tangents) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.TangentKind, this.tangents, updatable);\n            }\n            if (this.uvs) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UVKind, this.uvs, updatable);\n            }\n            if (this.uvs2) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UV2Kind, this.uvs2, updatable);\n            }\n            if (this.uvs3) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UV3Kind, this.uvs3, updatable);\n            }\n            if (this.uvs4) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UV4Kind, this.uvs4, updatable);\n            }\n            if (this.uvs5) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UV5Kind, this.uvs5, updatable);\n            }\n            if (this.uvs6) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.UV6Kind, this.uvs6, updatable);\n            }\n            if (this.colors) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.ColorKind, this.colors, updatable);\n            }\n            if (this.matricesIndices) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);\n            }\n            if (this.matricesWeights) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);\n            }\n            if (this.matricesIndicesExtra) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);\n            }\n            if (this.matricesWeightsExtra) {\n                meshOrGeometry.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);\n            }\n            if (this.indices) {\n                meshOrGeometry.setIndices(this.indices);\n            }\n            return this;\n        };\n        VertexData.prototype._update = function (meshOrGeometry, updateExtends, makeItUnique) {\n            if (this.positions) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);\n            }\n            if (this.normals) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);\n            }\n            if (this.tangents) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);\n            }\n            if (this.uvs) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);\n            }\n            if (this.uvs2) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);\n            }\n            if (this.uvs3) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);\n            }\n            if (this.uvs4) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);\n            }\n            if (this.uvs5) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);\n            }\n            if (this.uvs6) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);\n            }\n            if (this.colors) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);\n            }\n            if (this.matricesIndices) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);\n            }\n            if (this.matricesWeights) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);\n            }\n            if (this.matricesIndicesExtra) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);\n            }\n            if (this.matricesWeightsExtra) {\n                meshOrGeometry.updateVerticesData(BABYLON.VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);\n            }\n            if (this.indices) {\n                meshOrGeometry.setIndices(this.indices);\n            }\n            return this;\n        };\n        /**\n         * Transforms each position and each normal of the vertexData according to the passed Matrix.\n         * Returns the VertexData.\n         */\n        VertexData.prototype.transform = function (matrix) {\n            var transformed = BABYLON.Vector3.Zero();\n            var index;\n            if (this.positions) {\n                var position = BABYLON.Vector3.Zero();\n                for (index = 0; index < this.positions.length; index += 3) {\n                    BABYLON.Vector3.FromArrayToRef(this.positions, index, position);\n                    BABYLON.Vector3.TransformCoordinatesToRef(position, matrix, transformed);\n                    this.positions[index] = transformed.x;\n                    this.positions[index + 1] = transformed.y;\n                    this.positions[index + 2] = transformed.z;\n                }\n            }\n            if (this.normals) {\n                var normal = BABYLON.Vector3.Zero();\n                for (index = 0; index < this.normals.length; index += 3) {\n                    BABYLON.Vector3.FromArrayToRef(this.normals, index, normal);\n                    BABYLON.Vector3.TransformNormalToRef(normal, matrix, transformed);\n                    this.normals[index] = transformed.x;\n                    this.normals[index + 1] = transformed.y;\n                    this.normals[index + 2] = transformed.z;\n                }\n            }\n            if (this.tangents) {\n                var tangent = BABYLON.Vector4.Zero();\n                var tangentTransformed = BABYLON.Vector4.Zero();\n                for (index = 0; index < this.tangents.length; index += 4) {\n                    BABYLON.Vector4.FromArrayToRef(this.tangents, index, tangent);\n                    BABYLON.Vector4.TransformNormalToRef(tangent, matrix, tangentTransformed);\n                    this.tangents[index] = tangentTransformed.x;\n                    this.tangents[index + 1] = tangentTransformed.y;\n                    this.tangents[index + 2] = tangentTransformed.z;\n                    this.tangents[index + 3] = tangentTransformed.w;\n                }\n            }\n            return this;\n        };\n        /**\n         * Merges the passed VertexData into the current one.\n         * Returns the modified VertexData.\n         */\n        VertexData.prototype.merge = function (other) {\n            if (other.indices) {\n                if (!this.indices) {\n                    this.indices = [];\n                }\n                var offset = this.positions ? this.positions.length / 3 : 0;\n                for (var index = 0; index < other.indices.length; index++) {\n                    //TODO check type - if Int32Array | Uint32Array | Uint16Array!\n                    this.indices.push(other.indices[index] + offset);\n                }\n            }\n            this.positions = this._mergeElement(this.positions, other.positions);\n            this.normals = this._mergeElement(this.normals, other.normals);\n            this.tangents = this._mergeElement(this.tangents, other.tangents);\n            this.uvs = this._mergeElement(this.uvs, other.uvs);\n            this.uvs2 = this._mergeElement(this.uvs2, other.uvs2);\n            this.uvs3 = this._mergeElement(this.uvs3, other.uvs3);\n            this.uvs4 = this._mergeElement(this.uvs4, other.uvs4);\n            this.uvs5 = this._mergeElement(this.uvs5, other.uvs5);\n            this.uvs6 = this._mergeElement(this.uvs6, other.uvs6);\n            this.colors = this._mergeElement(this.colors, other.colors);\n            this.matricesIndices = this._mergeElement(this.matricesIndices, other.matricesIndices);\n            this.matricesWeights = this._mergeElement(this.matricesWeights, other.matricesWeights);\n            this.matricesIndicesExtra = this._mergeElement(this.matricesIndicesExtra, other.matricesIndicesExtra);\n            this.matricesWeightsExtra = this._mergeElement(this.matricesWeightsExtra, other.matricesWeightsExtra);\n            return this;\n        };\n        VertexData.prototype._mergeElement = function (source, other) {\n            if (!other)\n                return source;\n            if (!source)\n                return other;\n            var len = other.length + source.length;\n            var isSrcTypedArray = source instanceof Float32Array;\n            var isOthTypedArray = other instanceof Float32Array;\n            // use non-loop method when the source is Float32Array\n            if (isSrcTypedArray) {\n                var ret32 = new Float32Array(len);\n                ret32.set(source);\n                ret32.set(other, source.length);\n                return ret32;\n                // source is number[], when other is also use concat\n            }\n            else if (!isOthTypedArray) {\n                return source.concat(other);\n                // source is a number[], but other is a Float32Array, loop required\n            }\n            else {\n                var ret = source.slice(0); // copy source to a separate array\n                for (var i = 0, len = other.length; i < len; i++) {\n                    ret.push(other[i]);\n                }\n                return ret;\n            }\n        };\n        /**\n         * Serializes the VertexData.\n         * Returns a serialized object.\n         */\n        VertexData.prototype.serialize = function () {\n            var serializationObject = this.serialize();\n            if (this.positions) {\n                serializationObject.positions = this.positions;\n            }\n            if (this.normals) {\n                serializationObject.normals = this.normals;\n            }\n            if (this.tangents) {\n                serializationObject.tangents = this.tangents;\n            }\n            if (this.uvs) {\n                serializationObject.uvs = this.uvs;\n            }\n            if (this.uvs2) {\n                serializationObject.uvs2 = this.uvs2;\n            }\n            if (this.uvs3) {\n                serializationObject.uvs3 = this.uvs3;\n            }\n            if (this.uvs4) {\n                serializationObject.uvs4 = this.uvs4;\n            }\n            if (this.uvs5) {\n                serializationObject.uvs5 = this.uvs5;\n            }\n            if (this.uvs6) {\n                serializationObject.uvs6 = this.uvs6;\n            }\n            if (this.colors) {\n                serializationObject.colors = this.colors;\n            }\n            if (this.matricesIndices) {\n                serializationObject.matricesIndices = this.matricesIndices;\n                serializationObject.matricesIndices._isExpanded = true;\n            }\n            if (this.matricesWeights) {\n                serializationObject.matricesWeights = this.matricesWeights;\n            }\n            if (this.matricesIndicesExtra) {\n                serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;\n                serializationObject.matricesIndicesExtra._isExpanded = true;\n            }\n            if (this.matricesWeightsExtra) {\n                serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;\n            }\n            serializationObject.indices = this.indices;\n            return serializationObject;\n        };\n        // Statics\n        /**\n         * Returns the object VertexData associated to the passed mesh.\n         */\n        VertexData.ExtractFromMesh = function (mesh, copyWhenShared, forceCopy) {\n            return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);\n        };\n        /**\n         * Returns the object VertexData associated to the passed geometry.\n         */\n        VertexData.ExtractFromGeometry = function (geometry, copyWhenShared, forceCopy) {\n            return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);\n        };\n        VertexData._ExtractFrom = function (meshOrGeometry, copyWhenShared, forceCopy) {\n            var result = new VertexData();\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind)) {\n                result.positions = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.PositionKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                result.normals = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.NormalKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.TangentKind)) {\n                result.tangents = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.TangentKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                result.uvs = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UVKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                result.uvs2 = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UV2Kind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UV3Kind)) {\n                result.uvs3 = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UV3Kind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UV4Kind)) {\n                result.uvs4 = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UV4Kind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UV5Kind)) {\n                result.uvs5 = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UV5Kind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.UV6Kind)) {\n                result.uvs6 = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.UV6Kind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.ColorKind)) {\n                result.colors = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.ColorKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesIndicesKind)) {\n                result.matricesIndices = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesWeightsKind)) {\n                result.matricesWeights = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesIndicesExtraKind)) {\n                result.matricesIndicesExtra = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);\n            }\n            if (meshOrGeometry.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesWeightsExtraKind)) {\n                result.matricesWeightsExtra = meshOrGeometry.getVerticesData(BABYLON.VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);\n            }\n            result.indices = meshOrGeometry.getIndices(copyWhenShared);\n            return result;\n        };\n        /**\n         * Creates the vertexData of the Ribbon.\n         */\n        VertexData.CreateRibbon = function (options) {\n            var pathArray = options.pathArray;\n            var closeArray = options.closeArray || false;\n            var closePath = options.closePath || false;\n            var invertUV = options.invertUV || false;\n            var defaultOffset = Math.floor(pathArray[0].length / 2);\n            var offset = options.offset || defaultOffset;\n            offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var customUV = options.uvs;\n            var customColors = options.colors;\n            var positions = [];\n            var indices = [];\n            var normals = [];\n            var uvs = [];\n            var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\n            var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray\n            var uTotalDistance = []; // uTotalDistance[p] : total distance of path p\n            var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\n            var minlg; // minimal length among all paths from pathArray\n            var lg = []; // array of path lengths : nb of vertex per path\n            var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\n            var p; // path iterator\n            var i; // point iterator\n            var j; // point iterator\n            // if single path in pathArray\n            if (pathArray.length < 2) {\n                var ar1 = [];\n                var ar2 = [];\n                for (i = 0; i < pathArray[0].length - offset; i++) {\n                    ar1.push(pathArray[0][i]);\n                    ar2.push(pathArray[0][i + offset]);\n                }\n                pathArray = [ar1, ar2];\n            }\n            // positions and horizontal distances (u)\n            var idc = 0;\n            var closePathCorr = (closePath) ? 1 : 0; // the final index will be +1 if closePath\n            var path;\n            var l;\n            minlg = pathArray[0].length;\n            var vectlg;\n            var dist;\n            for (p = 0; p < pathArray.length; p++) {\n                uTotalDistance[p] = 0;\n                us[p] = [0];\n                path = pathArray[p];\n                l = path.length;\n                minlg = (minlg < l) ? minlg : l;\n                j = 0;\n                while (j < l) {\n                    positions.push(path[j].x, path[j].y, path[j].z);\n                    if (j > 0) {\n                        vectlg = path[j].subtract(path[j - 1]).length();\n                        dist = vectlg + uTotalDistance[p];\n                        us[p].push(dist);\n                        uTotalDistance[p] = dist;\n                    }\n                    j++;\n                }\n                if (closePath) {\n                    j--;\n                    positions.push(path[0].x, path[0].y, path[0].z);\n                    vectlg = path[j].subtract(path[0]).length();\n                    dist = vectlg + uTotalDistance[p];\n                    us[p].push(dist);\n                    uTotalDistance[p] = dist;\n                }\n                lg[p] = l + closePathCorr;\n                idx[p] = idc;\n                idc += (l + closePathCorr);\n            }\n            // vertical distances (v)\n            var path1;\n            var path2;\n            var vertex1;\n            var vertex2;\n            for (i = 0; i < minlg + closePathCorr; i++) {\n                vTotalDistance[i] = 0;\n                vs[i] = [0];\n                for (p = 0; p < pathArray.length - 1; p++) {\n                    path1 = pathArray[p];\n                    path2 = pathArray[p + 1];\n                    if (i === minlg) {\n                        vertex1 = path1[0];\n                        vertex2 = path2[0];\n                    }\n                    else {\n                        vertex1 = path1[i];\n                        vertex2 = path2[i];\n                    }\n                    vectlg = vertex2.subtract(vertex1).length();\n                    dist = vectlg + vTotalDistance[i];\n                    vs[i].push(dist);\n                    vTotalDistance[i] = dist;\n                }\n                if (closeArray) {\n                    path1 = pathArray[p];\n                    path2 = pathArray[0];\n                    if (i === minlg) {\n                        vertex2 = path2[0];\n                    }\n                    vectlg = vertex2.subtract(vertex1).length();\n                    dist = vectlg + vTotalDistance[i];\n                    vTotalDistance[i] = dist;\n                }\n            }\n            // uvs\n            var u;\n            var v;\n            if (customUV) {\n                for (p = 0; p < customUV.length; p++) {\n                    uvs.push(customUV[p].x, customUV[p].y);\n                }\n            }\n            else {\n                for (p = 0; p < pathArray.length; p++) {\n                    for (i = 0; i < minlg + closePathCorr; i++) {\n                        u = (uTotalDistance[p] != 0.0) ? us[p][i] / uTotalDistance[p] : 0.0;\n                        v = (vTotalDistance[i] != 0.0) ? vs[i][p] / vTotalDistance[i] : 0.0;\n                        if (invertUV) {\n                            uvs.push(v, u);\n                        }\n                        else {\n                            uvs.push(u, v);\n                        }\n                    }\n                }\n            }\n            // indices\n            p = 0; // path index\n            var pi = 0; // positions array index\n            var l1 = lg[p] - 1; // path1 length\n            var l2 = lg[p + 1] - 1; // path2 length\n            var min = (l1 < l2) ? l1 : l2; // current path stop index\n            var shft = idx[1] - idx[0]; // shift\n            var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\n            while (pi <= min && p < path1nb) {\n                // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\n                indices.push(pi, pi + shft, pi + 1);\n                indices.push(pi + shft + 1, pi + 1, pi + shft);\n                pi += 1;\n                if (pi === min) {\n                    p++;\n                    if (p === lg.length - 1) {\n                        shft = idx[0] - idx[p];\n                        l1 = lg[p] - 1;\n                        l2 = lg[0] - 1;\n                    }\n                    else {\n                        shft = idx[p + 1] - idx[p];\n                        l1 = lg[p] - 1;\n                        l2 = lg[p + 1] - 1;\n                    }\n                    pi = idx[p];\n                    min = (l1 < l2) ? l1 + pi : l2 + pi;\n                }\n            }\n            // normals\n            VertexData.ComputeNormals(positions, indices, normals);\n            if (closePath) {\n                var indexFirst = 0;\n                var indexLast = 0;\n                for (p = 0; p < pathArray.length; p++) {\n                    indexFirst = idx[p] * 3;\n                    if (p + 1 < pathArray.length) {\n                        indexLast = (idx[p + 1] - 1) * 3;\n                    }\n                    else {\n                        indexLast = normals.length - 3;\n                    }\n                    normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n                    normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n                    normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n                    normals[indexLast] = normals[indexFirst];\n                    normals[indexLast + 1] = normals[indexFirst + 1];\n                    normals[indexLast + 2] = normals[indexFirst + 2];\n                }\n            }\n            // sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Colors\n            if (customColors) {\n                var colors = new Float32Array(customColors.length * 4);\n                for (var c = 0; c < customColors.length; c++) {\n                    colors[c * 4] = customColors[c].r;\n                    colors[c * 4 + 1] = customColors[c].g;\n                    colors[c * 4 + 2] = customColors[c].b;\n                    colors[c * 4 + 3] = customColors[c].a;\n                }\n            }\n            // Result\n            var vertexData = new VertexData();\n            var positions32 = new Float32Array(positions);\n            var normals32 = new Float32Array(normals);\n            var uvs32 = new Float32Array(uvs);\n            vertexData.indices = indices;\n            vertexData.positions = positions32;\n            vertexData.normals = normals32;\n            vertexData.uvs = uvs32;\n            if (customColors) {\n                vertexData.set(colors, BABYLON.VertexBuffer.ColorKind);\n            }\n            if (closePath) {\n                vertexData._idx = idx;\n            }\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Box.\n         */\n        VertexData.CreateBox = function (options) {\n            var normalsSource = [\n                new BABYLON.Vector3(0, 0, 1),\n                new BABYLON.Vector3(0, 0, -1),\n                new BABYLON.Vector3(1, 0, 0),\n                new BABYLON.Vector3(-1, 0, 0),\n                new BABYLON.Vector3(0, 1, 0),\n                new BABYLON.Vector3(0, -1, 0)\n            ];\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var width = options.width || options.size || 1;\n            var height = options.height || options.size || 1;\n            var depth = options.depth || options.size || 1;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var faceUV = options.faceUV || new Array(6);\n            var faceColors = options.faceColors;\n            var colors = [];\n            // default face colors and UV if undefined\n            for (var f = 0; f < 6; f++) {\n                if (faceUV[f] === undefined) {\n                    faceUV[f] = new BABYLON.Vector4(0, 0, 1, 1);\n                }\n                if (faceColors && faceColors[f] === undefined) {\n                    faceColors[f] = new BABYLON.Color4(1, 1, 1, 1);\n                }\n            }\n            var scaleVector = new BABYLON.Vector3(width / 2, height / 2, depth / 2);\n            // Create each face in turn.\n            for (var index = 0; index < normalsSource.length; index++) {\n                var normal = normalsSource[index];\n                // Get two vectors perpendicular to the face normal and to each other.\n                var side1 = new BABYLON.Vector3(normal.y, normal.z, normal.x);\n                var side2 = BABYLON.Vector3.Cross(normal, side1);\n                // Six indices (two triangles) per face.\n                var verticesLength = positions.length / 3;\n                indices.push(verticesLength);\n                indices.push(verticesLength + 1);\n                indices.push(verticesLength + 2);\n                indices.push(verticesLength);\n                indices.push(verticesLength + 2);\n                indices.push(verticesLength + 3);\n                // Four vertices per face.\n                var vertex = normal.subtract(side1).subtract(side2).multiply(scaleVector);\n                positions.push(vertex.x, vertex.y, vertex.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(faceUV[index].z, faceUV[index].w);\n                if (faceColors) {\n                    colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n                }\n                vertex = normal.subtract(side1).add(side2).multiply(scaleVector);\n                positions.push(vertex.x, vertex.y, vertex.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(faceUV[index].x, faceUV[index].w);\n                if (faceColors) {\n                    colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n                }\n                vertex = normal.add(side1).add(side2).multiply(scaleVector);\n                positions.push(vertex.x, vertex.y, vertex.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(faceUV[index].x, faceUV[index].y);\n                if (faceColors) {\n                    colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n                }\n                vertex = normal.add(side1).subtract(side2).multiply(scaleVector);\n                positions.push(vertex.x, vertex.y, vertex.z);\n                normals.push(normal.x, normal.y, normal.z);\n                uvs.push(faceUV[index].z, faceUV[index].y);\n                if (faceColors) {\n                    colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\n                }\n            }\n            // sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            if (faceColors) {\n                var totalColors = (sideOrientation === BABYLON.Mesh.DOUBLESIDE) ? colors.concat(colors) : colors;\n                vertexData.colors = totalColors;\n            }\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Sphere.\n         */\n        VertexData.CreateSphere = function (options) {\n            var segments = options.segments || 32;\n            var diameterX = options.diameterX || options.diameter || 1;\n            var diameterY = options.diameterY || options.diameter || 1;\n            var diameterZ = options.diameterZ || options.diameter || 1;\n            var arc = (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n            var slice = (options.slice <= 0) ? 1.0 : options.slice || 1.0;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var radius = new BABYLON.Vector3(diameterX / 2, diameterY / 2, diameterZ / 2);\n            var totalZRotationSteps = 2 + segments;\n            var totalYRotationSteps = 2 * totalZRotationSteps;\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n                var normalizedZ = zRotationStep / totalZRotationSteps;\n                var angleZ = normalizedZ * Math.PI * slice;\n                for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n                    var normalizedY = yRotationStep / totalYRotationSteps;\n                    var angleY = normalizedY * Math.PI * 2 * arc;\n                    var rotationZ = BABYLON.Matrix.RotationZ(-angleZ);\n                    var rotationY = BABYLON.Matrix.RotationY(angleY);\n                    var afterRotZ = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Up(), rotationZ);\n                    var complete = BABYLON.Vector3.TransformCoordinates(afterRotZ, rotationY);\n                    var vertex = complete.multiply(radius);\n                    var normal = complete.divide(radius).normalize();\n                    positions.push(vertex.x, vertex.y, vertex.z);\n                    normals.push(normal.x, normal.y, normal.z);\n                    uvs.push(normalizedY, normalizedZ);\n                }\n                if (zRotationStep > 0) {\n                    var verticesCount = positions.length / 3;\n                    for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\n                        indices.push((firstIndex));\n                        indices.push((firstIndex + 1));\n                        indices.push(firstIndex + totalYRotationSteps + 1);\n                        indices.push((firstIndex + totalYRotationSteps + 1));\n                        indices.push((firstIndex + 1));\n                        indices.push((firstIndex + totalYRotationSteps + 2));\n                    }\n                }\n            }\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Cylinder or Cone.\n         */\n        VertexData.CreateCylinder = function (options) {\n            var height = options.height || 2;\n            var diameterTop = (options.diameterTop === 0) ? 0 : options.diameterTop || options.diameter || 1;\n            var diameterBottom = (options.diameterBottom === 0) ? 0 : options.diameterBottom || options.diameter || 1;\n            var tessellation = options.tessellation || 24;\n            var subdivisions = options.subdivisions || 1;\n            var hasRings = options.hasRings;\n            var enclose = options.enclose;\n            var arc = (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var faceUV = options.faceUV || new Array(3);\n            var faceColors = options.faceColors;\n            // default face colors and UV if undefined\n            var quadNb = (arc !== 1 && enclose) ? 2 : 0;\n            var ringNb = (hasRings) ? subdivisions : 1;\n            var surfaceNb = 2 + (1 + quadNb) * ringNb;\n            var f;\n            for (f = 0; f < surfaceNb; f++) {\n                if (faceColors && faceColors[f] === undefined) {\n                    faceColors[f] = new BABYLON.Color4(1, 1, 1, 1);\n                }\n            }\n            for (f = 0; f < surfaceNb; f++) {\n                if (faceUV && faceUV[f] === undefined) {\n                    faceUV[f] = new BABYLON.Vector4(0, 0, 1, 1);\n                }\n            }\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var colors = [];\n            var angle_step = Math.PI * 2 * arc / tessellation;\n            var angle;\n            var h;\n            var radius;\n            var tan = (diameterBottom - diameterTop) / 2 / height;\n            var ringVertex = BABYLON.Vector3.Zero();\n            var ringNormal = BABYLON.Vector3.Zero();\n            var ringFirstVertex = BABYLON.Vector3.Zero();\n            var ringFirstNormal = BABYLON.Vector3.Zero();\n            var quadNormal = BABYLON.Vector3.Zero();\n            var Y = BABYLON.Axis.Y;\n            // positions, normals, uvs\n            var i;\n            var j;\n            var r;\n            var ringIdx = 1;\n            var s = 1; // surface index\n            var cs = 0;\n            var v = 0;\n            for (i = 0; i <= subdivisions; i++) {\n                h = i / subdivisions;\n                radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\n                ringIdx = (hasRings && i !== 0 && i !== subdivisions) ? 2 : 1;\n                for (r = 0; r < ringIdx; r++) {\n                    if (hasRings) {\n                        s += r;\n                    }\n                    if (enclose) {\n                        s += 2 * r;\n                    }\n                    for (j = 0; j <= tessellation; j++) {\n                        angle = j * angle_step;\n                        // position\n                        ringVertex.x = Math.cos(-angle) * radius;\n                        ringVertex.y = -height / 2 + h * height;\n                        ringVertex.z = Math.sin(-angle) * radius;\n                        // normal\n                        if (diameterTop === 0 && i === subdivisions) {\n                            // if no top cap, reuse former normals\n                            ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\n                            ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\n                            ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\n                        }\n                        else {\n                            ringNormal.x = ringVertex.x;\n                            ringNormal.z = ringVertex.z;\n                            ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\n                            ringNormal.normalize();\n                        }\n                        // keep first ring vertex values for enclose\n                        if (j === 0) {\n                            ringFirstVertex.copyFrom(ringVertex);\n                            ringFirstNormal.copyFrom(ringNormal);\n                        }\n                        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                        normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\n                        if (hasRings) {\n                            v = (cs !== s) ? faceUV[s].y : faceUV[s].w;\n                        }\n                        else {\n                            v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\n                        }\n                        uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);\n                        if (faceColors) {\n                            colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\n                        }\n                    }\n                    // if enclose, add four vertices and their dedicated normals\n                    if (arc !== 1 && enclose) {\n                        positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\n                        positions.push(0, ringVertex.y, 0);\n                        positions.push(0, ringVertex.y, 0);\n                        positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\n                        BABYLON.Vector3.CrossToRef(Y, ringNormal, quadNormal);\n                        quadNormal.normalize();\n                        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                        BABYLON.Vector3.CrossToRef(ringFirstNormal, Y, quadNormal);\n                        quadNormal.normalize();\n                        normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\n                        if (hasRings) {\n                            v = (cs !== s) ? faceUV[s + 1].y : faceUV[s + 1].w;\n                        }\n                        else {\n                            v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\n                        }\n                        uvs.push(faceUV[s + 1].x, v);\n                        uvs.push(faceUV[s + 1].z, v);\n                        if (hasRings) {\n                            v = (cs !== s) ? faceUV[s + 2].y : faceUV[s + 2].w;\n                        }\n                        else {\n                            v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\n                        }\n                        uvs.push(faceUV[s + 2].x, v);\n                        uvs.push(faceUV[s + 2].z, v);\n                        if (faceColors) {\n                            colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                            colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\n                            colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                            colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\n                        }\n                    }\n                    if (cs !== s) {\n                        cs = s;\n                    }\n                }\n            }\n            // indices\n            var e = (arc !== 1 && enclose) ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\n            var s;\n            i = 0;\n            for (s = 0; s < subdivisions; s++) {\n                for (j = 0; j < tessellation; j++) {\n                    var i0 = i * (e + 1) + j;\n                    var i1 = (i + 1) * (e + 1) + j;\n                    var i2 = i * (e + 1) + (j + 1);\n                    var i3 = (i + 1) * (e + 1) + (j + 1);\n                    indices.push(i0, i1, i2);\n                    indices.push(i3, i2, i1);\n                }\n                if (arc !== 1 && enclose) {\n                    indices.push(i0 + 2, i1 + 2, i2 + 2);\n                    indices.push(i3 + 2, i2 + 2, i1 + 2);\n                    indices.push(i0 + 4, i1 + 4, i2 + 4);\n                    indices.push(i3 + 4, i2 + 4, i1 + 4);\n                }\n                i = (hasRings) ? (i + 2) : (i + 1);\n            }\n            // Caps\n            var createCylinderCap = function (isTop) {\n                var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\n                if (radius === 0) {\n                    return;\n                }\n                // Cap positions, normals & uvs\n                var angle;\n                var circleVector;\n                var i;\n                var u = (isTop) ? faceUV[surfaceNb - 1] : faceUV[0];\n                var c;\n                if (faceColors) {\n                    c = (isTop) ? faceColors[surfaceNb - 1] : faceColors[0];\n                }\n                // cap center\n                var vbase = positions.length / 3;\n                var offset = isTop ? height / 2 : -height / 2;\n                var center = new BABYLON.Vector3(0, offset, 0);\n                positions.push(center.x, center.y, center.z);\n                normals.push(0, isTop ? 1 : -1, 0);\n                uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);\n                if (faceColors) {\n                    colors.push(c.r, c.g, c.b, c.a);\n                }\n                var textureScale = new BABYLON.Vector2(0.5, 0.5);\n                for (i = 0; i <= tessellation; i++) {\n                    angle = Math.PI * 2 * i * arc / tessellation;\n                    var cos = Math.cos(-angle);\n                    var sin = Math.sin(-angle);\n                    circleVector = new BABYLON.Vector3(cos * radius, offset, sin * radius);\n                    var textureCoordinate = new BABYLON.Vector2(cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\n                    positions.push(circleVector.x, circleVector.y, circleVector.z);\n                    normals.push(0, isTop ? 1 : -1, 0);\n                    uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);\n                    if (faceColors) {\n                        colors.push(c.r, c.g, c.b, c.a);\n                    }\n                }\n                // Cap indices\n                for (i = 0; i < tessellation; i++) {\n                    if (!isTop) {\n                        indices.push(vbase);\n                        indices.push(vbase + (i + 1));\n                        indices.push(vbase + (i + 2));\n                    }\n                    else {\n                        indices.push(vbase);\n                        indices.push(vbase + (i + 2));\n                        indices.push(vbase + (i + 1));\n                    }\n                }\n            };\n            // add caps to geometry\n            createCylinderCap(false);\n            createCylinderCap(true);\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            if (faceColors) {\n                vertexData.colors = colors;\n            }\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Torus.\n         */\n        VertexData.CreateTorus = function (options) {\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var diameter = options.diameter || 1;\n            var thickness = options.thickness || 0.5;\n            var tessellation = options.tessellation || 16;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var stride = tessellation + 1;\n            for (var i = 0; i <= tessellation; i++) {\n                var u = i / tessellation;\n                var outerAngle = i * Math.PI * 2.0 / tessellation - Math.PI / 2.0;\n                var transform = BABYLON.Matrix.Translation(diameter / 2.0, 0, 0).multiply(BABYLON.Matrix.RotationY(outerAngle));\n                for (var j = 0; j <= tessellation; j++) {\n                    var v = 1 - j / tessellation;\n                    var innerAngle = j * Math.PI * 2.0 / tessellation + Math.PI;\n                    var dx = Math.cos(innerAngle);\n                    var dy = Math.sin(innerAngle);\n                    // Create a vertex.\n                    var normal = new BABYLON.Vector3(dx, dy, 0);\n                    var position = normal.scale(thickness / 2);\n                    var textureCoordinate = new BABYLON.Vector2(u, v);\n                    position = BABYLON.Vector3.TransformCoordinates(position, transform);\n                    normal = BABYLON.Vector3.TransformNormal(normal, transform);\n                    positions.push(position.x, position.y, position.z);\n                    normals.push(normal.x, normal.y, normal.z);\n                    uvs.push(textureCoordinate.x, textureCoordinate.y);\n                    // And create indices for two triangles.\n                    var nextI = (i + 1) % stride;\n                    var nextJ = (j + 1) % stride;\n                    indices.push(i * stride + j);\n                    indices.push(i * stride + nextJ);\n                    indices.push(nextI * stride + j);\n                    indices.push(i * stride + nextJ);\n                    indices.push(nextI * stride + nextJ);\n                    indices.push(nextI * stride + j);\n                }\n            }\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the LineSystem.\n         */\n        VertexData.CreateLineSystem = function (options) {\n            var indices = [];\n            var positions = [];\n            var lines = options.lines;\n            var idx = 0;\n            for (var l = 0; l < lines.length; l++) {\n                var points = lines[l];\n                for (var index = 0; index < points.length; index++) {\n                    positions.push(points[index].x, points[index].y, points[index].z);\n                    if (index > 0) {\n                        indices.push(idx - 1);\n                        indices.push(idx);\n                    }\n                    idx++;\n                }\n            }\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            return vertexData;\n        };\n        /**\n         * Create the VertexData of the DashedLines.\n         */\n        VertexData.CreateDashedLines = function (options) {\n            var dashSize = options.dashSize || 3;\n            var gapSize = options.gapSize || 1;\n            var dashNb = options.dashNb || 200;\n            var points = options.points;\n            var positions = new Array();\n            var indices = new Array();\n            var curvect = BABYLON.Vector3.Zero();\n            var lg = 0;\n            var nb = 0;\n            var shft = 0;\n            var dashshft = 0;\n            var curshft = 0;\n            var idx = 0;\n            var i = 0;\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                lg += curvect.length();\n            }\n            shft = lg / dashNb;\n            dashshft = dashSize * shft / (dashSize + gapSize);\n            for (i = 0; i < points.length - 1; i++) {\n                points[i + 1].subtractToRef(points[i], curvect);\n                nb = Math.floor(curvect.length() / shft);\n                curvect.normalize();\n                for (var j = 0; j < nb; j++) {\n                    curshft = shft * j;\n                    positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\n                    positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\n                    indices.push(idx, idx + 1);\n                    idx += 2;\n                }\n            }\n            // Result\n            var vertexData = new VertexData();\n            vertexData.positions = positions;\n            vertexData.indices = indices;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Ground.\n         */\n        VertexData.CreateGround = function (options) {\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var row, col;\n            var width = options.width || 1;\n            var height = options.height || 1;\n            var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n            var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n            for (row = 0; row <= subdivisionsY; row++) {\n                for (col = 0; col <= subdivisionsX; col++) {\n                    var position = new BABYLON.Vector3((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));\n                    var normal = new BABYLON.Vector3(0, 1.0, 0);\n                    positions.push(position.x, position.y, position.z);\n                    normals.push(normal.x, normal.y, normal.z);\n                    uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\n                }\n            }\n            for (row = 0; row < subdivisionsY; row++) {\n                for (col = 0; col < subdivisionsX; col++) {\n                    indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n                    indices.push(col + 1 + row * (subdivisionsX + 1));\n                    indices.push(col + row * (subdivisionsX + 1));\n                    indices.push(col + (row + 1) * (subdivisionsX + 1));\n                    indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\n                    indices.push(col + row * (subdivisionsX + 1));\n                }\n            }\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the TiledGround.\n         */\n        VertexData.CreateTiledGround = function (options) {\n            var xmin = options.xmin || -1.0;\n            var zmin = options.zmin || -1.0;\n            var xmax = options.xmax || 1.0;\n            var zmax = options.zmax || 1.0;\n            var subdivisions = options.subdivisions || { w: 1, h: 1 };\n            var precision = options.precision || { w: 1, h: 1 };\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var row, col, tileRow, tileCol;\n            subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;\n            subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;\n            precision.w = (precision.w < 1) ? 1 : precision.w;\n            precision.h = (precision.h < 1) ? 1 : precision.h;\n            var tileSize = {\n                'w': (xmax - xmin) / subdivisions.w,\n                'h': (zmax - zmin) / subdivisions.h\n            };\n            function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\n                // Indices\n                var base = positions.length / 3;\n                var rowLength = precision.w + 1;\n                for (row = 0; row < precision.h; row++) {\n                    for (col = 0; col < precision.w; col++) {\n                        var square = [\n                            base + col + row * rowLength,\n                            base + (col + 1) + row * rowLength,\n                            base + (col + 1) + (row + 1) * rowLength,\n                            base + col + (row + 1) * rowLength\n                        ];\n                        indices.push(square[1]);\n                        indices.push(square[2]);\n                        indices.push(square[3]);\n                        indices.push(square[0]);\n                        indices.push(square[1]);\n                        indices.push(square[3]);\n                    }\n                }\n                // Position, normals and uvs\n                var position = BABYLON.Vector3.Zero();\n                var normal = new BABYLON.Vector3(0, 1.0, 0);\n                for (row = 0; row <= precision.h; row++) {\n                    position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\n                    for (col = 0; col <= precision.w; col++) {\n                        position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\n                        position.y = 0;\n                        positions.push(position.x, position.y, position.z);\n                        normals.push(normal.x, normal.y, normal.z);\n                        uvs.push(col / precision.w, row / precision.h);\n                    }\n                }\n            }\n            for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\n                for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\n                    applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\n                }\n            }\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Ground designed from a heightmap.\n         */\n        VertexData.CreateGroundFromHeightMap = function (options) {\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var row, col;\n            var filter = options.colorFilter || new BABYLON.Color3(0.3, 0.59, 0.11);\n            // Vertices\n            for (row = 0; row <= options.subdivisions; row++) {\n                for (col = 0; col <= options.subdivisions; col++) {\n                    var position = new BABYLON.Vector3((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));\n                    // Compute height\n                    var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\n                    var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\n                    var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\n                    var r = options.buffer[pos] / 255.0;\n                    var g = options.buffer[pos + 1] / 255.0;\n                    var b = options.buffer[pos + 2] / 255.0;\n                    var gradient = r * filter.r + g * filter.g + b * filter.b;\n                    position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\n                    // Add  vertex\n                    positions.push(position.x, position.y, position.z);\n                    normals.push(0, 0, 0);\n                    uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\n                }\n            }\n            // Indices\n            for (row = 0; row < options.subdivisions; row++) {\n                for (col = 0; col < options.subdivisions; col++) {\n                    indices.push(col + 1 + (row + 1) * (options.subdivisions + 1));\n                    indices.push(col + 1 + row * (options.subdivisions + 1));\n                    indices.push(col + row * (options.subdivisions + 1));\n                    indices.push(col + (row + 1) * (options.subdivisions + 1));\n                    indices.push(col + 1 + (row + 1) * (options.subdivisions + 1));\n                    indices.push(col + row * (options.subdivisions + 1));\n                }\n            }\n            // Normals\n            VertexData.ComputeNormals(positions, indices, normals);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Plane.\n         */\n        VertexData.CreatePlane = function (options) {\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var width = options.width || options.size || 1;\n            var height = options.height || options.size || 1;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            // Vertices\n            var halfWidth = width / 2.0;\n            var halfHeight = height / 2.0;\n            positions.push(-halfWidth, -halfHeight, 0);\n            normals.push(0, 0, -1.0);\n            uvs.push(0.0, 0.0);\n            positions.push(halfWidth, -halfHeight, 0);\n            normals.push(0, 0, -1.0);\n            uvs.push(1.0, 0.0);\n            positions.push(halfWidth, halfHeight, 0);\n            normals.push(0, 0, -1.0);\n            uvs.push(1.0, 1.0);\n            positions.push(-halfWidth, halfHeight, 0);\n            normals.push(0, 0, -1.0);\n            uvs.push(0.0, 1.0);\n            // Indices\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the Disc or regular Polygon.\n         */\n        VertexData.CreateDisc = function (options) {\n            var positions = [];\n            var indices = [];\n            var normals = [];\n            var uvs = [];\n            var radius = options.radius || 0.5;\n            var tessellation = options.tessellation || 64;\n            var arc = (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            // positions and uvs\n            positions.push(0, 0, 0); // disc center first\n            uvs.push(0.5, 0.5);\n            var theta = Math.PI * 2 * arc;\n            var step = theta / tessellation;\n            for (var a = 0; a < theta; a += step) {\n                var x = Math.cos(a);\n                var y = Math.sin(a);\n                var u = (x + 1) / 2;\n                var v = (1 - y) / 2;\n                positions.push(radius * x, radius * y, 0);\n                uvs.push(u, v);\n            }\n            if (arc === 1) {\n                positions.push(positions[3], positions[4], positions[5]); // close the circle\n                uvs.push(uvs[2], uvs[3]);\n            }\n            //indices\n            var vertexNb = positions.length / 3;\n            for (var i = 1; i < vertexNb - 1; i++) {\n                indices.push(i + 1, 0, i);\n            }\n            // result\n            VertexData.ComputeNormals(positions, indices, normals);\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        /**\n         * Re-creates the VertexData of the Polygon for sideOrientation.\n         */\n        VertexData.CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs) {\n            var faceUV = fUV || new Array(3);\n            var faceColors = fColors;\n            var colors = [];\n            // default face colors and UV if undefined\n            for (var f = 0; f < 3; f++) {\n                if (faceUV[f] === undefined) {\n                    faceUV[f] = new BABYLON.Vector4(0, 0, 1, 1);\n                }\n                if (faceColors && faceColors[f] === undefined) {\n                    faceColors[f] = new BABYLON.Color4(1, 1, 1, 1);\n                }\n            }\n            var positions = polygon.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var normals = polygon.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var uvs = polygon.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var indices = polygon.getIndices();\n            // set face colours and textures\n            var idx = 0;\n            var face = 0;\n            for (var index = 0; index < normals.length; index += 3) {\n                //Edge Face  no. 1\n                if (Math.abs(normals[index + 1]) == 0) {\n                    face = 1;\n                }\n                //Top Face  no. 0\n                if (normals[index + 1] == 1) {\n                    face = 0;\n                }\n                //Bottom Face  no. 2\n                if (normals[index + 1] == -1) {\n                    face = 2;\n                }\n                idx = index / 3;\n                uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\n                uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\n                if (faceColors) {\n                    colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\n                }\n            }\n            // sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            if (faceColors) {\n                var totalColors = (sideOrientation === BABYLON.Mesh.DOUBLESIDE) ? colors.concat(colors) : colors;\n                vertexData.colors = totalColors;\n            }\n            return vertexData;\n        };\n        /**\n         * Creates the VertexData of the IcoSphere.\n         */\n        VertexData.CreateIcoSphere = function (options) {\n            var sideOrientation = options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var radius = options.radius || 1;\n            var flat = (options.flat === undefined) ? true : options.flat;\n            var subdivisions = options.subdivisions || 4;\n            var radiusX = options.radiusX || radius;\n            var radiusY = options.radiusY || radius;\n            var radiusZ = options.radiusZ || radius;\n            var t = (1 + Math.sqrt(5)) / 2;\n            // 12 vertex x,y,z\n            var ico_vertices = [\n                -1, t, -0, 1, t, 0, -1, -t, 0, 1, -t, 0,\n                0, -1, -t, 0, 1, -t, 0, -1, t, 0, 1, t,\n                t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, -1 // v8-11\n            ];\n            // index of 3 vertex makes a face of icopshere\n            var ico_indices = [\n                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23,\n                1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8,\n                14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9,\n                4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1\n            ];\n            // vertex for uv have aliased position, not for UV\n            var vertices_unalias_id = [\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n                // vertex alias\n                0,\n                2,\n                3,\n                3,\n                3,\n                4,\n                7,\n                8,\n                9,\n                9,\n                10,\n                11 // 23: B + 12\n            ];\n            // uv as integer step (not pixels !)\n            var ico_vertexuv = [\n                5, 1, 3, 1, 6, 4, 0, 0,\n                5, 3, 4, 2, 2, 2, 4, 0,\n                2, 0, 1, 1, 6, 0, 6, 2,\n                // vertex alias (for same vertex on different faces)\n                0, 4,\n                3, 3,\n                4, 4,\n                3, 1,\n                4, 2,\n                4, 4,\n                0, 2,\n                1, 1,\n                2, 2,\n                3, 3,\n                1, 3,\n                2, 4 // 23: B + 12\n            ];\n            // Vertices[0, 1, ...9, A, B] : position on UV plane\n            // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\n            // First island of uv mapping\n            // v = 4h          3+  2\n            // v = 3h        9+  4\n            // v = 2h      9+  5   B\n            // v = 1h    9   1   0\n            // v = 0h  3   8   7   A\n            //     u = 0 1 2 3 4 5 6  *a\n            // Second island of uv mapping\n            // v = 4h  0+  B+  4+\n            // v = 3h    A+  2+\n            // v = 2h  7+  6   3+\n            // v = 1h    8+  3+\n            // v = 0h\n            //     u = 0 1 2 3 4 5 6  *a\n            // Face layout on texture UV mapping\n            // ============\n            // \\ 4  /\\ 16 /   ======\n            //  \\  /  \\  /   /\\ 11 /\n            //   \\/ 7  \\/   /  \\  /\n            //    =======  / 10 \\/\n            //   /\\ 17 /\\  =======\n            //  /  \\  /  \\ \\ 15 /\\\n            // / 8  \\/ 12 \\ \\  /  \\\n            // ============  \\/ 6  \\\n            // \\ 18 /\\  ============\n            //  \\  /  \\ \\ 5  /\\ 0  /\n            //   \\/ 13 \\ \\  /  \\  /\n            //   =======  \\/ 1  \\/\n            //       =============\n            //      /\\ 19 /\\  2 /\\\n            //     /  \\  /  \\  /  \\\n            //    / 14 \\/ 9  \\/  3 \\\n            //   ===================\n            // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\n            var ustep = 138 / 1024;\n            var vstep = 239 / 1024;\n            var uoffset = 60 / 1024;\n            var voffset = 26 / 1024;\n            // Second island should have margin, not to touch the first island\n            // avoid any borderline artefact in pixel rounding\n            var island_u_offset = -40 / 1024;\n            var island_v_offset = +20 / 1024;\n            // face is either island 0 or 1 :\n            // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\n            var island = [\n                0, 0, 0, 0, 1,\n                0, 0, 1, 1, 0,\n                0, 0, 1, 1, 0,\n                0, 1, 1, 1, 0 //  15 - 19\n            ];\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var current_indice = 0;\n            // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\n            var face_vertex_pos = new Array(3);\n            var face_vertex_uv = new Array(3);\n            var v012;\n            for (v012 = 0; v012 < 3; v012++) {\n                face_vertex_pos[v012] = BABYLON.Vector3.Zero();\n                face_vertex_uv[v012] = BABYLON.Vector2.Zero();\n            }\n            // create all with normals\n            for (var face = 0; face < 20; face++) {\n                // 3 vertex per face\n                for (v012 = 0; v012 < 3; v012++) {\n                    // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\n                    var v_id = ico_indices[3 * face + v012];\n                    // vertex have 3D position (x,y,z)\n                    face_vertex_pos[v012].copyFromFloats(ico_vertices[3 * vertices_unalias_id[v_id]], ico_vertices[3 * vertices_unalias_id[v_id] + 1], ico_vertices[3 * vertices_unalias_id[v_id] + 2]);\n                    // Normalize to get normal, then scale to radius\n                    face_vertex_pos[v012].normalize().scaleInPlace(radius);\n                    // uv Coordinates from vertex ID\n                    face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);\n                }\n                // Subdivide the face (interpolate pos, norm, uv)\n                // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\n                // - norm is linear interpolation of vertex corner normal\n                //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\n                // - uv is linear interpolation\n                //\n                // Topology is as below for sub-divide by 2\n                // vertex shown as v0,v1,v2\n                // interp index is i1 to progress in range [v0,v1[\n                // interp index is i2 to progress in range [v0,v2[\n                // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\n                //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n                //\n                //\n                //                    i2    v2\n                //                    ^    ^\n                //                   /    / \\\n                //                  /    /   \\\n                //                 /    /     \\\n                //                /    / (0,1) \\\n                //               /    #---------\\\n                //              /    / \\ (0,0)'/ \\\n                //             /    /   \\     /   \\\n                //            /    /     \\   /     \\\n                //           /    / (0,0) \\ / (1,0) \\\n                //          /    #---------#---------\\\n                //              v0                    v1\n                //\n                //              --------------------> i1\n                //\n                // interp of (i1,i2):\n                //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\n                //  along i1 :  lerp(x0,x1, i1/(S-i2))\n                //\n                // centroid of triangle is needed to get help normal computation\n                //  (c1,c2) are used for centroid location\n                var interp_vertex = function (i1, i2, c1, c2) {\n                    // vertex is interpolated from\n                    //   - face_vertex_pos[0..2]\n                    //   - face_vertex_uv[0..2]\n                    var pos_x0 = BABYLON.Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\n                    var pos_x1 = BABYLON.Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\n                    var pos_interp = (subdivisions === i2) ? face_vertex_pos[2] : BABYLON.Vector3.Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\n                    pos_interp.normalize();\n                    var vertex_normal;\n                    if (flat) {\n                        // in flat mode, recalculate normal as face centroid normal\n                        var centroid_x0 = BABYLON.Vector3.Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\n                        var centroid_x1 = BABYLON.Vector3.Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\n                        vertex_normal = BABYLON.Vector3.Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\n                    }\n                    else {\n                        // in smooth mode, recalculate normal from each single vertex position\n                        vertex_normal = new BABYLON.Vector3(pos_interp.x, pos_interp.y, pos_interp.z);\n                    }\n                    // Vertex normal need correction due to X,Y,Z radius scaling\n                    vertex_normal.x /= radiusX;\n                    vertex_normal.y /= radiusY;\n                    vertex_normal.z /= radiusZ;\n                    vertex_normal.normalize();\n                    var uv_x0 = BABYLON.Vector2.Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\n                    var uv_x1 = BABYLON.Vector2.Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\n                    var uv_interp = (subdivisions === i2) ? face_vertex_uv[2] : BABYLON.Vector2.Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\n                    positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\n                    normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\n                    uvs.push(uv_interp.x, uv_interp.y);\n                    // push each vertex has member of a face\n                    // Same vertex can bleong to multiple face, it is pushed multiple time (duplicate vertex are present)\n                    indices.push(current_indice);\n                    current_indice++;\n                };\n                for (var i2 = 0; i2 < subdivisions; i2++) {\n                    for (var i1 = 0; i1 + i2 < subdivisions; i1++) {\n                        // face : (i1,i2)  for /\\  :\n                        // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\n                        interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                        interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                        interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\n                        if (i1 + i2 + 1 < subdivisions) {\n                            // face : (i1,i2)' for \\/  :\n                            // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\n                            interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                            interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                            interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\n                        }\n                    }\n                }\n            }\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        // inspired from // http://stemkoski.github.io/Three.js/Polyhedra.html\n        /**\n         * Creates the VertexData of the Polyhedron.\n         */\n        VertexData.CreatePolyhedron = function (options) {\n            // provided polyhedron types :\n            // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\n            // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\n            var polyhedra = [];\n            polyhedra[0] = { vertex: [[0, 0, 1.732051], [1.632993, 0, -0.5773503], [-0.8164966, 1.414214, -0.5773503], [-0.8164966, -1.414214, -0.5773503]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]] };\n            polyhedra[1] = { vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]] };\n            polyhedra[2] = {\n                vertex: [[0, 0, 1.070466], [0.7136442, 0, 0.7978784], [-0.3568221, 0.618034, 0.7978784], [-0.3568221, -0.618034, 0.7978784], [0.7978784, 0.618034, 0.3568221], [0.7978784, -0.618034, 0.3568221], [-0.9341724, 0.381966, 0.3568221], [0.1362939, 1, 0.3568221], [0.1362939, -1, 0.3568221], [-0.9341724, -0.381966, 0.3568221], [0.9341724, 0.381966, -0.3568221], [0.9341724, -0.381966, -0.3568221], [-0.7978784, 0.618034, -0.3568221], [-0.1362939, 1, -0.3568221], [-0.1362939, -1, -0.3568221], [-0.7978784, -0.618034, -0.3568221], [0.3568221, 0.618034, -0.7978784], [0.3568221, -0.618034, -0.7978784], [-0.7136442, 0, -0.7978784], [0, 0, -1.070466]],\n                face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]\n            };\n            polyhedra[3] = {\n                vertex: [[0, 0, 1.175571], [1.051462, 0, 0.5257311], [0.3249197, 1, 0.5257311], [-0.8506508, 0.618034, 0.5257311], [-0.8506508, -0.618034, 0.5257311], [0.3249197, -1, 0.5257311], [0.8506508, 0.618034, -0.5257311], [0.8506508, -0.618034, -0.5257311], [-0.3249197, 1, -0.5257311], [-1.051462, 0, -0.5257311], [-0.3249197, -1, -0.5257311], [0, 0, -1.175571]],\n                face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]\n            };\n            polyhedra[4] = {\n                vertex: [[0, 0, 1.070722], [0.7148135, 0, 0.7971752], [-0.104682, 0.7071068, 0.7971752], [-0.6841528, 0.2071068, 0.7971752], [-0.104682, -0.7071068, 0.7971752], [0.6101315, 0.7071068, 0.5236279], [1.04156, 0.2071068, 0.1367736], [0.6101315, -0.7071068, 0.5236279], [-0.3574067, 1, 0.1367736], [-0.7888348, -0.5, 0.5236279], [-0.9368776, 0.5, 0.1367736], [-0.3574067, -1, 0.1367736], [0.3574067, 1, -0.1367736], [0.9368776, -0.5, -0.1367736], [0.7888348, 0.5, -0.5236279], [0.3574067, -1, -0.1367736], [-0.6101315, 0.7071068, -0.5236279], [-1.04156, -0.2071068, -0.1367736], [-0.6101315, -0.7071068, -0.5236279], [0.104682, 0.7071068, -0.7971752], [0.6841528, -0.2071068, -0.7971752], [0.104682, -0.7071068, -0.7971752], [-0.7148135, 0, -0.7971752], [0, 0, -1.070722]],\n                face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]\n            };\n            polyhedra[5] = { vertex: [[0, 0, 1.322876], [1.309307, 0, 0.1889822], [-0.9819805, 0.8660254, 0.1889822], [0.1636634, -1.299038, 0.1889822], [0.3273268, 0.8660254, -0.9449112], [-0.8183171, -0.4330127, -0.9449112]], face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]] };\n            polyhedra[6] = { vertex: [[0, 0, 1.159953], [1.013464, 0, 0.5642542], [-0.3501431, 0.9510565, 0.5642542], [-0.7715208, -0.6571639, 0.5642542], [0.6633206, 0.9510565, -0.03144481], [0.8682979, -0.6571639, -0.3996071], [-1.121664, 0.2938926, -0.03144481], [-0.2348831, -1.063314, -0.3996071], [0.5181548, 0.2938926, -0.9953061], [-0.5850262, -0.112257, -0.9953061]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]] };\n            polyhedra[7] = { vertex: [[0, 0, 1.118034], [0.8944272, 0, 0.6708204], [-0.2236068, 0.8660254, 0.6708204], [-0.7826238, -0.4330127, 0.6708204], [0.6708204, 0.8660254, 0.2236068], [1.006231, -0.4330127, -0.2236068], [-1.006231, 0.4330127, 0.2236068], [-0.6708204, -0.8660254, -0.2236068], [0.7826238, 0.4330127, -0.6708204], [0.2236068, -0.8660254, -0.6708204], [-0.8944272, 0, -0.6708204], [0, 0, -1.118034]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]] };\n            polyhedra[8] = { vertex: [[-0.729665, 0.670121, 0.319155], [-0.655235, -0.29213, -0.754096], [-0.093922, -0.607123, 0.537818], [0.702196, 0.595691, 0.485187], [0.776626, -0.36656, -0.588064]], face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]] };\n            polyhedra[9] = { vertex: [[-0.868849, -0.100041, 0.61257], [-0.329458, 0.976099, 0.28078], [-0.26629, -0.013796, -0.477654], [-0.13392, -1.034115, 0.229829], [0.738834, 0.707117, -0.307018], [0.859683, -0.535264, -0.338508]], face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]] };\n            polyhedra[10] = { vertex: [[-0.610389, 0.243975, 0.531213], [-0.187812, -0.48795, -0.664016], [-0.187812, 0.9759, -0.664016], [0.187812, -0.9759, 0.664016], [0.798201, 0.243975, 0.132803]], face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]] };\n            polyhedra[11] = { vertex: [[-1.028778, 0.392027, -0.048786], [-0.640503, -0.646161, 0.621837], [-0.125162, -0.395663, -0.540059], [0.004683, 0.888447, -0.651988], [0.125161, 0.395663, 0.540059], [0.632925, -0.791376, 0.433102], [1.031672, 0.157063, -0.354165]], face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]] };\n            polyhedra[12] = { vertex: [[-0.669867, 0.334933, -0.529576], [-0.669867, 0.334933, 0.529577], [-0.4043, 1.212901, 0], [-0.334933, -0.669867, -0.529576], [-0.334933, -0.669867, 0.529577], [0.334933, 0.669867, -0.529576], [0.334933, 0.669867, 0.529577], [0.4043, -1.212901, 0], [0.669867, -0.334933, -0.529576], [0.669867, -0.334933, 0.529577]], face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]] };\n            polyhedra[13] = { vertex: [[-0.931836, 0.219976, -0.264632], [-0.636706, 0.318353, 0.692816], [-0.613483, -0.735083, -0.264632], [-0.326545, 0.979634, 0], [-0.318353, -0.636706, 0.692816], [-0.159176, 0.477529, -0.856368], [0.159176, -0.477529, -0.856368], [0.318353, 0.636706, 0.692816], [0.326545, -0.979634, 0], [0.613482, 0.735082, -0.264632], [0.636706, -0.318353, 0.692816], [0.931835, -0.219977, -0.264632]], face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]] };\n            polyhedra[14] = {\n                vertex: [[-0.93465, 0.300459, -0.271185], [-0.838689, -0.260219, -0.516017], [-0.711319, 0.717591, 0.128359], [-0.710334, -0.156922, 0.080946], [-0.599799, 0.556003, -0.725148], [-0.503838, -0.004675, -0.969981], [-0.487004, 0.26021, 0.48049], [-0.460089, -0.750282, -0.512622], [-0.376468, 0.973135, -0.325605], [-0.331735, -0.646985, 0.084342], [-0.254001, 0.831847, 0.530001], [-0.125239, -0.494738, -0.966586], [0.029622, 0.027949, 0.730817], [0.056536, -0.982543, -0.262295], [0.08085, 1.087391, 0.076037], [0.125583, -0.532729, 0.485984], [0.262625, 0.599586, 0.780328], [0.391387, -0.726999, -0.716259], [0.513854, -0.868287, 0.139347], [0.597475, 0.85513, 0.326364], [0.641224, 0.109523, 0.783723], [0.737185, -0.451155, 0.538891], [0.848705, -0.612742, -0.314616], [0.976075, 0.365067, 0.32976], [1.072036, -0.19561, 0.084927]],\n                face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]\n            };\n            var type = (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\n            var size = options.size;\n            var sizeX = options.sizeX || size || 1;\n            var sizeY = options.sizeY || size || 1;\n            var sizeZ = options.sizeZ || size || 1;\n            var data = options.custom || polyhedra[type];\n            var nbfaces = data.face.length;\n            var faceUV = options.faceUV || new Array(nbfaces);\n            var faceColors = options.faceColors;\n            var flat = (options.flat === undefined) ? true : options.flat;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            var positions = [];\n            var indices = [];\n            var normals = [];\n            var uvs = [];\n            var colors = [];\n            var index = 0;\n            var faceIdx = 0; // face cursor in the array \"indexes\"\n            var indexes = [];\n            var i = 0;\n            var f = 0;\n            var u, v, ang, x, y, tmp;\n            // default face colors and UV if undefined\n            if (flat) {\n                for (f = 0; f < nbfaces; f++) {\n                    if (faceColors && faceColors[f] === undefined) {\n                        faceColors[f] = new BABYLON.Color4(1, 1, 1, 1);\n                    }\n                    if (faceUV && faceUV[f] === undefined) {\n                        faceUV[f] = new BABYLON.Vector4(0, 0, 1, 1);\n                    }\n                }\n            }\n            if (!flat) {\n                for (i = 0; i < data.vertex.length; i++) {\n                    positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\n                    uvs.push(0, 0);\n                }\n                for (f = 0; f < nbfaces; f++) {\n                    for (i = 0; i < data.face[f].length - 2; i++) {\n                        indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\n                    }\n                }\n            }\n            else {\n                for (f = 0; f < nbfaces; f++) {\n                    var fl = data.face[f].length; // number of vertices of the current face\n                    ang = 2 * Math.PI / fl;\n                    x = 0.5 * Math.tan(ang / 2);\n                    y = 0.5;\n                    // positions, uvs, colors\n                    for (i = 0; i < fl; i++) {\n                        // positions\n                        positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\n                        indexes.push(index);\n                        index++;\n                        // uvs\n                        u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\n                        v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\n                        uvs.push(u, v);\n                        tmp = x * Math.cos(ang) - y * Math.sin(ang);\n                        y = x * Math.sin(ang) + y * Math.cos(ang);\n                        x = tmp;\n                        // colors\n                        if (faceColors) {\n                            colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\n                        }\n                    }\n                    // indices from indexes\n                    for (i = 0; i < fl - 2; i++) {\n                        indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\n                    }\n                    faceIdx += fl;\n                }\n            }\n            VertexData.ComputeNormals(positions, indices, normals);\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            var vertexData = new VertexData();\n            vertexData.positions = positions;\n            vertexData.indices = indices;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            if (faceColors && flat) {\n                vertexData.colors = colors;\n            }\n            return vertexData;\n        };\n        // based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n        /**\n         * Creates the VertexData of the Torus Knot.\n         */\n        VertexData.CreateTorusKnot = function (options) {\n            var indices = [];\n            var positions = [];\n            var normals = [];\n            var uvs = [];\n            var radius = options.radius || 2;\n            var tube = options.tube || 0.5;\n            var radialSegments = options.radialSegments || 32;\n            var tubularSegments = options.tubularSegments || 32;\n            var p = options.p || 2;\n            var q = options.q || 3;\n            var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            // Helper\n            var getPos = function (angle) {\n                var cu = Math.cos(angle);\n                var su = Math.sin(angle);\n                var quOverP = q / p * angle;\n                var cs = Math.cos(quOverP);\n                var tx = radius * (2 + cs) * 0.5 * cu;\n                var ty = radius * (2 + cs) * su * 0.5;\n                var tz = radius * Math.sin(quOverP) * 0.5;\n                return new BABYLON.Vector3(tx, ty, tz);\n            };\n            // Vertices\n            var i;\n            var j;\n            for (i = 0; i <= radialSegments; i++) {\n                var modI = i % radialSegments;\n                var u = modI / radialSegments * 2 * p * Math.PI;\n                var p1 = getPos(u);\n                var p2 = getPos(u + 0.01);\n                var tang = p2.subtract(p1);\n                var n = p2.add(p1);\n                var bitan = BABYLON.Vector3.Cross(tang, n);\n                n = BABYLON.Vector3.Cross(bitan, tang);\n                bitan.normalize();\n                n.normalize();\n                for (j = 0; j < tubularSegments; j++) {\n                    var modJ = j % tubularSegments;\n                    var v = modJ / tubularSegments * 2 * Math.PI;\n                    var cx = -tube * Math.cos(v);\n                    var cy = tube * Math.sin(v);\n                    positions.push(p1.x + cx * n.x + cy * bitan.x);\n                    positions.push(p1.y + cx * n.y + cy * bitan.y);\n                    positions.push(p1.z + cx * n.z + cy * bitan.z);\n                    uvs.push(i / radialSegments);\n                    uvs.push(j / tubularSegments);\n                }\n            }\n            for (i = 0; i < radialSegments; i++) {\n                for (j = 0; j < tubularSegments; j++) {\n                    var jNext = (j + 1) % tubularSegments;\n                    var a = i * tubularSegments + j;\n                    var b = (i + 1) * tubularSegments + j;\n                    var c = (i + 1) * tubularSegments + jNext;\n                    var d = i * tubularSegments + jNext;\n                    indices.push(d);\n                    indices.push(b);\n                    indices.push(a);\n                    indices.push(d);\n                    indices.push(c);\n                    indices.push(b);\n                }\n            }\n            // Normals\n            VertexData.ComputeNormals(positions, indices, normals);\n            // Sides\n            VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\n            // Result\n            var vertexData = new VertexData();\n            vertexData.indices = indices;\n            vertexData.positions = positions;\n            vertexData.normals = normals;\n            vertexData.uvs = uvs;\n            return vertexData;\n        };\n        // Tools\n        /**\n         * @param {any} - positions (number[] or Float32Array)\n         * @param {any} - indices   (number[] or Uint16Array)\n         * @param {any} - normals   (number[] or Float32Array)\n         * options (optional) :\n         * facetPositions : optional array of facet positions (vector3)\n         * facetNormals : optional array of facet normals (vector3)\n         * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation\n         * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation\n         * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation\n         * bbSize : optional bounding box size data, required for facetPartitioning computation\n         * bInfo : optional bounding info, required for facetPartitioning computation\n         */\n        VertexData.ComputeNormals = function (positions, indices, normals, options) {\n            // temporary scalar variables\n            var index = 0; // facet index     \n            var p1p2x = 0.0; // p1p2 vector x coordinate\n            var p1p2y = 0.0; // p1p2 vector y coordinate\n            var p1p2z = 0.0; // p1p2 vector z coordinate\n            var p3p2x = 0.0; // p3p2 vector x coordinate\n            var p3p2y = 0.0; // p3p2 vector y coordinate\n            var p3p2z = 0.0; // p3p2 vector z coordinate\n            var faceNormalx = 0.0; // facet normal x coordinate\n            var faceNormaly = 0.0; // facet normal y coordinate\n            var faceNormalz = 0.0; // facet normal z coordinate\n            var length = 0.0; // facet normal length before normalization\n            var v1x = 0; // vector1 x index in the positions array\n            var v1y = 0; // vector1 y index in the positions array\n            var v1z = 0; // vector1 z index in the positions array\n            var v2x = 0; // vector2 x index in the positions array\n            var v2y = 0; // vector2 y index in the positions array\n            var v2z = 0; // vector2 z index in the positions array\n            var v3x = 0; // vector3 x index in the positions array\n            var v3y = 0; // vector3 y index in the positions array\n            var v3z = 0; // vector3 z index in the positions array\n            var computeFacetNormals = false;\n            var computeFacetPositions = false;\n            var computeFacetPartitioning = false;\n            var faceNormalSign = 1;\n            if (options) {\n                computeFacetNormals = (options.facetNormals) ? true : false;\n                computeFacetPositions = (options.facetPositions) ? true : false;\n                computeFacetPartitioning = (options.facetPartitioning) ? true : false;\n                faceNormalSign = (options.useRightHandedSystem === true) ? -1 : 1;\n            }\n            // facetPartitioning reinit if needed\n            if (computeFacetPartitioning) {\n                var ox = 0; // X partitioning index for facet position\n                var oy = 0; // Y partinioning index for facet position\n                var oz = 0; // Z partinioning index for facet position\n                var b1x = 0; // X partitioning index for facet v1 vertex\n                var b1y = 0; // Y partitioning index for facet v1 vertex\n                var b1z = 0; // z partitioning index for facet v1 vertex\n                var b2x = 0; // X partitioning index for facet v2 vertex\n                var b2y = 0; // Y partitioning index for facet v2 vertex\n                var b2z = 0; // Z partitioning index for facet v2 vertex\n                var b3x = 0; // X partitioning index for facet v3 vertex\n                var b3y = 0; // Y partitioning index for facet v3 vertex\n                var b3z = 0; // Z partitioning index for facet v3 vertex\n                var block_idx_o = 0; // facet barycenter block index\n                var block_idx_v1 = 0; // v1 vertex block index\n                var block_idx_v2 = 0; // v2 vertex block index\n                var block_idx_v3 = 0; // v3 vertex block index  \n                var bbSizeMax = (options.bbSize.x > options.bbSize.y) ? options.bbSize.x : options.bbSize.y;\n                bbSizeMax = (bbSizeMax > options.bbSize.z) ? bbSizeMax : options.bbSize.z;\n                var xSubRatio = options.subDiv.X * options.ratio / options.bbSize.x;\n                var ySubRatio = options.subDiv.Y * options.ratio / options.bbSize.y;\n                var zSubRatio = options.subDiv.Z * options.ratio / options.bbSize.z;\n                var subSq = options.subDiv.max * options.subDiv.max;\n                options.facetPartitioning.length = 0;\n            }\n            // reset the normals\n            for (index = 0; index < positions.length; index++) {\n                normals[index] = 0.0;\n            }\n            // Loop : 1 indice triplet = 1 facet\n            var nbFaces = indices.length / 3;\n            for (index = 0; index < nbFaces; index++) {\n                // get the indexes of the coordinates of each vertex of the facet\n                v1x = indices[index * 3] * 3;\n                v1y = v1x + 1;\n                v1z = v1x + 2;\n                v2x = indices[index * 3 + 1] * 3;\n                v2y = v2x + 1;\n                v2z = v2x + 2;\n                v3x = indices[index * 3 + 2] * 3;\n                v3y = v3x + 1;\n                v3z = v3x + 2;\n                p1p2x = positions[v1x] - positions[v2x]; // compute two vectors per facet : p1p2 and p3p2\n                p1p2y = positions[v1y] - positions[v2y];\n                p1p2z = positions[v1z] - positions[v2z];\n                p3p2x = positions[v3x] - positions[v2x];\n                p3p2y = positions[v3y] - positions[v2y];\n                p3p2z = positions[v3z] - positions[v2z];\n                // compute the face normal with the cross product\n                faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);\n                faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);\n                faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);\n                // normalize this normal and store it in the array facetData\n                length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n                length = (length === 0) ? 1.0 : length;\n                faceNormalx /= length;\n                faceNormaly /= length;\n                faceNormalz /= length;\n                if (computeFacetNormals) {\n                    options.facetNormals[index].x = faceNormalx;\n                    options.facetNormals[index].y = faceNormaly;\n                    options.facetNormals[index].z = faceNormalz;\n                }\n                if (computeFacetPositions) {\n                    // compute and the facet barycenter coordinates in the array facetPositions \n                    options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3.0;\n                    options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3.0;\n                    options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3.0;\n                }\n                if (computeFacetPartitioning) {\n                    // store the facet indexes in arrays in the main facetPartitioning array :\n                    // compute each facet vertex (+ facet barycenter) index in the partiniong array\n                    ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * options.ratio) * xSubRatio);\n                    oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * options.ratio) * ySubRatio);\n                    oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * options.ratio) * zSubRatio);\n                    b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * options.ratio) * xSubRatio);\n                    b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * options.ratio) * ySubRatio);\n                    b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * options.ratio) * zSubRatio);\n                    b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * options.ratio) * xSubRatio);\n                    b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * options.ratio) * ySubRatio);\n                    b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * options.ratio) * zSubRatio);\n                    b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * options.ratio) * xSubRatio);\n                    b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * options.ratio) * ySubRatio);\n                    b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * options.ratio) * zSubRatio);\n                    block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;\n                    block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;\n                    block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;\n                    block_idx_o = ox + options.subDiv.max * oy + subSq * oz;\n                    options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();\n                    options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();\n                    options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();\n                    options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();\n                    // push each facet index in each block containing the vertex\n                    options.facetPartitioning[block_idx_v1].push(index);\n                    if (block_idx_v2 != block_idx_v1) {\n                        options.facetPartitioning[block_idx_v2].push(index);\n                    }\n                    if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {\n                        options.facetPartitioning[block_idx_v3].push(index);\n                    }\n                    if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {\n                        options.facetPartitioning[block_idx_o].push(index);\n                    }\n                }\n                // compute the normals anyway\n                normals[v1x] += faceNormalx; // accumulate all the normals per face\n                normals[v1y] += faceNormaly;\n                normals[v1z] += faceNormalz;\n                normals[v2x] += faceNormalx;\n                normals[v2y] += faceNormaly;\n                normals[v2z] += faceNormalz;\n                normals[v3x] += faceNormalx;\n                normals[v3y] += faceNormaly;\n                normals[v3z] += faceNormalz;\n            }\n            // last normalization of each normal\n            for (index = 0; index < normals.length / 3; index++) {\n                faceNormalx = normals[index * 3];\n                faceNormaly = normals[index * 3 + 1];\n                faceNormalz = normals[index * 3 + 2];\n                length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);\n                length = (length === 0) ? 1.0 : length;\n                faceNormalx /= length;\n                faceNormaly /= length;\n                faceNormalz /= length;\n                normals[index * 3] = faceNormalx;\n                normals[index * 3 + 1] = faceNormaly;\n                normals[index * 3 + 2] = faceNormalz;\n            }\n        };\n        VertexData._ComputeSides = function (sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {\n            var li = indices.length;\n            var ln = normals.length;\n            var i;\n            var n;\n            sideOrientation = sideOrientation || BABYLON.Mesh.DEFAULTSIDE;\n            switch (sideOrientation) {\n                case BABYLON.Mesh.FRONTSIDE:\n                    // nothing changed\n                    break;\n                case BABYLON.Mesh.BACKSIDE:\n                    var tmp;\n                    // indices\n                    for (i = 0; i < li; i += 3) {\n                        tmp = indices[i];\n                        indices[i] = indices[i + 2];\n                        indices[i + 2] = tmp;\n                    }\n                    // normals\n                    for (n = 0; n < ln; n++) {\n                        normals[n] = -normals[n];\n                    }\n                    break;\n                case BABYLON.Mesh.DOUBLESIDE:\n                    // positions\n                    var lp = positions.length;\n                    var l = lp / 3;\n                    for (var p = 0; p < lp; p++) {\n                        positions[lp + p] = positions[p];\n                    }\n                    // indices\n                    for (i = 0; i < li; i += 3) {\n                        indices[i + li] = indices[i + 2] + l;\n                        indices[i + 1 + li] = indices[i + 1] + l;\n                        indices[i + 2 + li] = indices[i] + l;\n                    }\n                    // normals\n                    for (n = 0; n < ln; n++) {\n                        normals[ln + n] = -normals[n];\n                    }\n                    // uvs\n                    var lu = uvs.length;\n                    var u = 0;\n                    for (u = 0; u < lu; u++) {\n                        uvs[u + lu] = uvs[u];\n                    }\n                    var frontUVs = frontUVs ? frontUVs : new BABYLON.Vector4(0.0, 0.0, 1.0, 1.0);\n                    var backUVs = backUVs ? backUVs : new BABYLON.Vector4(0.0, 0.0, 1.0, 1.0);\n                    u = 0;\n                    for (i = 0; i < lu / 2; i++) {\n                        uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];\n                        uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];\n                        uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];\n                        uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];\n                        u += 2;\n                    }\n                    break;\n            }\n        };\n        /**\n         * Creates a new VertexData from the imported parameters.\n         */\n        VertexData.ImportVertexData = function (parsedVertexData, geometry) {\n            var vertexData = new VertexData();\n            // positions\n            var positions = parsedVertexData.positions;\n            if (positions) {\n                vertexData.set(positions, BABYLON.VertexBuffer.PositionKind);\n            }\n            // normals\n            var normals = parsedVertexData.normals;\n            if (normals) {\n                vertexData.set(normals, BABYLON.VertexBuffer.NormalKind);\n            }\n            // tangents\n            var tangents = parsedVertexData.tangents;\n            if (tangents) {\n                vertexData.set(tangents, BABYLON.VertexBuffer.TangentKind);\n            }\n            // uvs\n            var uvs = parsedVertexData.uvs;\n            if (uvs) {\n                vertexData.set(uvs, BABYLON.VertexBuffer.UVKind);\n            }\n            // uv2s\n            var uv2s = parsedVertexData.uv2s;\n            if (uv2s) {\n                vertexData.set(uv2s, BABYLON.VertexBuffer.UV2Kind);\n            }\n            // uv3s\n            var uv3s = parsedVertexData.uv3s;\n            if (uv3s) {\n                vertexData.set(uv3s, BABYLON.VertexBuffer.UV3Kind);\n            }\n            // uv4s\n            var uv4s = parsedVertexData.uv4s;\n            if (uv4s) {\n                vertexData.set(uv4s, BABYLON.VertexBuffer.UV4Kind);\n            }\n            // uv5s\n            var uv5s = parsedVertexData.uv5s;\n            if (uv5s) {\n                vertexData.set(uv5s, BABYLON.VertexBuffer.UV5Kind);\n            }\n            // uv6s\n            var uv6s = parsedVertexData.uv6s;\n            if (uv6s) {\n                vertexData.set(uv6s, BABYLON.VertexBuffer.UV6Kind);\n            }\n            // colors\n            var colors = parsedVertexData.colors;\n            if (colors) {\n                vertexData.set(BABYLON.Color4.CheckColors4(colors, positions.length / 3), BABYLON.VertexBuffer.ColorKind);\n            }\n            // matricesIndices\n            var matricesIndices = parsedVertexData.matricesIndices;\n            if (matricesIndices) {\n                vertexData.set(matricesIndices, BABYLON.VertexBuffer.MatricesIndicesKind);\n            }\n            // matricesWeights\n            var matricesWeights = parsedVertexData.matricesWeights;\n            if (matricesWeights) {\n                vertexData.set(matricesWeights, BABYLON.VertexBuffer.MatricesWeightsKind);\n            }\n            // indices\n            var indices = parsedVertexData.indices;\n            if (indices) {\n                vertexData.indices = indices;\n            }\n            geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);\n        };\n        return VertexData;\n    }());\n    BABYLON.VertexData = VertexData;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.mesh.vertexData.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Geometry = (function () {\n        function Geometry(id, scene, vertexData, updatable, mesh) {\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NONE;\n            this._totalVertices = 0;\n            this._isDisposed = false;\n            this.id = id;\n            this._engine = scene.getEngine();\n            this._meshes = [];\n            this._scene = scene;\n            //Init vertex buffer cache\n            this._vertexBuffers = {};\n            this._indices = [];\n            // vertexData\n            if (vertexData) {\n                this.setAllVerticesData(vertexData, updatable);\n            }\n            else {\n                this._totalVertices = 0;\n                this._indices = [];\n            }\n            if (this._engine.getCaps().vertexArrayObject) {\n                this._vertexArrayObjects = {};\n            }\n            // applyToMesh\n            if (mesh) {\n                if (mesh.getClassName() === \"LinesMesh\") {\n                    this.boundingBias = new BABYLON.Vector2(0, mesh.intersectionThreshold);\n                    this.updateExtend();\n                }\n                this.applyToMesh(mesh);\n                mesh.computeWorldMatrix(true);\n            }\n        }\n        Object.defineProperty(Geometry.prototype, \"boundingBias\", {\n            /**\n             *  The Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y\n             * @returns The Bias Vector\n             */\n            get: function () {\n                return this._boundingBias;\n            },\n            set: function (value) {\n                if (this._boundingBias && this._boundingBias.equals(value)) {\n                    return;\n                }\n                this._boundingBias = value.clone();\n                this.updateBoundingInfo(true, null);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Geometry.prototype, \"extend\", {\n            get: function () {\n                return this._extend;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Geometry.prototype.getScene = function () {\n            return this._scene;\n        };\n        Geometry.prototype.getEngine = function () {\n            return this._engine;\n        };\n        Geometry.prototype.isReady = function () {\n            return this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADED || this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_NONE;\n        };\n        Object.defineProperty(Geometry.prototype, \"doNotSerialize\", {\n            get: function () {\n                for (var index = 0; index < this._meshes.length; index++) {\n                    if (!this._meshes[index].doNotSerialize) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Geometry.prototype.setAllVerticesData = function (vertexData, updatable) {\n            vertexData.applyToGeometry(this, updatable);\n            this.notifyUpdate();\n        };\n        Geometry.prototype.setVerticesData = function (kind, data, updatable, stride) {\n            var buffer = new BABYLON.VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);\n            this.setVerticesBuffer(buffer);\n        };\n        Geometry.prototype.removeVerticesData = function (kind) {\n            if (this._vertexBuffers[kind]) {\n                this._vertexBuffers[kind].dispose();\n                delete this._vertexBuffers[kind];\n            }\n        };\n        Geometry.prototype.setVerticesBuffer = function (buffer) {\n            var kind = buffer.getKind();\n            if (this._vertexBuffers[kind]) {\n                this._vertexBuffers[kind].dispose();\n            }\n            this._vertexBuffers[kind] = buffer;\n            if (kind === BABYLON.VertexBuffer.PositionKind) {\n                var data = buffer.getData();\n                var stride = buffer.getStrideSize();\n                this._totalVertices = data.length / stride;\n                this.updateExtend(data, stride);\n                this._resetPointsArrayCache();\n                var meshes = this._meshes;\n                var numOfMeshes = meshes.length;\n                for (var index = 0; index < numOfMeshes; index++) {\n                    var mesh = meshes[index];\n                    mesh._boundingInfo = new BABYLON.BoundingInfo(this._extend.minimum, this._extend.maximum);\n                    mesh._createGlobalSubMesh();\n                    mesh.computeWorldMatrix(true);\n                }\n            }\n            this.notifyUpdate(kind);\n            if (this._vertexArrayObjects) {\n                this._disposeVertexArrayObjects();\n                this._vertexArrayObjects = {}; // Will trigger a rebuild of the VAO if supported\n            }\n        };\n        Geometry.prototype.updateVerticesDataDirectly = function (kind, data, offset) {\n            var vertexBuffer = this.getVertexBuffer(kind);\n            if (!vertexBuffer) {\n                return;\n            }\n            vertexBuffer.updateDirectly(data, offset);\n            this.notifyUpdate(kind);\n        };\n        Geometry.prototype.updateVerticesData = function (kind, data, updateExtends) {\n            var vertexBuffer = this.getVertexBuffer(kind);\n            if (!vertexBuffer) {\n                return;\n            }\n            vertexBuffer.update(data);\n            if (kind === BABYLON.VertexBuffer.PositionKind) {\n                var stride = vertexBuffer.getStrideSize();\n                this._totalVertices = data.length / stride;\n                this.updateBoundingInfo(updateExtends, data);\n            }\n            this.notifyUpdate(kind);\n        };\n        Geometry.prototype.updateBoundingInfo = function (updateExtends, data) {\n            if (updateExtends) {\n                this.updateExtend(data);\n            }\n            var meshes = this._meshes;\n            var numOfMeshes = meshes.length;\n            this._resetPointsArrayCache();\n            for (var index = 0; index < numOfMeshes; index++) {\n                var mesh = meshes[index];\n                if (updateExtends) {\n                    mesh._boundingInfo = new BABYLON.BoundingInfo(this._extend.minimum, this._extend.maximum);\n                    for (var subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                        var subMesh = mesh.subMeshes[subIndex];\n                        subMesh.refreshBoundingInfo();\n                    }\n                }\n            }\n        };\n        Geometry.prototype._bind = function (effect, indexToBind) {\n            if (indexToBind === void 0) { indexToBind = undefined; }\n            if (indexToBind === undefined) {\n                indexToBind = this._indexBuffer;\n            }\n            if (indexToBind != this._indexBuffer || !this._vertexArrayObjects) {\n                this._engine.bindBuffers(this.getVertexBuffers(), indexToBind, effect);\n                return;\n            }\n            // Using VAO\n            if (!this._vertexArrayObjects[effect.key]) {\n                this._vertexArrayObjects[effect.key] = this._engine.recordVertexArrayObject(this.getVertexBuffers(), indexToBind, effect);\n            }\n            this._engine.bindVertexArrayObject(this._vertexArrayObjects[effect.key], indexToBind);\n        };\n        Geometry.prototype.getTotalVertices = function () {\n            if (!this.isReady()) {\n                return 0;\n            }\n            return this._totalVertices;\n        };\n        Geometry.prototype.getVerticesData = function (kind, copyWhenShared, forceCopy) {\n            var vertexBuffer = this.getVertexBuffer(kind);\n            if (!vertexBuffer) {\n                return null;\n            }\n            var orig = vertexBuffer.getData();\n            if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {\n                return orig;\n            }\n            else {\n                var len = orig.length;\n                var copy = [];\n                for (var i = 0; i < len; i++) {\n                    copy.push(orig[i]);\n                }\n                return copy;\n            }\n        };\n        Geometry.prototype.getVertexBuffer = function (kind) {\n            if (!this.isReady()) {\n                return null;\n            }\n            return this._vertexBuffers[kind];\n        };\n        Geometry.prototype.getVertexBuffers = function () {\n            if (!this.isReady()) {\n                return null;\n            }\n            return this._vertexBuffers;\n        };\n        Geometry.prototype.isVerticesDataPresent = function (kind) {\n            if (!this._vertexBuffers) {\n                if (this._delayInfo) {\n                    return this._delayInfo.indexOf(kind) !== -1;\n                }\n                return false;\n            }\n            return this._vertexBuffers[kind] !== undefined;\n        };\n        Geometry.prototype.getVerticesDataKinds = function () {\n            var result = [];\n            var kind;\n            if (!this._vertexBuffers && this._delayInfo) {\n                for (kind in this._delayInfo) {\n                    result.push(kind);\n                }\n            }\n            else {\n                for (kind in this._vertexBuffers) {\n                    result.push(kind);\n                }\n            }\n            return result;\n        };\n        Geometry.prototype.setIndices = function (indices, totalVertices) {\n            if (this._indexBuffer) {\n                this._engine._releaseBuffer(this._indexBuffer);\n            }\n            this._disposeVertexArrayObjects();\n            this._indices = indices;\n            if (this._meshes.length !== 0 && this._indices) {\n                this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n            }\n            if (totalVertices !== undefined) {\n                this._totalVertices = totalVertices;\n            }\n            var meshes = this._meshes;\n            var numOfMeshes = meshes.length;\n            for (var index = 0; index < numOfMeshes; index++) {\n                meshes[index]._createGlobalSubMesh();\n            }\n            this.notifyUpdate();\n        };\n        Geometry.prototype.getTotalIndices = function () {\n            if (!this.isReady()) {\n                return 0;\n            }\n            return this._indices.length;\n        };\n        Geometry.prototype.getIndices = function (copyWhenShared) {\n            if (!this.isReady()) {\n                return null;\n            }\n            var orig = this._indices;\n            if (!copyWhenShared || this._meshes.length === 1) {\n                return orig;\n            }\n            else {\n                var len = orig.length;\n                var copy = [];\n                for (var i = 0; i < len; i++) {\n                    copy.push(orig[i]);\n                }\n                return copy;\n            }\n        };\n        Geometry.prototype.getIndexBuffer = function () {\n            if (!this.isReady()) {\n                return null;\n            }\n            return this._indexBuffer;\n        };\n        Geometry.prototype._releaseVertexArrayObject = function (effect) {\n            if (!effect || !this._vertexArrayObjects) {\n                return;\n            }\n            if (this._vertexArrayObjects[effect.key]) {\n                this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);\n                delete this._vertexArrayObjects[effect.key];\n            }\n        };\n        Geometry.prototype.releaseForMesh = function (mesh, shouldDispose) {\n            var meshes = this._meshes;\n            var index = meshes.indexOf(mesh);\n            if (index === -1) {\n                return;\n            }\n            meshes.splice(index, 1);\n            mesh._geometry = null;\n            if (meshes.length === 0 && shouldDispose) {\n                this.dispose();\n            }\n        };\n        Geometry.prototype.applyToMesh = function (mesh) {\n            if (mesh._geometry === this) {\n                return;\n            }\n            var previousGeometry = mesh._geometry;\n            if (previousGeometry) {\n                previousGeometry.releaseForMesh(mesh);\n            }\n            var meshes = this._meshes;\n            // must be done before setting vertexBuffers because of mesh._createGlobalSubMesh()\n            mesh._geometry = this;\n            this._scene.pushGeometry(this);\n            meshes.push(mesh);\n            if (this.isReady()) {\n                this._applyToMesh(mesh);\n            }\n            else {\n                mesh._boundingInfo = this._boundingInfo;\n            }\n        };\n        Geometry.prototype.updateExtend = function (data, stride) {\n            if (data === void 0) { data = null; }\n            if (!data) {\n                data = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind].getData();\n            }\n            this._extend = BABYLON.Tools.ExtractMinAndMax(data, 0, this._totalVertices, this.boundingBias, stride);\n        };\n        Geometry.prototype._applyToMesh = function (mesh) {\n            var numOfMeshes = this._meshes.length;\n            // vertexBuffers\n            for (var kind in this._vertexBuffers) {\n                if (numOfMeshes === 1) {\n                    this._vertexBuffers[kind].create();\n                }\n                var buffer = this._vertexBuffers[kind].getBuffer();\n                if (buffer)\n                    buffer.references = numOfMeshes;\n                if (kind === BABYLON.VertexBuffer.PositionKind) {\n                    if (!this._extend) {\n                        this.updateExtend(this._vertexBuffers[kind].getData());\n                    }\n                    mesh._boundingInfo = new BABYLON.BoundingInfo(this._extend.minimum, this._extend.maximum);\n                    mesh._createGlobalSubMesh();\n                    //bounding info was just created again, world matrix should be applied again.\n                    mesh._updateBoundingInfo();\n                }\n            }\n            // indexBuffer\n            if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {\n                this._indexBuffer = this._engine.createIndexBuffer(this._indices);\n            }\n            if (this._indexBuffer) {\n                this._indexBuffer.references = numOfMeshes;\n            }\n        };\n        Geometry.prototype.notifyUpdate = function (kind) {\n            if (this.onGeometryUpdated) {\n                this.onGeometryUpdated(this, kind);\n            }\n            for (var _i = 0, _a = this._meshes; _i < _a.length; _i++) {\n                var mesh = _a[_i];\n                mesh._markSubMeshesAsAttributesDirty();\n            }\n        };\n        Geometry.prototype.load = function (scene, onLoaded) {\n            if (this.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADING) {\n                return;\n            }\n            if (this.isReady()) {\n                if (onLoaded) {\n                    onLoaded();\n                }\n                return;\n            }\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADING;\n            this._queueLoad(scene, onLoaded);\n        };\n        Geometry.prototype._queueLoad = function (scene, onLoaded) {\n            var _this = this;\n            scene._addPendingData(this);\n            BABYLON.Tools.LoadFile(this.delayLoadingFile, function (data) {\n                _this._delayLoadingFunction(JSON.parse(data), _this);\n                _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n                _this._delayInfo = [];\n                scene._removePendingData(_this);\n                var meshes = _this._meshes;\n                var numOfMeshes = meshes.length;\n                for (var index = 0; index < numOfMeshes; index++) {\n                    _this._applyToMesh(meshes[index]);\n                }\n                if (onLoaded) {\n                    onLoaded();\n                }\n            }, function () { }, scene.database);\n        };\n        /**\n         * Invert the geometry to move from a right handed system to a left handed one.\n         */\n        Geometry.prototype.toLeftHanded = function () {\n            // Flip faces\n            var tIndices = this.getIndices(false);\n            if (tIndices != null && tIndices.length > 0) {\n                for (var i = 0; i < tIndices.length; i += 3) {\n                    var tTemp = tIndices[i + 0];\n                    tIndices[i + 0] = tIndices[i + 2];\n                    tIndices[i + 2] = tTemp;\n                }\n                this.setIndices(tIndices);\n            }\n            // Negate position.z\n            var tPositions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind, false);\n            if (tPositions != null && tPositions.length > 0) {\n                for (var i = 0; i < tPositions.length; i += 3) {\n                    tPositions[i + 2] = -tPositions[i + 2];\n                }\n                this.setVerticesData(BABYLON.VertexBuffer.PositionKind, tPositions, false);\n            }\n            // Negate normal.z\n            var tNormals = this.getVerticesData(BABYLON.VertexBuffer.NormalKind, false);\n            if (tNormals != null && tNormals.length > 0) {\n                for (var i = 0; i < tNormals.length; i += 3) {\n                    tNormals[i + 2] = -tNormals[i + 2];\n                }\n                this.setVerticesData(BABYLON.VertexBuffer.NormalKind, tNormals, false);\n            }\n        };\n        // Cache\n        Geometry.prototype._resetPointsArrayCache = function () {\n            this._positions = null;\n        };\n        Geometry.prototype._generatePointsArray = function () {\n            if (this._positions)\n                return true;\n            this._positions = [];\n            var data = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            if (!data) {\n                return false;\n            }\n            for (var index = 0; index < data.length; index += 3) {\n                this._positions.push(BABYLON.Vector3.FromArray(data, index));\n            }\n            return true;\n        };\n        Geometry.prototype.isDisposed = function () {\n            return this._isDisposed;\n        };\n        Geometry.prototype._disposeVertexArrayObjects = function () {\n            if (this._vertexArrayObjects) {\n                for (var kind in this._vertexArrayObjects) {\n                    this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);\n                }\n                this._vertexArrayObjects = {};\n            }\n        };\n        Geometry.prototype.dispose = function () {\n            var meshes = this._meshes;\n            var numOfMeshes = meshes.length;\n            var index;\n            for (index = 0; index < numOfMeshes; index++) {\n                this.releaseForMesh(meshes[index]);\n            }\n            this._meshes = [];\n            this._disposeVertexArrayObjects();\n            for (var kind in this._vertexBuffers) {\n                this._vertexBuffers[kind].dispose();\n            }\n            this._vertexBuffers = {};\n            this._totalVertices = 0;\n            if (this._indexBuffer) {\n                this._engine._releaseBuffer(this._indexBuffer);\n            }\n            this._indexBuffer = null;\n            this._indices = [];\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NONE;\n            this.delayLoadingFile = null;\n            this._delayLoadingFunction = null;\n            this._delayInfo = [];\n            this._boundingInfo = null;\n            this._scene.removeGeometry(this);\n            this._isDisposed = true;\n        };\n        Geometry.prototype.copy = function (id) {\n            var vertexData = new BABYLON.VertexData();\n            vertexData.indices = [];\n            var indices = this.getIndices();\n            for (var index = 0; index < indices.length; index++) {\n                vertexData.indices.push(indices[index]);\n            }\n            var updatable = false;\n            var stopChecking = false;\n            var kind;\n            for (kind in this._vertexBuffers) {\n                // using slice() to make a copy of the array and not just reference it\n                var data = this.getVerticesData(kind);\n                if (data instanceof Float32Array) {\n                    vertexData.set(new Float32Array(data), kind);\n                }\n                else {\n                    vertexData.set(data.slice(0), kind);\n                }\n                if (!stopChecking) {\n                    updatable = this.getVertexBuffer(kind).isUpdatable();\n                    stopChecking = !updatable;\n                }\n            }\n            var geometry = new Geometry(id, this._scene, vertexData, updatable, null);\n            geometry.delayLoadState = this.delayLoadState;\n            geometry.delayLoadingFile = this.delayLoadingFile;\n            geometry._delayLoadingFunction = this._delayLoadingFunction;\n            for (kind in this._delayInfo) {\n                geometry._delayInfo = geometry._delayInfo || [];\n                geometry._delayInfo.push(kind);\n            }\n            // Bounding info\n            geometry._boundingInfo = new BABYLON.BoundingInfo(this._extend.minimum, this._extend.maximum);\n            return geometry;\n        };\n        Geometry.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.id = this.id;\n            if (BABYLON.Tags && BABYLON.Tags.HasTags(this)) {\n                serializationObject.tags = BABYLON.Tags.GetTags(this);\n            }\n            return serializationObject;\n        };\n        Geometry.prototype.toNumberArray = function (origin) {\n            if (Array.isArray(origin)) {\n                return origin;\n            }\n            else {\n                return Array.prototype.slice.call(origin);\n            }\n        };\n        Geometry.prototype.serializeVerticeData = function () {\n            var serializationObject = this.serialize();\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.PositionKind)) {\n                serializationObject.positions = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.PositionKind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.PositionKind).isUpdatable) {\n                    serializationObject.positions._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                serializationObject.normals = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.NormalKind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.NormalKind).isUpdatable) {\n                    serializationObject.normals._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                serializationObject.uvs = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UVKind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UVKind).isUpdatable) {\n                    serializationObject.uvs._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                serializationObject.uv2s = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UV2Kind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UV2Kind).isUpdatable) {\n                    serializationObject.uv2s._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UV3Kind)) {\n                serializationObject.uv3s = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UV3Kind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UV3Kind).isUpdatable) {\n                    serializationObject.uv3s._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UV4Kind)) {\n                serializationObject.uv4s = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UV4Kind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UV4Kind).isUpdatable) {\n                    serializationObject.uv4s._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UV5Kind)) {\n                serializationObject.uv5s = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UV5Kind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UV5Kind).isUpdatable) {\n                    serializationObject.uv5s._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.UV6Kind)) {\n                serializationObject.uv6s = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.UV6Kind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.UV6Kind).isUpdatable) {\n                    serializationObject.uv6s._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.ColorKind)) {\n                serializationObject.colors = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.ColorKind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.ColorKind).isUpdatable) {\n                    serializationObject.colors._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesIndicesKind)) {\n                serializationObject.matricesIndices = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind));\n                serializationObject.matricesIndices._isExpanded = true;\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.MatricesIndicesKind).isUpdatable) {\n                    serializationObject.matricesIndices._updatable = true;\n                }\n            }\n            if (this.isVerticesDataPresent(BABYLON.VertexBuffer.MatricesWeightsKind)) {\n                serializationObject.matricesWeights = this.toNumberArray(this.getVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind));\n                if (this.getVertexBuffer(BABYLON.VertexBuffer.MatricesWeightsKind).isUpdatable) {\n                    serializationObject.matricesWeights._updatable = true;\n                }\n            }\n            serializationObject.indices = this.toNumberArray(this.getIndices());\n            return serializationObject;\n        };\n        // Statics\n        Geometry.ExtractFromMesh = function (mesh, id) {\n            var geometry = mesh._geometry;\n            if (!geometry) {\n                return null;\n            }\n            return geometry.copy(id);\n        };\n        /**\n         * You should now use Tools.RandomId(), this method is still here for legacy reasons.\n         * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523\n         * Be aware Math.random() could cause collisions, but:\n         * \"All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide\"\n         */\n        Geometry.RandomId = function () {\n            return BABYLON.Tools.RandomId();\n        };\n        Geometry.ImportGeometry = function (parsedGeometry, mesh) {\n            var scene = mesh.getScene();\n            // Geometry\n            var geometryId = parsedGeometry.geometryId;\n            if (geometryId) {\n                var geometry = scene.getGeometryByID(geometryId);\n                if (geometry) {\n                    geometry.applyToMesh(mesh);\n                }\n            }\n            else if (parsedGeometry instanceof ArrayBuffer) {\n                var binaryInfo = mesh._binaryInfo;\n                if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {\n                    var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, positionsData, false);\n                }\n                if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {\n                    var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, normalsData, false);\n                }\n                if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {\n                    var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvsData, false);\n                }\n                if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {\n                    var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV2Kind, uvs2Data, false);\n                }\n                if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {\n                    var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV3Kind, uvs3Data, false);\n                }\n                if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {\n                    var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV4Kind, uvs4Data, false);\n                }\n                if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {\n                    var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV5Kind, uvs5Data, false);\n                }\n                if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {\n                    var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV6Kind, uvs6Data, false);\n                }\n                if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {\n                    var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);\n                }\n                if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {\n                    var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, matricesIndicesData, false);\n                }\n                if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {\n                    var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);\n                    mesh.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);\n                }\n                if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {\n                    var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);\n                    mesh.setIndices(indicesData);\n                }\n                if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {\n                    var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);\n                    mesh.subMeshes = [];\n                    for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {\n                        var materialIndex = subMeshesData[(i * 5) + 0];\n                        var verticesStart = subMeshesData[(i * 5) + 1];\n                        var verticesCount = subMeshesData[(i * 5) + 2];\n                        var indexStart = subMeshesData[(i * 5) + 3];\n                        var indexCount = subMeshesData[(i * 5) + 4];\n                        var subMesh = new BABYLON.SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);\n                    }\n                }\n            }\n            else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {\n                mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);\n                mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);\n                if (parsedGeometry.uvs) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);\n                }\n                if (parsedGeometry.uvs2) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);\n                }\n                if (parsedGeometry.uvs3) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);\n                }\n                if (parsedGeometry.uvs4) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);\n                }\n                if (parsedGeometry.uvs5) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);\n                }\n                if (parsedGeometry.uvs6) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);\n                }\n                if (parsedGeometry.colors) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.ColorKind, BABYLON.Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);\n                }\n                if (parsedGeometry.matricesIndices) {\n                    if (!parsedGeometry.matricesIndices._isExpanded) {\n                        var floatIndices = [];\n                        for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {\n                            var matricesIndex = parsedGeometry.matricesIndices[i];\n                            floatIndices.push(matricesIndex & 0x000000FF);\n                            floatIndices.push((matricesIndex & 0x0000FF00) >> 8);\n                            floatIndices.push((matricesIndex & 0x00FF0000) >> 16);\n                            floatIndices.push(matricesIndex >> 24);\n                        }\n                        mesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);\n                    }\n                    else {\n                        delete parsedGeometry.matricesIndices._isExpanded;\n                        mesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);\n                    }\n                }\n                if (parsedGeometry.matricesIndicesExtra) {\n                    if (!parsedGeometry.matricesIndicesExtra._isExpanded) {\n                        var floatIndices = [];\n                        for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {\n                            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];\n                            floatIndices.push(matricesIndex & 0x000000FF);\n                            floatIndices.push((matricesIndex & 0x0000FF00) >> 8);\n                            floatIndices.push((matricesIndex & 0x00FF0000) >> 16);\n                            floatIndices.push(matricesIndex >> 24);\n                        }\n                        mesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);\n                    }\n                    else {\n                        delete parsedGeometry.matricesIndices._isExpanded;\n                        mesh.setVerticesData(BABYLON.VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);\n                    }\n                }\n                if (parsedGeometry.matricesWeights) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);\n                }\n                if (parsedGeometry.matricesWeightsExtra) {\n                    mesh.setVerticesData(BABYLON.VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);\n                }\n                mesh.setIndices(parsedGeometry.indices);\n            }\n            // SubMeshes\n            if (parsedGeometry.subMeshes) {\n                mesh.subMeshes = [];\n                for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {\n                    var parsedSubMesh = parsedGeometry.subMeshes[subIndex];\n                    var subMesh = new BABYLON.SubMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);\n                }\n            }\n            // Flat shading\n            if (mesh._shouldGenerateFlatShading) {\n                mesh.convertToFlatShadedMesh();\n                delete mesh._shouldGenerateFlatShading;\n            }\n            // Update\n            mesh.computeWorldMatrix(true);\n            // Octree\n            if (scene['_selectionOctree']) {\n                scene['_selectionOctree'].addMesh(mesh);\n            }\n        };\n        Geometry.Parse = function (parsedVertexData, scene, rootUrl) {\n            if (scene.getGeometryByID(parsedVertexData.id)) {\n                return null; // null since geometry could be something else than a box...\n            }\n            var geometry = new Geometry(parsedVertexData.id, scene);\n            if (BABYLON.Tags) {\n                BABYLON.Tags.AddTagsTo(geometry, parsedVertexData.tags);\n            }\n            if (parsedVertexData.delayLoadingFile) {\n                geometry.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;\n                geometry._boundingInfo = new BABYLON.BoundingInfo(BABYLON.Vector3.FromArray(parsedVertexData.boundingBoxMinimum), BABYLON.Vector3.FromArray(parsedVertexData.boundingBoxMaximum));\n                geometry._delayInfo = [];\n                if (parsedVertexData.hasUVs) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UVKind);\n                }\n                if (parsedVertexData.hasUVs2) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UV2Kind);\n                }\n                if (parsedVertexData.hasUVs3) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UV3Kind);\n                }\n                if (parsedVertexData.hasUVs4) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UV4Kind);\n                }\n                if (parsedVertexData.hasUVs5) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UV5Kind);\n                }\n                if (parsedVertexData.hasUVs6) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.UV6Kind);\n                }\n                if (parsedVertexData.hasColors) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.ColorKind);\n                }\n                if (parsedVertexData.hasMatricesIndices) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                }\n                if (parsedVertexData.hasMatricesWeights) {\n                    geometry._delayInfo.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                }\n                geometry._delayLoadingFunction = BABYLON.VertexData.ImportVertexData;\n            }\n            else {\n                BABYLON.VertexData.ImportVertexData(parsedVertexData, geometry);\n            }\n            scene.pushGeometry(geometry, true);\n            return geometry;\n        };\n        return Geometry;\n    }());\n    BABYLON.Geometry = Geometry;\n    /////// Primitives //////////////////////////////////////////////\n    (function (Geometry) {\n        var Primitives;\n        (function (Primitives) {\n            /// Abstract class\n            var _Primitive = (function (_super) {\n                __extends(_Primitive, _super);\n                function _Primitive(id, scene, _canBeRegenerated, mesh) {\n                    var _this = _super.call(this, id, scene, null, false, mesh) || this;\n                    _this._canBeRegenerated = _canBeRegenerated;\n                    _this._beingRegenerated = true;\n                    _this.regenerate();\n                    _this._beingRegenerated = false;\n                    return _this;\n                }\n                _Primitive.prototype.canBeRegenerated = function () {\n                    return this._canBeRegenerated;\n                };\n                _Primitive.prototype.regenerate = function () {\n                    if (!this._canBeRegenerated) {\n                        return;\n                    }\n                    this._beingRegenerated = true;\n                    this.setAllVerticesData(this._regenerateVertexData(), false);\n                    this._beingRegenerated = false;\n                };\n                _Primitive.prototype.asNewGeometry = function (id) {\n                    return _super.prototype.copy.call(this, id);\n                };\n                // overrides\n                _Primitive.prototype.setAllVerticesData = function (vertexData, updatable) {\n                    if (!this._beingRegenerated) {\n                        return;\n                    }\n                    _super.prototype.setAllVerticesData.call(this, vertexData, false);\n                };\n                _Primitive.prototype.setVerticesData = function (kind, data, updatable) {\n                    if (!this._beingRegenerated) {\n                        return;\n                    }\n                    _super.prototype.setVerticesData.call(this, kind, data, false);\n                };\n                // to override\n                // protected\n                _Primitive.prototype._regenerateVertexData = function () {\n                    throw new Error(\"Abstract method\");\n                };\n                _Primitive.prototype.copy = function (id) {\n                    throw new Error(\"Must be overriden in sub-classes.\");\n                };\n                _Primitive.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.canBeRegenerated = this.canBeRegenerated();\n                    return serializationObject;\n                };\n                return _Primitive;\n            }(Geometry));\n            Primitives._Primitive = _Primitive;\n            var Ribbon = (function (_super) {\n                __extends(Ribbon, _super);\n                // Members\n                function Ribbon(id, scene, pathArray, closeArray, closePath, offset, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.pathArray = pathArray;\n                    _this.closeArray = closeArray;\n                    _this.closePath = closePath;\n                    _this.offset = offset;\n                    _this.side = side;\n                    return _this;\n                }\n                Ribbon.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateRibbon({ pathArray: this.pathArray, closeArray: this.closeArray, closePath: this.closePath, offset: this.offset, sideOrientation: this.side });\n                };\n                Ribbon.prototype.copy = function (id) {\n                    return new Ribbon(id, this.getScene(), this.pathArray, this.closeArray, this.closePath, this.offset, this.canBeRegenerated(), null, this.side);\n                };\n                return Ribbon;\n            }(_Primitive));\n            Primitives.Ribbon = Ribbon;\n            var Box = (function (_super) {\n                __extends(Box, _super);\n                // Members\n                function Box(id, scene, size, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.size = size;\n                    _this.side = side;\n                    return _this;\n                }\n                Box.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateBox({ size: this.size, sideOrientation: this.side });\n                };\n                Box.prototype.copy = function (id) {\n                    return new Box(id, this.getScene(), this.size, this.canBeRegenerated(), null, this.side);\n                };\n                Box.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.size = this.size;\n                    return serializationObject;\n                };\n                Box.Parse = function (parsedBox, scene) {\n                    if (scene.getGeometryByID(parsedBox.id)) {\n                        return null; // null since geometry could be something else than a box...\n                    }\n                    var box = new Geometry.Primitives.Box(parsedBox.id, scene, parsedBox.size, parsedBox.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(box, parsedBox.tags);\n                    }\n                    scene.pushGeometry(box, true);\n                    return box;\n                };\n                return Box;\n            }(_Primitive));\n            Primitives.Box = Box;\n            var Sphere = (function (_super) {\n                __extends(Sphere, _super);\n                function Sphere(id, scene, segments, diameter, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.segments = segments;\n                    _this.diameter = diameter;\n                    _this.side = side;\n                    return _this;\n                }\n                Sphere.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateSphere({ segments: this.segments, diameter: this.diameter, sideOrientation: this.side });\n                };\n                Sphere.prototype.copy = function (id) {\n                    return new Sphere(id, this.getScene(), this.segments, this.diameter, this.canBeRegenerated(), null, this.side);\n                };\n                Sphere.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.segments = this.segments;\n                    serializationObject.diameter = this.diameter;\n                    return serializationObject;\n                };\n                Sphere.Parse = function (parsedSphere, scene) {\n                    if (scene.getGeometryByID(parsedSphere.id)) {\n                        return null; // null since geometry could be something else than a sphere...\n                    }\n                    var sphere = new Geometry.Primitives.Sphere(parsedSphere.id, scene, parsedSphere.segments, parsedSphere.diameter, parsedSphere.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(sphere, parsedSphere.tags);\n                    }\n                    scene.pushGeometry(sphere, true);\n                    return sphere;\n                };\n                return Sphere;\n            }(_Primitive));\n            Primitives.Sphere = Sphere;\n            var Disc = (function (_super) {\n                __extends(Disc, _super);\n                // Members\n                function Disc(id, scene, radius, tessellation, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.radius = radius;\n                    _this.tessellation = tessellation;\n                    _this.side = side;\n                    return _this;\n                }\n                Disc.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateDisc({ radius: this.radius, tessellation: this.tessellation, sideOrientation: this.side });\n                };\n                Disc.prototype.copy = function (id) {\n                    return new Disc(id, this.getScene(), this.radius, this.tessellation, this.canBeRegenerated(), null, this.side);\n                };\n                return Disc;\n            }(_Primitive));\n            Primitives.Disc = Disc;\n            var Cylinder = (function (_super) {\n                __extends(Cylinder, _super);\n                function Cylinder(id, scene, height, diameterTop, diameterBottom, tessellation, subdivisions, canBeRegenerated, mesh, side) {\n                    if (subdivisions === void 0) { subdivisions = 1; }\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.height = height;\n                    _this.diameterTop = diameterTop;\n                    _this.diameterBottom = diameterBottom;\n                    _this.tessellation = tessellation;\n                    _this.subdivisions = subdivisions;\n                    _this.side = side;\n                    return _this;\n                }\n                Cylinder.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateCylinder({ height: this.height, diameterTop: this.diameterTop, diameterBottom: this.diameterBottom, tessellation: this.tessellation, subdivisions: this.subdivisions, sideOrientation: this.side });\n                };\n                Cylinder.prototype.copy = function (id) {\n                    return new Cylinder(id, this.getScene(), this.height, this.diameterTop, this.diameterBottom, this.tessellation, this.subdivisions, this.canBeRegenerated(), null, this.side);\n                };\n                Cylinder.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.height = this.height;\n                    serializationObject.diameterTop = this.diameterTop;\n                    serializationObject.diameterBottom = this.diameterBottom;\n                    serializationObject.tessellation = this.tessellation;\n                    return serializationObject;\n                };\n                Cylinder.Parse = function (parsedCylinder, scene) {\n                    if (scene.getGeometryByID(parsedCylinder.id)) {\n                        return null; // null since geometry could be something else than a cylinder...\n                    }\n                    var cylinder = new Geometry.Primitives.Cylinder(parsedCylinder.id, scene, parsedCylinder.height, parsedCylinder.diameterTop, parsedCylinder.diameterBottom, parsedCylinder.tessellation, parsedCylinder.subdivisions, parsedCylinder.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(cylinder, parsedCylinder.tags);\n                    }\n                    scene.pushGeometry(cylinder, true);\n                    return cylinder;\n                };\n                return Cylinder;\n            }(_Primitive));\n            Primitives.Cylinder = Cylinder;\n            var Torus = (function (_super) {\n                __extends(Torus, _super);\n                function Torus(id, scene, diameter, thickness, tessellation, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.diameter = diameter;\n                    _this.thickness = thickness;\n                    _this.tessellation = tessellation;\n                    _this.side = side;\n                    return _this;\n                }\n                Torus.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateTorus({ diameter: this.diameter, thickness: this.thickness, tessellation: this.tessellation, sideOrientation: this.side });\n                };\n                Torus.prototype.copy = function (id) {\n                    return new Torus(id, this.getScene(), this.diameter, this.thickness, this.tessellation, this.canBeRegenerated(), null, this.side);\n                };\n                Torus.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.diameter = this.diameter;\n                    serializationObject.thickness = this.thickness;\n                    serializationObject.tessellation = this.tessellation;\n                    return serializationObject;\n                };\n                Torus.Parse = function (parsedTorus, scene) {\n                    if (scene.getGeometryByID(parsedTorus.id)) {\n                        return null; // null since geometry could be something else than a torus...\n                    }\n                    var torus = new Geometry.Primitives.Torus(parsedTorus.id, scene, parsedTorus.diameter, parsedTorus.thickness, parsedTorus.tessellation, parsedTorus.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(torus, parsedTorus.tags);\n                    }\n                    scene.pushGeometry(torus, true);\n                    return torus;\n                };\n                return Torus;\n            }(_Primitive));\n            Primitives.Torus = Torus;\n            var Ground = (function (_super) {\n                __extends(Ground, _super);\n                function Ground(id, scene, width, height, subdivisions, canBeRegenerated, mesh) {\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.width = width;\n                    _this.height = height;\n                    _this.subdivisions = subdivisions;\n                    return _this;\n                }\n                Ground.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateGround({ width: this.width, height: this.height, subdivisions: this.subdivisions });\n                };\n                Ground.prototype.copy = function (id) {\n                    return new Ground(id, this.getScene(), this.width, this.height, this.subdivisions, this.canBeRegenerated(), null);\n                };\n                Ground.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.width = this.width;\n                    serializationObject.height = this.height;\n                    serializationObject.subdivisions = this.subdivisions;\n                    return serializationObject;\n                };\n                Ground.Parse = function (parsedGround, scene) {\n                    if (scene.getGeometryByID(parsedGround.id)) {\n                        return null; // null since geometry could be something else than a ground...\n                    }\n                    var ground = new Geometry.Primitives.Ground(parsedGround.id, scene, parsedGround.width, parsedGround.height, parsedGround.subdivisions, parsedGround.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(ground, parsedGround.tags);\n                    }\n                    scene.pushGeometry(ground, true);\n                    return ground;\n                };\n                return Ground;\n            }(_Primitive));\n            Primitives.Ground = Ground;\n            var TiledGround = (function (_super) {\n                __extends(TiledGround, _super);\n                function TiledGround(id, scene, xmin, zmin, xmax, zmax, subdivisions, precision, canBeRegenerated, mesh) {\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.xmin = xmin;\n                    _this.zmin = zmin;\n                    _this.xmax = xmax;\n                    _this.zmax = zmax;\n                    _this.subdivisions = subdivisions;\n                    _this.precision = precision;\n                    return _this;\n                }\n                TiledGround.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateTiledGround({ xmin: this.xmin, zmin: this.zmin, xmax: this.xmax, zmax: this.zmax, subdivisions: this.subdivisions, precision: this.precision });\n                };\n                TiledGround.prototype.copy = function (id) {\n                    return new TiledGround(id, this.getScene(), this.xmin, this.zmin, this.xmax, this.zmax, this.subdivisions, this.precision, this.canBeRegenerated(), null);\n                };\n                return TiledGround;\n            }(_Primitive));\n            Primitives.TiledGround = TiledGround;\n            var Plane = (function (_super) {\n                __extends(Plane, _super);\n                function Plane(id, scene, size, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.size = size;\n                    _this.side = side;\n                    return _this;\n                }\n                Plane.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreatePlane({ size: this.size, sideOrientation: this.side });\n                };\n                Plane.prototype.copy = function (id) {\n                    return new Plane(id, this.getScene(), this.size, this.canBeRegenerated(), null, this.side);\n                };\n                Plane.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.size = this.size;\n                    return serializationObject;\n                };\n                Plane.Parse = function (parsedPlane, scene) {\n                    if (scene.getGeometryByID(parsedPlane.id)) {\n                        return null; // null since geometry could be something else than a ground...\n                    }\n                    var plane = new Geometry.Primitives.Plane(parsedPlane.id, scene, parsedPlane.size, parsedPlane.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(plane, parsedPlane.tags);\n                    }\n                    scene.pushGeometry(plane, true);\n                    return plane;\n                };\n                return Plane;\n            }(_Primitive));\n            Primitives.Plane = Plane;\n            var TorusKnot = (function (_super) {\n                __extends(TorusKnot, _super);\n                function TorusKnot(id, scene, radius, tube, radialSegments, tubularSegments, p, q, canBeRegenerated, mesh, side) {\n                    if (side === void 0) { side = BABYLON.Mesh.DEFAULTSIDE; }\n                    var _this = _super.call(this, id, scene, canBeRegenerated, mesh) || this;\n                    _this.radius = radius;\n                    _this.tube = tube;\n                    _this.radialSegments = radialSegments;\n                    _this.tubularSegments = tubularSegments;\n                    _this.p = p;\n                    _this.q = q;\n                    _this.side = side;\n                    return _this;\n                }\n                TorusKnot.prototype._regenerateVertexData = function () {\n                    return BABYLON.VertexData.CreateTorusKnot({ radius: this.radius, tube: this.tube, radialSegments: this.radialSegments, tubularSegments: this.tubularSegments, p: this.p, q: this.q, sideOrientation: this.side });\n                };\n                TorusKnot.prototype.copy = function (id) {\n                    return new TorusKnot(id, this.getScene(), this.radius, this.tube, this.radialSegments, this.tubularSegments, this.p, this.q, this.canBeRegenerated(), null, this.side);\n                };\n                TorusKnot.prototype.serialize = function () {\n                    var serializationObject = _super.prototype.serialize.call(this);\n                    serializationObject.radius = this.radius;\n                    serializationObject.tube = this.tube;\n                    serializationObject.radialSegments = this.radialSegments;\n                    serializationObject.tubularSegments = this.tubularSegments;\n                    serializationObject.p = this.p;\n                    serializationObject.q = this.q;\n                    return serializationObject;\n                };\n                ;\n                TorusKnot.Parse = function (parsedTorusKnot, scene) {\n                    if (scene.getGeometryByID(parsedTorusKnot.id)) {\n                        return null; // null since geometry could be something else than a ground...\n                    }\n                    var torusKnot = new Geometry.Primitives.TorusKnot(parsedTorusKnot.id, scene, parsedTorusKnot.radius, parsedTorusKnot.tube, parsedTorusKnot.radialSegments, parsedTorusKnot.tubularSegments, parsedTorusKnot.p, parsedTorusKnot.q, parsedTorusKnot.canBeRegenerated, null);\n                    if (BABYLON.Tags) {\n                        BABYLON.Tags.AddTagsTo(torusKnot, parsedTorusKnot.tags);\n                    }\n                    scene.pushGeometry(torusKnot, true);\n                    return torusKnot;\n                };\n                return TorusKnot;\n            }(_Primitive));\n            Primitives.TorusKnot = TorusKnot;\n        })(Primitives = Geometry.Primitives || (Geometry.Primitives = {}));\n    })(Geometry = BABYLON.Geometry || (BABYLON.Geometry = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.geometry.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcessManager = (function () {\n        function PostProcessManager(scene) {\n            this._vertexBuffers = {};\n            this._scene = scene;\n        }\n        PostProcessManager.prototype._prepareBuffers = function () {\n            if (this._vertexBuffers[BABYLON.VertexBuffer.PositionKind]) {\n                return;\n            }\n            // VBO\n            var vertices = [];\n            vertices.push(1, 1);\n            vertices.push(-1, 1);\n            vertices.push(-1, -1);\n            vertices.push(1, -1);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = new BABYLON.VertexBuffer(this._scene.getEngine(), vertices, BABYLON.VertexBuffer.PositionKind, false, false, 2);\n            // Indices\n            var indices = [];\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);\n        };\n        // Methods\n        PostProcessManager.prototype._prepareFrame = function (sourceTexture, postProcesses) {\n            var postProcesses = postProcesses || this._scene.activeCamera._postProcesses;\n            if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\n                return false;\n            }\n            postProcesses[0].activate(this._scene.activeCamera, sourceTexture, postProcesses !== null && postProcesses !== undefined);\n            return true;\n        };\n        PostProcessManager.prototype.directRender = function (postProcesses, targetTexture) {\n            var engine = this._scene.getEngine();\n            for (var index = 0; index < postProcesses.length; index++) {\n                if (index < postProcesses.length - 1) {\n                    postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture);\n                }\n                else {\n                    if (targetTexture) {\n                        engine.bindFramebuffer(targetTexture);\n                    }\n                    else {\n                        engine.restoreDefaultFramebuffer();\n                    }\n                }\n                var pp = postProcesses[index];\n                var effect = pp.apply();\n                if (effect) {\n                    pp.onBeforeRenderObservable.notifyObservers(effect);\n                    // VBOs\n                    this._prepareBuffers();\n                    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n                    // Draw order\n                    engine.draw(true, 0, 6);\n                    pp.onAfterRenderObservable.notifyObservers(effect);\n                }\n            }\n            // Restore depth buffer\n            engine.setDepthBuffer(true);\n            engine.setDepthWrite(true);\n        };\n        PostProcessManager.prototype._finalizeFrame = function (doNotPresent, targetTexture, faceIndex, postProcesses) {\n            postProcesses = postProcesses || this._scene.activeCamera._postProcesses;\n            if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {\n                return;\n            }\n            var engine = this._scene.getEngine();\n            for (var index = 0, len = postProcesses.length; index < len; index++) {\n                if (index < len - 1) {\n                    postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture);\n                }\n                else {\n                    if (targetTexture) {\n                        engine.bindFramebuffer(targetTexture, faceIndex);\n                    }\n                    else {\n                        engine.restoreDefaultFramebuffer();\n                    }\n                }\n                if (doNotPresent) {\n                    break;\n                }\n                var pp = postProcesses[index];\n                var effect = pp.apply();\n                if (effect) {\n                    pp.onBeforeRenderObservable.notifyObservers(effect);\n                    // VBOs\n                    this._prepareBuffers();\n                    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n                    // Draw order\n                    engine.draw(true, 0, 6);\n                    pp.onAfterRenderObservable.notifyObservers(effect);\n                }\n            }\n            // Restore states\n            engine.setDepthBuffer(true);\n            engine.setDepthWrite(true);\n            engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n        };\n        PostProcessManager.prototype.dispose = function () {\n            var buffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (buffer) {\n                buffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n        };\n        return PostProcessManager;\n    }());\n    BABYLON.PostProcessManager = PostProcessManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcessManager.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var StandardMaterialDefines = (function (_super) {\n        __extends(StandardMaterialDefines, _super);\n        function StandardMaterialDefines() {\n            var _this = _super.call(this) || this;\n            _this.MAINUV1 = false;\n            _this.MAINUV2 = false;\n            _this.DIFFUSE = false;\n            _this.DIFFUSEDIRECTUV = 0;\n            _this.AMBIENT = false;\n            _this.AMBIENTDIRECTUV = 0;\n            _this.OPACITY = false;\n            _this.OPACITYDIRECTUV = 0;\n            _this.OPACITYRGB = false;\n            _this.REFLECTION = false;\n            _this.EMISSIVE = false;\n            _this.EMISSIVEDIRECTUV = 0;\n            _this.SPECULAR = false;\n            _this.SPECULARDIRECTUV = 0;\n            _this.BUMP = false;\n            _this.BUMPDIRECTUV = 0;\n            _this.PARALLAX = false;\n            _this.PARALLAXOCCLUSION = false;\n            _this.SPECULAROVERALPHA = false;\n            _this.CLIPPLANE = false;\n            _this.ALPHATEST = false;\n            _this.ALPHAFROMDIFFUSE = false;\n            _this.POINTSIZE = false;\n            _this.FOG = false;\n            _this.SPECULARTERM = false;\n            _this.DIFFUSEFRESNEL = false;\n            _this.OPACITYFRESNEL = false;\n            _this.REFLECTIONFRESNEL = false;\n            _this.REFRACTIONFRESNEL = false;\n            _this.EMISSIVEFRESNEL = false;\n            _this.FRESNEL = false;\n            _this.NORMAL = false;\n            _this.UV1 = false;\n            _this.UV2 = false;\n            _this.VERTEXCOLOR = false;\n            _this.VERTEXALPHA = false;\n            _this.NUM_BONE_INFLUENCERS = 0;\n            _this.BonesPerMesh = 0;\n            _this.INSTANCES = false;\n            _this.GLOSSINESS = false;\n            _this.ROUGHNESS = false;\n            _this.EMISSIVEASILLUMINATION = false;\n            _this.LINKEMISSIVEWITHDIFFUSE = false;\n            _this.REFLECTIONFRESNELFROMSPECULAR = false;\n            _this.LIGHTMAP = false;\n            _this.LIGHTMAPDIRECTUV = 0;\n            _this.USELIGHTMAPASSHADOWMAP = false;\n            _this.REFLECTIONMAP_3D = false;\n            _this.REFLECTIONMAP_SPHERICAL = false;\n            _this.REFLECTIONMAP_PLANAR = false;\n            _this.REFLECTIONMAP_CUBIC = false;\n            _this.REFLECTIONMAP_PROJECTION = false;\n            _this.REFLECTIONMAP_SKYBOX = false;\n            _this.REFLECTIONMAP_EXPLICIT = false;\n            _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n            _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n            _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n            _this.INVERTCUBICMAP = false;\n            _this.LOGARITHMICDEPTH = false;\n            _this.REFRACTION = false;\n            _this.REFRACTIONMAP_3D = false;\n            _this.REFLECTIONOVERALPHA = false;\n            _this.INVERTNORMALMAPX = false;\n            _this.INVERTNORMALMAPY = false;\n            _this.TWOSIDEDLIGHTING = false;\n            _this.SHADOWFLOAT = false;\n            _this.MORPHTARGETS = false;\n            _this.MORPHTARGETS_NORMAL = false;\n            _this.MORPHTARGETS_TANGENT = false;\n            _this.NUM_MORPH_INFLUENCERS = 0;\n            _this.USERIGHTHANDEDSYSTEM = false;\n            _this.IMAGEPROCESSING = false;\n            _this.VIGNETTE = false;\n            _this.VIGNETTEBLENDMODEMULTIPLY = false;\n            _this.VIGNETTEBLENDMODEOPAQUE = false;\n            _this.TONEMAPPING = false;\n            _this.CONTRAST = false;\n            _this.COLORCURVES = false;\n            _this.COLORGRADING = false;\n            _this.SAMPLER3DGREENDEPTH = false;\n            _this.SAMPLER3DBGRMAP = false;\n            _this.IMAGEPROCESSINGPOSTPROCESS = false;\n            _this.EXPOSURE = false;\n            _this.rebuild();\n            return _this;\n        }\n        StandardMaterialDefines.prototype.setReflectionMode = function (modeToEnable) {\n            var modes = [\n                \"REFLECTIONMAP_CUBIC\", \"REFLECTIONMAP_EXPLICIT\", \"REFLECTIONMAP_PLANAR\",\n                \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_PROJECTION\", \"REFLECTIONMAP_SKYBOX\",\n                \"REFLECTIONMAP_SPHERICAL\", \"REFLECTIONMAP_EQUIRECTANGULAR\", \"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\",\n                \"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\"\n            ];\n            for (var _i = 0, modes_1 = modes; _i < modes_1.length; _i++) {\n                var mode = modes_1[_i];\n                this[mode] = (mode === modeToEnable);\n            }\n        };\n        return StandardMaterialDefines;\n    }(BABYLON.MaterialDefines));\n    BABYLON.StandardMaterialDefines = StandardMaterialDefines;\n    var StandardMaterial = (function (_super) {\n        __extends(StandardMaterial, _super);\n        function StandardMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.ambientColor = new BABYLON.Color3(0, 0, 0);\n            _this.diffuseColor = new BABYLON.Color3(1, 1, 1);\n            _this.specularColor = new BABYLON.Color3(1, 1, 1);\n            _this.emissiveColor = new BABYLON.Color3(0, 0, 0);\n            _this.specularPower = 64;\n            _this._useAlphaFromDiffuseTexture = false;\n            _this._useEmissiveAsIllumination = false;\n            _this._linkEmissiveWithDiffuse = false;\n            _this._useSpecularOverAlpha = false;\n            _this._useReflectionOverAlpha = false;\n            _this._disableLighting = false;\n            _this._useParallax = false;\n            _this._useParallaxOcclusion = false;\n            _this.parallaxScaleBias = 0.05;\n            _this._roughness = 0;\n            _this.indexOfRefraction = 0.98;\n            _this.invertRefractionY = true;\n            _this._useLightmapAsShadowmap = false;\n            _this._useReflectionFresnelFromSpecular = false;\n            _this._useGlossinessFromSpecularMapAlpha = false;\n            _this._maxSimultaneousLights = 4;\n            /**\n             * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n             */\n            _this._invertNormalMapX = false;\n            /**\n             * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n             */\n            _this._invertNormalMapY = false;\n            /**\n             * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n             */\n            _this._twoSidedLighting = false;\n            _this._renderTargets = new BABYLON.SmartArray(16);\n            _this._worldViewProjectionMatrix = BABYLON.Matrix.Zero();\n            _this._globalAmbientColor = new BABYLON.Color3(0, 0, 0);\n            // Setup the default processing configuration to the scene.\n            _this._attachImageProcessingConfiguration(null);\n            _this.getRenderTargetTextures = function () {\n                _this._renderTargets.reset();\n                if (StandardMaterial.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\n                    _this._renderTargets.push(_this._reflectionTexture);\n                }\n                if (StandardMaterial.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {\n                    _this._renderTargets.push(_this._refractionTexture);\n                }\n                return _this._renderTargets;\n            };\n            return _this;\n        }\n        Object.defineProperty(StandardMaterial.prototype, \"imageProcessingConfiguration\", {\n            /**\n             * Gets the image processing configuration used either in this material.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration;\n            },\n            /**\n             * Sets the Default image processing configuration used either in the this material.\n             *\n             * If sets to null, the scene one is in use.\n             */\n            set: function (value) {\n                this._attachImageProcessingConfiguration(value);\n                // Ensure the effect will be rebuilt.\n                this._markAllSubMeshesAsTexturesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Attaches a new image processing configuration to the Standard Material.\n         * @param configuration\n         */\n        StandardMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n            var _this = this;\n            if (configuration === this._imageProcessingConfiguration) {\n                return;\n            }\n            // Detaches observer.\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            // Pick the scene configuration if needed.\n            if (!configuration) {\n                this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n            }\n            else {\n                this._imageProcessingConfiguration = configuration;\n            }\n            // Attaches observer.\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (conf) {\n                _this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        };\n        Object.defineProperty(StandardMaterial.prototype, \"cameraColorCurvesEnabled\", {\n            /**\n             * Gets wether the color curves effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorCurvesEnabled;\n            },\n            /**\n             * Sets wether the color curves effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorCurvesEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingEnabled\", {\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorGradingEnabled;\n            },\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorGradingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial.prototype, \"cameraToneMappingEnabled\", {\n            /**\n             * Gets wether tonemapping is enabled or not.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.toneMappingEnabled;\n            },\n            /**\n             * Sets wether tonemapping is enabled or not\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.toneMappingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(StandardMaterial.prototype, \"cameraExposure\", {\n            /**\n             * The camera exposure used on this material.\n             * This property is here and not in the camera to allow controlling exposure without full screen post process.\n             * This corresponds to a photographic exposure.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.exposure;\n            },\n            /**\n             * The camera exposure used on this material.\n             * This property is here and not in the camera to allow controlling exposure without full screen post process.\n             * This corresponds to a photographic exposure.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.exposure = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(StandardMaterial.prototype, \"cameraContrast\", {\n            /**\n             * Gets The camera contrast used on this material.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.contrast;\n            },\n            /**\n             * Sets The camera contrast used on this material.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.contrast = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial.prototype, \"cameraColorGradingTexture\", {\n            /**\n             * Gets the Color Grading 2D Lookup Texture.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.colorGradingTexture;\n            },\n            /**\n             * Sets the Color Grading 2D Lookup Texture.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.colorGradingTexture = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StandardMaterial.prototype.getClassName = function () {\n            return \"StandardMaterial\";\n        };\n        Object.defineProperty(StandardMaterial.prototype, \"useLogarithmicDepth\", {\n            get: function () {\n                return this._useLogarithmicDepth;\n            },\n            set: function (value) {\n                this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n                this._markAllSubMeshesAsMiscDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StandardMaterial.prototype.needAlphaBlending = function () {\n            return (this.alpha < 1.0) || (this._opacityTexture != null) || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;\n        };\n        StandardMaterial.prototype.needAlphaTesting = function () {\n            return this._diffuseTexture != null && this._diffuseTexture.hasAlpha;\n        };\n        StandardMaterial.prototype._shouldUseAlphaFromDiffuseTexture = function () {\n            return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture;\n        };\n        StandardMaterial.prototype.getAlphaTestTexture = function () {\n            return this._diffuseTexture;\n        };\n        /**\n         * Child classes can use it to update shaders\n         */\n        StandardMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n            if (this.isFrozen) {\n                if (this._wasPreviouslyReady && subMesh.effect) {\n                    return true;\n                }\n            }\n            if (!subMesh._materialDefines) {\n                subMesh._materialDefines = new StandardMaterialDefines();\n            }\n            var scene = this.getScene();\n            var defines = subMesh._materialDefines;\n            if (!this.checkReadyOnEveryCall && subMesh.effect) {\n                if (defines._renderId === scene.getRenderId()) {\n                    return true;\n                }\n            }\n            var engine = scene.getEngine();\n            // Lights\n            defines._needNormals = BABYLON.MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n            // Textures\n            if (defines._areTexturesDirty) {\n                defines._needUVs = false;\n                defines.MAINUV1 = false;\n                defines.MAINUV2 = false;\n                if (scene.texturesEnabled) {\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                        if (!this._diffuseTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, \"DIFFUSE\");\n                        }\n                    }\n                    else {\n                        defines.DIFFUSE = false;\n                    }\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                        if (!this._ambientTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n                        }\n                    }\n                    else {\n                        defines.AMBIENT = false;\n                    }\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                        if (!this._opacityTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n                            defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n                        }\n                    }\n                    else {\n                        defines.OPACITY = false;\n                    }\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                        if (!this._reflectionTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            defines._needNormals = true;\n                            defines.REFLECTION = true;\n                            defines.ROUGHNESS = (this._roughness > 0);\n                            defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;\n                            defines.INVERTCUBICMAP = (this._reflectionTexture.coordinatesMode === BABYLON.Texture.INVCUBIC_MODE);\n                            defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;\n                            switch (this._reflectionTexture.coordinatesMode) {\n                                case BABYLON.Texture.CUBIC_MODE:\n                                case BABYLON.Texture.INVCUBIC_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_CUBIC\");\n                                    break;\n                                case BABYLON.Texture.EXPLICIT_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_EXPLICIT\");\n                                    break;\n                                case BABYLON.Texture.PLANAR_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_PLANAR\");\n                                    break;\n                                case BABYLON.Texture.PROJECTION_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_PROJECTION\");\n                                    break;\n                                case BABYLON.Texture.SKYBOX_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_SKYBOX\");\n                                    break;\n                                case BABYLON.Texture.SPHERICAL_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_SPHERICAL\");\n                                    break;\n                                case BABYLON.Texture.EQUIRECTANGULAR_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR\");\n                                    break;\n                                case BABYLON.Texture.FIXED_EQUIRECTANGULAR_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_EQUIRECTANGULAR_FIXED\");\n                                    break;\n                                case BABYLON.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                                    defines.setReflectionMode(\"REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\");\n                                    break;\n                            }\n                        }\n                    }\n                    else {\n                        defines.REFLECTION = false;\n                    }\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                        if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n                        }\n                    }\n                    else {\n                        defines.EMISSIVE = false;\n                    }\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                        if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n                            defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n                        }\n                    }\n                    else {\n                        defines.LIGHTMAP = false;\n                    }\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                        if (!this._specularTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, \"SPECULAR\");\n                            defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;\n                        }\n                    }\n                    else {\n                        defines.SPECULAR = false;\n                    }\n                    if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {\n                        // Bump texure can not be not blocking.\n                        if (!this._bumpTexture.isReady()) {\n                            return false;\n                        }\n                        else {\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n                            defines.INVERTNORMALMAPX = this.invertNormalMapX;\n                            defines.INVERTNORMALMAPY = this.invertNormalMapY;\n                            defines.PARALLAX = this._useParallax;\n                            defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;\n                        }\n                    }\n                    else {\n                        defines.BUMP = false;\n                    }\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                        if (!this._refractionTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        else {\n                            defines._needUVs = true;\n                            defines.REFRACTION = true;\n                            defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;\n                        }\n                    }\n                    else {\n                        defines.REFRACTION = false;\n                    }\n                    defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;\n                }\n                else {\n                    defines.DIFFUSE = false;\n                    defines.AMBIENT = false;\n                    defines.OPACITY = false;\n                    defines.REFLECTION = false;\n                    defines.EMISSIVE = false;\n                    defines.LIGHTMAP = false;\n                    defines.BUMP = false;\n                    defines.REFRACTION = false;\n                }\n                defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();\n                defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;\n                defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;\n                defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;\n            }\n            if (defines._areImageProcessingDirty) {\n                if (!this._imageProcessingConfiguration.isReady()) {\n                    return false;\n                }\n                this._imageProcessingConfiguration.prepareDefines(defines);\n            }\n            if (defines._areFresnelDirty) {\n                if (StandardMaterial.FresnelEnabled) {\n                    // Fresnel\n                    if (this._diffuseFresnelParameters || this._opacityFresnelParameters ||\n                        this._emissiveFresnelParameters || this._refractionFresnelParameters ||\n                        this._reflectionFresnelParameters) {\n                        defines.DIFFUSEFRESNEL = (this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled);\n                        defines.OPACITYFRESNEL = (this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled);\n                        defines.REFLECTIONFRESNEL = (this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled);\n                        defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;\n                        defines.REFRACTIONFRESNEL = (this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled);\n                        defines.EMISSIVEFRESNEL = (this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled);\n                        defines._needNormals = true;\n                        defines.FRESNEL = true;\n                    }\n                }\n                else {\n                    defines.FRESNEL = false;\n                }\n            }\n            // Misc.\n            BABYLON.MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, defines);\n            // Attribs\n            BABYLON.MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);\n            // Values that need to be evaluated on every frame\n            BABYLON.MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances);\n            if (scene._mirroredCameraPosition && defines.BUMP) {\n                defines.INVERTNORMALMAPX = !this.invertNormalMapX;\n                defines.INVERTNORMALMAPY = !this.invertNormalMapY;\n                defines.markAsUnprocessed();\n            }\n            // Get correct effect      \n            if (defines.isDirty) {\n                defines.markAsProcessed();\n                scene.resetCachedMaterial();\n                // Fallbacks\n                var fallbacks = new BABYLON.EffectFallbacks();\n                if (defines.REFLECTION) {\n                    fallbacks.addFallback(0, \"REFLECTION\");\n                }\n                if (defines.SPECULAR) {\n                    fallbacks.addFallback(0, \"SPECULAR\");\n                }\n                if (defines.BUMP) {\n                    fallbacks.addFallback(0, \"BUMP\");\n                }\n                if (defines.PARALLAX) {\n                    fallbacks.addFallback(1, \"PARALLAX\");\n                }\n                if (defines.PARALLAXOCCLUSION) {\n                    fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\n                }\n                if (defines.SPECULAROVERALPHA) {\n                    fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\n                }\n                if (defines.FOG) {\n                    fallbacks.addFallback(1, \"FOG\");\n                }\n                if (defines.POINTSIZE) {\n                    fallbacks.addFallback(0, \"POINTSIZE\");\n                }\n                if (defines.LOGARITHMICDEPTH) {\n                    fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n                }\n                BABYLON.MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n                if (defines.SPECULARTERM) {\n                    fallbacks.addFallback(0, \"SPECULARTERM\");\n                }\n                if (defines.DIFFUSEFRESNEL) {\n                    fallbacks.addFallback(1, \"DIFFUSEFRESNEL\");\n                }\n                if (defines.OPACITYFRESNEL) {\n                    fallbacks.addFallback(2, \"OPACITYFRESNEL\");\n                }\n                if (defines.REFLECTIONFRESNEL) {\n                    fallbacks.addFallback(3, \"REFLECTIONFRESNEL\");\n                }\n                if (defines.EMISSIVEFRESNEL) {\n                    fallbacks.addFallback(4, \"EMISSIVEFRESNEL\");\n                }\n                if (defines.FRESNEL) {\n                    fallbacks.addFallback(4, \"FRESNEL\");\n                }\n                //Attributes\n                var attribs = [BABYLON.VertexBuffer.PositionKind];\n                if (defines.NORMAL) {\n                    attribs.push(BABYLON.VertexBuffer.NormalKind);\n                }\n                if (defines.UV1) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                }\n                if (defines.UV2) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                }\n                if (defines.VERTEXCOLOR) {\n                    attribs.push(BABYLON.VertexBuffer.ColorKind);\n                }\n                BABYLON.MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n                BABYLON.MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n                BABYLON.MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n                var shaderName = \"default\";\n                var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vDiffuseColor\", \"vSpecularColor\", \"vEmissiveColor\",\n                    \"vFogInfos\", \"vFogColor\", \"pointSize\",\n                    \"vDiffuseInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vSpecularInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\",\n                    \"mBones\",\n                    \"vClipPlane\", \"diffuseMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"specularMatrix\", \"bumpMatrix\", \"lightmapMatrix\", \"refractionMatrix\",\n                    \"diffuseLeftColor\", \"diffuseRightColor\", \"opacityParts\", \"reflectionLeftColor\", \"reflectionRightColor\", \"emissiveLeftColor\", \"emissiveRightColor\", \"refractionLeftColor\", \"refractionRightColor\",\n                    \"logarithmicDepthConstant\"\n                ];\n                var samplers = [\"diffuseSampler\", \"ambientSampler\", \"opacitySampler\", \"reflectionCubeSampler\", \"reflection2DSampler\", \"emissiveSampler\", \"specularSampler\", \"bumpSampler\", \"lightmapSampler\", \"refractionCubeSampler\", \"refraction2DSampler\"];\n                var uniformBuffers = [\"Material\", \"Scene\"];\n                BABYLON.ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                BABYLON.ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n                BABYLON.MaterialHelper.PrepareUniformsAndSamplersList({\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: defines,\n                    maxSimultaneousLights: this._maxSimultaneousLights\n                });\n                if (this.customShaderNameResolve) {\n                    shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines);\n                }\n                var join = defines.toString();\n                subMesh.setEffect(scene.getEngine().createEffect(shaderName, {\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: this.onCompiled,\n                    onError: this.onError,\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }\n                }, engine), defines);\n                this.buildUniformLayout();\n            }\n            if (!subMesh.effect.isReady()) {\n                return false;\n            }\n            defines._renderId = scene.getRenderId();\n            this._wasPreviouslyReady = true;\n            return true;\n        };\n        StandardMaterial.prototype.buildUniformLayout = function () {\n            // Order is important !\n            this._uniformBuffer.addUniform(\"diffuseLeftColor\", 4);\n            this._uniformBuffer.addUniform(\"diffuseRightColor\", 4);\n            this._uniformBuffer.addUniform(\"opacityParts\", 4);\n            this._uniformBuffer.addUniform(\"reflectionLeftColor\", 4);\n            this._uniformBuffer.addUniform(\"reflectionRightColor\", 4);\n            this._uniformBuffer.addUniform(\"refractionLeftColor\", 4);\n            this._uniformBuffer.addUniform(\"refractionRightColor\", 4);\n            this._uniformBuffer.addUniform(\"emissiveLeftColor\", 4);\n            this._uniformBuffer.addUniform(\"emissiveRightColor\", 4);\n            this._uniformBuffer.addUniform(\"vDiffuseInfos\", 2);\n            this._uniformBuffer.addUniform(\"vAmbientInfos\", 2);\n            this._uniformBuffer.addUniform(\"vOpacityInfos\", 2);\n            this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\n            this._uniformBuffer.addUniform(\"vEmissiveInfos\", 2);\n            this._uniformBuffer.addUniform(\"vLightmapInfos\", 2);\n            this._uniformBuffer.addUniform(\"vSpecularInfos\", 2);\n            this._uniformBuffer.addUniform(\"vBumpInfos\", 3);\n            this._uniformBuffer.addUniform(\"diffuseMatrix\", 16);\n            this._uniformBuffer.addUniform(\"ambientMatrix\", 16);\n            this._uniformBuffer.addUniform(\"opacityMatrix\", 16);\n            this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\n            this._uniformBuffer.addUniform(\"emissiveMatrix\", 16);\n            this._uniformBuffer.addUniform(\"lightmapMatrix\", 16);\n            this._uniformBuffer.addUniform(\"specularMatrix\", 16);\n            this._uniformBuffer.addUniform(\"bumpMatrix\", 16);\n            this._uniformBuffer.addUniform(\"refractionMatrix\", 16);\n            this._uniformBuffer.addUniform(\"vRefractionInfos\", 4);\n            this._uniformBuffer.addUniform(\"vSpecularColor\", 4);\n            this._uniformBuffer.addUniform(\"vEmissiveColor\", 3);\n            this._uniformBuffer.addUniform(\"vDiffuseColor\", 4);\n            this._uniformBuffer.addUniform(\"pointSize\", 1);\n            this._uniformBuffer.create();\n        };\n        StandardMaterial.prototype.unbind = function () {\n            if (this._activeEffect) {\n                if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n                    this._activeEffect.setTexture(\"reflection2DSampler\", null);\n                }\n                if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\n                    this._activeEffect.setTexture(\"refraction2DSampler\", null);\n                }\n            }\n            _super.prototype.unbind.call(this);\n        };\n        StandardMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n            var scene = this.getScene();\n            var defines = subMesh._materialDefines;\n            if (!defines) {\n                return;\n            }\n            var effect = subMesh.effect;\n            this._activeEffect = effect;\n            // Matrices        \n            this.bindOnlyWorldMatrix(world);\n            // Bones\n            BABYLON.MaterialHelper.BindBonesParameters(mesh, effect);\n            if (this._mustRebind(scene, effect, mesh.visibility)) {\n                this._uniformBuffer.bindToEffect(effect, \"Material\");\n                this.bindViewProjection(effect);\n                if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n                    if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {\n                        // Fresnel\n                        if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {\n                            this._uniformBuffer.updateColor4(\"diffuseLeftColor\", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);\n                            this._uniformBuffer.updateColor4(\"diffuseRightColor\", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);\n                        }\n                        if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {\n                            this._uniformBuffer.updateColor4(\"opacityParts\", new BABYLON.Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);\n                        }\n                        if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {\n                            this._uniformBuffer.updateColor4(\"reflectionLeftColor\", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);\n                            this._uniformBuffer.updateColor4(\"reflectionRightColor\", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);\n                        }\n                        if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {\n                            this._uniformBuffer.updateColor4(\"refractionLeftColor\", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);\n                            this._uniformBuffer.updateColor4(\"refractionRightColor\", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);\n                        }\n                        if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {\n                            this._uniformBuffer.updateColor4(\"emissiveLeftColor\", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);\n                            this._uniformBuffer.updateColor4(\"emissiveRightColor\", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);\n                        }\n                    }\n                    // Textures     \n                    if (scene.texturesEnabled) {\n                        if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vDiffuseInfos\", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._diffuseTexture, this._uniformBuffer, \"diffuse\");\n                        }\n                        if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._ambientTexture, this._uniformBuffer, \"ambient\");\n                        }\n                        if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._opacityTexture, this._uniformBuffer, \"opacity\");\n                        }\n                        if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vReflectionInfos\", this._reflectionTexture.level, this.roughness);\n                            this._uniformBuffer.updateMatrix(\"reflectionMatrix\", this._reflectionTexture.getReflectionTextureMatrix());\n                        }\n                        if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._emissiveTexture, this._uniformBuffer, \"emissive\");\n                        }\n                        if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._lightmapTexture, this._uniformBuffer, \"lightmap\");\n                        }\n                        if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vSpecularInfos\", this._specularTexture.coordinatesIndex, this._specularTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._specularTexture, this._uniformBuffer, \"specular\");\n                        }\n                        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n                            this._uniformBuffer.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, 1.0 / this._bumpTexture.level, this.parallaxScaleBias);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._bumpTexture, this._uniformBuffer, \"bump\");\n                        }\n                        if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                            var depth = 1.0;\n                            if (!this._refractionTexture.isCube) {\n                                this._uniformBuffer.updateMatrix(\"refractionMatrix\", this._refractionTexture.getReflectionTextureMatrix());\n                                if (this._refractionTexture.depth) {\n                                    depth = this._refractionTexture.depth;\n                                }\n                            }\n                            this._uniformBuffer.updateFloat4(\"vRefractionInfos\", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);\n                        }\n                    }\n                    // Point size\n                    if (this.pointsCloud) {\n                        this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\n                    }\n                    if (defines.SPECULARTERM) {\n                        this._uniformBuffer.updateColor4(\"vSpecularColor\", this.specularColor, this.specularPower);\n                    }\n                    this._uniformBuffer.updateColor3(\"vEmissiveColor\", this.emissiveColor);\n                    // Diffuse\n                    this._uniformBuffer.updateColor4(\"vDiffuseColor\", this.diffuseColor, this.alpha * mesh.visibility);\n                }\n                // Textures     \n                if (scene.texturesEnabled) {\n                    if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {\n                        effect.setTexture(\"diffuseSampler\", this._diffuseTexture);\n                    }\n                    if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {\n                        effect.setTexture(\"ambientSampler\", this._ambientTexture);\n                    }\n                    if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {\n                        effect.setTexture(\"opacitySampler\", this._opacityTexture);\n                    }\n                    if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {\n                        if (this._reflectionTexture.isCube) {\n                            effect.setTexture(\"reflectionCubeSampler\", this._reflectionTexture);\n                        }\n                        else {\n                            effect.setTexture(\"reflection2DSampler\", this._reflectionTexture);\n                        }\n                    }\n                    if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {\n                        effect.setTexture(\"emissiveSampler\", this._emissiveTexture);\n                    }\n                    if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {\n                        effect.setTexture(\"lightmapSampler\", this._lightmapTexture);\n                    }\n                    if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {\n                        effect.setTexture(\"specularSampler\", this._specularTexture);\n                    }\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {\n                        effect.setTexture(\"bumpSampler\", this._bumpTexture);\n                    }\n                    if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {\n                        var depth = 1.0;\n                        if (this._refractionTexture.isCube) {\n                            effect.setTexture(\"refractionCubeSampler\", this._refractionTexture);\n                        }\n                        else {\n                            effect.setTexture(\"refraction2DSampler\", this._refractionTexture);\n                        }\n                    }\n                }\n                // Clip plane\n                BABYLON.MaterialHelper.BindClipPlane(effect, scene);\n                // Colors\n                scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);\n                effect.setVector3(\"vEyePosition\", scene._mirroredCameraPosition ? scene._mirroredCameraPosition : scene.activeCamera.position);\n                effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n            }\n            if (this._mustRebind(scene, effect) || !this.isFrozen) {\n                // Lights\n                if (scene.lightsEnabled && !this._disableLighting) {\n                    BABYLON.MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);\n                }\n                // View\n                if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== BABYLON.Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture) {\n                    this.bindView(effect);\n                }\n                // Fog\n                BABYLON.MaterialHelper.BindFogParameters(scene, mesh, effect);\n                // Morph targets\n                if (defines.NUM_MORPH_INFLUENCERS) {\n                    BABYLON.MaterialHelper.BindMorphTargetParameters(mesh, effect);\n                }\n                // Log. depth\n                BABYLON.MaterialHelper.BindLogDepth(defines, effect, scene);\n                // image processing\n                this._imageProcessingConfiguration.bind(this._activeEffect);\n            }\n            this._uniformBuffer.update();\n            this._afterBind(mesh, this._activeEffect);\n        };\n        StandardMaterial.prototype.getAnimatables = function () {\n            var results = [];\n            if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {\n                results.push(this._diffuseTexture);\n            }\n            if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n                results.push(this._ambientTexture);\n            }\n            if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n                results.push(this._opacityTexture);\n            }\n            if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n                results.push(this._reflectionTexture);\n            }\n            if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n                results.push(this._emissiveTexture);\n            }\n            if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {\n                results.push(this._specularTexture);\n            }\n            if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n                results.push(this._bumpTexture);\n            }\n            if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n                results.push(this._lightmapTexture);\n            }\n            if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n                results.push(this._refractionTexture);\n            }\n            return results;\n        };\n        StandardMaterial.prototype.getActiveTextures = function () {\n            var activeTextures = _super.prototype.getActiveTextures.call(this);\n            if (this._diffuseTexture) {\n                activeTextures.push(this._diffuseTexture);\n            }\n            if (this._ambientTexture) {\n                activeTextures.push(this._ambientTexture);\n            }\n            if (this._opacityTexture) {\n                activeTextures.push(this._opacityTexture);\n            }\n            if (this._reflectionTexture) {\n                activeTextures.push(this._reflectionTexture);\n            }\n            if (this._emissiveTexture) {\n                activeTextures.push(this._emissiveTexture);\n            }\n            if (this._specularTexture) {\n                activeTextures.push(this._specularTexture);\n            }\n            if (this._bumpTexture) {\n                activeTextures.push(this._bumpTexture);\n            }\n            if (this._lightmapTexture) {\n                activeTextures.push(this._lightmapTexture);\n            }\n            if (this._refractionTexture) {\n                activeTextures.push(this._refractionTexture);\n            }\n            return activeTextures;\n        };\n        StandardMaterial.prototype.hasTexture = function (texture) {\n            if (_super.prototype.hasTexture.call(this, texture)) {\n                return true;\n            }\n            if (this._diffuseTexture === texture) {\n                return true;\n            }\n            if (this._ambientTexture === texture) {\n                return true;\n            }\n            if (this._opacityTexture === texture) {\n                return true;\n            }\n            if (this._reflectionTexture === texture) {\n                return true;\n            }\n            if (this._emissiveTexture === texture) {\n                return true;\n            }\n            if (this._specularTexture === texture) {\n                return true;\n            }\n            if (this._bumpTexture === texture) {\n                return true;\n            }\n            if (this._lightmapTexture === texture) {\n                return true;\n            }\n            if (this._refractionTexture === texture) {\n                return true;\n            }\n            return false;\n        };\n        StandardMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n            if (forceDisposeTextures) {\n                if (this._diffuseTexture) {\n                    this._diffuseTexture.dispose();\n                }\n                if (this._ambientTexture) {\n                    this._ambientTexture.dispose();\n                }\n                if (this._opacityTexture) {\n                    this._opacityTexture.dispose();\n                }\n                if (this._reflectionTexture) {\n                    this._reflectionTexture.dispose();\n                }\n                if (this._emissiveTexture) {\n                    this._emissiveTexture.dispose();\n                }\n                if (this._specularTexture) {\n                    this._specularTexture.dispose();\n                }\n                if (this._bumpTexture) {\n                    this._bumpTexture.dispose();\n                }\n                if (this._lightmapTexture) {\n                    this._lightmapTexture.dispose();\n                }\n                if (this._refractionTexture) {\n                    this._refractionTexture.dispose();\n                }\n            }\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n        };\n        StandardMaterial.prototype.clone = function (name) {\n            var _this = this;\n            var result = BABYLON.SerializationHelper.Clone(function () { return new StandardMaterial(name, _this.getScene()); }, this);\n            result.name = name;\n            result.id = name;\n            return result;\n        };\n        StandardMaterial.prototype.serialize = function () {\n            return BABYLON.SerializationHelper.Serialize(this);\n        };\n        // Statics\n        StandardMaterial.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new StandardMaterial(source.name, scene); }, source, scene, rootUrl);\n        };\n        Object.defineProperty(StandardMaterial, \"DiffuseTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._DiffuseTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._DiffuseTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._DiffuseTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"AmbientTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._AmbientTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._AmbientTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._AmbientTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"OpacityTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._OpacityTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._OpacityTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._OpacityTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"ReflectionTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._ReflectionTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._ReflectionTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._ReflectionTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"EmissiveTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._EmissiveTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._EmissiveTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._EmissiveTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"SpecularTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._SpecularTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._SpecularTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._SpecularTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"BumpTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._BumpTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._BumpTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._BumpTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"LightmapTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._LightmapTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._LightmapTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._LightmapTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"RefractionTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._RefractionTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._RefractionTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._RefractionTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"ColorGradingTextureEnabled\", {\n            get: function () {\n                return StandardMaterial._ColorGradingTextureEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._ColorGradingTextureEnabled === value) {\n                    return;\n                }\n                StandardMaterial._ColorGradingTextureEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.TextureDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardMaterial, \"FresnelEnabled\", {\n            get: function () {\n                return StandardMaterial._FresnelEnabled;\n            },\n            set: function (value) {\n                if (StandardMaterial._FresnelEnabled === value) {\n                    return;\n                }\n                StandardMaterial._FresnelEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.FresnelDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return StandardMaterial;\n    }(BABYLON.PushMaterial));\n    // Flags used to enable or disable a type of texture for all Standard Materials\n    StandardMaterial._DiffuseTextureEnabled = true;\n    StandardMaterial._AmbientTextureEnabled = true;\n    StandardMaterial._OpacityTextureEnabled = true;\n    StandardMaterial._ReflectionTextureEnabled = true;\n    StandardMaterial._EmissiveTextureEnabled = true;\n    StandardMaterial._SpecularTextureEnabled = true;\n    StandardMaterial._BumpTextureEnabled = true;\n    StandardMaterial._LightmapTextureEnabled = true;\n    StandardMaterial._RefractionTextureEnabled = true;\n    StandardMaterial._ColorGradingTextureEnabled = true;\n    StandardMaterial._FresnelEnabled = true;\n    __decorate([\n        BABYLON.serializeAsTexture(\"diffuseTexture\")\n    ], StandardMaterial.prototype, \"_diffuseTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"diffuseTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"ambientTexture\")\n    ], StandardMaterial.prototype, \"_ambientTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"ambientTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"opacityTexture\")\n    ], StandardMaterial.prototype, \"_opacityTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"opacityTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"reflectionTexture\")\n    ], StandardMaterial.prototype, \"_reflectionTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"reflectionTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"emissiveTexture\")\n    ], StandardMaterial.prototype, \"_emissiveTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"emissiveTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"specularTexture\")\n    ], StandardMaterial.prototype, \"_specularTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"specularTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"bumpTexture\")\n    ], StandardMaterial.prototype, \"_bumpTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"bumpTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"lightmapTexture\")\n    ], StandardMaterial.prototype, \"_lightmapTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"lightmapTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"refractionTexture\")\n    ], StandardMaterial.prototype, \"_refractionTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"refractionTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"ambient\")\n    ], StandardMaterial.prototype, \"ambientColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"diffuse\")\n    ], StandardMaterial.prototype, \"diffuseColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"specular\")\n    ], StandardMaterial.prototype, \"specularColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"emissive\")\n    ], StandardMaterial.prototype, \"emissiveColor\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardMaterial.prototype, \"specularPower\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useAlphaFromDiffuseTexture\")\n    ], StandardMaterial.prototype, \"_useAlphaFromDiffuseTexture\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useAlphaFromDiffuseTexture\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useEmissiveAsIllumination\")\n    ], StandardMaterial.prototype, \"_useEmissiveAsIllumination\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useEmissiveAsIllumination\", void 0);\n    __decorate([\n        BABYLON.serialize(\"linkEmissiveWithDiffuse\")\n    ], StandardMaterial.prototype, \"_linkEmissiveWithDiffuse\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"linkEmissiveWithDiffuse\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useSpecularOverAlpha\")\n    ], StandardMaterial.prototype, \"_useSpecularOverAlpha\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useSpecularOverAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useReflectionOverAlpha\")\n    ], StandardMaterial.prototype, \"_useReflectionOverAlpha\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useReflectionOverAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(\"disableLighting\")\n    ], StandardMaterial.prototype, \"_disableLighting\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    ], StandardMaterial.prototype, \"disableLighting\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useParallax\")\n    ], StandardMaterial.prototype, \"_useParallax\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useParallax\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useParallaxOcclusion\")\n    ], StandardMaterial.prototype, \"_useParallaxOcclusion\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useParallaxOcclusion\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardMaterial.prototype, \"parallaxScaleBias\", void 0);\n    __decorate([\n        BABYLON.serialize(\"roughness\")\n    ], StandardMaterial.prototype, \"_roughness\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"roughness\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardMaterial.prototype, \"indexOfRefraction\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardMaterial.prototype, \"invertRefractionY\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useLightmapAsShadowmap\")\n    ], StandardMaterial.prototype, \"_useLightmapAsShadowmap\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n    __decorate([\n        BABYLON.serializeAsFresnelParameters(\"diffuseFresnelParameters\")\n    ], StandardMaterial.prototype, \"_diffuseFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"diffuseFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.serializeAsFresnelParameters(\"opacityFresnelParameters\")\n    ], StandardMaterial.prototype, \"_opacityFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"opacityFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.serializeAsFresnelParameters(\"reflectionFresnelParameters\")\n    ], StandardMaterial.prototype, \"_reflectionFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"reflectionFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.serializeAsFresnelParameters(\"refractionFresnelParameters\")\n    ], StandardMaterial.prototype, \"_refractionFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"refractionFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.serializeAsFresnelParameters(\"emissiveFresnelParameters\")\n    ], StandardMaterial.prototype, \"_emissiveFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"emissiveFresnelParameters\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useReflectionFresnelFromSpecular\")\n    ], StandardMaterial.prototype, \"_useReflectionFresnelFromSpecular\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsFresnelDirty\")\n    ], StandardMaterial.prototype, \"useReflectionFresnelFromSpecular\", void 0);\n    __decorate([\n        BABYLON.serialize(\"useGlossinessFromSpecularMapAlpha\")\n    ], StandardMaterial.prototype, \"_useGlossinessFromSpecularMapAlpha\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"useGlossinessFromSpecularMapAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(\"maxSimultaneousLights\")\n    ], StandardMaterial.prototype, \"_maxSimultaneousLights\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    ], StandardMaterial.prototype, \"maxSimultaneousLights\", void 0);\n    __decorate([\n        BABYLON.serialize(\"invertNormalMapX\")\n    ], StandardMaterial.prototype, \"_invertNormalMapX\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"invertNormalMapX\", void 0);\n    __decorate([\n        BABYLON.serialize(\"invertNormalMapY\")\n    ], StandardMaterial.prototype, \"_invertNormalMapY\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"invertNormalMapY\", void 0);\n    __decorate([\n        BABYLON.serialize(\"twoSidedLighting\")\n    ], StandardMaterial.prototype, \"_twoSidedLighting\", void 0);\n    __decorate([\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], StandardMaterial.prototype, \"twoSidedLighting\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardMaterial.prototype, \"useLogarithmicDepth\", null);\n    BABYLON.StandardMaterial = StandardMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.standardMaterial.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PBRMaterialDefines = (function (_super) {\n        __extends(PBRMaterialDefines, _super);\n        function PBRMaterialDefines() {\n            var _this = _super.call(this) || this;\n            _this.PBR = true;\n            _this.MAINUV1 = false;\n            _this.MAINUV2 = false;\n            _this.UV1 = false;\n            _this.UV2 = false;\n            _this.ALBEDO = false;\n            _this.ALBEDODIRECTUV = 0;\n            _this.VERTEXCOLOR = false;\n            _this.AMBIENT = false;\n            _this.AMBIENTDIRECTUV = 0;\n            _this.AMBIENTINGRAYSCALE = false;\n            _this.OPACITY = false;\n            _this.VERTEXALPHA = false;\n            _this.OPACITYDIRECTUV = 0;\n            _this.OPACITYRGB = false;\n            _this.ALPHATEST = false;\n            _this.ALPHABLEND = false;\n            _this.ALPHAFROMALBEDO = false;\n            _this.ALPHATESTVALUE = 0.5;\n            _this.SPECULAROVERALPHA = false;\n            _this.RADIANCEOVERALPHA = false;\n            _this.ALPHAFRESNEL = false;\n            _this.PREMULTIPLYALPHA = false;\n            _this.EMISSIVE = false;\n            _this.EMISSIVEDIRECTUV = 0;\n            _this.REFLECTIVITY = false;\n            _this.REFLECTIVITYDIRECTUV = 0;\n            _this.SPECULARTERM = false;\n            _this.MICROSURFACEFROMREFLECTIVITYMAP = false;\n            _this.MICROSURFACEAUTOMATIC = false;\n            _this.LODBASEDMICROSFURACE = false;\n            _this.MICROSURFACEMAP = false;\n            _this.MICROSURFACEMAPDIRECTUV = 0;\n            _this.METALLICWORKFLOW = false;\n            _this.ROUGHNESSSTOREINMETALMAPALPHA = false;\n            _this.ROUGHNESSSTOREINMETALMAPGREEN = false;\n            _this.METALLNESSSTOREINMETALMAPBLUE = false;\n            _this.AOSTOREINMETALMAPRED = false;\n            _this.ENVIRONMENTBRDF = false;\n            _this.NORMAL = false;\n            _this.TANGENT = false;\n            _this.BUMP = false;\n            _this.BUMPDIRECTUV = 0;\n            _this.PARALLAX = false;\n            _this.PARALLAXOCCLUSION = false;\n            _this.INVERTNORMALMAPX = false;\n            _this.INVERTNORMALMAPY = false;\n            _this.NORMALXYSCALE = true;\n            _this.LIGHTMAP = false;\n            _this.LIGHTMAPDIRECTUV = 0;\n            _this.USELIGHTMAPASSHADOWMAP = false;\n            _this.REFLECTION = false;\n            _this.REFLECTIONMAP_3D = false;\n            _this.REFLECTIONMAP_SPHERICAL = false;\n            _this.REFLECTIONMAP_PLANAR = false;\n            _this.REFLECTIONMAP_CUBIC = false;\n            _this.REFLECTIONMAP_PROJECTION = false;\n            _this.REFLECTIONMAP_SKYBOX = false;\n            _this.REFLECTIONMAP_EXPLICIT = false;\n            _this.REFLECTIONMAP_EQUIRECTANGULAR = false;\n            _this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n            _this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n            _this.INVERTCUBICMAP = false;\n            _this.USESPHERICALFROMREFLECTIONMAP = false;\n            _this.USESPHERICALINFRAGMENT = false;\n            _this.REFLECTIONMAP_OPPOSITEZ = false;\n            _this.LODINREFLECTIONALPHA = false;\n            _this.GAMMAREFLECTION = false;\n            _this.REFRACTION = false;\n            _this.REFRACTIONMAP_3D = false;\n            _this.REFRACTIONMAP_OPPOSITEZ = false;\n            _this.LODINREFRACTIONALPHA = false;\n            _this.GAMMAREFRACTION = false;\n            _this.LINKREFRACTIONTOTRANSPARENCY = false;\n            _this.INSTANCES = false;\n            _this.NUM_BONE_INFLUENCERS = 0;\n            _this.BonesPerMesh = 0;\n            _this.MORPHTARGETS = false;\n            _this.MORPHTARGETS_NORMAL = false;\n            _this.MORPHTARGETS_TANGENT = false;\n            _this.NUM_MORPH_INFLUENCERS = 0;\n            _this.IMAGEPROCESSING = false;\n            _this.VIGNETTE = false;\n            _this.VIGNETTEBLENDMODEMULTIPLY = false;\n            _this.VIGNETTEBLENDMODEOPAQUE = false;\n            _this.TONEMAPPING = false;\n            _this.CONTRAST = false;\n            _this.COLORCURVES = false;\n            _this.COLORGRADING = false;\n            _this.SAMPLER3DGREENDEPTH = false;\n            _this.SAMPLER3DBGRMAP = false;\n            _this.IMAGEPROCESSINGPOSTPROCESS = false;\n            _this.EXPOSURE = false;\n            _this.USEPHYSICALLIGHTFALLOFF = false;\n            _this.TWOSIDEDLIGHTING = false;\n            _this.SHADOWFLOAT = false;\n            _this.USERIGHTHANDEDSYSTEM = false;\n            _this.CLIPPLANE = false;\n            _this.POINTSIZE = false;\n            _this.FOG = false;\n            _this.LOGARITHMICDEPTH = false;\n            _this.rebuild();\n            return _this;\n        }\n        PBRMaterialDefines.prototype.reset = function () {\n            _super.prototype.reset.call(this);\n            this.ALPHATESTVALUE = 0.5;\n            this.PBR = true;\n        };\n        return PBRMaterialDefines;\n    }(BABYLON.MaterialDefines));\n    /**\n     * The Physically based material base class of BJS.\n     *\n     * This offers the main features of a standard PBR material.\n     * For more information, please refer to the documentation :\n     * http://doc.babylonjs.com/extensions/Physically_Based_Rendering\n     */\n    var PBRBaseMaterial = (function (_super) {\n        __extends(PBRBaseMaterial, _super);\n        /**\n         * Instantiates a new PBRMaterial instance.\n         *\n         * @param name The material name\n         * @param scene The scene the material will be use in.\n         */\n        function PBRBaseMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            /**\n             * Intensity of the direct lights e.g. the four lights available in your scene.\n             * This impacts both the direct diffuse and specular highlights.\n             */\n            _this._directIntensity = 1.0;\n            /**\n             * Intensity of the emissive part of the material.\n             * This helps controlling the emissive effect without modifying the emissive color.\n             */\n            _this._emissiveIntensity = 1.0;\n            /**\n             * Intensity of the environment e.g. how much the environment will light the object\n             * either through harmonics for rough material or through the refelction for shiny ones.\n             */\n            _this._environmentIntensity = 1.0;\n            /**\n             * This is a special control allowing the reduction of the specular highlights coming from the\n             * four lights of the scene. Those highlights may not be needed in full environment lighting.\n             */\n            _this._specularIntensity = 1.0;\n            _this._lightingInfos = new BABYLON.Vector4(_this._directIntensity, _this._emissiveIntensity, _this._environmentIntensity, _this._specularIntensity);\n            /**\n             * Debug Control allowing disabling the bump map on this material.\n             */\n            _this._disableBumpMap = false;\n            /**\n             * AKA Occlusion Texture Intensity in other nomenclature.\n             */\n            _this._ambientTextureStrength = 1.0;\n            _this._ambientColor = new BABYLON.Color3(0, 0, 0);\n            /**\n             * AKA Diffuse Color in other nomenclature.\n             */\n            _this._albedoColor = new BABYLON.Color3(1, 1, 1);\n            /**\n             * AKA Specular Color in other nomenclature.\n             */\n            _this._reflectivityColor = new BABYLON.Color3(1, 1, 1);\n            _this._reflectionColor = new BABYLON.Color3(1, 1, 1);\n            _this._emissiveColor = new BABYLON.Color3(0, 0, 0);\n            /**\n             * AKA Glossiness in other nomenclature.\n             */\n            _this._microSurface = 0.9;\n            /**\n             * source material index of refraction (IOR)' / 'destination material IOR.\n             */\n            _this._indexOfRefraction = 0.66;\n            /**\n             * Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.\n             */\n            _this._invertRefractionY = false;\n            /**\n             * This parameters will make the material used its opacity to control how much it is refracting aginst not.\n             * Materials half opaque for instance using refraction could benefit from this control.\n             */\n            _this._linkRefractionWithTransparency = false;\n            _this._useLightmapAsShadowmap = false;\n            /**\n             * Specifies that the alpha is coming form the albedo channel alpha channel.\n             */\n            _this._useAlphaFromAlbedoTexture = false;\n            /**\n             * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).\n             * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\n             */\n            _this._useSpecularOverAlpha = true;\n            /**\n             * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n             */\n            _this._useMicroSurfaceFromReflectivityMapAlpha = false;\n            /**\n             * Specifies if the metallic texture contains the roughness information in its alpha channel.\n             */\n            _this._useRoughnessFromMetallicTextureAlpha = true;\n            /**\n             * Specifies if the metallic texture contains the roughness information in its green channel.\n             */\n            _this._useRoughnessFromMetallicTextureGreen = false;\n            /**\n             * Specifies if the metallic texture contains the metallness information in its blue channel.\n             */\n            _this._useMetallnessFromMetallicTextureBlue = false;\n            /**\n             * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\n             */\n            _this._useAmbientOcclusionFromMetallicTextureRed = false;\n            /**\n             * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\n             */\n            _this._useAmbientInGrayScale = false;\n            /**\n             * In case the reflectivity map does not contain the microsurface information in its alpha channel,\n             * The material will try to infer what glossiness each pixel should be.\n             */\n            _this._useAutoMicroSurfaceFromReflectivityMap = false;\n            /**\n             * BJS is using an harcoded light falloff based on a manually sets up range.\n             * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.\n             * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\n             */\n            _this._usePhysicalLightFalloff = true;\n            /**\n             * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\n             * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\n             */\n            _this._useRadianceOverAlpha = true;\n            /**\n             * Allows using the bump map in parallax mode.\n             */\n            _this._useParallax = false;\n            /**\n             * Allows using the bump map in parallax occlusion mode.\n             */\n            _this._useParallaxOcclusion = false;\n            /**\n             * Controls the scale bias of the parallax mode.\n             */\n            _this._parallaxScaleBias = 0.05;\n            /**\n             * If sets to true, disables all the lights affecting the material.\n             */\n            _this._disableLighting = false;\n            /**\n             * Number of Simultaneous lights allowed on the material.\n             */\n            _this._maxSimultaneousLights = 4;\n            /**\n             * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n             */\n            _this._invertNormalMapX = false;\n            /**\n             * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n             */\n            _this._invertNormalMapY = false;\n            /**\n             * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n             */\n            _this._twoSidedLighting = false;\n            /**\n             * Defines the alpha limits in alpha test mode.\n             */\n            _this._alphaCutOff = 0.4;\n            /**\n             * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\n             */\n            _this._forceAlphaTest = false;\n            /**\n             * Specifies that the alpha is premultiplied before output (this enables alpha premultiplied blending).\n             * in your scene composition.\n             */\n            _this._premultiplyAlpha = false;\n            /**\n             * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n             * And/Or occlude the blended part.\n             */\n            _this._useAlphaFresnel = false;\n            /**\n             * Specifies the environment BRDF texture used to comput the scale and offset roughness values\n             * from cos thetav and roughness:\n             * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n             */\n            _this._environmentBRDFTexture = null;\n            _this._renderTargets = new BABYLON.SmartArray(16);\n            _this._worldViewProjectionMatrix = BABYLON.Matrix.Zero();\n            _this._globalAmbientColor = new BABYLON.Color3(0, 0, 0);\n            _this._tempColor = new BABYLON.Color3();\n            // Setup the default processing configuration to the scene.\n            _this._attachImageProcessingConfiguration(null);\n            _this.getRenderTargetTextures = function () {\n                _this._renderTargets.reset();\n                if (BABYLON.StandardMaterial.ReflectionTextureEnabled && _this._reflectionTexture && _this._reflectionTexture.isRenderTarget) {\n                    _this._renderTargets.push(_this._reflectionTexture);\n                }\n                if (BABYLON.StandardMaterial.RefractionTextureEnabled && _this._refractionTexture && _this._refractionTexture.isRenderTarget) {\n                    _this._renderTargets.push(_this._refractionTexture);\n                }\n                return _this._renderTargets;\n            };\n            _this._environmentBRDFTexture = BABYLON.TextureTools.GetEnvironmentBRDFTexture(scene);\n            return _this;\n        }\n        /**\n         * Attaches a new image processing configuration to the PBR Material.\n         * @param configuration\n         */\n        PBRBaseMaterial.prototype._attachImageProcessingConfiguration = function (configuration) {\n            var _this = this;\n            if (configuration === this._imageProcessingConfiguration) {\n                return;\n            }\n            // Detaches observer.\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            // Pick the scene configuration if needed.\n            if (!configuration) {\n                this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;\n            }\n            else {\n                this._imageProcessingConfiguration = configuration;\n            }\n            // Attaches observer.\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (conf) {\n                _this._markAllSubMeshesAsImageProcessingDirty();\n            });\n        };\n        Object.defineProperty(PBRBaseMaterial.prototype, \"useLogarithmicDepth\", {\n            get: function () {\n                return this._useLogarithmicDepth;\n            },\n            set: function (value) {\n                this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PBRBaseMaterial.prototype.needAlphaBlending = function () {\n            if (this._linkRefractionWithTransparency) {\n                return false;\n            }\n            return (this.alpha < 1.0) || (this._opacityTexture != null) || this._shouldUseAlphaFromAlbedoTexture();\n        };\n        PBRBaseMaterial.prototype.needAlphaTesting = function () {\n            if (this._forceAlphaTest) {\n                return true;\n            }\n            if (this._linkRefractionWithTransparency) {\n                return false;\n            }\n            return this._albedoTexture != null && this._albedoTexture.hasAlpha;\n        };\n        PBRBaseMaterial.prototype._shouldUseAlphaFromAlbedoTexture = function () {\n            return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture;\n        };\n        PBRBaseMaterial.prototype.getAlphaTestTexture = function () {\n            return this._albedoTexture;\n        };\n        PBRBaseMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\n            if (this.isFrozen) {\n                if (this._wasPreviouslyReady) {\n                    return true;\n                }\n            }\n            if (!subMesh._materialDefines) {\n                subMesh._materialDefines = new PBRMaterialDefines();\n            }\n            var scene = this.getScene();\n            var defines = subMesh._materialDefines;\n            if (!this.checkReadyOnEveryCall && subMesh.effect) {\n                if (defines._renderId === scene.getRenderId()) {\n                    return true;\n                }\n            }\n            var engine = scene.getEngine();\n            // Lights\n            BABYLON.MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\n            defines._needNormals = true;\n            // Textures\n            if (defines._areTexturesDirty) {\n                defines._needUVs = false;\n                if (scene.texturesEnabled) {\n                    if (scene.getEngine().getCaps().textureLOD) {\n                        defines.LODBASEDMICROSFURACE = true;\n                    }\n                    if (this._albedoTexture && BABYLON.StandardMaterial.DiffuseTextureEnabled) {\n                        if (!this._albedoTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, \"ALBEDO\");\n                    }\n                    else {\n                        defines.ALBEDO = false;\n                    }\n                    if (this._ambientTexture && BABYLON.StandardMaterial.AmbientTextureEnabled) {\n                        if (!this._ambientTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, \"AMBIENT\");\n                        defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;\n                    }\n                    else {\n                        defines.AMBIENT = false;\n                    }\n                    if (this._opacityTexture && BABYLON.StandardMaterial.OpacityTextureEnabled) {\n                        if (!this._opacityTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, \"OPACITY\");\n                        defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;\n                    }\n                    else {\n                        defines.OPACITY = false;\n                    }\n                    var reflectionTexture = this._getReflectionTexture();\n                    if (reflectionTexture && BABYLON.StandardMaterial.ReflectionTextureEnabled) {\n                        if (!reflectionTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        defines.REFLECTION = true;\n                        defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\n                        defines.REFLECTIONMAP_OPPOSITEZ = reflectionTexture.invertZ;\n                        defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\n                        if (reflectionTexture.coordinatesMode === BABYLON.Texture.INVCUBIC_MODE) {\n                            defines.INVERTCUBICMAP = true;\n                        }\n                        defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\n                        switch (reflectionTexture.coordinatesMode) {\n                            case BABYLON.Texture.CUBIC_MODE:\n                            case BABYLON.Texture.INVCUBIC_MODE:\n                                defines.REFLECTIONMAP_CUBIC = true;\n                                break;\n                            case BABYLON.Texture.EXPLICIT_MODE:\n                                defines.REFLECTIONMAP_EXPLICIT = true;\n                                break;\n                            case BABYLON.Texture.PLANAR_MODE:\n                                defines.REFLECTIONMAP_PLANAR = true;\n                                break;\n                            case BABYLON.Texture.PROJECTION_MODE:\n                                defines.REFLECTIONMAP_PROJECTION = true;\n                                break;\n                            case BABYLON.Texture.SKYBOX_MODE:\n                                defines.REFLECTIONMAP_SKYBOX = true;\n                                break;\n                            case BABYLON.Texture.SPHERICAL_MODE:\n                                defines.REFLECTIONMAP_SPHERICAL = true;\n                                break;\n                            case BABYLON.Texture.EQUIRECTANGULAR_MODE:\n                                defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\n                                break;\n                            case BABYLON.Texture.FIXED_EQUIRECTANGULAR_MODE:\n                                defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\n                                break;\n                            case BABYLON.Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\n                                defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\n                                break;\n                        }\n                        if (reflectionTexture.coordinatesMode !== BABYLON.Texture.SKYBOX_MODE) {\n                            if (reflectionTexture.sphericalPolynomial) {\n                                defines.USESPHERICALFROMREFLECTIONMAP = true;\n                                if (scene.getEngine().getCaps().maxVaryingVectors <= 8) {\n                                    defines.USESPHERICALINFRAGMENT = true;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        defines.REFLECTION = false;\n                        defines.REFLECTIONMAP_3D = false;\n                        defines.REFLECTIONMAP_SPHERICAL = false;\n                        defines.REFLECTIONMAP_PLANAR = false;\n                        defines.REFLECTIONMAP_CUBIC = false;\n                        defines.REFLECTIONMAP_PROJECTION = false;\n                        defines.REFLECTIONMAP_SKYBOX = false;\n                        defines.REFLECTIONMAP_EXPLICIT = false;\n                        defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\n                        defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\n                        defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\n                        defines.INVERTCUBICMAP = false;\n                        defines.USESPHERICALFROMREFLECTIONMAP = false;\n                        defines.USESPHERICALINFRAGMENT = false;\n                        defines.REFLECTIONMAP_OPPOSITEZ = false;\n                        defines.LODINREFLECTIONALPHA = false;\n                        defines.GAMMAREFLECTION = false;\n                    }\n                    if (this._lightmapTexture && BABYLON.StandardMaterial.LightmapTextureEnabled) {\n                        if (!this._lightmapTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, \"LIGHTMAP\");\n                        defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;\n                    }\n                    else {\n                        defines.LIGHTMAP = false;\n                    }\n                    if (this._emissiveTexture && BABYLON.StandardMaterial.EmissiveTextureEnabled) {\n                        if (!this._emissiveTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, \"EMISSIVE\");\n                    }\n                    else {\n                        defines.EMISSIVE = false;\n                    }\n                    if (BABYLON.StandardMaterial.SpecularTextureEnabled) {\n                        if (this._metallicTexture) {\n                            if (!this._metallicTexture.isReadyOrNotBlocking()) {\n                                return false;\n                            }\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, \"REFLECTIVITY\");\n                            defines.METALLICWORKFLOW = true;\n                            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;\n                            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;\n                            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;\n                            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\n                        }\n                        else if (this._reflectivityTexture) {\n                            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {\n                                return false;\n                            }\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, \"REFLECTIVITY\");\n                            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;\n                            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;\n                        }\n                        else {\n                            defines.REFLECTIVITY = false;\n                        }\n                        if (this._microSurfaceTexture) {\n                            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {\n                                return false;\n                            }\n                            BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, \"MICROSURFACEMAP\");\n                        }\n                        else {\n                            defines.MICROSURFACEMAP = false;\n                        }\n                    }\n                    else {\n                        defines.REFLECTIVITY = false;\n                        defines.MICROSURFACEMAP = false;\n                    }\n                    if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && BABYLON.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap) {\n                        // Bump texure can not be none blocking.\n                        if (!this._bumpTexture.isReady()) {\n                            return false;\n                        }\n                        BABYLON.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, \"BUMP\");\n                        if (this._useParallax && this._albedoTexture && BABYLON.StandardMaterial.DiffuseTextureEnabled) {\n                            defines.PARALLAX = true;\n                            if (this._useParallaxOcclusion) {\n                                defines.PARALLAXOCCLUSION = true;\n                            }\n                        }\n                        if (this._invertNormalMapX) {\n                            defines.INVERTNORMALMAPX = true;\n                        }\n                        if (this._invertNormalMapY) {\n                            defines.INVERTNORMALMAPY = true;\n                        }\n                        if (scene._mirroredCameraPosition) {\n                            defines.INVERTNORMALMAPX = !defines.INVERTNORMALMAPX;\n                            defines.INVERTNORMALMAPY = !defines.INVERTNORMALMAPY;\n                        }\n                        defines.USERIGHTHANDEDSYSTEM = scene.useRightHandedSystem;\n                    }\n                    else {\n                        defines.BUMP = false;\n                    }\n                    var refractionTexture = this._getRefractionTexture();\n                    if (refractionTexture && BABYLON.StandardMaterial.RefractionTextureEnabled) {\n                        if (!refractionTexture.isReadyOrNotBlocking()) {\n                            return false;\n                        }\n                        defines.REFRACTION = true;\n                        defines.REFRACTIONMAP_3D = refractionTexture.isCube;\n                        defines.GAMMAREFRACTION = refractionTexture.gammaSpace;\n                        defines.REFRACTIONMAP_OPPOSITEZ = reflectionTexture.invertZ;\n                        defines.LODINREFRACTIONALPHA = reflectionTexture.lodLevelInAlpha;\n                        if (this._linkRefractionWithTransparency) {\n                            defines.LINKREFRACTIONTOTRANSPARENCY = true;\n                        }\n                    }\n                    else {\n                        defines.REFRACTION = false;\n                    }\n                    if (this._environmentBRDFTexture && BABYLON.StandardMaterial.ReflectionTextureEnabled) {\n                        // This is blocking.\n                        if (!this._environmentBRDFTexture.isReady()) {\n                            return false;\n                        }\n                        defines.ENVIRONMENTBRDF = true;\n                    }\n                    if (this._shouldUseAlphaFromAlbedoTexture()) {\n                        defines.ALPHAFROMALBEDO = true;\n                    }\n                }\n                if (this._useSpecularOverAlpha) {\n                    defines.SPECULAROVERALPHA = true;\n                }\n                if (this._usePhysicalLightFalloff) {\n                    defines.USEPHYSICALLIGHTFALLOFF = true;\n                }\n                if (this._useRadianceOverAlpha) {\n                    defines.RADIANCEOVERALPHA = true;\n                }\n                if ((this._metallic !== undefined && this._metallic !== null) || (this._roughness !== undefined && this._roughness !== null)) {\n                    defines.METALLICWORKFLOW = true;\n                }\n                if (!this.backFaceCulling && this._twoSidedLighting) {\n                    defines.TWOSIDEDLIGHTING = true;\n                }\n                defines.ALPHATESTVALUE = this._alphaCutOff;\n                defines.PREMULTIPLYALPHA = this._premultiplyAlpha;\n                defines.ALPHABLEND = this.needAlphaBlending();\n                defines.ALPHAFRESNEL = this._useAlphaFresnel;\n            }\n            if (defines._areImageProcessingDirty) {\n                if (!this._imageProcessingConfiguration.isReady()) {\n                    return false;\n                }\n                this._imageProcessingConfiguration.prepareDefines(defines);\n            }\n            // Misc.\n            BABYLON.MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, defines);\n            // Values that need to be evaluated on every frame\n            BABYLON.MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, defines, useInstances, this._forceAlphaTest);\n            // Attribs\n            if (BABYLON.MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true)) {\n                if (mesh) {\n                    if (!scene.getEngine().getCaps().standardDerivatives && !mesh.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                        mesh.createNormals(true);\n                        BABYLON.Tools.Warn(\"PBRMaterial: Normals have been created for the mesh: \" + mesh.name);\n                    }\n                }\n            }\n            // Get correct effect\n            if (defines.isDirty) {\n                defines.markAsProcessed();\n                scene.resetCachedMaterial();\n                // Fallbacks\n                var fallbacks = new BABYLON.EffectFallbacks();\n                if (defines.ENVIRONMENTBRDF) {\n                    fallbacks.addFallback(0, \"ENVIRONMENTBRDF\");\n                }\n                if (defines.REFLECTION) {\n                    fallbacks.addFallback(0, \"REFLECTION\");\n                }\n                if (defines.REFRACTION) {\n                    fallbacks.addFallback(0, \"REFRACTION\");\n                }\n                if (defines.REFLECTIVITY) {\n                    fallbacks.addFallback(0, \"REFLECTIVITY\");\n                }\n                if (defines.BUMP) {\n                    fallbacks.addFallback(0, \"BUMP\");\n                }\n                if (defines.PARALLAX) {\n                    fallbacks.addFallback(1, \"PARALLAX\");\n                }\n                if (defines.PARALLAXOCCLUSION) {\n                    fallbacks.addFallback(0, \"PARALLAXOCCLUSION\");\n                }\n                if (defines.SPECULAROVERALPHA) {\n                    fallbacks.addFallback(0, \"SPECULAROVERALPHA\");\n                }\n                if (defines.FOG) {\n                    fallbacks.addFallback(1, \"FOG\");\n                }\n                if (defines.POINTSIZE) {\n                    fallbacks.addFallback(0, \"POINTSIZE\");\n                }\n                if (defines.LOGARITHMICDEPTH) {\n                    fallbacks.addFallback(0, \"LOGARITHMICDEPTH\");\n                }\n                BABYLON.MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);\n                if (defines.SPECULARTERM) {\n                    fallbacks.addFallback(0, \"SPECULARTERM\");\n                }\n                if (defines.NUM_BONE_INFLUENCERS > 0) {\n                    fallbacks.addCPUSkinningFallback(0, mesh);\n                }\n                //Attributes\n                var attribs = [BABYLON.VertexBuffer.PositionKind];\n                if (defines.NORMAL) {\n                    attribs.push(BABYLON.VertexBuffer.NormalKind);\n                }\n                if (defines.TANGENT) {\n                    attribs.push(BABYLON.VertexBuffer.TangentKind);\n                }\n                if (defines.UV1) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                }\n                if (defines.UV2) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                }\n                if (defines.VERTEXCOLOR) {\n                    attribs.push(BABYLON.VertexBuffer.ColorKind);\n                }\n                BABYLON.MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\n                BABYLON.MaterialHelper.PrepareAttributesForInstances(attribs, defines);\n                BABYLON.MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);\n                var uniforms = [\"world\", \"view\", \"viewProjection\", \"vEyePosition\", \"vLightsType\", \"vAmbientColor\", \"vAlbedoColor\", \"vReflectivityColor\", \"vEmissiveColor\", \"vReflectionColor\",\n                    \"vFogInfos\", \"vFogColor\", \"pointSize\",\n                    \"vAlbedoInfos\", \"vAmbientInfos\", \"vOpacityInfos\", \"vReflectionInfos\", \"vEmissiveInfos\", \"vReflectivityInfos\", \"vMicroSurfaceSamplerInfos\", \"vBumpInfos\", \"vLightmapInfos\", \"vRefractionInfos\",\n                    \"mBones\",\n                    \"vClipPlane\", \"albedoMatrix\", \"ambientMatrix\", \"opacityMatrix\", \"reflectionMatrix\", \"emissiveMatrix\", \"reflectivityMatrix\", \"microSurfaceSamplerMatrix\", \"bumpMatrix\", \"lightmapMatrix\", \"refractionMatrix\",\n                    \"vLightingIntensity\",\n                    \"logarithmicDepthConstant\",\n                    \"vSphericalX\", \"vSphericalY\", \"vSphericalZ\",\n                    \"vSphericalXX\", \"vSphericalYY\", \"vSphericalZZ\",\n                    \"vSphericalXY\", \"vSphericalYZ\", \"vSphericalZX\",\n                    \"vReflectionMicrosurfaceInfos\", \"vRefractionMicrosurfaceInfos\"\n                ];\n                var samplers = [\"albedoSampler\", \"reflectivitySampler\", \"ambientSampler\", \"emissiveSampler\",\n                    \"bumpSampler\", \"lightmapSampler\", \"opacitySampler\",\n                    \"refractionSampler\", \"refractionSamplerLow\", \"refractionSamplerHigh\",\n                    \"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\",\n                    \"microSurfaceSampler\", \"environmentBrdfSampler\"];\n                var uniformBuffers = [\"Material\", \"Scene\"];\n                BABYLON.ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\n                BABYLON.ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\n                BABYLON.MaterialHelper.PrepareUniformsAndSamplersList({\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: defines,\n                    maxSimultaneousLights: this._maxSimultaneousLights\n                });\n                var onCompiled = function (effect) {\n                    if (this.onCompiled) {\n                        this.onCompiled(effect);\n                    }\n                    this.bindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\n                }.bind(this);\n                var join = defines.toString();\n                subMesh.setEffect(scene.getEngine().createEffect(\"pbr\", {\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: uniformBuffers,\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: fallbacks,\n                    onCompiled: onCompiled,\n                    onError: this.onError,\n                    indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS }\n                }, engine), defines);\n                this.buildUniformLayout();\n            }\n            if (!subMesh.effect.isReady()) {\n                return false;\n            }\n            defines._renderId = scene.getRenderId();\n            this._wasPreviouslyReady = true;\n            return true;\n        };\n        PBRBaseMaterial.prototype.buildUniformLayout = function () {\n            // Order is important !\n            this._uniformBuffer.addUniform(\"vAlbedoInfos\", 2);\n            this._uniformBuffer.addUniform(\"vAmbientInfos\", 3);\n            this._uniformBuffer.addUniform(\"vOpacityInfos\", 2);\n            this._uniformBuffer.addUniform(\"vEmissiveInfos\", 2);\n            this._uniformBuffer.addUniform(\"vLightmapInfos\", 2);\n            this._uniformBuffer.addUniform(\"vReflectivityInfos\", 3);\n            this._uniformBuffer.addUniform(\"vMicroSurfaceSamplerInfos\", 2);\n            this._uniformBuffer.addUniform(\"vRefractionInfos\", 4);\n            this._uniformBuffer.addUniform(\"vReflectionInfos\", 2);\n            this._uniformBuffer.addUniform(\"vBumpInfos\", 3);\n            this._uniformBuffer.addUniform(\"albedoMatrix\", 16);\n            this._uniformBuffer.addUniform(\"ambientMatrix\", 16);\n            this._uniformBuffer.addUniform(\"opacityMatrix\", 16);\n            this._uniformBuffer.addUniform(\"emissiveMatrix\", 16);\n            this._uniformBuffer.addUniform(\"lightmapMatrix\", 16);\n            this._uniformBuffer.addUniform(\"reflectivityMatrix\", 16);\n            this._uniformBuffer.addUniform(\"microSurfaceSamplerMatrix\", 16);\n            this._uniformBuffer.addUniform(\"bumpMatrix\", 16);\n            this._uniformBuffer.addUniform(\"refractionMatrix\", 16);\n            this._uniformBuffer.addUniform(\"reflectionMatrix\", 16);\n            this._uniformBuffer.addUniform(\"vReflectionColor\", 3);\n            this._uniformBuffer.addUniform(\"vAlbedoColor\", 4);\n            this._uniformBuffer.addUniform(\"vLightingIntensity\", 4);\n            this._uniformBuffer.addUniform(\"vRefractionMicrosurfaceInfos\", 3);\n            this._uniformBuffer.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\n            this._uniformBuffer.addUniform(\"vReflectivityColor\", 4);\n            this._uniformBuffer.addUniform(\"vEmissiveColor\", 3);\n            this._uniformBuffer.addUniform(\"pointSize\", 1);\n            this._uniformBuffer.create();\n        };\n        PBRBaseMaterial.prototype.unbind = function () {\n            if (this._reflectionTexture && this._reflectionTexture.isRenderTarget) {\n                this._uniformBuffer.setTexture(\"reflectionSampler\", null);\n            }\n            if (this._refractionTexture && this._refractionTexture.isRenderTarget) {\n                this._uniformBuffer.setTexture(\"refractionSampler\", null);\n            }\n            _super.prototype.unbind.call(this);\n        };\n        PBRBaseMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n            this._activeEffect.setMatrix(\"world\", world);\n        };\n        PBRBaseMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\n            var scene = this.getScene();\n            var defines = subMesh._materialDefines;\n            if (!defines) {\n                return;\n            }\n            var effect = subMesh.effect;\n            this._activeEffect = effect;\n            // Matrices\n            this.bindOnlyWorldMatrix(world);\n            // Bones\n            BABYLON.MaterialHelper.BindBonesParameters(mesh, this._activeEffect);\n            if (this._mustRebind(scene, effect, mesh.visibility)) {\n                this._uniformBuffer.bindToEffect(effect, \"Material\");\n                this.bindViewProjection(effect);\n                if (!this._uniformBuffer.useUbo || !this.isFrozen || !this._uniformBuffer.isSync) {\n                    // Texture uniforms\n                    if (scene.texturesEnabled) {\n                        if (this._albedoTexture && BABYLON.StandardMaterial.DiffuseTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vAlbedoInfos\", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._albedoTexture, this._uniformBuffer, \"albedo\");\n                        }\n                        if (this._ambientTexture && BABYLON.StandardMaterial.AmbientTextureEnabled) {\n                            this._uniformBuffer.updateFloat3(\"vAmbientInfos\", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._ambientTexture, this._uniformBuffer, \"ambient\");\n                        }\n                        if (this._opacityTexture && BABYLON.StandardMaterial.OpacityTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._opacityTexture, this._uniformBuffer, \"opacity\");\n                        }\n                        var reflectionTexture = this._getReflectionTexture();\n                        if (reflectionTexture && BABYLON.StandardMaterial.ReflectionTextureEnabled) {\n                            this._uniformBuffer.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\n                            this._uniformBuffer.updateFloat2(\"vReflectionInfos\", reflectionTexture.level, 0);\n                            if (defines.USESPHERICALFROMREFLECTIONMAP) {\n                                var polynomials = reflectionTexture.sphericalPolynomial;\n                                this._activeEffect.setFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\n                                this._activeEffect.setFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\n                                this._activeEffect.setFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\n                                this._activeEffect.setFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\n                                this._activeEffect.setFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\n                                this._activeEffect.setFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\n                                this._activeEffect.setFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\n                                this._activeEffect.setFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\n                                this._activeEffect.setFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\n                            }\n                            this._uniformBuffer.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\n                        }\n                        if (this._emissiveTexture && BABYLON.StandardMaterial.EmissiveTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vEmissiveInfos\", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._emissiveTexture, this._uniformBuffer, \"emissive\");\n                        }\n                        if (this._lightmapTexture && BABYLON.StandardMaterial.LightmapTextureEnabled) {\n                            this._uniformBuffer.updateFloat2(\"vLightmapInfos\", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._lightmapTexture, this._uniformBuffer, \"lightmap\");\n                        }\n                        if (BABYLON.StandardMaterial.SpecularTextureEnabled) {\n                            if (this._metallicTexture) {\n                                this._uniformBuffer.updateFloat3(\"vReflectivityInfos\", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);\n                                BABYLON.MaterialHelper.BindTextureMatrix(this._metallicTexture, this._uniformBuffer, \"reflectivity\");\n                            }\n                            else if (this._reflectivityTexture) {\n                                this._uniformBuffer.updateFloat3(\"vReflectivityInfos\", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1.0);\n                                BABYLON.MaterialHelper.BindTextureMatrix(this._reflectivityTexture, this._uniformBuffer, \"reflectivity\");\n                            }\n                            if (this._microSurfaceTexture) {\n                                this._uniformBuffer.updateFloat2(\"vMicroSurfaceSamplerInfos\", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);\n                                BABYLON.MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, this._uniformBuffer, \"microSurfaceSampler\");\n                            }\n                        }\n                        if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && BABYLON.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap) {\n                            this._uniformBuffer.updateFloat3(\"vBumpInfos\", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);\n                            BABYLON.MaterialHelper.BindTextureMatrix(this._bumpTexture, this._uniformBuffer, \"bump\");\n                        }\n                        var refractionTexture = this._getRefractionTexture();\n                        if (refractionTexture && BABYLON.StandardMaterial.RefractionTextureEnabled) {\n                            this._uniformBuffer.updateMatrix(\"refractionMatrix\", refractionTexture.getReflectionTextureMatrix());\n                            var depth = 1.0;\n                            if (!refractionTexture.isCube) {\n                                if (refractionTexture.depth) {\n                                    depth = refractionTexture.depth;\n                                }\n                            }\n                            this._uniformBuffer.updateFloat4(\"vRefractionInfos\", refractionTexture.level, this._indexOfRefraction, depth, this._invertRefractionY ? -1 : 1);\n                            this._uniformBuffer.updateFloat3(\"vRefractionMicrosurfaceInfos\", refractionTexture.getSize().width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset);\n                        }\n                    }\n                    // Point size\n                    if (this.pointsCloud) {\n                        this._uniformBuffer.updateFloat(\"pointSize\", this.pointSize);\n                    }\n                    // Colors\n                    if (defines.METALLICWORKFLOW) {\n                        BABYLON.PBRMaterial._scaledReflectivity.r = (this._metallic === undefined || this._metallic === null) ? 1 : this._metallic;\n                        BABYLON.PBRMaterial._scaledReflectivity.g = (this._roughness === undefined || this._roughness === null) ? 1 : this._roughness;\n                        this._uniformBuffer.updateColor4(\"vReflectivityColor\", BABYLON.PBRMaterial._scaledReflectivity, 0);\n                    }\n                    else {\n                        this._uniformBuffer.updateColor4(\"vReflectivityColor\", this._reflectivityColor, this._microSurface);\n                    }\n                    this._uniformBuffer.updateColor3(\"vEmissiveColor\", this._emissiveColor);\n                    this._uniformBuffer.updateColor3(\"vReflectionColor\", this._reflectionColor);\n                    this._uniformBuffer.updateColor4(\"vAlbedoColor\", this._albedoColor, this.alpha * mesh.visibility);\n                    // Misc\n                    this._lightingInfos.x = this._directIntensity;\n                    this._lightingInfos.y = this._emissiveIntensity;\n                    this._lightingInfos.z = this._environmentIntensity;\n                    this._lightingInfos.w = this._specularIntensity;\n                    this._uniformBuffer.updateVector4(\"vLightingIntensity\", this._lightingInfos);\n                }\n                // Textures\n                if (scene.texturesEnabled) {\n                    if (this._albedoTexture && BABYLON.StandardMaterial.DiffuseTextureEnabled) {\n                        this._uniformBuffer.setTexture(\"albedoSampler\", this._albedoTexture);\n                    }\n                    if (this._ambientTexture && BABYLON.StandardMaterial.AmbientTextureEnabled) {\n                        this._uniformBuffer.setTexture(\"ambientSampler\", this._ambientTexture);\n                    }\n                    if (this._opacityTexture && BABYLON.StandardMaterial.OpacityTextureEnabled) {\n                        this._uniformBuffer.setTexture(\"opacitySampler\", this._opacityTexture);\n                    }\n                    if (reflectionTexture && BABYLON.StandardMaterial.ReflectionTextureEnabled) {\n                        if (defines.LODBASEDMICROSFURACE) {\n                            this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture);\n                        }\n                        else {\n                            this._uniformBuffer.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\n                            this._uniformBuffer.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\n                            this._uniformBuffer.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\n                        }\n                    }\n                    if (defines.ENVIRONMENTBRDF) {\n                        this._uniformBuffer.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\n                    }\n                    if (refractionTexture && BABYLON.StandardMaterial.RefractionTextureEnabled) {\n                        if (defines.LODBASEDMICROSFURACE) {\n                            this._uniformBuffer.setTexture(\"refractionSampler\", refractionTexture);\n                        }\n                        else {\n                            this._uniformBuffer.setTexture(\"refractionSampler\", refractionTexture._lodTextureMid || refractionTexture);\n                            this._uniformBuffer.setTexture(\"refractionSamplerLow\", refractionTexture._lodTextureLow || refractionTexture);\n                            this._uniformBuffer.setTexture(\"refractionSamplerHigh\", refractionTexture._lodTextureHigh || refractionTexture);\n                        }\n                    }\n                    if (this._emissiveTexture && BABYLON.StandardMaterial.EmissiveTextureEnabled) {\n                        this._uniformBuffer.setTexture(\"emissiveSampler\", this._emissiveTexture);\n                    }\n                    if (this._lightmapTexture && BABYLON.StandardMaterial.LightmapTextureEnabled) {\n                        this._uniformBuffer.setTexture(\"lightmapSampler\", this._lightmapTexture);\n                    }\n                    if (BABYLON.StandardMaterial.SpecularTextureEnabled) {\n                        if (this._metallicTexture) {\n                            this._uniformBuffer.setTexture(\"reflectivitySampler\", this._metallicTexture);\n                        }\n                        else if (this._reflectivityTexture) {\n                            this._uniformBuffer.setTexture(\"reflectivitySampler\", this._reflectivityTexture);\n                        }\n                        if (this._microSurfaceTexture) {\n                            this._uniformBuffer.setTexture(\"microSurfaceSampler\", this._microSurfaceTexture);\n                        }\n                    }\n                    if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && BABYLON.StandardMaterial.BumpTextureEnabled && !this._disableBumpMap) {\n                        this._uniformBuffer.setTexture(\"bumpSampler\", this._bumpTexture);\n                    }\n                }\n                // Clip plane\n                BABYLON.MaterialHelper.BindClipPlane(this._activeEffect, scene);\n                // Colors\n                scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);\n                effect.setVector3(\"vEyePosition\", scene._mirroredCameraPosition ? scene._mirroredCameraPosition : scene.activeCamera.position);\n                effect.setColor3(\"vAmbientColor\", this._globalAmbientColor);\n            }\n            if (this._mustRebind(scene, effect) || !this.isFrozen) {\n                // Lights\n                if (scene.lightsEnabled && !this._disableLighting) {\n                    BABYLON.MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights, this._usePhysicalLightFalloff);\n                }\n                // View\n                if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== BABYLON.Scene.FOGMODE_NONE || reflectionTexture) {\n                    this.bindView(effect);\n                }\n                // Fog\n                BABYLON.MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect);\n                // Morph targets\n                if (defines.NUM_MORPH_INFLUENCERS) {\n                    BABYLON.MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);\n                }\n                // image processing\n                this._imageProcessingConfiguration.bind(this._activeEffect);\n                // Log. depth\n                BABYLON.MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);\n            }\n            this._uniformBuffer.update();\n            this._afterBind(mesh);\n            scene = null;\n        };\n        PBRBaseMaterial.prototype.getAnimatables = function () {\n            var results = [];\n            if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {\n                results.push(this._albedoTexture);\n            }\n            if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {\n                results.push(this._ambientTexture);\n            }\n            if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {\n                results.push(this._opacityTexture);\n            }\n            if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {\n                results.push(this._reflectionTexture);\n            }\n            if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {\n                results.push(this._emissiveTexture);\n            }\n            if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {\n                results.push(this._metallicTexture);\n            }\n            else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {\n                results.push(this._reflectivityTexture);\n            }\n            if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {\n                results.push(this._bumpTexture);\n            }\n            if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {\n                results.push(this._lightmapTexture);\n            }\n            if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {\n                results.push(this._refractionTexture);\n            }\n            return results;\n        };\n        PBRBaseMaterial.prototype._getReflectionTexture = function () {\n            if (this._reflectionTexture) {\n                return this._reflectionTexture;\n            }\n            return this.getScene().environmentTexture;\n        };\n        PBRBaseMaterial.prototype._getRefractionTexture = function () {\n            if (this._refractionTexture) {\n                return this._refractionTexture;\n            }\n            if (this._linkRefractionWithTransparency) {\n                return this.getScene().environmentTexture;\n            }\n            return null;\n        };\n        PBRBaseMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n            if (forceDisposeTextures) {\n                if (this._albedoTexture) {\n                    this._albedoTexture.dispose();\n                }\n                if (this._ambientTexture) {\n                    this._ambientTexture.dispose();\n                }\n                if (this._opacityTexture) {\n                    this._opacityTexture.dispose();\n                }\n                if (this._reflectionTexture) {\n                    this._reflectionTexture.dispose();\n                }\n                if (this._environmentBRDFTexture) {\n                    this._environmentBRDFTexture.dispose();\n                }\n                if (this._emissiveTexture) {\n                    this._emissiveTexture.dispose();\n                }\n                if (this._metallicTexture) {\n                    this._metallicTexture.dispose();\n                }\n                if (this._reflectivityTexture) {\n                    this._reflectivityTexture.dispose();\n                }\n                if (this._bumpTexture) {\n                    this._bumpTexture.dispose();\n                }\n                if (this._lightmapTexture) {\n                    this._lightmapTexture.dispose();\n                }\n                if (this._refractionTexture) {\n                    this._refractionTexture.dispose();\n                }\n            }\n            this._renderTargets.dispose();\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n        };\n        return PBRBaseMaterial;\n    }(BABYLON.PushMaterial));\n    PBRBaseMaterial._scaledReflectivity = new BABYLON.Color3();\n    __decorate([\n        BABYLON.serializeAsImageProcessingConfiguration()\n    ], PBRBaseMaterial.prototype, \"_imageProcessingConfiguration\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], PBRBaseMaterial.prototype, \"useLogarithmicDepth\", null);\n    BABYLON.PBRBaseMaterial = PBRBaseMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pbrBaseMaterial.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        /**\n         * The Physically based simple base material of BJS.\n         *\n         * This enables better naming and convention enforcements on top of the pbrMaterial.\n         * It is used as the base class for both the specGloss and metalRough conventions.\n         */\n        var PBRBaseSimpleMaterial = (function (_super) {\n            __extends(PBRBaseSimpleMaterial, _super);\n            /**\n             * Instantiates a new PBRMaterial instance.\n             *\n             * @param name The material name\n             * @param scene The scene the material will be use in.\n             */\n            function PBRBaseSimpleMaterial(name, scene) {\n                var _this = _super.call(this, name, scene) || this;\n                /**\n                 * Number of Simultaneous lights allowed on the material.\n                 */\n                _this.maxSimultaneousLights = 4;\n                /**\n                 * If sets to true, disables all the lights affecting the material.\n                 */\n                _this.disableLighting = false;\n                /**\n                 * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n                 */\n                _this.invertNormalMapX = false;\n                /**\n                 * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n                 */\n                _this.invertNormalMapY = false;\n                /**\n                 * Emissivie color used to self-illuminate the model.\n                 */\n                _this.emissiveColor = new BABYLON.Color3(0, 0, 0);\n                /**\n                 * Occlusion Channel Strenght.\n                 */\n                _this.occlusionStrength = 1.0;\n                _this._transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_OPAQUE;\n                _this._useAmbientInGrayScale = true;\n                return _this;\n            }\n            Object.defineProperty(PBRBaseSimpleMaterial.prototype, \"transparencyMode\", {\n                /**\n                 * Gets the current transparency mode.\n                 */\n                get: function () {\n                    return this._transparencyMode;\n                },\n                /**\n                 * Sets the transparency mode of the material.\n                 */\n                set: function (value) {\n                    if (this._transparencyMode === value) {\n                        return;\n                    }\n                    this._transparencyMode = value;\n                    if (value === BABYLON.PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND) {\n                        this._forceAlphaTest = true;\n                    }\n                    else {\n                        this._forceAlphaTest = false;\n                    }\n                    this._markAllSubMeshesAsTexturesDirty();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(PBRBaseSimpleMaterial.prototype, \"doubleSided\", {\n                /**\n                 * Gets the current double sided mode.\n                 */\n                get: function () {\n                    return this._twoSidedLighting;\n                },\n                /**\n                 * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n                 */\n                set: function (value) {\n                    if (this._twoSidedLighting === value) {\n                        return;\n                    }\n                    this._twoSidedLighting = value;\n                    this.backFaceCulling = !value;\n                    this._markAllSubMeshesAsTexturesDirty();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            /**\n             * Specifies wether or not the alpha value of the albedo texture should be used.\n             */\n            PBRBaseSimpleMaterial.prototype._shouldUseAlphaFromAlbedoTexture = function () {\n                return this._albedoTexture && this._albedoTexture.hasAlpha && this._transparencyMode !== BABYLON.PBRMaterial.PBRMATERIAL_OPAQUE;\n            };\n            /**\n             * Specifies wether or not the meshes using this material should be rendered in alpha blend mode.\n             */\n            PBRBaseSimpleMaterial.prototype.needAlphaBlending = function () {\n                if (this._linkRefractionWithTransparency) {\n                    return false;\n                }\n                return (this.alpha < 1.0) ||\n                    (this._shouldUseAlphaFromAlbedoTexture() &&\n                        (this._transparencyMode === BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND ||\n                            this._transparencyMode === BABYLON.PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND));\n            };\n            /**\n             * Specifies wether or not the meshes using this material should be rendered in alpha test mode.\n             */\n            PBRBaseSimpleMaterial.prototype.needAlphaTesting = function () {\n                if (this._linkRefractionWithTransparency) {\n                    return false;\n                }\n                return this._shouldUseAlphaFromAlbedoTexture() &&\n                    this._transparencyMode === BABYLON.PBRMaterial.PBRMATERIAL_ALPHATEST;\n            };\n            return PBRBaseSimpleMaterial;\n        }(BABYLON.PBRBaseMaterial));\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"maxSimultaneousLights\", void 0);\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"disableLighting\", void 0);\n        __decorate([\n            BABYLON.serializeAsTexture(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectionTexture\")\n        ], PBRBaseSimpleMaterial.prototype, \"environmentTexture\", void 0);\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"invertNormalMapX\", void 0);\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"invertNormalMapY\", void 0);\n        __decorate([\n            BABYLON.serializeAsTexture(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_bumpTexture\")\n        ], PBRBaseSimpleMaterial.prototype, \"normalTexture\", void 0);\n        __decorate([\n            BABYLON.serializeAsColor3(\"emissive\"),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"emissiveColor\", void 0);\n        __decorate([\n            BABYLON.serializeAsTexture(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n        ], PBRBaseSimpleMaterial.prototype, \"emissiveTexture\", void 0);\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTextureStrength\")\n        ], PBRBaseSimpleMaterial.prototype, \"occlusionStrength\", void 0);\n        __decorate([\n            BABYLON.serializeAsTexture(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_ambientTexture\")\n        ], PBRBaseSimpleMaterial.prototype, \"occlusionTexture\", void 0);\n        __decorate([\n            BABYLON.serialize(),\n            BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_alphaCutOff\")\n        ], PBRBaseSimpleMaterial.prototype, \"alphaCutOff\", void 0);\n        __decorate([\n            BABYLON.serialize()\n        ], PBRBaseSimpleMaterial.prototype, \"transparencyMode\", null);\n        __decorate([\n            BABYLON.serialize()\n        ], PBRBaseSimpleMaterial.prototype, \"doubleSided\", null);\n        Internals.PBRBaseSimpleMaterial = PBRBaseSimpleMaterial;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pbrBaseSimpleMaterial.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * The Physically based material of BJS.\n     *\n     * This offers the main features of a standard PBR material.\n     * For more information, please refer to the documentation :\n     * http://doc.babylonjs.com/extensions/Physically_Based_Rendering\n     */\n    var PBRMaterial = (function (_super) {\n        __extends(PBRMaterial, _super);\n        /**\n         * Instantiates a new PBRMaterial instance.\n         *\n         * @param name The material name\n         * @param scene The scene the material will be use in.\n         */\n        function PBRMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            /**\n             * Intensity of the direct lights e.g. the four lights available in your scene.\n             * This impacts both the direct diffuse and specular highlights.\n             */\n            _this.directIntensity = 1.0;\n            /**\n             * Intensity of the emissive part of the material.\n             * This helps controlling the emissive effect without modifying the emissive color.\n             */\n            _this.emissiveIntensity = 1.0;\n            /**\n             * Intensity of the environment e.g. how much the environment will light the object\n             * either through harmonics for rough material or through the refelction for shiny ones.\n             */\n            _this.environmentIntensity = 1.0;\n            /**\n             * This is a special control allowing the reduction of the specular highlights coming from the\n             * four lights of the scene. Those highlights may not be needed in full environment lighting.\n             */\n            _this.specularIntensity = 1.0;\n            /**\n             * Debug Control allowing disabling the bump map on this material.\n             */\n            _this.disableBumpMap = false;\n            /**\n             * AKA Occlusion Texture Intensity in other nomenclature.\n             */\n            _this.ambientTextureStrength = 1.0;\n            _this.ambientColor = new BABYLON.Color3(0, 0, 0);\n            /**\n             * AKA Diffuse Color in other nomenclature.\n             */\n            _this.albedoColor = new BABYLON.Color3(1, 1, 1);\n            /**\n             * AKA Specular Color in other nomenclature.\n             */\n            _this.reflectivityColor = new BABYLON.Color3(1, 1, 1);\n            _this.reflectionColor = new BABYLON.Color3(1.0, 1.0, 1.0);\n            _this.emissiveColor = new BABYLON.Color3(0, 0, 0);\n            /**\n             * AKA Glossiness in other nomenclature.\n             */\n            _this.microSurface = 1.0;\n            /**\n             * source material index of refraction (IOR)' / 'destination material IOR.\n             */\n            _this.indexOfRefraction = 0.66;\n            /**\n             * Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.\n             */\n            _this.invertRefractionY = false;\n            /**\n             * This parameters will make the material used its opacity to control how much it is refracting aginst not.\n             * Materials half opaque for instance using refraction could benefit from this control.\n             */\n            _this.linkRefractionWithTransparency = false;\n            _this.useLightmapAsShadowmap = false;\n            /**\n             * Specifies that the alpha is coming form the albedo channel alpha channel.\n             */\n            _this.useAlphaFromAlbedoTexture = false;\n            /**\n             * Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).\n             * A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.\n             */\n            _this.useSpecularOverAlpha = true;\n            /**\n             * Specifies if the reflectivity texture contains the glossiness information in its alpha channel.\n             */\n            _this.useMicroSurfaceFromReflectivityMapAlpha = false;\n            /**\n             * Specifies if the metallic texture contains the roughness information in its alpha channel.\n             */\n            _this.useRoughnessFromMetallicTextureAlpha = true;\n            /**\n             * Specifies if the metallic texture contains the roughness information in its green channel.\n             */\n            _this.useRoughnessFromMetallicTextureGreen = false;\n            /**\n             * Specifies if the metallic texture contains the metallness information in its blue channel.\n             */\n            _this.useMetallnessFromMetallicTextureBlue = false;\n            /**\n             * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\n             */\n            _this.useAmbientOcclusionFromMetallicTextureRed = false;\n            /**\n             * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\n             */\n            _this.useAmbientInGrayScale = false;\n            /**\n             * In case the reflectivity map does not contain the microsurface information in its alpha channel,\n             * The material will try to infer what glossiness each pixel should be.\n             */\n            _this.useAutoMicroSurfaceFromReflectivityMap = false;\n            /**\n             * BJS is using an harcoded light falloff based on a manually sets up range.\n             * In PBR, one way to represents the fallof is to use the inverse squared root algorythm.\n             * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\n             */\n            _this.usePhysicalLightFalloff = true;\n            /**\n             * Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).\n             * A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.\n             */\n            _this.useRadianceOverAlpha = true;\n            /**\n             * Allows using the bump map in parallax mode.\n             */\n            _this.useParallax = false;\n            /**\n             * Allows using the bump map in parallax occlusion mode.\n             */\n            _this.useParallaxOcclusion = false;\n            /**\n             * Controls the scale bias of the parallax mode.\n             */\n            _this.parallaxScaleBias = 0.05;\n            /**\n             * If sets to true, disables all the lights affecting the material.\n             */\n            _this.disableLighting = false;\n            /**\n             * Number of Simultaneous lights allowed on the material.\n             */\n            _this.maxSimultaneousLights = 4;\n            /**\n             * If sets to true, x component of normal map value will invert (x = 1.0 - x).\n             */\n            _this.invertNormalMapX = false;\n            /**\n             * If sets to true, y component of normal map value will invert (y = 1.0 - y).\n             */\n            _this.invertNormalMapY = false;\n            /**\n             * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\n             */\n            _this.twoSidedLighting = false;\n            /**\n             * Specifies that the alpha is premultiplied before output (this enables alpha premultiplied blending).\n             * in your scene composition.\n             */\n            _this.premultiplyAlpha = false;\n            /**\n             * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n             * And/Or occlude the blended part.\n             */\n            _this.useAlphaFresnel = false;\n            /**\n             * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\n             * And/Or occlude the blended part.\n             */\n            _this.environmentBRDFTexture = null;\n            _this._environmentBRDFTexture = BABYLON.TextureTools.GetEnvironmentBRDFTexture(scene);\n            return _this;\n        }\n        Object.defineProperty(PBRMaterial, \"PBRMATERIAL_OPAQUE\", {\n            /**\n             * PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.\n             */\n            get: function () {\n                return this._PBRMATERIAL_OPAQUE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial, \"PBRMATERIAL_ALPHATEST\", {\n            /**\n             * PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.\n             */\n            get: function () {\n                return this._PBRMATERIAL_ALPHATEST;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial, \"PBRMATERIAL_ALPHABLEND\", {\n            /**\n             * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n             */\n            get: function () {\n                return this._PBRMATERIAL_ALPHABLEND;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial, \"PBRMATERIAL_ALPHATESTANDBLEND\", {\n            /**\n             * PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.\n             * They are also discarded below the alpha cutoff threshold to improve performances.\n             */\n            get: function () {\n                return this._PBRMATERIAL_ALPHATESTANDBLEND;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"imageProcessingConfiguration\", {\n            /**\n             * Gets the image processing configuration used either in this material.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration;\n            },\n            /**\n             * Sets the Default image processing configuration used either in the this material.\n             *\n             * If sets to null, the scene one is in use.\n             */\n            set: function (value) {\n                this._attachImageProcessingConfiguration(value);\n                // Ensure the effect will be rebuilt.\n                this._markAllSubMeshesAsTexturesDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"cameraColorCurvesEnabled\", {\n            /**\n             * Gets wether the color curves effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorCurvesEnabled;\n            },\n            /**\n             * Sets wether the color curves effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorCurvesEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"cameraColorGradingEnabled\", {\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorGradingEnabled;\n            },\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorGradingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"cameraToneMappingEnabled\", {\n            /**\n             * Gets wether tonemapping is enabled or not.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.toneMappingEnabled;\n            },\n            /**\n             * Sets wether tonemapping is enabled or not\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.toneMappingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(PBRMaterial.prototype, \"cameraExposure\", {\n            /**\n             * The camera exposure used on this material.\n             * This property is here and not in the camera to allow controlling exposure without full screen post process.\n             * This corresponds to a photographic exposure.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.exposure;\n            },\n            /**\n             * The camera exposure used on this material.\n             * This property is here and not in the camera to allow controlling exposure without full screen post process.\n             * This corresponds to a photographic exposure.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.exposure = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(PBRMaterial.prototype, \"cameraContrast\", {\n            /**\n             * Gets The camera contrast used on this material.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.contrast;\n            },\n            /**\n             * Sets The camera contrast used on this material.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.contrast = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"cameraColorGradingTexture\", {\n            /**\n             * Gets the Color Grading 2D Lookup Texture.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.colorGradingTexture;\n            },\n            /**\n             * Sets the Color Grading 2D Lookup Texture.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.colorGradingTexture = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PBRMaterial.prototype, \"cameraColorCurves\", {\n            /**\n             * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\n             * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n             * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n             * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.colorCurves;\n            },\n            /**\n             * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\n             * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n             * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n             * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.colorCurves = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PBRMaterial.prototype.getClassName = function () {\n            return \"PBRMaterial\";\n        };\n        PBRMaterial.prototype.getActiveTextures = function () {\n            var activeTextures = _super.prototype.getActiveTextures.call(this);\n            if (this._albedoTexture) {\n                activeTextures.push(this._albedoTexture);\n            }\n            if (this._ambientTexture) {\n                activeTextures.push(this._ambientTexture);\n            }\n            if (this._opacityTexture) {\n                activeTextures.push(this._opacityTexture);\n            }\n            if (this._reflectionTexture) {\n                activeTextures.push(this._reflectionTexture);\n            }\n            if (this._emissiveTexture) {\n                activeTextures.push(this._emissiveTexture);\n            }\n            if (this._reflectionTexture) {\n                activeTextures.push(this._reflectionTexture);\n            }\n            if (this._metallicTexture) {\n                activeTextures.push(this._metallicTexture);\n            }\n            if (this._microSurfaceTexture) {\n                activeTextures.push(this._microSurfaceTexture);\n            }\n            if (this._bumpTexture) {\n                activeTextures.push(this._bumpTexture);\n            }\n            if (this._lightmapTexture) {\n                activeTextures.push(this._lightmapTexture);\n            }\n            if (this._refractionTexture) {\n                activeTextures.push(this._refractionTexture);\n            }\n            return activeTextures;\n        };\n        PBRMaterial.prototype.hasTexture = function (texture) {\n            if (_super.prototype.hasTexture.call(this, texture)) {\n                return true;\n            }\n            if (this._albedoTexture === texture) {\n                return true;\n            }\n            if (this._ambientTexture === texture) {\n                return true;\n            }\n            if (this._opacityTexture === texture) {\n                return true;\n            }\n            if (this._reflectionTexture === texture) {\n                return true;\n            }\n            if (this._metallicTexture === texture) {\n                return true;\n            }\n            if (this._microSurfaceTexture === texture) {\n                return true;\n            }\n            if (this._bumpTexture === texture) {\n                return true;\n            }\n            if (this._lightmapTexture === texture) {\n                return true;\n            }\n            if (this._refractionTexture === texture) {\n                return true;\n            }\n            return false;\n        };\n        PBRMaterial.prototype.clone = function (name) {\n            var _this = this;\n            return BABYLON.SerializationHelper.Clone(function () { return new PBRMaterial(name, _this.getScene()); }, this);\n        };\n        PBRMaterial.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"BABYLON.PBRMaterial\";\n            return serializationObject;\n        };\n        // Statics\n        PBRMaterial.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new PBRMaterial(source.name, scene); }, source, scene, rootUrl);\n        };\n        return PBRMaterial;\n    }(BABYLON.PBRBaseMaterial));\n    PBRMaterial._PBRMATERIAL_OPAQUE = 0;\n    PBRMaterial._PBRMATERIAL_ALPHATEST = 1;\n    PBRMaterial._PBRMATERIAL_ALPHABLEND = 2;\n    PBRMaterial._PBRMATERIAL_ALPHATESTANDBLEND = 3;\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"directIntensity\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"emissiveIntensity\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"environmentIntensity\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"specularIntensity\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"disableBumpMap\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"albedoTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"ambientTexture\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"ambientTextureStrength\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"opacityTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"reflectionTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"emissiveTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"reflectivityTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"metallicTexture\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"metallic\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"roughness\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"microSurfaceTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"bumpTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", null)\n    ], PBRMaterial.prototype, \"lightmapTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"refractionTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"ambient\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"ambientColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"albedo\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"albedoColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"reflectivity\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"reflectivityColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"reflection\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"reflectionColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"emissive\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"emissiveColor\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"microSurface\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"indexOfRefraction\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"invertRefractionY\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"linkRefractionWithTransparency\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useLightmapAsShadowmap\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useAlphaFromAlbedoTexture\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useSpecularOverAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useMicroSurfaceFromReflectivityMapAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useRoughnessFromMetallicTextureAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useRoughnessFromMetallicTextureGreen\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useMetallnessFromMetallicTextureBlue\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useAmbientOcclusionFromMetallicTextureRed\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useAmbientInGrayScale\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useAutoMicroSurfaceFromReflectivityMap\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"usePhysicalLightFalloff\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useRadianceOverAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useParallax\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useParallaxOcclusion\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"parallaxScaleBias\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    ], PBRMaterial.prototype, \"disableLighting\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\n    ], PBRMaterial.prototype, \"maxSimultaneousLights\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"invertNormalMapX\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"invertNormalMapY\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"twoSidedLighting\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"premultiplyAlpha\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"useAlphaFresnel\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMaterial.prototype, \"environmentBRDFTexture\", void 0);\n    BABYLON.PBRMaterial = PBRMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pbrMaterial.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * The PBR material of BJS following the metal roughness convention.\n     *\n     * This fits to the PBR convention in the GLTF definition:\n     * https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0\n     */\n    var PBRMetallicRoughnessMaterial = (function (_super) {\n        __extends(PBRMetallicRoughnessMaterial, _super);\n        /**\n         * Instantiates a new PBRMetalRoughnessMaterial instance.\n         *\n         * @param name The material name\n         * @param scene The scene the material will be use in.\n         */\n        function PBRMetallicRoughnessMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._useRoughnessFromMetallicTextureAlpha = false;\n            _this._useRoughnessFromMetallicTextureGreen = true;\n            _this._useMetallnessFromMetallicTextureBlue = true;\n            return _this;\n        }\n        /**\n         * Return the currrent class name of the material.\n         */\n        PBRMetallicRoughnessMaterial.prototype.getClassName = function () {\n            return \"PBRMetallicRoughnessMaterial\";\n        };\n        /**\n         * Return the active textures of the material.\n         */\n        PBRMetallicRoughnessMaterial.prototype.getActiveTextures = function () {\n            var activeTextures = _super.prototype.getActiveTextures.call(this);\n            if (this.baseTexture) {\n                activeTextures.push(this.baseTexture);\n            }\n            if (this.metallicRoughnessTexture) {\n                activeTextures.push(this.metallicRoughnessTexture);\n            }\n            return activeTextures;\n        };\n        PBRMetallicRoughnessMaterial.prototype.hasTexture = function (texture) {\n            if (_super.prototype.hasTexture.call(this, texture)) {\n                return true;\n            }\n            if (this.baseTexture === texture) {\n                return true;\n            }\n            if (this.metallicRoughnessTexture === texture) {\n                return true;\n            }\n            return false;\n        };\n        PBRMetallicRoughnessMaterial.prototype.clone = function (name) {\n            var _this = this;\n            return BABYLON.SerializationHelper.Clone(function () { return new PBRMetallicRoughnessMaterial(name, _this.getScene()); }, this);\n        };\n        /**\n         * Serialize the material to a parsable JSON object.\n         */\n        PBRMetallicRoughnessMaterial.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"BABYLON.PBRMetallicRoughnessMaterial\";\n            return serializationObject;\n        };\n        /**\n         * Parses a JSON object correponding to the serialize function.\n         */\n        PBRMetallicRoughnessMaterial.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new PBRMetallicRoughnessMaterial(source.name, scene); }, source, scene, rootUrl);\n        };\n        return PBRMetallicRoughnessMaterial;\n    }(BABYLON.Internals.PBRBaseSimpleMaterial));\n    __decorate([\n        BABYLON.serializeAsColor3(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")\n    ], PBRMetallicRoughnessMaterial.prototype, \"baseColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")\n    ], PBRMetallicRoughnessMaterial.prototype, \"baseTexture\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMetallicRoughnessMaterial.prototype, \"metallic\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n    ], PBRMetallicRoughnessMaterial.prototype, \"roughness\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_metallicTexture\")\n    ], PBRMetallicRoughnessMaterial.prototype, \"metallicRoughnessTexture\", void 0);\n    BABYLON.PBRMetallicRoughnessMaterial = PBRMetallicRoughnessMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pbrMetallicRoughnessMaterial.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * The PBR material of BJS following the specular glossiness convention.\n     *\n     * This fits to the PBR convention in the GLTF definition:\n     * https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness\n     */\n    var PBRSpecularGlossinessMaterial = (function (_super) {\n        __extends(PBRSpecularGlossinessMaterial, _super);\n        /**\n         * Instantiates a new PBRSpecularGlossinessMaterial instance.\n         *\n         * @param name The material name\n         * @param scene The scene the material will be use in.\n         */\n        function PBRSpecularGlossinessMaterial(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._useMicroSurfaceFromReflectivityMapAlpha = true;\n            return _this;\n        }\n        /**\n         * Return the currrent class name of the material.\n         */\n        PBRSpecularGlossinessMaterial.prototype.getClassName = function () {\n            return \"PBRSpecularGlossinessMaterial\";\n        };\n        /**\n         * Return the active textures of the material.\n         */\n        PBRSpecularGlossinessMaterial.prototype.getActiveTextures = function () {\n            var activeTextures = _super.prototype.getActiveTextures.call(this);\n            if (this.diffuseTexture) {\n                activeTextures.push(this.diffuseTexture);\n            }\n            if (this.specularGlossinessTexture) {\n                activeTextures.push(this.specularGlossinessTexture);\n            }\n            return activeTextures;\n        };\n        PBRSpecularGlossinessMaterial.prototype.hasTexture = function (texture) {\n            if (_super.prototype.hasTexture.call(this, texture)) {\n                return true;\n            }\n            if (this.diffuseTexture === texture) {\n                return true;\n            }\n            if (this.specularGlossinessTexture === texture) {\n                return true;\n            }\n            return false;\n        };\n        PBRSpecularGlossinessMaterial.prototype.clone = function (name) {\n            var _this = this;\n            return BABYLON.SerializationHelper.Clone(function () { return new PBRSpecularGlossinessMaterial(name, _this.getScene()); }, this);\n        };\n        /**\n         * Serialize the material to a parsable JSON object.\n         */\n        PBRSpecularGlossinessMaterial.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"BABYLON.PBRSpecularGlossinessMaterial\";\n            return serializationObject;\n        };\n        /**\n         * Parses a JSON object correponding to the serialize function.\n         */\n        PBRSpecularGlossinessMaterial.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new PBRSpecularGlossinessMaterial(source.name, scene); }, source, scene, rootUrl);\n        };\n        return PBRSpecularGlossinessMaterial;\n    }(BABYLON.Internals.PBRBaseSimpleMaterial));\n    __decorate([\n        BABYLON.serializeAsColor3(\"diffuse\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoColor\")\n    ], PBRSpecularGlossinessMaterial.prototype, \"diffuseColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_albedoTexture\")\n    ], PBRSpecularGlossinessMaterial.prototype, \"diffuseTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor3(\"specular\"),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityColor\")\n    ], PBRSpecularGlossinessMaterial.prototype, \"specularColor\", void 0);\n    __decorate([\n        BABYLON.serialize(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_microSurface\")\n    ], PBRSpecularGlossinessMaterial.prototype, \"glossiness\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(),\n        BABYLON.expandToProperty(\"_markAllSubMeshesAsTexturesDirty\", \"_reflectivityTexture\")\n    ], PBRSpecularGlossinessMaterial.prototype, \"specularGlossinessTexture\", void 0);\n    BABYLON.PBRSpecularGlossinessMaterial = PBRSpecularGlossinessMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pbrSpecularGlossinessMaterial.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    BABYLON.CameraInputTypes = {};\n    var CameraInputsManager = (function () {\n        function CameraInputsManager(camera) {\n            this.attached = {};\n            this.camera = camera;\n            this.checkInputs = function () { };\n        }\n        CameraInputsManager.prototype.add = function (input) {\n            var type = input.getSimpleName();\n            if (this.attached[type]) {\n                BABYLON.Tools.Warn(\"camera input of type \" + type + \" already exists on camera\");\n                return;\n            }\n            this.attached[type] = input;\n            input.camera = this.camera;\n            //for checkInputs, we are dynamically creating a function\n            //the goal is to avoid the performance penalty of looping for inputs in the render loop\n            if (input.checkInputs) {\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n            }\n            if (this.attachedElement) {\n                input.attachControl(this.attachedElement);\n            }\n        };\n        CameraInputsManager.prototype.remove = function (inputToRemove) {\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                if (input === inputToRemove) {\n                    input.detachControl(this.attachedElement);\n                    delete this.attached[cam];\n                    this.rebuildInputCheck();\n                }\n            }\n        };\n        CameraInputsManager.prototype.removeByType = function (inputType) {\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                if (input.getTypeName() === inputType) {\n                    input.detachControl(this.attachedElement);\n                    delete this.attached[cam];\n                    this.rebuildInputCheck();\n                }\n            }\n        };\n        CameraInputsManager.prototype._addCheckInputs = function (fn) {\n            var current = this.checkInputs;\n            return function () {\n                current();\n                fn();\n            };\n        };\n        CameraInputsManager.prototype.attachInput = function (input) {\n            input.attachControl(this.attachedElement, this.noPreventDefault);\n        };\n        CameraInputsManager.prototype.attachElement = function (element, noPreventDefault) {\n            if (this.attachedElement) {\n                return;\n            }\n            noPreventDefault = BABYLON.Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n            this.attachedElement = element;\n            this.noPreventDefault = noPreventDefault;\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                this.attached[cam].attachControl(element, noPreventDefault);\n            }\n        };\n        CameraInputsManager.prototype.detachElement = function (element) {\n            if (this.attachedElement !== element) {\n                return;\n            }\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                this.attached[cam].detachControl(element);\n            }\n            this.attachedElement = null;\n        };\n        CameraInputsManager.prototype.rebuildInputCheck = function () {\n            this.checkInputs = function () { };\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                if (input.checkInputs) {\n                    this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\n                }\n            }\n        };\n        CameraInputsManager.prototype.clear = function () {\n            if (this.attachedElement) {\n                this.detachElement(this.attachedElement);\n            }\n            this.attached = {};\n            this.attachedElement = null;\n            this.checkInputs = function () { };\n        };\n        CameraInputsManager.prototype.serialize = function (serializedCamera) {\n            var inputs = {};\n            for (var cam in this.attached) {\n                var input = this.attached[cam];\n                var res = BABYLON.SerializationHelper.Serialize(input);\n                inputs[input.getTypeName()] = res;\n            }\n            serializedCamera.inputsmgr = inputs;\n        };\n        CameraInputsManager.prototype.parse = function (parsedCamera) {\n            var parsedInputs = parsedCamera.inputsmgr;\n            if (parsedInputs) {\n                this.clear();\n                for (var n in parsedInputs) {\n                    var construct = BABYLON.CameraInputTypes[n];\n                    if (construct) {\n                        var parsedinput = parsedInputs[n];\n                        var input = BABYLON.SerializationHelper.Parse(function () { return new construct(); }, parsedinput, null);\n                        this.add(input);\n                    }\n                }\n            }\n            else {\n                //2016-03-08 this part is for managing backward compatibility\n                for (var n in this.attached) {\n                    var construct = BABYLON.CameraInputTypes[this.attached[n].getTypeName()];\n                    if (construct) {\n                        var input = BABYLON.SerializationHelper.Parse(function () { return new construct(); }, parsedCamera, null);\n                        this.remove(this.attached[n]);\n                        this.add(input);\n                    }\n                }\n            }\n        };\n        return CameraInputsManager;\n    }());\n    BABYLON.CameraInputsManager = CameraInputsManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.cameraInputsManager.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraMouseInput = (function () {\n        function FreeCameraMouseInput(touchEnabled) {\n            if (touchEnabled === void 0) { touchEnabled = true; }\n            this.touchEnabled = touchEnabled;\n            this.buttons = [0, 1, 2];\n            this.angularSensibility = 2000.0;\n        }\n        FreeCameraMouseInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            var engine = this.camera.getEngine();\n            if (!this._pointerInput) {\n                this._pointerInput = function (p, s) {\n                    var evt = p.event;\n                    if (!_this.touchEnabled && evt.pointerType === \"touch\") {\n                        return;\n                    }\n                    if (p.type !== BABYLON.PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n                        return;\n                    }\n                    if (p.type === BABYLON.PointerEventTypes.POINTERDOWN) {\n                        try {\n                            evt.srcElement.setPointerCapture(evt.pointerId);\n                        }\n                        catch (e) {\n                            //Nothing to do with the error. Execution will continue.\n                        }\n                        _this.previousPosition = {\n                            x: evt.clientX,\n                            y: evt.clientY\n                        };\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                            element.focus();\n                        }\n                    }\n                    else if (p.type === BABYLON.PointerEventTypes.POINTERUP) {\n                        try {\n                            evt.srcElement.releasePointerCapture(evt.pointerId);\n                        }\n                        catch (e) {\n                            //Nothing to do with the error.\n                        }\n                        _this.previousPosition = null;\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                    else if (p.type === BABYLON.PointerEventTypes.POINTERMOVE) {\n                        if (!_this.previousPosition || engine.isPointerLock) {\n                            return;\n                        }\n                        var offsetX = evt.clientX - _this.previousPosition.x;\n                        var offsetY = evt.clientY - _this.previousPosition.y;\n                        if (_this.camera.getScene().useRightHandedSystem) {\n                            _this.camera.cameraRotation.y -= offsetX / _this.angularSensibility;\n                        }\n                        else {\n                            _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n                        }\n                        _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n                        _this.previousPosition = {\n                            x: evt.clientX,\n                            y: evt.clientY\n                        };\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                };\n            }\n            this._onMouseMove = function (evt) {\n                if (!engine.isPointerLock) {\n                    return;\n                }\n                var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n                var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n                if (_this.camera.getScene().useRightHandedSystem) {\n                    _this.camera.cameraRotation.y -= offsetX / _this.angularSensibility;\n                }\n                else {\n                    _this.camera.cameraRotation.y += offsetX / _this.angularSensibility;\n                }\n                _this.camera.cameraRotation.x += offsetY / _this.angularSensibility;\n                _this.previousPosition = null;\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n            };\n            this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, BABYLON.PointerEventTypes.POINTERDOWN | BABYLON.PointerEventTypes.POINTERUP | BABYLON.PointerEventTypes.POINTERMOVE);\n            element.addEventListener(\"mousemove\", this._onMouseMove, false);\n        };\n        FreeCameraMouseInput.prototype.detachControl = function (element) {\n            if (this._observer && element) {\n                this.camera.getScene().onPointerObservable.remove(this._observer);\n                element.removeEventListener(\"mousemove\", this._onMouseMove);\n                this._observer = null;\n                this._onMouseMove = null;\n                this.previousPosition = null;\n            }\n        };\n        FreeCameraMouseInput.prototype.getTypeName = function () {\n            return \"FreeCameraMouseInput\";\n        };\n        FreeCameraMouseInput.prototype.getSimpleName = function () {\n            return \"mouse\";\n        };\n        return FreeCameraMouseInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraMouseInput.prototype, \"buttons\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraMouseInput.prototype, \"angularSensibility\", void 0);\n    BABYLON.FreeCameraMouseInput = FreeCameraMouseInput;\n    BABYLON.CameraInputTypes[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraMouseInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraKeyboardMoveInput = (function () {\n        function FreeCameraKeyboardMoveInput() {\n            this._keys = [];\n            this.keysUp = [38];\n            this.keysDown = [40];\n            this.keysLeft = [37];\n            this.keysRight = [39];\n        }\n        FreeCameraKeyboardMoveInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            if (!this._onKeyDown) {\n                element.tabIndex = 1;\n                this._onKeyDown = function (evt) {\n                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysRight.indexOf(evt.keyCode) !== -1) {\n                        var index = _this._keys.indexOf(evt.keyCode);\n                        if (index === -1) {\n                            _this._keys.push(evt.keyCode);\n                        }\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                };\n                this._onKeyUp = function (evt) {\n                    if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                        _this.keysRight.indexOf(evt.keyCode) !== -1) {\n                        var index = _this._keys.indexOf(evt.keyCode);\n                        if (index >= 0) {\n                            _this._keys.splice(index, 1);\n                        }\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                };\n                element.addEventListener(\"keydown\", this._onKeyDown, false);\n                element.addEventListener(\"keyup\", this._onKeyUp, false);\n                BABYLON.Tools.RegisterTopRootEvents([\n                    { name: \"blur\", handler: this._onLostFocus }\n                ]);\n            }\n        };\n        FreeCameraKeyboardMoveInput.prototype.detachControl = function (element) {\n            if (this._onKeyDown) {\n                element.removeEventListener(\"keydown\", this._onKeyDown);\n                element.removeEventListener(\"keyup\", this._onKeyUp);\n                BABYLON.Tools.UnregisterTopRootEvents([\n                    { name: \"blur\", handler: this._onLostFocus }\n                ]);\n                this._keys = [];\n                this._onKeyDown = null;\n                this._onKeyUp = null;\n            }\n        };\n        FreeCameraKeyboardMoveInput.prototype.checkInputs = function () {\n            if (this._onKeyDown) {\n                var camera = this.camera;\n                // Keyboard\n                for (var index = 0; index < this._keys.length; index++) {\n                    var keyCode = this._keys[index];\n                    var speed = camera._computeLocalCameraSpeed();\n                    if (this.keysLeft.indexOf(keyCode) !== -1) {\n                        camera._localDirection.copyFromFloats(-speed, 0, 0);\n                    }\n                    else if (this.keysUp.indexOf(keyCode) !== -1) {\n                        camera._localDirection.copyFromFloats(0, 0, speed);\n                    }\n                    else if (this.keysRight.indexOf(keyCode) !== -1) {\n                        camera._localDirection.copyFromFloats(speed, 0, 0);\n                    }\n                    else if (this.keysDown.indexOf(keyCode) !== -1) {\n                        camera._localDirection.copyFromFloats(0, 0, -speed);\n                    }\n                    if (camera.getScene().useRightHandedSystem) {\n                        camera._localDirection.z *= -1;\n                    }\n                    camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\n                    BABYLON.Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\n                    camera.cameraDirection.addInPlace(camera._transformedDirection);\n                }\n            }\n        };\n        FreeCameraKeyboardMoveInput.prototype.getTypeName = function () {\n            return \"FreeCameraKeyboardMoveInput\";\n        };\n        FreeCameraKeyboardMoveInput.prototype._onLostFocus = function (e) {\n            this._keys = [];\n        };\n        FreeCameraKeyboardMoveInput.prototype.getSimpleName = function () {\n            return \"keyboard\";\n        };\n        return FreeCameraKeyboardMoveInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraKeyboardMoveInput.prototype, \"keysUp\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraKeyboardMoveInput.prototype, \"keysDown\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraKeyboardMoveInput.prototype, \"keysLeft\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraKeyboardMoveInput.prototype, \"keysRight\", void 0);\n    BABYLON.FreeCameraKeyboardMoveInput = FreeCameraKeyboardMoveInput;\n    BABYLON.CameraInputTypes[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraKeyboardMoveInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraInputsManager = (function (_super) {\n        __extends(FreeCameraInputsManager, _super);\n        function FreeCameraInputsManager(camera) {\n            return _super.call(this, camera) || this;\n        }\n        FreeCameraInputsManager.prototype.addKeyboard = function () {\n            this.add(new BABYLON.FreeCameraKeyboardMoveInput());\n            return this;\n        };\n        FreeCameraInputsManager.prototype.addMouse = function (touchEnabled) {\n            if (touchEnabled === void 0) { touchEnabled = true; }\n            this.add(new BABYLON.FreeCameraMouseInput(touchEnabled));\n            return this;\n        };\n        FreeCameraInputsManager.prototype.addGamepad = function () {\n            this.add(new BABYLON.FreeCameraGamepadInput());\n            return this;\n        };\n        FreeCameraInputsManager.prototype.addDeviceOrientation = function () {\n            this.add(new BABYLON.FreeCameraDeviceOrientationInput());\n            return this;\n        };\n        FreeCameraInputsManager.prototype.addTouch = function () {\n            this.add(new BABYLON.FreeCameraTouchInput());\n            return this;\n        };\n        FreeCameraInputsManager.prototype.addVirtualJoystick = function () {\n            this.add(new BABYLON.FreeCameraVirtualJoystickInput());\n            return this;\n        };\n        return FreeCameraInputsManager;\n    }(BABYLON.CameraInputsManager));\n    BABYLON.FreeCameraInputsManager = FreeCameraInputsManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraInputsManager.js.map\n\n/// <reference path=\"babylon.camera.ts\" />\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var TargetCamera = (function (_super) {\n        __extends(TargetCamera, _super);\n        function TargetCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.cameraDirection = new BABYLON.Vector3(0, 0, 0);\n            _this.cameraRotation = new BABYLON.Vector2(0, 0);\n            _this.rotation = new BABYLON.Vector3(0, 0, 0);\n            _this.speed = 2.0;\n            _this.noRotationConstraint = false;\n            _this.lockedTarget = null;\n            _this._currentTarget = BABYLON.Vector3.Zero();\n            _this._viewMatrix = BABYLON.Matrix.Zero();\n            _this._camMatrix = BABYLON.Matrix.Zero();\n            _this._cameraTransformMatrix = BABYLON.Matrix.Zero();\n            _this._cameraRotationMatrix = BABYLON.Matrix.Zero();\n            _this._referencePoint = new BABYLON.Vector3(0, 0, 1);\n            _this._defaultUpVector = new BABYLON.Vector3(0, 1, 0);\n            _this._transformedReferencePoint = BABYLON.Vector3.Zero();\n            _this._lookAtTemp = BABYLON.Matrix.Zero();\n            _this._tempMatrix = BABYLON.Matrix.Zero();\n            return _this;\n        }\n        TargetCamera.prototype.getFrontPosition = function (distance) {\n            var direction = this.getTarget().subtract(this.position);\n            direction.normalize();\n            direction.scaleInPlace(distance);\n            return this.globalPosition.add(direction);\n        };\n        TargetCamera.prototype._getLockedTargetPosition = function () {\n            if (!this.lockedTarget) {\n                return null;\n            }\n            if (this.lockedTarget.absolutePosition) {\n                this.lockedTarget.computeWorldMatrix();\n            }\n            return this.lockedTarget.absolutePosition || this.lockedTarget;\n        };\n        // Cache\n        TargetCamera.prototype._initCache = function () {\n            _super.prototype._initCache.call(this);\n            this._cache.lockedTarget = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            this._cache.rotation = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            this._cache.rotationQuaternion = new BABYLON.Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        };\n        TargetCamera.prototype._updateCache = function (ignoreParentClass) {\n            if (!ignoreParentClass) {\n                _super.prototype._updateCache.call(this);\n            }\n            var lockedTargetPosition = this._getLockedTargetPosition();\n            if (!lockedTargetPosition) {\n                this._cache.lockedTarget = null;\n            }\n            else {\n                if (!this._cache.lockedTarget) {\n                    this._cache.lockedTarget = lockedTargetPosition.clone();\n                }\n                else {\n                    this._cache.lockedTarget.copyFrom(lockedTargetPosition);\n                }\n            }\n            this._cache.rotation.copyFrom(this.rotation);\n            if (this.rotationQuaternion)\n                this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\n        };\n        // Synchronized\n        TargetCamera.prototype._isSynchronizedViewMatrix = function () {\n            if (!_super.prototype._isSynchronizedViewMatrix.call(this)) {\n                return false;\n            }\n            var lockedTargetPosition = this._getLockedTargetPosition();\n            return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition)\n                && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));\n        };\n        // Methods\n        TargetCamera.prototype._computeLocalCameraSpeed = function () {\n            var engine = this.getEngine();\n            return this.speed * Math.sqrt((engine.getDeltaTime() / (engine.getFps() * 100.0)));\n        };\n        // Target\n        TargetCamera.prototype.setTarget = function (target) {\n            this.upVector.normalize();\n            BABYLON.Matrix.LookAtLHToRef(this.position, target, this._defaultUpVector, this._camMatrix);\n            this._camMatrix.invert();\n            this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);\n            var vDir = target.subtract(this.position);\n            if (vDir.x >= 0.0) {\n                this.rotation.y = (-Math.atan(vDir.z / vDir.x) + Math.PI / 2.0);\n            }\n            else {\n                this.rotation.y = (-Math.atan(vDir.z / vDir.x) - Math.PI / 2.0);\n            }\n            this.rotation.z = 0;\n            if (isNaN(this.rotation.x)) {\n                this.rotation.x = 0;\n            }\n            if (isNaN(this.rotation.y)) {\n                this.rotation.y = 0;\n            }\n            if (isNaN(this.rotation.z)) {\n                this.rotation.z = 0;\n            }\n            if (this.rotationQuaternion) {\n                BABYLON.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n            }\n        };\n        /**\n         * Return the current target position of the camera. This value is expressed in local space.\n         */\n        TargetCamera.prototype.getTarget = function () {\n            return this._currentTarget;\n        };\n        TargetCamera.prototype._decideIfNeedsToMove = function () {\n            return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n        };\n        TargetCamera.prototype._updatePosition = function () {\n            if (this.parent) {\n                this.parent.getWorldMatrix().invertToRef(BABYLON.Tmp.Matrix[0]);\n                BABYLON.Vector3.TransformNormalToRef(this.cameraDirection, BABYLON.Tmp.Matrix[0], BABYLON.Tmp.Vector3[0]);\n                this.position.addInPlace(BABYLON.Tmp.Vector3[0]);\n                return;\n            }\n            this.position.addInPlace(this.cameraDirection);\n        };\n        TargetCamera.prototype._checkInputs = function () {\n            var needToMove = this._decideIfNeedsToMove();\n            var needToRotate = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;\n            // Move\n            if (needToMove) {\n                this._updatePosition();\n            }\n            // Rotate\n            if (needToRotate) {\n                this.rotation.x += this.cameraRotation.x;\n                this.rotation.y += this.cameraRotation.y;\n                //rotate, if quaternion is set and rotation was used\n                if (this.rotationQuaternion) {\n                    var len = this.rotation.lengthSquared();\n                    if (len) {\n                        BABYLON.Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);\n                    }\n                }\n                if (!this.noRotationConstraint) {\n                    var limit = (Math.PI / 2) * 0.95;\n                    if (this.rotation.x > limit)\n                        this.rotation.x = limit;\n                    if (this.rotation.x < -limit)\n                        this.rotation.x = -limit;\n                }\n            }\n            // Inertia\n            if (needToMove) {\n                if (Math.abs(this.cameraDirection.x) < this.speed * BABYLON.Epsilon) {\n                    this.cameraDirection.x = 0;\n                }\n                if (Math.abs(this.cameraDirection.y) < this.speed * BABYLON.Epsilon) {\n                    this.cameraDirection.y = 0;\n                }\n                if (Math.abs(this.cameraDirection.z) < this.speed * BABYLON.Epsilon) {\n                    this.cameraDirection.z = 0;\n                }\n                this.cameraDirection.scaleInPlace(this.inertia);\n            }\n            if (needToRotate) {\n                if (Math.abs(this.cameraRotation.x) < this.speed * BABYLON.Epsilon) {\n                    this.cameraRotation.x = 0;\n                }\n                if (Math.abs(this.cameraRotation.y) < this.speed * BABYLON.Epsilon) {\n                    this.cameraRotation.y = 0;\n                }\n                this.cameraRotation.scaleInPlace(this.inertia);\n            }\n            _super.prototype._checkInputs.call(this);\n        };\n        TargetCamera.prototype._updateCameraRotationMatrix = function () {\n            if (this.rotationQuaternion) {\n                this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\n                //update the up vector!\n                BABYLON.Vector3.TransformNormalToRef(this._defaultUpVector, this._cameraRotationMatrix, this.upVector);\n            }\n            else {\n                BABYLON.Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\n            }\n        };\n        TargetCamera.prototype._getViewMatrix = function () {\n            if (!this.lockedTarget) {\n                // Compute\n                this._updateCameraRotationMatrix();\n                BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n                // Computing target and final matrix\n                this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n            }\n            else {\n                this._currentTarget.copyFrom(this._getLockedTargetPosition());\n            }\n            if (this.getScene().useRightHandedSystem) {\n                BABYLON.Matrix.LookAtRHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);\n            }\n            else {\n                BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._viewMatrix);\n            }\n            return this._viewMatrix;\n        };\n        /**\n         * @override\n         * Override Camera.createRigCamera\n         */\n        TargetCamera.prototype.createRigCamera = function (name, cameraIndex) {\n            if (this.cameraRigMode !== BABYLON.Camera.RIG_MODE_NONE) {\n                var rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\n                if (this.cameraRigMode === BABYLON.Camera.RIG_MODE_VR || this.cameraRigMode === BABYLON.Camera.RIG_MODE_WEBVR) {\n                    if (!this.rotationQuaternion) {\n                        this.rotationQuaternion = new BABYLON.Quaternion();\n                    }\n                    rigCamera._cameraRigParams = {};\n                    rigCamera.rotationQuaternion = new BABYLON.Quaternion();\n                }\n                return rigCamera;\n            }\n            return null;\n        };\n        /**\n         * @override\n         * Override Camera._updateRigCameras\n         */\n        TargetCamera.prototype._updateRigCameras = function () {\n            var camLeft = this._rigCameras[0];\n            var camRight = this._rigCameras[1];\n            switch (this.cameraRigMode) {\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n                    //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\n                    var leftSign = (this.cameraRigMode === BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? 1 : -1;\n                    var rightSign = (this.cameraRigMode === BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED) ? -1 : 1;\n                    this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft.position);\n                    this._getRigCamPosition(this._cameraRigParams.stereoHalfAngle * rightSign, camRight.position);\n                    camLeft.setTarget(this.getTarget());\n                    camRight.setTarget(this.getTarget());\n                    break;\n                case BABYLON.Camera.RIG_MODE_VR:\n                    if (camLeft.rotationQuaternion) {\n                        camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                        camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\n                    }\n                    else {\n                        camLeft.rotation.copyFrom(this.rotation);\n                        camRight.rotation.copyFrom(this.rotation);\n                    }\n                    camLeft.position.copyFrom(this.position);\n                    camRight.position.copyFrom(this.position);\n                    break;\n            }\n            _super.prototype._updateRigCameras.call(this);\n        };\n        TargetCamera.prototype._getRigCamPosition = function (halfSpace, result) {\n            if (!this._rigCamTransformMatrix) {\n                this._rigCamTransformMatrix = new BABYLON.Matrix();\n            }\n            var target = this.getTarget();\n            BABYLON.Matrix.Translation(-target.x, -target.y, -target.z).multiplyToRef(BABYLON.Matrix.RotationY(halfSpace), this._rigCamTransformMatrix);\n            this._rigCamTransformMatrix = this._rigCamTransformMatrix.multiply(BABYLON.Matrix.Translation(target.x, target.y, target.z));\n            BABYLON.Vector3.TransformCoordinatesToRef(this.position, this._rigCamTransformMatrix, result);\n        };\n        TargetCamera.prototype.getClassName = function () {\n            return \"TargetCamera\";\n        };\n        return TargetCamera;\n    }(BABYLON.Camera));\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], TargetCamera.prototype, \"rotation\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], TargetCamera.prototype, \"speed\", void 0);\n    __decorate([\n        BABYLON.serializeAsMeshReference(\"lockedTargetId\")\n    ], TargetCamera.prototype, \"lockedTarget\", void 0);\n    BABYLON.TargetCamera = TargetCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.targetCamera.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCamera = (function (_super) {\n        __extends(FreeCamera, _super);\n        function FreeCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);\n            _this.checkCollisions = false;\n            _this.applyGravity = false;\n            _this._needMoveForGravity = false;\n            _this._oldPosition = BABYLON.Vector3.Zero();\n            _this._diffPosition = BABYLON.Vector3.Zero();\n            _this._newPosition = BABYLON.Vector3.Zero();\n            // Collisions\n            _this._collisionMask = -1;\n            _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n                if (collidedMesh === void 0) { collidedMesh = null; }\n                //TODO move this to the collision coordinator!\n                if (_this.getScene().workerCollisions)\n                    newPosition.multiplyInPlace(_this._collider.radius);\n                var updatePosition = function (newPos) {\n                    _this._newPosition.copyFrom(newPos);\n                    _this._newPosition.subtractToRef(_this._oldPosition, _this._diffPosition);\n                    var oldPosition = _this.position.clone();\n                    if (_this._diffPosition.length() > BABYLON.Engine.CollisionsEpsilon) {\n                        _this.position.addInPlace(_this._diffPosition);\n                        if (_this.onCollide && collidedMesh) {\n                            _this.onCollide(collidedMesh);\n                        }\n                    }\n                };\n                updatePosition(newPosition);\n            };\n            _this.inputs = new BABYLON.FreeCameraInputsManager(_this);\n            _this.inputs.addKeyboard().addMouse();\n            return _this;\n        }\n        Object.defineProperty(FreeCamera.prototype, \"angularSensibility\", {\n            //-- begin properties for backward compatibility for inputs\n            get: function () {\n                var mouse = this.inputs.attached[\"mouse\"];\n                if (mouse)\n                    return mouse.angularSensibility;\n            },\n            set: function (value) {\n                var mouse = this.inputs.attached[\"mouse\"];\n                if (mouse)\n                    mouse.angularSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FreeCamera.prototype, \"keysUp\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysUp;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysUp = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FreeCamera.prototype, \"keysDown\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysDown;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysDown = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FreeCamera.prototype, \"keysLeft\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysLeft;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysLeft = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FreeCamera.prototype, \"keysRight\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysRight;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysRight = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Controls\n        FreeCamera.prototype.attachControl = function (element, noPreventDefault) {\n            this.inputs.attachElement(element, noPreventDefault);\n        };\n        FreeCamera.prototype.detachControl = function (element) {\n            this.inputs.detachElement(element);\n            this.cameraDirection = new BABYLON.Vector3(0, 0, 0);\n            this.cameraRotation = new BABYLON.Vector2(0, 0);\n        };\n        Object.defineProperty(FreeCamera.prototype, \"collisionMask\", {\n            get: function () {\n                return this._collisionMask;\n            },\n            set: function (mask) {\n                this._collisionMask = !isNaN(mask) ? mask : -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        FreeCamera.prototype._collideWithWorld = function (velocity) {\n            var globalPosition;\n            if (this.parent) {\n                globalPosition = BABYLON.Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\n            }\n            else {\n                globalPosition = this.position;\n            }\n            globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\n            if (!this._collider) {\n                this._collider = new BABYLON.Collider();\n            }\n            this._collider.radius = this.ellipsoid;\n            this._collider.collisionMask = this._collisionMask;\n            //no need for clone, as long as gravity is not on.\n            var actualVelocity = velocity;\n            //add gravity to the velocity to prevent the dual-collision checking\n            if (this.applyGravity) {\n                //this prevents mending with cameraDirection, a global variable of the free camera class.\n                actualVelocity = velocity.add(this.getScene().gravity);\n            }\n            this.getScene().collisionCoordinator.getNewPosition(this._oldPosition, actualVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n        };\n        FreeCamera.prototype._checkInputs = function () {\n            if (!this._localDirection) {\n                this._localDirection = BABYLON.Vector3.Zero();\n                this._transformedDirection = BABYLON.Vector3.Zero();\n            }\n            this.inputs.checkInputs();\n            _super.prototype._checkInputs.call(this);\n        };\n        FreeCamera.prototype._decideIfNeedsToMove = function () {\n            return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\n        };\n        FreeCamera.prototype._updatePosition = function () {\n            if (this.checkCollisions && this.getScene().collisionsEnabled) {\n                this._collideWithWorld(this.cameraDirection);\n            }\n            else {\n                _super.prototype._updatePosition.call(this);\n            }\n        };\n        FreeCamera.prototype.dispose = function () {\n            this.inputs.clear();\n            _super.prototype.dispose.call(this);\n        };\n        FreeCamera.prototype.getClassName = function () {\n            return \"FreeCamera\";\n        };\n        return FreeCamera;\n    }(BABYLON.TargetCamera));\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], FreeCamera.prototype, \"ellipsoid\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCamera.prototype, \"checkCollisions\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCamera.prototype, \"applyGravity\", void 0);\n    BABYLON.FreeCamera = FreeCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCamera.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCameraKeyboardMoveInput = (function () {\n        function ArcRotateCameraKeyboardMoveInput() {\n            this._keys = [];\n            this.keysUp = [38];\n            this.keysDown = [40];\n            this.keysLeft = [37];\n            this.keysRight = [39];\n        }\n        ArcRotateCameraKeyboardMoveInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            element.tabIndex = 1;\n            this._onKeyDown = function (evt) {\n                if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysRight.indexOf(evt.keyCode) !== -1) {\n                    var index = _this._keys.indexOf(evt.keyCode);\n                    if (index === -1) {\n                        _this._keys.push(evt.keyCode);\n                    }\n                    if (evt.preventDefault) {\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            };\n            this._onKeyUp = function (evt) {\n                if (_this.keysUp.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysDown.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysLeft.indexOf(evt.keyCode) !== -1 ||\n                    _this.keysRight.indexOf(evt.keyCode) !== -1) {\n                    var index = _this._keys.indexOf(evt.keyCode);\n                    if (index >= 0) {\n                        _this._keys.splice(index, 1);\n                    }\n                    if (evt.preventDefault) {\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                    }\n                }\n            };\n            this._onLostFocus = function () {\n                _this._keys = [];\n            };\n            element.addEventListener(\"keydown\", this._onKeyDown, false);\n            element.addEventListener(\"keyup\", this._onKeyUp, false);\n            BABYLON.Tools.RegisterTopRootEvents([\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n        };\n        ArcRotateCameraKeyboardMoveInput.prototype.detachControl = function (element) {\n            if (element) {\n                element.removeEventListener(\"keydown\", this._onKeyDown);\n                element.removeEventListener(\"keyup\", this._onKeyUp);\n            }\n            BABYLON.Tools.UnregisterTopRootEvents([\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n            this._keys = [];\n            this._onKeyDown = null;\n            this._onKeyUp = null;\n            this._onLostFocus = null;\n        };\n        ArcRotateCameraKeyboardMoveInput.prototype.checkInputs = function () {\n            if (this._onKeyDown) {\n                var camera = this.camera;\n                for (var index = 0; index < this._keys.length; index++) {\n                    var keyCode = this._keys[index];\n                    if (this.keysLeft.indexOf(keyCode) !== -1) {\n                        camera.inertialAlphaOffset -= 0.01;\n                    }\n                    else if (this.keysUp.indexOf(keyCode) !== -1) {\n                        camera.inertialBetaOffset -= 0.01;\n                    }\n                    else if (this.keysRight.indexOf(keyCode) !== -1) {\n                        camera.inertialAlphaOffset += 0.01;\n                    }\n                    else if (this.keysDown.indexOf(keyCode) !== -1) {\n                        camera.inertialBetaOffset += 0.01;\n                    }\n                }\n            }\n        };\n        ArcRotateCameraKeyboardMoveInput.prototype.getTypeName = function () {\n            return \"ArcRotateCameraKeyboardMoveInput\";\n        };\n        ArcRotateCameraKeyboardMoveInput.prototype.getSimpleName = function () {\n            return \"keyboard\";\n        };\n        return ArcRotateCameraKeyboardMoveInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysUp\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysDown\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysLeft\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraKeyboardMoveInput.prototype, \"keysRight\", void 0);\n    BABYLON.ArcRotateCameraKeyboardMoveInput = ArcRotateCameraKeyboardMoveInput;\n    BABYLON.CameraInputTypes[\"ArcRotateCameraKeyboardMoveInput\"] = ArcRotateCameraKeyboardMoveInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraKeyboardMoveInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCameraMouseWheelInput = (function () {\n        function ArcRotateCameraMouseWheelInput() {\n            this.wheelPrecision = 3.0;\n        }\n        ArcRotateCameraMouseWheelInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            this._wheel = function (p, s) {\n                //sanity check - this should be a PointerWheel event.\n                if (p.type !== BABYLON.PointerEventTypes.POINTERWHEEL)\n                    return;\n                var event = p.event;\n                var delta = 0;\n                if (event.wheelDelta) {\n                    delta = event.wheelDelta / (_this.wheelPrecision * 40);\n                }\n                else if (event.detail) {\n                    delta = -event.detail / _this.wheelPrecision;\n                }\n                if (delta)\n                    _this.camera.inertialRadiusOffset += delta;\n                if (event.preventDefault) {\n                    if (!noPreventDefault) {\n                        event.preventDefault();\n                    }\n                }\n            };\n            this._observer = this.camera.getScene().onPointerObservable.add(this._wheel, BABYLON.PointerEventTypes.POINTERWHEEL);\n        };\n        ArcRotateCameraMouseWheelInput.prototype.detachControl = function (element) {\n            if (this._observer && element) {\n                this.camera.getScene().onPointerObservable.remove(this._observer);\n                this._observer = null;\n                this._wheel = null;\n            }\n        };\n        ArcRotateCameraMouseWheelInput.prototype.getTypeName = function () {\n            return \"ArcRotateCameraMouseWheelInput\";\n        };\n        ArcRotateCameraMouseWheelInput.prototype.getSimpleName = function () {\n            return \"mousewheel\";\n        };\n        return ArcRotateCameraMouseWheelInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraMouseWheelInput.prototype, \"wheelPrecision\", void 0);\n    BABYLON.ArcRotateCameraMouseWheelInput = ArcRotateCameraMouseWheelInput;\n    BABYLON.CameraInputTypes[\"ArcRotateCameraMouseWheelInput\"] = ArcRotateCameraMouseWheelInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraMouseWheelInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var eventPrefix = BABYLON.Tools.GetPointerPrefix();\n    var ArcRotateCameraPointersInput = (function () {\n        function ArcRotateCameraPointersInput() {\n            this.buttons = [0, 1, 2];\n            this.angularSensibilityX = 1000.0;\n            this.angularSensibilityY = 1000.0;\n            this.pinchPrecision = 6.0;\n            this.panningSensibility = 50.0;\n            this._isPanClick = false;\n            this.pinchInwards = true;\n        }\n        ArcRotateCameraPointersInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            var engine = this.camera.getEngine();\n            var cacheSoloPointer; // cache pointer object for better perf on camera rotation\n            var pointA, pointB;\n            var previousPinchDistance = 0;\n            this._pointerInput = function (p, s) {\n                var evt = p.event;\n                if (p.type !== BABYLON.PointerEventTypes.POINTERMOVE && _this.buttons.indexOf(evt.button) === -1) {\n                    return;\n                }\n                if (p.type === BABYLON.PointerEventTypes.POINTERDOWN) {\n                    try {\n                        evt.srcElement.setPointerCapture(evt.pointerId);\n                    }\n                    catch (e) {\n                        //Nothing to do with the error. Execution will continue.\n                    }\n                    // Manage panning with pan button click\n                    _this._isPanClick = evt.button === _this.camera._panningMouseButton;\n                    // manage pointers\n                    cacheSoloPointer = { x: evt.clientX, y: evt.clientY, pointerId: evt.pointerId, type: evt.pointerType };\n                    if (pointA === undefined) {\n                        pointA = cacheSoloPointer;\n                    }\n                    else if (pointB === undefined) {\n                        pointB = cacheSoloPointer;\n                    }\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                        element.focus();\n                    }\n                }\n                else if (p.type === BABYLON.PointerEventTypes.POINTERUP) {\n                    try {\n                        evt.srcElement.releasePointerCapture(evt.pointerId);\n                    }\n                    catch (e) {\n                        //Nothing to do with the error.\n                    }\n                    cacheSoloPointer = null;\n                    previousPinchDistance = 0;\n                    //would be better to use pointers.remove(evt.pointerId) for multitouch gestures, \n                    //but emptying completly pointers collection is required to fix a bug on iPhone : \n                    //when changing orientation while pinching camera, one pointer stay pressed forever if we don't release all pointers  \n                    //will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n                    pointA = pointB = undefined;\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                }\n                else if (p.type === BABYLON.PointerEventTypes.POINTERMOVE) {\n                    if (!noPreventDefault) {\n                        evt.preventDefault();\n                    }\n                    // One button down\n                    if (pointA && pointB === undefined) {\n                        if (_this.panningSensibility !== 0 &&\n                            ((evt.ctrlKey && _this.camera._useCtrlForPanning) ||\n                                (!_this.camera._useCtrlForPanning && _this._isPanClick))) {\n                            _this.camera\n                                .inertialPanningX += -(evt.clientX - cacheSoloPointer.x) / _this.panningSensibility;\n                            _this.camera\n                                .inertialPanningY += (evt.clientY - cacheSoloPointer.y) / _this.panningSensibility;\n                        }\n                        else {\n                            var offsetX = evt.clientX - cacheSoloPointer.x;\n                            var offsetY = evt.clientY - cacheSoloPointer.y;\n                            _this.camera.inertialAlphaOffset -= offsetX / _this.angularSensibilityX;\n                            _this.camera.inertialBetaOffset -= offsetY / _this.angularSensibilityY;\n                        }\n                        cacheSoloPointer.x = evt.clientX;\n                        cacheSoloPointer.y = evt.clientY;\n                    }\n                    else if (pointA && pointB) {\n                        //if (noPreventDefault) { evt.preventDefault(); } //if pinch gesture, could be useful to force preventDefault to avoid html page scroll/zoom in some mobile browsers\n                        var ed = (pointA.pointerId === evt.pointerId) ? pointA : pointB;\n                        ed.x = evt.clientX;\n                        ed.y = evt.clientY;\n                        var direction = _this.pinchInwards ? 1 : -1;\n                        var distX = pointA.x - pointB.x;\n                        var distY = pointA.y - pointB.y;\n                        var pinchSquaredDistance = (distX * distX) + (distY * distY);\n                        if (previousPinchDistance === 0) {\n                            previousPinchDistance = pinchSquaredDistance;\n                            return;\n                        }\n                        if (pinchSquaredDistance !== previousPinchDistance) {\n                            _this.camera\n                                .inertialRadiusOffset += (pinchSquaredDistance - previousPinchDistance) /\n                                (_this.pinchPrecision *\n                                    ((_this.angularSensibilityX + _this.angularSensibilityY) / 2) *\n                                    direction);\n                            previousPinchDistance = pinchSquaredDistance;\n                        }\n                    }\n                }\n            };\n            this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, BABYLON.PointerEventTypes.POINTERDOWN | BABYLON.PointerEventTypes.POINTERUP | BABYLON.PointerEventTypes.POINTERMOVE);\n            this._onContextMenu = function (evt) {\n                evt.preventDefault();\n            };\n            if (!this.camera._useCtrlForPanning) {\n                element.addEventListener(\"contextmenu\", this._onContextMenu, false);\n            }\n            this._onLostFocus = function () {\n                //this._keys = [];\n                pointA = pointB = undefined;\n                previousPinchDistance = 0;\n                cacheSoloPointer = null;\n            };\n            this._onMouseMove = function (evt) {\n                if (!engine.isPointerLock) {\n                    return;\n                }\n                var offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n                var offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n                _this.camera.inertialAlphaOffset -= offsetX / _this.angularSensibilityX;\n                _this.camera.inertialBetaOffset -= offsetY / _this.angularSensibilityY;\n                if (!noPreventDefault) {\n                    evt.preventDefault();\n                }\n            };\n            this._onGestureStart = function (e) {\n                if (window.MSGesture === undefined) {\n                    return;\n                }\n                if (!_this._MSGestureHandler) {\n                    _this._MSGestureHandler = new MSGesture();\n                    _this._MSGestureHandler.target = element;\n                }\n                _this._MSGestureHandler.addPointer(e.pointerId);\n            };\n            this._onGesture = function (e) {\n                _this.camera.radius *= e.scale;\n                if (e.preventDefault) {\n                    if (!noPreventDefault) {\n                        e.stopPropagation();\n                        e.preventDefault();\n                    }\n                }\n            };\n            element.addEventListener(\"mousemove\", this._onMouseMove, false);\n            element.addEventListener(\"MSPointerDown\", this._onGestureStart, false);\n            element.addEventListener(\"MSGestureChange\", this._onGesture, false);\n            BABYLON.Tools.RegisterTopRootEvents([\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n        };\n        ArcRotateCameraPointersInput.prototype.detachControl = function (element) {\n            if (element && this._observer) {\n                this.camera.getScene().onPointerObservable.remove(this._observer);\n                this._observer = null;\n                element.removeEventListener(\"contextmenu\", this._onContextMenu);\n                element.removeEventListener(\"mousemove\", this._onMouseMove);\n                element.removeEventListener(\"MSPointerDown\", this._onGestureStart);\n                element.removeEventListener(\"MSGestureChange\", this._onGesture);\n                this._isPanClick = false;\n                this.pinchInwards = true;\n                this._onMouseMove = null;\n                this._onGestureStart = null;\n                this._onGesture = null;\n                this._MSGestureHandler = null;\n                this._onLostFocus = null;\n                this._onContextMenu = null;\n            }\n            BABYLON.Tools.UnregisterTopRootEvents([\n                { name: \"blur\", handler: this._onLostFocus }\n            ]);\n        };\n        ArcRotateCameraPointersInput.prototype.getTypeName = function () {\n            return \"ArcRotateCameraPointersInput\";\n        };\n        ArcRotateCameraPointersInput.prototype.getSimpleName = function () {\n            return \"pointers\";\n        };\n        return ArcRotateCameraPointersInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraPointersInput.prototype, \"buttons\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraPointersInput.prototype, \"angularSensibilityX\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraPointersInput.prototype, \"angularSensibilityY\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraPointersInput.prototype, \"pinchPrecision\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraPointersInput.prototype, \"panningSensibility\", void 0);\n    BABYLON.ArcRotateCameraPointersInput = ArcRotateCameraPointersInput;\n    BABYLON.CameraInputTypes[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraPointersInput.js.map\n\n/// <reference path=\"babylon.targetCamera.ts\" />\n/// <reference path=\"..\\Tools\\babylon.tools.ts\" />\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCamera = (function (_super) {\n        __extends(ArcRotateCamera, _super);\n        function ArcRotateCamera(name, alpha, beta, radius, target, scene) {\n            var _this = _super.call(this, name, BABYLON.Vector3.Zero(), scene) || this;\n            _this.inertialAlphaOffset = 0;\n            _this.inertialBetaOffset = 0;\n            _this.inertialRadiusOffset = 0;\n            _this.lowerAlphaLimit = null;\n            _this.upperAlphaLimit = null;\n            _this.lowerBetaLimit = 0.01;\n            _this.upperBetaLimit = Math.PI;\n            _this.lowerRadiusLimit = null;\n            _this.upperRadiusLimit = null;\n            _this.inertialPanningX = 0;\n            _this.inertialPanningY = 0;\n            _this.panningInertia = 0.9;\n            //-- end properties for backward compatibility for inputs\n            _this.zoomOnFactor = 1;\n            _this.targetScreenOffset = BABYLON.Vector2.Zero();\n            _this.allowUpsideDown = true;\n            _this._viewMatrix = new BABYLON.Matrix();\n            // Panning\n            _this.panningAxis = new BABYLON.Vector3(1, 1, 0);\n            _this.checkCollisions = false;\n            _this.collisionRadius = new BABYLON.Vector3(0.5, 0.5, 0.5);\n            _this._previousPosition = BABYLON.Vector3.Zero();\n            _this._collisionVelocity = BABYLON.Vector3.Zero();\n            _this._newPosition = BABYLON.Vector3.Zero();\n            _this._onCollisionPositionChange = function (collisionId, newPosition, collidedMesh) {\n                if (collidedMesh === void 0) { collidedMesh = null; }\n                if (_this.getScene().workerCollisions && _this.checkCollisions) {\n                    newPosition.multiplyInPlace(_this._collider.radius);\n                }\n                if (!collidedMesh) {\n                    _this._previousPosition.copyFrom(_this.position);\n                }\n                else {\n                    _this.setPosition(newPosition);\n                    if (_this.onCollide) {\n                        _this.onCollide(collidedMesh);\n                    }\n                }\n                // Recompute because of constraints\n                var cosa = Math.cos(_this.alpha);\n                var sina = Math.sin(_this.alpha);\n                var cosb = Math.cos(_this.beta);\n                var sinb = Math.sin(_this.beta);\n                if (sinb === 0) {\n                    sinb = 0.0001;\n                }\n                var target = _this._getTargetPosition();\n                target.addToRef(new BABYLON.Vector3(_this.radius * cosa * sinb, _this.radius * cosb, _this.radius * sina * sinb), _this._newPosition);\n                _this.position.copyFrom(_this._newPosition);\n                var up = _this.upVector;\n                if (_this.allowUpsideDown && _this.beta < 0) {\n                    up = up.clone();\n                    up = up.negate();\n                }\n                BABYLON.Matrix.LookAtLHToRef(_this.position, target, up, _this._viewMatrix);\n                _this._viewMatrix.m[12] += _this.targetScreenOffset.x;\n                _this._viewMatrix.m[13] += _this.targetScreenOffset.y;\n                _this._collisionTriggered = false;\n            };\n            _this._target = BABYLON.Vector3.Zero();\n            if (target) {\n                _this.setTarget(target);\n            }\n            _this.alpha = alpha;\n            _this.beta = beta;\n            _this.radius = radius;\n            _this.getViewMatrix();\n            _this.inputs = new BABYLON.ArcRotateCameraInputsManager(_this);\n            _this.inputs.addKeyboard().addMouseWheel().addPointers();\n            return _this;\n        }\n        Object.defineProperty(ArcRotateCamera.prototype, \"target\", {\n            get: function () {\n                return this._target;\n            },\n            set: function (value) {\n                this.setTarget(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityX\", {\n            //-- begin properties for backward compatibility for inputs\n            get: function () {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers)\n                    return pointers.angularSensibilityX;\n            },\n            set: function (value) {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers) {\n                    pointers.angularSensibilityX = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"angularSensibilityY\", {\n            get: function () {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers)\n                    return pointers.angularSensibilityY;\n            },\n            set: function (value) {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers) {\n                    pointers.angularSensibilityY = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"pinchPrecision\", {\n            get: function () {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers)\n                    return pointers.pinchPrecision;\n            },\n            set: function (value) {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers) {\n                    pointers.pinchPrecision = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"panningSensibility\", {\n            get: function () {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers)\n                    return pointers.panningSensibility;\n            },\n            set: function (value) {\n                var pointers = this.inputs.attached[\"pointers\"];\n                if (pointers) {\n                    pointers.panningSensibility = value;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"keysUp\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysUp;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysUp = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"keysDown\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysDown;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysDown = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"keysLeft\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysLeft;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysLeft = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"keysRight\", {\n            get: function () {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    return keyboard.keysRight;\n            },\n            set: function (value) {\n                var keyboard = this.inputs.attached[\"keyboard\"];\n                if (keyboard)\n                    keyboard.keysRight = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ArcRotateCamera.prototype, \"wheelPrecision\", {\n            get: function () {\n                var mousewheel = this.inputs.attached[\"mousewheel\"];\n                if (mousewheel)\n                    return mousewheel.wheelPrecision;\n            },\n            set: function (value) {\n                var mousewheel = this.inputs.attached[\"mousewheel\"];\n                if (mousewheel)\n                    mousewheel.wheelPrecision = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Cache\n        ArcRotateCamera.prototype._initCache = function () {\n            _super.prototype._initCache.call(this);\n            this._cache._target = new BABYLON.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n            this._cache.alpha = undefined;\n            this._cache.beta = undefined;\n            this._cache.radius = undefined;\n            this._cache.targetScreenOffset = BABYLON.Vector2.Zero();\n        };\n        ArcRotateCamera.prototype._updateCache = function (ignoreParentClass) {\n            if (!ignoreParentClass) {\n                _super.prototype._updateCache.call(this);\n            }\n            this._cache._target.copyFrom(this._getTargetPosition());\n            this._cache.alpha = this.alpha;\n            this._cache.beta = this.beta;\n            this._cache.radius = this.radius;\n            this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset);\n        };\n        ArcRotateCamera.prototype._getTargetPosition = function () {\n            if (this._targetHost && this._targetHost.getAbsolutePosition) {\n                var pos = this._targetHost.getAbsolutePosition();\n                if (this._targetBoundingCenter) {\n                    pos.addToRef(this._targetBoundingCenter, this._target);\n                }\n                else {\n                    this._target.copyFrom(pos);\n                }\n            }\n            var lockedTargetPosition = this._getLockedTargetPosition();\n            if (lockedTargetPosition) {\n                return lockedTargetPosition;\n            }\n            return this._target;\n        };\n        // Synchronized\n        ArcRotateCamera.prototype._isSynchronizedViewMatrix = function () {\n            if (!_super.prototype._isSynchronizedViewMatrix.call(this))\n                return false;\n            return this._cache._target.equals(this._getTargetPosition())\n                && this._cache.alpha === this.alpha\n                && this._cache.beta === this.beta\n                && this._cache.radius === this.radius\n                && this._cache.targetScreenOffset.equals(this.targetScreenOffset);\n        };\n        // Methods\n        ArcRotateCamera.prototype.attachControl = function (element, noPreventDefault, useCtrlForPanning, panningMouseButton) {\n            var _this = this;\n            if (useCtrlForPanning === void 0) { useCtrlForPanning = true; }\n            if (panningMouseButton === void 0) { panningMouseButton = 2; }\n            this._useCtrlForPanning = useCtrlForPanning;\n            this._panningMouseButton = panningMouseButton;\n            this.inputs.attachElement(element, noPreventDefault);\n            this._reset = function () {\n                _this.inertialAlphaOffset = 0;\n                _this.inertialBetaOffset = 0;\n                _this.inertialRadiusOffset = 0;\n            };\n        };\n        ArcRotateCamera.prototype.detachControl = function (element) {\n            this.inputs.detachElement(element);\n            if (this._reset) {\n                this._reset();\n            }\n        };\n        ArcRotateCamera.prototype._checkInputs = function () {\n            //if (async) collision inspection was triggered, don't update the camera's position - until the collision callback was called.\n            if (this._collisionTriggered) {\n                return;\n            }\n            this.inputs.checkInputs();\n            // Inertia\n            if (this.inertialAlphaOffset !== 0 || this.inertialBetaOffset !== 0 || this.inertialRadiusOffset !== 0) {\n                if (this.getScene().useRightHandedSystem) {\n                    this.alpha -= this.beta <= 0 ? -this.inertialAlphaOffset : this.inertialAlphaOffset;\n                }\n                else {\n                    this.alpha += this.beta <= 0 ? -this.inertialAlphaOffset : this.inertialAlphaOffset;\n                }\n                this.beta += this.inertialBetaOffset;\n                this.radius -= this.inertialRadiusOffset;\n                this.inertialAlphaOffset *= this.inertia;\n                this.inertialBetaOffset *= this.inertia;\n                this.inertialRadiusOffset *= this.inertia;\n                if (Math.abs(this.inertialAlphaOffset) < this.speed * BABYLON.Epsilon)\n                    this.inertialAlphaOffset = 0;\n                if (Math.abs(this.inertialBetaOffset) < this.speed * BABYLON.Epsilon)\n                    this.inertialBetaOffset = 0;\n                if (Math.abs(this.inertialRadiusOffset) < this.speed * BABYLON.Epsilon)\n                    this.inertialRadiusOffset = 0;\n            }\n            // Panning inertia\n            if (this.inertialPanningX !== 0 || this.inertialPanningY !== 0) {\n                if (!this._localDirection) {\n                    this._localDirection = BABYLON.Vector3.Zero();\n                    this._transformedDirection = BABYLON.Vector3.Zero();\n                }\n                this._localDirection.copyFromFloats(this.inertialPanningX, this.inertialPanningY, this.inertialPanningY);\n                this._localDirection.multiplyInPlace(this.panningAxis);\n                this._viewMatrix.invertToRef(this._cameraTransformMatrix);\n                BABYLON.Vector3.TransformNormalToRef(this._localDirection, this._cameraTransformMatrix, this._transformedDirection);\n                //Eliminate y if map panning is enabled (panningAxis == 1,0,1)\n                if (!this.panningAxis.y) {\n                    this._transformedDirection.y = 0;\n                }\n                if (!this._targetHost) {\n                    this._target.addInPlace(this._transformedDirection);\n                }\n                this.inertialPanningX *= this.panningInertia;\n                this.inertialPanningY *= this.panningInertia;\n                if (Math.abs(this.inertialPanningX) < this.speed * BABYLON.Epsilon)\n                    this.inertialPanningX = 0;\n                if (Math.abs(this.inertialPanningY) < this.speed * BABYLON.Epsilon)\n                    this.inertialPanningY = 0;\n            }\n            // Limits\n            this._checkLimits();\n            _super.prototype._checkInputs.call(this);\n        };\n        ArcRotateCamera.prototype._checkLimits = function () {\n            if (this.lowerBetaLimit === null || this.lowerBetaLimit === undefined) {\n                if (this.allowUpsideDown && this.beta > Math.PI) {\n                    this.beta = this.beta - (2 * Math.PI);\n                }\n            }\n            else {\n                if (this.beta < this.lowerBetaLimit) {\n                    this.beta = this.lowerBetaLimit;\n                }\n            }\n            if (this.upperBetaLimit === null || this.upperBetaLimit === undefined) {\n                if (this.allowUpsideDown && this.beta < -Math.PI) {\n                    this.beta = this.beta + (2 * Math.PI);\n                }\n            }\n            else {\n                if (this.beta > this.upperBetaLimit) {\n                    this.beta = this.upperBetaLimit;\n                }\n            }\n            if (this.lowerAlphaLimit && this.alpha < this.lowerAlphaLimit) {\n                this.alpha = this.lowerAlphaLimit;\n            }\n            if (this.upperAlphaLimit && this.alpha > this.upperAlphaLimit) {\n                this.alpha = this.upperAlphaLimit;\n            }\n            if (this.lowerRadiusLimit && this.radius < this.lowerRadiusLimit) {\n                this.radius = this.lowerRadiusLimit;\n            }\n            if (this.upperRadiusLimit && this.radius > this.upperRadiusLimit) {\n                this.radius = this.upperRadiusLimit;\n            }\n        };\n        ArcRotateCamera.prototype.rebuildAnglesAndRadius = function () {\n            var radiusv3 = this.position.subtract(this._getTargetPosition());\n            this.radius = radiusv3.length();\n            // Alpha\n            this.alpha = Math.acos(radiusv3.x / Math.sqrt(Math.pow(radiusv3.x, 2) + Math.pow(radiusv3.z, 2)));\n            if (radiusv3.z < 0) {\n                this.alpha = 2 * Math.PI - this.alpha;\n            }\n            // Beta\n            this.beta = Math.acos(radiusv3.y / this.radius);\n            this._checkLimits();\n        };\n        ArcRotateCamera.prototype.setPosition = function (position) {\n            if (this.position.equals(position)) {\n                return;\n            }\n            this.position.copyFrom(position);\n            this.rebuildAnglesAndRadius();\n        };\n        ArcRotateCamera.prototype.setTarget = function (target, toBoundingCenter, allowSamePosition) {\n            if (toBoundingCenter === void 0) { toBoundingCenter = false; }\n            if (allowSamePosition === void 0) { allowSamePosition = false; }\n            if (target.getBoundingInfo) {\n                if (toBoundingCenter) {\n                    this._targetBoundingCenter = target.getBoundingInfo().boundingBox.centerWorld.clone();\n                }\n                else {\n                    this._targetBoundingCenter = null;\n                }\n                this._targetHost = target;\n                this._target = this._getTargetPosition();\n            }\n            else {\n                var newTarget = target;\n                var currentTarget = this._getTargetPosition();\n                if (currentTarget && !allowSamePosition && currentTarget.equals(newTarget)) {\n                    return;\n                }\n                this._target = newTarget;\n                this._targetBoundingCenter = null;\n            }\n            this.rebuildAnglesAndRadius();\n        };\n        ArcRotateCamera.prototype._getViewMatrix = function () {\n            // Compute\n            var cosa = Math.cos(this.alpha);\n            var sina = Math.sin(this.alpha);\n            var cosb = Math.cos(this.beta);\n            var sinb = Math.sin(this.beta);\n            if (sinb === 0) {\n                sinb = 0.0001;\n            }\n            var target = this._getTargetPosition();\n            target.addToRef(new BABYLON.Vector3(this.radius * cosa * sinb, this.radius * cosb, this.radius * sina * sinb), this._newPosition);\n            if (this.getScene().collisionsEnabled && this.checkCollisions) {\n                if (!this._collider) {\n                    this._collider = new BABYLON.Collider();\n                }\n                this._collider.radius = this.collisionRadius;\n                this._newPosition.subtractToRef(this.position, this._collisionVelocity);\n                this._collisionTriggered = true;\n                this.getScene().collisionCoordinator.getNewPosition(this.position, this._collisionVelocity, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\n            }\n            else {\n                this.position.copyFrom(this._newPosition);\n                var up = this.upVector;\n                if (this.allowUpsideDown && sinb < 0) {\n                    up = up.clone();\n                    up = up.negate();\n                }\n                if (this.getScene().useRightHandedSystem) {\n                    BABYLON.Matrix.LookAtRHToRef(this.position, target, up, this._viewMatrix);\n                }\n                else {\n                    BABYLON.Matrix.LookAtLHToRef(this.position, target, up, this._viewMatrix);\n                }\n                this._viewMatrix.m[12] += this.targetScreenOffset.x;\n                this._viewMatrix.m[13] += this.targetScreenOffset.y;\n            }\n            this._currentTarget = target;\n            return this._viewMatrix;\n        };\n        ArcRotateCamera.prototype.zoomOn = function (meshes, doNotUpdateMaxZ) {\n            if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }\n            meshes = meshes || this.getScene().meshes;\n            var minMaxVector = BABYLON.Mesh.MinMax(meshes);\n            var distance = BABYLON.Vector3.Distance(minMaxVector.min, minMaxVector.max);\n            this.radius = distance * this.zoomOnFactor;\n            this.focusOn({ min: minMaxVector.min, max: minMaxVector.max, distance: distance }, doNotUpdateMaxZ);\n        };\n        ArcRotateCamera.prototype.focusOn = function (meshesOrMinMaxVectorAndDistance, doNotUpdateMaxZ) {\n            if (doNotUpdateMaxZ === void 0) { doNotUpdateMaxZ = false; }\n            var meshesOrMinMaxVector;\n            var distance;\n            if (meshesOrMinMaxVectorAndDistance.min === undefined) {\n                meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance || this.getScene().meshes;\n                meshesOrMinMaxVector = BABYLON.Mesh.MinMax(meshesOrMinMaxVector);\n                distance = BABYLON.Vector3.Distance(meshesOrMinMaxVector.min, meshesOrMinMaxVector.max);\n            }\n            else {\n                meshesOrMinMaxVector = meshesOrMinMaxVectorAndDistance;\n                distance = meshesOrMinMaxVectorAndDistance.distance;\n            }\n            this._target = BABYLON.Mesh.Center(meshesOrMinMaxVector);\n            if (!doNotUpdateMaxZ) {\n                this.maxZ = distance * 2;\n            }\n        };\n        /**\n         * @override\n         * Override Camera.createRigCamera\n         */\n        ArcRotateCamera.prototype.createRigCamera = function (name, cameraIndex) {\n            var alphaShift;\n            switch (this.cameraRigMode) {\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n                case BABYLON.Camera.RIG_MODE_VR:\n                    alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? 1 : -1);\n                    break;\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                    alphaShift = this._cameraRigParams.stereoHalfAngle * (cameraIndex === 0 ? -1 : 1);\n                    break;\n            }\n            var rigCam = new ArcRotateCamera(name, this.alpha + alphaShift, this.beta, this.radius, this._target, this.getScene());\n            rigCam._cameraRigParams = {};\n            return rigCam;\n        };\n        /**\n         * @override\n         * Override Camera._updateRigCameras\n         */\n        ArcRotateCamera.prototype._updateRigCameras = function () {\n            var camLeft = this._rigCameras[0];\n            var camRight = this._rigCameras[1];\n            camLeft.beta = camRight.beta = this.beta;\n            camLeft.radius = camRight.radius = this.radius;\n            switch (this.cameraRigMode) {\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\n                case BABYLON.Camera.RIG_MODE_VR:\n                    camLeft.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n                    camRight.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n                    break;\n                case BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\n                    camLeft.alpha = this.alpha + this._cameraRigParams.stereoHalfAngle;\n                    camRight.alpha = this.alpha - this._cameraRigParams.stereoHalfAngle;\n                    break;\n            }\n            _super.prototype._updateRigCameras.call(this);\n        };\n        ArcRotateCamera.prototype.dispose = function () {\n            this.inputs.clear();\n            _super.prototype.dispose.call(this);\n        };\n        ArcRotateCamera.prototype.getClassName = function () {\n            return \"ArcRotateCamera\";\n        };\n        return ArcRotateCamera;\n    }(BABYLON.TargetCamera));\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"alpha\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"beta\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"radius\", void 0);\n    __decorate([\n        BABYLON.serializeAsVector3(\"target\")\n    ], ArcRotateCamera.prototype, \"_target\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"inertialAlphaOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"inertialBetaOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"inertialRadiusOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"lowerAlphaLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"upperAlphaLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"lowerBetaLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"upperBetaLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"lowerRadiusLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"upperRadiusLimit\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"inertialPanningX\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"inertialPanningY\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"panningInertia\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"zoomOnFactor\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCamera.prototype, \"allowUpsideDown\", void 0);\n    BABYLON.ArcRotateCamera = ArcRotateCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCamera.js.map\n\n/// <reference path=\"..\\Cameras\\babylon.cameraInputsManager.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCameraInputsManager = (function (_super) {\n        __extends(ArcRotateCameraInputsManager, _super);\n        function ArcRotateCameraInputsManager(camera) {\n            return _super.call(this, camera) || this;\n        }\n        ArcRotateCameraInputsManager.prototype.addMouseWheel = function () {\n            this.add(new BABYLON.ArcRotateCameraMouseWheelInput());\n            return this;\n        };\n        ArcRotateCameraInputsManager.prototype.addPointers = function () {\n            this.add(new BABYLON.ArcRotateCameraPointersInput());\n            return this;\n        };\n        ArcRotateCameraInputsManager.prototype.addKeyboard = function () {\n            this.add(new BABYLON.ArcRotateCameraKeyboardMoveInput());\n            return this;\n        };\n        ArcRotateCameraInputsManager.prototype.addGamepad = function () {\n            this.add(new BABYLON.ArcRotateCameraGamepadInput());\n            return this;\n        };\n        ArcRotateCameraInputsManager.prototype.addVRDeviceOrientation = function () {\n            this.add(new BABYLON.ArcRotateCameraVRDeviceOrientationInput());\n            return this;\n        };\n        return ArcRotateCameraInputsManager;\n    }(BABYLON.CameraInputsManager));\n    BABYLON.ArcRotateCameraInputsManager = ArcRotateCameraInputsManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraInputsManager.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var HemisphericLight = (function (_super) {\n        __extends(HemisphericLight, _super);\n        /**\n         * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\n         * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\n         * The HemisphericLight can't cast shadows.\n         * Documentation : http://doc.babylonjs.com/tutorials/lights\n         */\n        function HemisphericLight(name, direction, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.groundColor = new BABYLON.Color3(0.0, 0.0, 0.0);\n            _this.direction = direction || BABYLON.Vector3.Up();\n            return _this;\n        }\n        HemisphericLight.prototype._buildUniformLayout = function () {\n            this._uniformBuffer.addUniform(\"vLightData\", 4);\n            this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n            this._uniformBuffer.addUniform(\"vLightSpecular\", 3);\n            this._uniformBuffer.addUniform(\"vLightGround\", 3);\n            this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n            this._uniformBuffer.addUniform(\"depthValues\", 2);\n            this._uniformBuffer.create();\n        };\n        /**\n         * Returns the string \"HemisphericLight\".\n         */\n        HemisphericLight.prototype.getClassName = function () {\n            return \"HemisphericLight\";\n        };\n        /**\n         * Sets the HemisphericLight direction towards the passed target (Vector3).\n         * Returns the updated direction.\n         */\n        HemisphericLight.prototype.setDirectionToTarget = function (target) {\n            this.direction = BABYLON.Vector3.Normalize(target.subtract(BABYLON.Vector3.Zero()));\n            return this.direction;\n        };\n        HemisphericLight.prototype.getShadowGenerator = function () {\n            return null;\n        };\n        /**\n         * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\n         * Returns the HemisphericLight.\n         */\n        HemisphericLight.prototype.transferToEffect = function (effect, lightIndex) {\n            var normalizeDirection = BABYLON.Vector3.Normalize(this.direction);\n            this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\n            this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\n            return this;\n        };\n        HemisphericLight.prototype._getWorldMatrix = function () {\n            if (!this._worldMatrix) {\n                this._worldMatrix = BABYLON.Matrix.Identity();\n            }\n            return this._worldMatrix;\n        };\n        /**\n         * Returns the integer 3.\n         */\n        HemisphericLight.prototype.getTypeID = function () {\n            return BABYLON.Light.LIGHTTYPEID_HEMISPHERICLIGHT;\n        };\n        return HemisphericLight;\n    }(BABYLON.Light));\n    __decorate([\n        BABYLON.serializeAsColor3()\n    ], HemisphericLight.prototype, \"groundColor\", void 0);\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], HemisphericLight.prototype, \"direction\", void 0);\n    BABYLON.HemisphericLight = HemisphericLight;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.hemisphericLight.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ShadowLight = (function (_super) {\n        __extends(ShadowLight, _super);\n        function ShadowLight() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._needProjectionMatrixCompute = true;\n            return _this;\n        }\n        Object.defineProperty(ShadowLight.prototype, \"direction\", {\n            get: function () {\n                return this._direction;\n            },\n            set: function (value) {\n                this._direction = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowLight.prototype, \"shadowMinZ\", {\n            get: function () {\n                return this._shadowMinZ;\n            },\n            set: function (value) {\n                this._shadowMinZ = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowLight.prototype, \"shadowMaxZ\", {\n            get: function () {\n                return this._shadowMaxZ;\n            },\n            set: function (value) {\n                this._shadowMaxZ = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Computes the light transformed position/direction in case the light is parented. Returns true if parented, else false.\n         */\n        ShadowLight.prototype.computeTransformedInformation = function () {\n            if (this.parent && this.parent.getWorldMatrix) {\n                if (!this.transformedPosition) {\n                    this.transformedPosition = BABYLON.Vector3.Zero();\n                }\n                BABYLON.Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\n                // In case the direction is present.\n                if (this.direction) {\n                    if (!this.transformedDirection) {\n                        this.transformedDirection = BABYLON.Vector3.Zero();\n                    }\n                    BABYLON.Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\n                }\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Return the depth scale used for the shadow map.\n         */\n        ShadowLight.prototype.getDepthScale = function () {\n            return 50.0;\n        };\n        /**\n         * Returns the light direction (Vector3) for any passed face index.\n         */\n        ShadowLight.prototype.getShadowDirection = function (faceIndex) {\n            return this.transformedDirection ? this.transformedDirection : this.direction;\n        };\n        /**\n         * Returns the DirectionalLight absolute position in the World.\n         */\n        ShadowLight.prototype.getAbsolutePosition = function () {\n            return this.transformedPosition ? this.transformedPosition : this.position;\n        };\n        /**\n         * Sets the DirectionalLight direction toward the passed target (Vector3).\n         * Returns the updated DirectionalLight direction (Vector3).\n         */\n        ShadowLight.prototype.setDirectionToTarget = function (target) {\n            this.direction = BABYLON.Vector3.Normalize(target.subtract(this.position));\n            return this.direction;\n        };\n        /**\n         * Returns the light rotation (Vector3).\n         */\n        ShadowLight.prototype.getRotation = function () {\n            this.direction.normalize();\n            var xaxis = BABYLON.Vector3.Cross(this.direction, BABYLON.Axis.Y);\n            var yaxis = BABYLON.Vector3.Cross(xaxis, this.direction);\n            return BABYLON.Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\n        };\n        /**\n         * Boolean : false by default.\n         */\n        ShadowLight.prototype.needCube = function () {\n            return false;\n        };\n        /**\n         * Specifies wether or not the projection matrix should be recomputed this frame.\n         */\n        ShadowLight.prototype.needProjectionMatrixCompute = function () {\n            return this._needProjectionMatrixCompute;\n        };\n        /**\n         * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\n         */\n        ShadowLight.prototype.forceProjectionMatrixCompute = function () {\n            this._needProjectionMatrixCompute = true;\n        };\n        /**\n         * Get the world matrix of the sahdow lights.\n         */\n        ShadowLight.prototype._getWorldMatrix = function () {\n            if (!this._worldMatrix) {\n                this._worldMatrix = BABYLON.Matrix.Identity();\n            }\n            BABYLON.Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\n            return this._worldMatrix;\n        };\n        /**\n         * Gets the minZ used for shadow according to both the scene and the light.\n         * @param activeCamera\n         */\n        ShadowLight.prototype.getDepthMinZ = function (activeCamera) {\n            return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        };\n        /**\n         * Gets the maxZ used for shadow according to both the scene and the light.\n         * @param activeCamera\n         */\n        ShadowLight.prototype.getDepthMaxZ = function (activeCamera) {\n            return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        };\n        /**\n         * Sets the projection matrix according to the type of light and custom projection matrix definition.\n         * Returns the light.\n         */\n        ShadowLight.prototype.setShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n            if (this.customProjectionMatrixBuilder) {\n                this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\n            }\n            else {\n                this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\n            }\n            return this;\n        };\n        return ShadowLight;\n    }(BABYLON.Light));\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], ShadowLight.prototype, \"position\", void 0);\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], ShadowLight.prototype, \"direction\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], ShadowLight.prototype, \"shadowMinZ\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], ShadowLight.prototype, \"shadowMaxZ\", null);\n    BABYLON.ShadowLight = ShadowLight;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.shadowLight.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PointLight = (function (_super) {\n        __extends(PointLight, _super);\n        /**\n         * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\n         * A PointLight emits the light in every direction.\n         * It can cast shadows.\n         * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\n         * ```javascript\n         * var pointLight = new BABYLON.PointLight(\"pl\", camera.position, scene);\n         * ```\n         * Documentation : http://doc.babylonjs.com/tutorials/lights\n         */\n        function PointLight(name, position, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._shadowAngle = Math.PI / 2;\n            _this.position = position;\n            return _this;\n        }\n        Object.defineProperty(PointLight.prototype, \"shadowAngle\", {\n            /**\n             * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n             * This specifies what angle the shadow will use to be created.\n             *\n             * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n             */\n            get: function () {\n                return this._shadowAngle;\n            },\n            /**\n             * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n             * This specifies what angle the shadow will use to be created.\n             *\n             * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\n             */\n            set: function (value) {\n                this._shadowAngle = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PointLight.prototype, \"direction\", {\n            get: function () {\n                return this._direction;\n            },\n            /**\n             * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\n             */\n            set: function (value) {\n                var previousNeedCube = this.needCube();\n                this._direction = value;\n                if (this.needCube() !== previousNeedCube && this._shadowGenerator) {\n                    this._shadowGenerator.recreateShadowMap();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the string \"PointLight\"\n         */\n        PointLight.prototype.getClassName = function () {\n            return \"PointLight\";\n        };\n        /**\n         * Returns the integer 0.\n         */\n        PointLight.prototype.getTypeID = function () {\n            return BABYLON.Light.LIGHTTYPEID_POINTLIGHT;\n        };\n        /**\n         * Specifies wether or not the shadowmap should be a cube texture.\n         */\n        PointLight.prototype.needCube = function () {\n            return !this.direction;\n        };\n        /**\n         * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\n         */\n        PointLight.prototype.getShadowDirection = function (faceIndex) {\n            if (this.direction) {\n                return _super.prototype.getShadowDirection.call(this, faceIndex);\n            }\n            else {\n                switch (faceIndex) {\n                    case 0:\n                        return new BABYLON.Vector3(1.0, 0.0, 0.0);\n                    case 1:\n                        return new BABYLON.Vector3(-1.0, 0.0, 0.0);\n                    case 2:\n                        return new BABYLON.Vector3(0.0, -1.0, 0.0);\n                    case 3:\n                        return new BABYLON.Vector3(0.0, 1.0, 0.0);\n                    case 4:\n                        return new BABYLON.Vector3(0.0, 0.0, 1.0);\n                    case 5:\n                        return new BABYLON.Vector3(0.0, 0.0, -1.0);\n                }\n            }\n            return BABYLON.Vector3.Zero();\n        };\n        /**\n         * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\n         * - fov = PI / 2\n         * - aspect ratio : 1.0\n         * - z-near and far equal to the active camera minZ and maxZ.\n         * Returns the PointLight.\n         */\n        PointLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n            var activeCamera = this.getScene().activeCamera;\n            BABYLON.Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1.0, this.getDepthMinZ(activeCamera), this.getDepthMaxZ(activeCamera), matrix);\n        };\n        PointLight.prototype._buildUniformLayout = function () {\n            this._uniformBuffer.addUniform(\"vLightData\", 4);\n            this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n            this._uniformBuffer.addUniform(\"vLightSpecular\", 3);\n            this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n            this._uniformBuffer.addUniform(\"depthValues\", 2);\n            this._uniformBuffer.create();\n        };\n        /**\n         * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n         * Returns the PointLight.\n         */\n        PointLight.prototype.transferToEffect = function (effect, lightIndex) {\n            if (this.computeTransformedInformation()) {\n                this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0.0, lightIndex);\n                return this;\n            }\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, 0, lightIndex);\n            return this;\n        };\n        return PointLight;\n    }(BABYLON.ShadowLight));\n    __decorate([\n        BABYLON.serialize()\n    ], PointLight.prototype, \"shadowAngle\", null);\n    BABYLON.PointLight = PointLight;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pointLight.js.map\n\n/// <reference path=\"babylon.light.ts\" />\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var DirectionalLight = (function (_super) {\n        __extends(DirectionalLight, _super);\n        /**\n         * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).\n         * The directional light is emitted from everywhere in the given direction.\n         * It can cast shawdows.\n         * Documentation : http://doc.babylonjs.com/tutorials/lights\n         */\n        function DirectionalLight(name, direction, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._shadowFrustumSize = 0;\n            _this._shadowOrthoScale = 0.5;\n            _this.autoUpdateExtends = true;\n            // Cache\n            _this._orthoLeft = Number.MAX_VALUE;\n            _this._orthoRight = Number.MIN_VALUE;\n            _this._orthoTop = Number.MIN_VALUE;\n            _this._orthoBottom = Number.MAX_VALUE;\n            _this.position = direction.scale(-1.0);\n            _this.direction = direction;\n            return _this;\n        }\n        Object.defineProperty(DirectionalLight.prototype, \"shadowFrustumSize\", {\n            /**\n             * Fix frustum size for the shadow generation. This is disabled if the value is 0.\n             */\n            get: function () {\n                return this._shadowFrustumSize;\n            },\n            /**\n             * Specifies a fix frustum size for the shadow generation.\n             */\n            set: function (value) {\n                this._shadowFrustumSize = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DirectionalLight.prototype, \"shadowOrthoScale\", {\n            get: function () {\n                return this._shadowOrthoScale;\n            },\n            set: function (value) {\n                this._shadowOrthoScale = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the string \"DirectionalLight\".\n         */\n        DirectionalLight.prototype.getClassName = function () {\n            return \"DirectionalLight\";\n        };\n        /**\n         * Returns the integer 1.\n         */\n        DirectionalLight.prototype.getTypeID = function () {\n            return BABYLON.Light.LIGHTTYPEID_DIRECTIONALLIGHT;\n        };\n        /**\n         * Sets the passed matrix \"matrix\" as projection matrix for the shadows cast by the light according to the passed view matrix.\n         * Returns the DirectionalLight Shadow projection matrix.\n         */\n        DirectionalLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n            if (this.shadowFrustumSize > 0) {\n                this._setDefaultFixedFrustumShadowProjectionMatrix(matrix, viewMatrix);\n            }\n            else {\n                this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);\n            }\n        };\n        /**\n         * Sets the passed matrix \"matrix\" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.\n         * Returns the DirectionalLight Shadow projection matrix.\n         */\n        DirectionalLight.prototype._setDefaultFixedFrustumShadowProjectionMatrix = function (matrix, viewMatrix) {\n            var activeCamera = this.getScene().activeCamera;\n            BABYLON.Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n        };\n        /**\n         * Sets the passed matrix \"matrix\" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.\n         * Returns the DirectionalLight Shadow projection matrix.\n         */\n        DirectionalLight.prototype._setDefaultAutoExtendShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n            var activeCamera = this.getScene().activeCamera;\n            // Check extends\n            if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {\n                var tempVector3 = BABYLON.Vector3.Zero();\n                this._orthoLeft = Number.MAX_VALUE;\n                this._orthoRight = Number.MIN_VALUE;\n                this._orthoTop = Number.MIN_VALUE;\n                this._orthoBottom = Number.MAX_VALUE;\n                for (var meshIndex = 0; meshIndex < renderList.length; meshIndex++) {\n                    var mesh = renderList[meshIndex];\n                    if (!mesh) {\n                        continue;\n                    }\n                    var boundingInfo = mesh.getBoundingInfo();\n                    if (!boundingInfo) {\n                        continue;\n                    }\n                    var boundingBox = boundingInfo.boundingBox;\n                    for (var index = 0; index < boundingBox.vectorsWorld.length; index++) {\n                        BABYLON.Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);\n                        if (tempVector3.x < this._orthoLeft)\n                            this._orthoLeft = tempVector3.x;\n                        if (tempVector3.y < this._orthoBottom)\n                            this._orthoBottom = tempVector3.y;\n                        if (tempVector3.x > this._orthoRight)\n                            this._orthoRight = tempVector3.x;\n                        if (tempVector3.y > this._orthoTop)\n                            this._orthoTop = tempVector3.y;\n                    }\n                }\n            }\n            var xOffset = this._orthoRight - this._orthoLeft;\n            var yOffset = this._orthoTop - this._orthoBottom;\n            BABYLON.Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ, matrix);\n        };\n        DirectionalLight.prototype._buildUniformLayout = function () {\n            this._uniformBuffer.addUniform(\"vLightData\", 4);\n            this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n            this._uniformBuffer.addUniform(\"vLightSpecular\", 3);\n            this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n            this._uniformBuffer.addUniform(\"depthValues\", 2);\n            this._uniformBuffer.create();\n        };\n        /**\n         * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.\n         * Returns the DirectionalLight.\n         */\n        DirectionalLight.prototype.transferToEffect = function (effect, lightIndex) {\n            if (this.computeTransformedInformation()) {\n                this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);\n                return this;\n            }\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);\n            return this;\n        };\n        /**\n         * Gets the minZ used for shadow according to both the scene and the light.\n         *\n         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n         * @param activeCamera\n         */\n        DirectionalLight.prototype.getDepthMinZ = function (activeCamera) {\n            return 1;\n        };\n        /**\n         * Gets the maxZ used for shadow according to both the scene and the light.\n         *\n         * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being\n         * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.\n         * @param activeCamera\n         */\n        DirectionalLight.prototype.getDepthMaxZ = function (activeCamera) {\n            return 1;\n        };\n        return DirectionalLight;\n    }(BABYLON.ShadowLight));\n    __decorate([\n        BABYLON.serialize()\n    ], DirectionalLight.prototype, \"shadowFrustumSize\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DirectionalLight.prototype, \"shadowOrthoScale\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DirectionalLight.prototype, \"autoUpdateExtends\", void 0);\n    BABYLON.DirectionalLight = DirectionalLight;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.directionalLight.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var SpotLight = (function (_super) {\n        __extends(SpotLight, _super);\n        /**\n         * Creates a SpotLight object in the scene with the passed parameters :\n         * - `position` (Vector3) is the initial SpotLight position,\n         * - `direction` (Vector3) is the initial SpotLight direction,\n         * - `angle` (float, in radians) is the spot light cone angle,\n         * - `exponent` (float) is the light decay speed with the distance from the emission spot.\n         * A spot light is a simply light oriented cone.\n         * It can cast shadows.\n         * Documentation : http://doc.babylonjs.com/tutorials/lights\n         */\n        function SpotLight(name, position, direction, angle, exponent, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.position = position;\n            _this.direction = direction;\n            _this.angle = angle;\n            _this.exponent = exponent;\n            return _this;\n        }\n        Object.defineProperty(SpotLight.prototype, \"angle\", {\n            get: function () {\n                return this._angle;\n            },\n            set: function (value) {\n                this._angle = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SpotLight.prototype, \"shadowAngleScale\", {\n            get: function () {\n                return this._shadowAngleScale;\n            },\n            /**\n             * Allows scaling the angle of the light for shadow generation only.\n             */\n            set: function (value) {\n                this._shadowAngleScale = value;\n                this.forceProjectionMatrixCompute();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the string \"SpotLight\".\n         */\n        SpotLight.prototype.getClassName = function () {\n            return \"SpotLight\";\n        };\n        /**\n         * Returns the integer 2.\n         */\n        SpotLight.prototype.getTypeID = function () {\n            return BABYLON.Light.LIGHTTYPEID_SPOTLIGHT;\n        };\n        /**\n         * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\n         * Returns the SpotLight.\n         */\n        SpotLight.prototype._setDefaultShadowProjectionMatrix = function (matrix, viewMatrix, renderList) {\n            var activeCamera = this.getScene().activeCamera;\n            this._shadowAngleScale = this._shadowAngleScale || 1;\n            var angle = this._shadowAngleScale * this._angle;\n            BABYLON.Matrix.PerspectiveFovLHToRef(angle, 1.0, this.getDepthMinZ(activeCamera), this.getDepthMaxZ(activeCamera), matrix);\n        };\n        SpotLight.prototype._buildUniformLayout = function () {\n            this._uniformBuffer.addUniform(\"vLightData\", 4);\n            this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n            this._uniformBuffer.addUniform(\"vLightSpecular\", 3);\n            this._uniformBuffer.addUniform(\"vLightDirection\", 3);\n            this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n            this._uniformBuffer.addUniform(\"depthValues\", 2);\n            this._uniformBuffer.create();\n        };\n        /**\n         * Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.\n         * Return the SpotLight.\n         */\n        SpotLight.prototype.transferToEffect = function (effect, lightIndex) {\n            var normalizeDirection;\n            if (this.computeTransformedInformation()) {\n                this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);\n                normalizeDirection = BABYLON.Vector3.Normalize(this.transformedDirection);\n            }\n            else {\n                this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);\n                normalizeDirection = BABYLON.Vector3.Normalize(this.direction);\n            }\n            this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, Math.cos(this.angle * 0.5), lightIndex);\n            return this;\n        };\n        return SpotLight;\n    }(BABYLON.ShadowLight));\n    __decorate([\n        BABYLON.serialize()\n    ], SpotLight.prototype, \"angle\", null);\n    __decorate([\n        BABYLON.serialize()\n        /**\n         * Allows scaling the angle of the light for shadow generation only.\n         */\n    ], SpotLight.prototype, \"shadowAngleScale\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], SpotLight.prototype, \"exponent\", void 0);\n    BABYLON.SpotLight = SpotLight;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.spotLight.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var AnimationRange = (function () {\n        function AnimationRange(name, from, to) {\n            this.name = name;\n            this.from = from;\n            this.to = to;\n        }\n        AnimationRange.prototype.clone = function () {\n            return new AnimationRange(this.name, this.from, this.to);\n        };\n        return AnimationRange;\n    }());\n    BABYLON.AnimationRange = AnimationRange;\n    /**\n     * Composed of a frame, and an action function\n     */\n    var AnimationEvent = (function () {\n        function AnimationEvent(frame, action, onlyOnce) {\n            this.frame = frame;\n            this.action = action;\n            this.onlyOnce = onlyOnce;\n            this.isDone = false;\n        }\n        return AnimationEvent;\n    }());\n    BABYLON.AnimationEvent = AnimationEvent;\n    var PathCursor = (function () {\n        function PathCursor(path) {\n            this.path = path;\n            this._onchange = new Array();\n            this.value = 0;\n            this.animations = new Array();\n        }\n        PathCursor.prototype.getPoint = function () {\n            var point = this.path.getPointAtLengthPosition(this.value);\n            return new BABYLON.Vector3(point.x, 0, point.y);\n        };\n        PathCursor.prototype.moveAhead = function (step) {\n            if (step === void 0) { step = 0.002; }\n            this.move(step);\n            return this;\n        };\n        PathCursor.prototype.moveBack = function (step) {\n            if (step === void 0) { step = 0.002; }\n            this.move(-step);\n            return this;\n        };\n        PathCursor.prototype.move = function (step) {\n            if (Math.abs(step) > 1) {\n                throw \"step size should be less than 1.\";\n            }\n            this.value += step;\n            this.ensureLimits();\n            this.raiseOnChange();\n            return this;\n        };\n        PathCursor.prototype.ensureLimits = function () {\n            while (this.value > 1) {\n                this.value -= 1;\n            }\n            while (this.value < 0) {\n                this.value += 1;\n            }\n            return this;\n        };\n        // used by animation engine\n        PathCursor.prototype.markAsDirty = function (propertyName) {\n            this.ensureLimits();\n            this.raiseOnChange();\n            return this;\n        };\n        PathCursor.prototype.raiseOnChange = function () {\n            var _this = this;\n            this._onchange.forEach(function (f) { return f(_this); });\n            return this;\n        };\n        PathCursor.prototype.onchange = function (f) {\n            this._onchange.push(f);\n            return this;\n        };\n        return PathCursor;\n    }());\n    BABYLON.PathCursor = PathCursor;\n    var Animation = (function () {\n        function Animation(name, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {\n            this.name = name;\n            this.targetProperty = targetProperty;\n            this.framePerSecond = framePerSecond;\n            this.dataType = dataType;\n            this.loopMode = loopMode;\n            this.enableBlending = enableBlending;\n            this._offsetsCache = {};\n            this._highLimitsCache = {};\n            this._stopped = false;\n            this._blendingFactor = 0;\n            // The set of event that will be linked to this animation\n            this._events = new Array();\n            this.allowMatricesInterpolation = false;\n            this.blendingSpeed = 0.01;\n            this._ranges = {};\n            this.targetPropertyPath = targetProperty.split(\".\");\n            this.dataType = dataType;\n            this.loopMode = loopMode === undefined ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;\n        }\n        Animation._PrepareAnimation = function (name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {\n            var dataType = undefined;\n            if (!isNaN(parseFloat(from)) && isFinite(from)) {\n                dataType = Animation.ANIMATIONTYPE_FLOAT;\n            }\n            else if (from instanceof BABYLON.Quaternion) {\n                dataType = Animation.ANIMATIONTYPE_QUATERNION;\n            }\n            else if (from instanceof BABYLON.Vector3) {\n                dataType = Animation.ANIMATIONTYPE_VECTOR3;\n            }\n            else if (from instanceof BABYLON.Vector2) {\n                dataType = Animation.ANIMATIONTYPE_VECTOR2;\n            }\n            else if (from instanceof BABYLON.Color3) {\n                dataType = Animation.ANIMATIONTYPE_COLOR3;\n            }\n            else if (from instanceof BABYLON.Size) {\n                dataType = Animation.ANIMATIONTYPE_SIZE;\n            }\n            if (dataType == undefined) {\n                return null;\n            }\n            var animation = new Animation(name, targetProperty, framePerSecond, dataType, loopMode);\n            var keys = [{ frame: 0, value: from }, { frame: totalFrame, value: to }];\n            animation.setKeys(keys);\n            if (easingFunction !== undefined) {\n                animation.setEasingFunction(easingFunction);\n            }\n            return animation;\n        };\n        Animation.CreateAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n            var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n            return node.getScene().beginDirectAnimation(node, [animation], 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\n        };\n        Animation.CreateMergeAndStartAnimation = function (name, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {\n            var animation = Animation._PrepareAnimation(name, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);\n            node.animations.push(animation);\n            return node.getScene().beginAnimation(node, 0, totalFrame, (animation.loopMode === 1), 1.0, onAnimationEnd);\n        };\n        // Methods\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        Animation.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name + \", property: \" + this.targetProperty;\n            ret += \", datatype: \" + ([\"Float\", \"Vector3\", \"Quaternion\", \"Matrix\", \"Color3\", \"Vector2\"])[this.dataType];\n            ret += \", nKeys: \" + (this._keys ? this._keys.length : \"none\");\n            ret += \", nRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n            if (fullDetails) {\n                ret += \", Ranges: {\";\n                var first = true;\n                for (var name in this._ranges) {\n                    if (first) {\n                        ret += \", \";\n                        first = false;\n                    }\n                    ret += name;\n                }\n                ret += \"}\";\n            }\n            return ret;\n        };\n        /**\n         * Add an event to this animation.\n         */\n        Animation.prototype.addEvent = function (event) {\n            this._events.push(event);\n        };\n        /**\n         * Remove all events found at the given frame\n         * @param frame\n         */\n        Animation.prototype.removeEvents = function (frame) {\n            for (var index = 0; index < this._events.length; index++) {\n                if (this._events[index].frame === frame) {\n                    this._events.splice(index, 1);\n                    index--;\n                }\n            }\n        };\n        Animation.prototype.createRange = function (name, from, to) {\n            // check name not already in use; could happen for bones after serialized\n            if (!this._ranges[name]) {\n                this._ranges[name] = new AnimationRange(name, from, to);\n            }\n        };\n        Animation.prototype.deleteRange = function (name, deleteFrames) {\n            if (deleteFrames === void 0) { deleteFrames = true; }\n            if (this._ranges[name]) {\n                if (deleteFrames) {\n                    var from = this._ranges[name].from;\n                    var to = this._ranges[name].to;\n                    // this loop MUST go high to low for multiple splices to work\n                    for (var key = this._keys.length - 1; key >= 0; key--) {\n                        if (this._keys[key].frame >= from && this._keys[key].frame <= to) {\n                            this._keys.splice(key, 1);\n                        }\n                    }\n                }\n                this._ranges[name] = undefined; // said much faster than 'delete this._range[name]' \n            }\n        };\n        Animation.prototype.getRange = function (name) {\n            return this._ranges[name];\n        };\n        Animation.prototype.reset = function () {\n            this._offsetsCache = {};\n            this._highLimitsCache = {};\n            this.currentFrame = 0;\n            this._blendingFactor = 0;\n            this._originalBlendValue = null;\n        };\n        Animation.prototype.isStopped = function () {\n            return this._stopped;\n        };\n        Animation.prototype.getKeys = function () {\n            return this._keys;\n        };\n        Animation.prototype.getHighestFrame = function () {\n            var ret = 0;\n            for (var key = 0, nKeys = this._keys.length; key < nKeys; key++) {\n                if (ret < this._keys[key].frame) {\n                    ret = this._keys[key].frame;\n                }\n            }\n            return ret;\n        };\n        Animation.prototype.getEasingFunction = function () {\n            return this._easingFunction;\n        };\n        Animation.prototype.setEasingFunction = function (easingFunction) {\n            this._easingFunction = easingFunction;\n        };\n        Animation.prototype.floatInterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Scalar.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.floatInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n            return BABYLON.Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n        };\n        Animation.prototype.quaternionInterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Quaternion.Slerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.quaternionInterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n            return BABYLON.Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();\n        };\n        Animation.prototype.vector3InterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Vector3.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.vector3InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n            return BABYLON.Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n        };\n        Animation.prototype.vector2InterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Vector2.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.vector2InterpolateFunctionWithTangents = function (startValue, outTangent, endValue, inTangent, gradient) {\n            return BABYLON.Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);\n        };\n        Animation.prototype.sizeInterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Size.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.color3InterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Color3.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.matrixInterpolateFunction = function (startValue, endValue, gradient) {\n            return BABYLON.Matrix.Lerp(startValue, endValue, gradient);\n        };\n        Animation.prototype.clone = function () {\n            var clone = new Animation(this.name, this.targetPropertyPath.join(\".\"), this.framePerSecond, this.dataType, this.loopMode);\n            clone.enableBlending = this.enableBlending;\n            clone.blendingSpeed = this.blendingSpeed;\n            if (this._keys) {\n                clone.setKeys(this._keys);\n            }\n            if (this._ranges) {\n                clone._ranges = {};\n                for (var name in this._ranges) {\n                    clone._ranges[name] = this._ranges[name].clone();\n                }\n            }\n            return clone;\n        };\n        Animation.prototype.setKeys = function (values) {\n            this._keys = values.slice(0);\n            this._offsetsCache = {};\n            this._highLimitsCache = {};\n        };\n        Animation.prototype._getKeyValue = function (value) {\n            if (typeof value === \"function\") {\n                return value();\n            }\n            return value;\n        };\n        Animation.prototype._interpolate = function (currentFrame, repeatCount, loopMode, offsetValue, highLimitValue) {\n            if (loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && repeatCount > 0) {\n                return highLimitValue.clone ? highLimitValue.clone() : highLimitValue;\n            }\n            this.currentFrame = currentFrame;\n            // Try to get a hash to find the right key\n            var startKeyIndex = Math.max(0, Math.min(this._keys.length - 1, Math.floor(this._keys.length * (currentFrame - this._keys[0].frame) / (this._keys[this._keys.length - 1].frame - this._keys[0].frame)) - 1));\n            if (this._keys[startKeyIndex].frame >= currentFrame) {\n                while (startKeyIndex - 1 >= 0 && this._keys[startKeyIndex].frame >= currentFrame) {\n                    startKeyIndex--;\n                }\n            }\n            for (var key = startKeyIndex; key < this._keys.length; key++) {\n                var endKey = this._keys[key + 1];\n                if (endKey.frame >= currentFrame) {\n                    var startKey = this._keys[key];\n                    var startValue = this._getKeyValue(startKey.value);\n                    var endValue = this._getKeyValue(endKey.value);\n                    var useTangent = startKey.outTangent !== undefined && endKey.inTangent !== undefined;\n                    var frameDelta = endKey.frame - startKey.frame;\n                    // gradient : percent of currentFrame between the frame inf and the frame sup\n                    var gradient = (currentFrame - startKey.frame) / frameDelta;\n                    // check for easingFunction and correction of gradient\n                    if (this._easingFunction != null) {\n                        gradient = this._easingFunction.ease(gradient);\n                    }\n                    switch (this.dataType) {\n                        // Float\n                        case Animation.ANIMATIONTYPE_FLOAT:\n                            var floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return floatValue;\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return offsetValue * repeatCount + floatValue;\n                            }\n                            break;\n                        // Quaternion\n                        case Animation.ANIMATIONTYPE_QUATERNION:\n                            var quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return quatValue;\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return quatValue.add(offsetValue.scale(repeatCount));\n                            }\n                            return quatValue;\n                        // Vector3\n                        case Animation.ANIMATIONTYPE_VECTOR3:\n                            var vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return vec3Value;\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return vec3Value.add(offsetValue.scale(repeatCount));\n                            }\n                        // Vector2\n                        case Animation.ANIMATIONTYPE_VECTOR2:\n                            var vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return vec2Value;\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return vec2Value.add(offsetValue.scale(repeatCount));\n                            }\n                        // Size\n                        case Animation.ANIMATIONTYPE_SIZE:\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return this.sizeInterpolateFunction(startValue, endValue, gradient);\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return this.sizeInterpolateFunction(startValue, endValue, gradient).add(offsetValue.scale(repeatCount));\n                            }\n                        // Color3\n                        case Animation.ANIMATIONTYPE_COLOR3:\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    return this.color3InterpolateFunction(startValue, endValue, gradient);\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return this.color3InterpolateFunction(startValue, endValue, gradient).add(offsetValue.scale(repeatCount));\n                            }\n                        // Matrix\n                        case Animation.ANIMATIONTYPE_MATRIX:\n                            switch (loopMode) {\n                                case Animation.ANIMATIONLOOPMODE_CYCLE:\n                                case Animation.ANIMATIONLOOPMODE_CONSTANT:\n                                    if (this.allowMatricesInterpolation) {\n                                        return this.matrixInterpolateFunction(startValue, endValue, gradient);\n                                    }\n                                case Animation.ANIMATIONLOOPMODE_RELATIVE:\n                                    return startValue;\n                            }\n                        default:\n                            break;\n                    }\n                    break;\n                }\n            }\n            return this._getKeyValue(this._keys[this._keys.length - 1].value);\n        };\n        Animation.prototype.setValue = function (currentValue, blend) {\n            if (blend === void 0) { blend = false; }\n            // Set value\n            var path;\n            var destination;\n            if (this.targetPropertyPath.length > 1) {\n                var property = this._target[this.targetPropertyPath[0]];\n                for (var index = 1; index < this.targetPropertyPath.length - 1; index++) {\n                    property = property[this.targetPropertyPath[index]];\n                }\n                path = this.targetPropertyPath[this.targetPropertyPath.length - 1];\n                destination = property;\n            }\n            else {\n                path = this.targetPropertyPath[0];\n                destination = this._target;\n            }\n            // Blending\n            if (this.enableBlending && this._blendingFactor <= 1.0) {\n                if (!this._originalBlendValue) {\n                    if (destination[path].clone) {\n                        this._originalBlendValue = destination[path].clone();\n                    }\n                    else {\n                        this._originalBlendValue = destination[path];\n                    }\n                }\n                if (this._originalBlendValue.prototype) {\n                    if (this._originalBlendValue.prototype.Lerp) {\n                        destination[path] = this._originalBlendValue.construtor.prototype.Lerp(currentValue, this._originalBlendValue, this._blendingFactor);\n                    }\n                    else {\n                        destination[path] = currentValue;\n                    }\n                }\n                else if (this._originalBlendValue.m) {\n                    destination[path] = BABYLON.Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                }\n                else {\n                    destination[path] = this._originalBlendValue * (1.0 - this._blendingFactor) + this._blendingFactor * currentValue;\n                }\n                this._blendingFactor += this.blendingSpeed;\n            }\n            else {\n                destination[path] = currentValue;\n            }\n            if (this._target.markAsDirty) {\n                this._target.markAsDirty(this.targetProperty);\n            }\n        };\n        Animation.prototype.goToFrame = function (frame) {\n            if (frame < this._keys[0].frame) {\n                frame = this._keys[0].frame;\n            }\n            else if (frame > this._keys[this._keys.length - 1].frame) {\n                frame = this._keys[this._keys.length - 1].frame;\n            }\n            var currentValue = this._interpolate(frame, 0, this.loopMode);\n            this.setValue(currentValue);\n        };\n        Animation.prototype.animate = function (delay, from, to, loop, speedRatio, blend) {\n            if (blend === void 0) { blend = false; }\n            if (!this.targetPropertyPath || this.targetPropertyPath.length < 1) {\n                this._stopped = true;\n                return false;\n            }\n            var returnValue = true;\n            // Adding a start key at frame 0 if missing\n            if (this._keys[0].frame !== 0) {\n                var newKey = { frame: 0, value: this._keys[0].value };\n                this._keys.splice(0, 0, newKey);\n            }\n            // Check limits\n            if (from < this._keys[0].frame || from > this._keys[this._keys.length - 1].frame) {\n                from = this._keys[0].frame;\n            }\n            if (to < this._keys[0].frame || to > this._keys[this._keys.length - 1].frame) {\n                to = this._keys[this._keys.length - 1].frame;\n            }\n            //to and from cannot be the same key\n            if (from === to) {\n                from++;\n            }\n            // Compute ratio\n            var range = to - from;\n            var offsetValue;\n            // ratio represents the frame delta between from and to\n            var ratio = delay * (this.framePerSecond * speedRatio) / 1000.0;\n            var highLimitValue = 0;\n            if (((to > from && ratio > range) || (from > to && ratio < range)) && !loop) {\n                returnValue = false;\n                highLimitValue = this._getKeyValue(this._keys[this._keys.length - 1].value);\n            }\n            else {\n                // Get max value if required\n                if (this.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n                    var keyOffset = to.toString() + from.toString();\n                    if (!this._offsetsCache[keyOffset]) {\n                        var fromValue = this._interpolate(from, 0, Animation.ANIMATIONLOOPMODE_CYCLE);\n                        var toValue = this._interpolate(to, 0, Animation.ANIMATIONLOOPMODE_CYCLE);\n                        switch (this.dataType) {\n                            // Float\n                            case Animation.ANIMATIONTYPE_FLOAT:\n                                this._offsetsCache[keyOffset] = toValue - fromValue;\n                                break;\n                            // Quaternion\n                            case Animation.ANIMATIONTYPE_QUATERNION:\n                                this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                                break;\n                            // Vector3\n                            case Animation.ANIMATIONTYPE_VECTOR3:\n                                this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            // Vector2\n                            case Animation.ANIMATIONTYPE_VECTOR2:\n                                this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            // Size\n                            case Animation.ANIMATIONTYPE_SIZE:\n                                this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            // Color3\n                            case Animation.ANIMATIONTYPE_COLOR3:\n                                this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            default:\n                                break;\n                        }\n                        this._highLimitsCache[keyOffset] = toValue;\n                    }\n                    highLimitValue = this._highLimitsCache[keyOffset];\n                    offsetValue = this._offsetsCache[keyOffset];\n                }\n            }\n            if (offsetValue === undefined) {\n                switch (this.dataType) {\n                    // Float\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        offsetValue = 0;\n                        break;\n                    // Quaternion\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        offsetValue = new BABYLON.Quaternion(0, 0, 0, 0);\n                        break;\n                    // Vector3\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                        offsetValue = BABYLON.Vector3.Zero();\n                        break;\n                    // Vector2\n                    case Animation.ANIMATIONTYPE_VECTOR2:\n                        offsetValue = BABYLON.Vector2.Zero();\n                        break;\n                    // Size\n                    case Animation.ANIMATIONTYPE_SIZE:\n                        offsetValue = BABYLON.Size.Zero();\n                        break;\n                    // Color3\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        offsetValue = BABYLON.Color3.Black();\n                }\n            }\n            // Compute value\n            var repeatCount = (ratio / range) >> 0;\n            var currentFrame = returnValue ? from + ratio % range : to;\n            var currentValue = this._interpolate(currentFrame, repeatCount, this.loopMode, offsetValue, highLimitValue);\n            // Set value\n            this.setValue(currentValue);\n            // Check events\n            for (var index = 0; index < this._events.length; index++) {\n                // Make sure current frame has passed event frame and that event frame is within the current range\n                // Also, handle both forward and reverse animations\n                if ((range > 0 && currentFrame >= this._events[index].frame && this._events[index].frame >= from) ||\n                    (range < 0 && currentFrame <= this._events[index].frame && this._events[index].frame <= from)) {\n                    var event = this._events[index];\n                    if (!event.isDone) {\n                        // If event should be done only once, remove it.\n                        if (event.onlyOnce) {\n                            this._events.splice(index, 1);\n                            index--;\n                        }\n                        event.isDone = true;\n                        event.action();\n                    } // Don't do anything if the event has already be done.\n                }\n                else if (this._events[index].isDone && !this._events[index].onlyOnce) {\n                    // reset event, the animation is looping\n                    this._events[index].isDone = false;\n                }\n            }\n            if (!returnValue) {\n                this._stopped = true;\n            }\n            return returnValue;\n        };\n        Animation.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.property = this.targetProperty;\n            serializationObject.framePerSecond = this.framePerSecond;\n            serializationObject.dataType = this.dataType;\n            serializationObject.loopBehavior = this.loopMode;\n            serializationObject.enableBlending = this.enableBlending;\n            serializationObject.blendingSpeed = this.blendingSpeed;\n            var dataType = this.dataType;\n            serializationObject.keys = [];\n            var keys = this.getKeys();\n            for (var index = 0; index < keys.length; index++) {\n                var animationKey = keys[index];\n                var key = {};\n                key.frame = animationKey.frame;\n                switch (dataType) {\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        key.values = [animationKey.value];\n                        break;\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                    case Animation.ANIMATIONTYPE_MATRIX:\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        key.values = animationKey.value.asArray();\n                        break;\n                }\n                serializationObject.keys.push(key);\n            }\n            serializationObject.ranges = [];\n            for (var name in this._ranges) {\n                var range = {};\n                range.name = name;\n                range.from = this._ranges[name].from;\n                range.to = this._ranges[name].to;\n                serializationObject.ranges.push(range);\n            }\n            return serializationObject;\n        };\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_FLOAT\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_FLOAT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_VECTOR3\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_VECTOR3;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_VECTOR2\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_VECTOR2;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_SIZE\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_SIZE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_QUATERNION\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_QUATERNION;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_MATRIX\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_MATRIX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONTYPE_COLOR3\", {\n            get: function () {\n                return Animation._ANIMATIONTYPE_COLOR3;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONLOOPMODE_RELATIVE\", {\n            get: function () {\n                return Animation._ANIMATIONLOOPMODE_RELATIVE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONLOOPMODE_CYCLE\", {\n            get: function () {\n                return Animation._ANIMATIONLOOPMODE_CYCLE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Animation, \"ANIMATIONLOOPMODE_CONSTANT\", {\n            get: function () {\n                return Animation._ANIMATIONLOOPMODE_CONSTANT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Animation.Parse = function (parsedAnimation) {\n            var animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);\n            var dataType = parsedAnimation.dataType;\n            var keys = [];\n            var data;\n            var index;\n            if (parsedAnimation.enableBlending) {\n                animation.enableBlending = parsedAnimation.enableBlending;\n            }\n            if (parsedAnimation.blendingSpeed) {\n                animation.blendingSpeed = parsedAnimation.blendingSpeed;\n            }\n            for (index = 0; index < parsedAnimation.keys.length; index++) {\n                var key = parsedAnimation.keys[index];\n                switch (dataType) {\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        data = key.values[0];\n                        break;\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        data = BABYLON.Quaternion.FromArray(key.values);\n                        break;\n                    case Animation.ANIMATIONTYPE_MATRIX:\n                        data = BABYLON.Matrix.FromArray(key.values);\n                        break;\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        data = BABYLON.Color3.FromArray(key.values);\n                        break;\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                    default:\n                        data = BABYLON.Vector3.FromArray(key.values);\n                        break;\n                }\n                keys.push({\n                    frame: key.frame,\n                    value: data\n                });\n            }\n            animation.setKeys(keys);\n            if (parsedAnimation.ranges) {\n                for (index = 0; index < parsedAnimation.ranges.length; index++) {\n                    data = parsedAnimation.ranges[index];\n                    animation.createRange(data.name, data.from, data.to);\n                }\n            }\n            return animation;\n        };\n        Animation.AppendSerializedAnimations = function (source, destination) {\n            if (source.animations) {\n                destination.animations = [];\n                for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {\n                    var animation = source.animations[animationIndex];\n                    destination.animations.push(animation.serialize());\n                }\n            }\n        };\n        return Animation;\n    }());\n    // Statics\n    Animation._ANIMATIONTYPE_FLOAT = 0;\n    Animation._ANIMATIONTYPE_VECTOR3 = 1;\n    Animation._ANIMATIONTYPE_QUATERNION = 2;\n    Animation._ANIMATIONTYPE_MATRIX = 3;\n    Animation._ANIMATIONTYPE_COLOR3 = 4;\n    Animation._ANIMATIONTYPE_VECTOR2 = 5;\n    Animation._ANIMATIONTYPE_SIZE = 6;\n    Animation._ANIMATIONLOOPMODE_RELATIVE = 0;\n    Animation._ANIMATIONLOOPMODE_CYCLE = 1;\n    Animation._ANIMATIONLOOPMODE_CONSTANT = 2;\n    BABYLON.Animation = Animation;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.animation.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Animatable = (function () {\n        function Animatable(scene, target, fromFrame, toFrame, loopAnimation, speedRatio, onAnimationEnd, animations) {\n            if (fromFrame === void 0) { fromFrame = 0; }\n            if (toFrame === void 0) { toFrame = 100; }\n            if (loopAnimation === void 0) { loopAnimation = false; }\n            if (speedRatio === void 0) { speedRatio = 1.0; }\n            this.target = target;\n            this.fromFrame = fromFrame;\n            this.toFrame = toFrame;\n            this.loopAnimation = loopAnimation;\n            this.speedRatio = speedRatio;\n            this.onAnimationEnd = onAnimationEnd;\n            this._localDelayOffset = null;\n            this._pausedDelay = null;\n            this._animations = new Array();\n            this._paused = false;\n            this.animationStarted = false;\n            if (animations) {\n                this.appendAnimations(target, animations);\n            }\n            this._scene = scene;\n            scene._activeAnimatables.push(this);\n        }\n        // Methods\n        Animatable.prototype.getAnimations = function () {\n            return this._animations;\n        };\n        Animatable.prototype.appendAnimations = function (target, animations) {\n            for (var index = 0; index < animations.length; index++) {\n                var animation = animations[index];\n                animation._target = target;\n                this._animations.push(animation);\n            }\n        };\n        Animatable.prototype.getAnimationByTargetProperty = function (property) {\n            var animations = this._animations;\n            for (var index = 0; index < animations.length; index++) {\n                if (animations[index].targetProperty === property) {\n                    return animations[index];\n                }\n            }\n            return null;\n        };\n        Animatable.prototype.reset = function () {\n            var animations = this._animations;\n            for (var index = 0; index < animations.length; index++) {\n                animations[index].reset();\n            }\n            this._localDelayOffset = null;\n            this._pausedDelay = null;\n        };\n        Animatable.prototype.enableBlending = function (blendingSpeed) {\n            var animations = this._animations;\n            for (var index = 0; index < animations.length; index++) {\n                animations[index].enableBlending = true;\n                animations[index].blendingSpeed = blendingSpeed;\n            }\n        };\n        Animatable.prototype.disableBlending = function () {\n            var animations = this._animations;\n            for (var index = 0; index < animations.length; index++) {\n                animations[index].enableBlending = false;\n            }\n        };\n        Animatable.prototype.goToFrame = function (frame) {\n            var animations = this._animations;\n            if (animations[0]) {\n                var fps = animations[0].framePerSecond;\n                var currentFrame = animations[0].currentFrame;\n                var adjustTime = frame - currentFrame;\n                var delay = adjustTime * 1000 / fps;\n                this._localDelayOffset -= delay;\n            }\n            for (var index = 0; index < animations.length; index++) {\n                animations[index].goToFrame(frame);\n            }\n        };\n        Animatable.prototype.pause = function () {\n            if (this._paused) {\n                return;\n            }\n            this._paused = true;\n        };\n        Animatable.prototype.restart = function () {\n            this._paused = false;\n        };\n        Animatable.prototype.stop = function (animationName) {\n            if (animationName) {\n                var idx = this._scene._activeAnimatables.indexOf(this);\n                if (idx > -1) {\n                    var animations = this._animations;\n                    for (var index = animations.length - 1; index >= 0; index--) {\n                        if (typeof animationName === \"string\" && animations[index].name != animationName) {\n                            continue;\n                        }\n                        animations[index].reset();\n                        animations.splice(index, 1);\n                    }\n                    if (animations.length == 0) {\n                        this._scene._activeAnimatables.splice(idx, 1);\n                        if (this.onAnimationEnd) {\n                            this.onAnimationEnd();\n                        }\n                    }\n                }\n            }\n            else {\n                var index = this._scene._activeAnimatables.indexOf(this);\n                if (index > -1) {\n                    this._scene._activeAnimatables.splice(index, 1);\n                    var animations = this._animations;\n                    for (var index = 0; index < animations.length; index++) {\n                        animations[index].reset();\n                    }\n                    if (this.onAnimationEnd) {\n                        this.onAnimationEnd();\n                    }\n                }\n            }\n        };\n        Animatable.prototype._animate = function (delay) {\n            if (this._paused) {\n                this.animationStarted = false;\n                if (this._pausedDelay === null) {\n                    this._pausedDelay = delay;\n                }\n                return true;\n            }\n            if (this._localDelayOffset === null) {\n                this._localDelayOffset = delay;\n            }\n            else if (this._pausedDelay !== null) {\n                this._localDelayOffset += delay - this._pausedDelay;\n                this._pausedDelay = null;\n            }\n            // Animating\n            var running = false;\n            var animations = this._animations;\n            var index;\n            for (index = 0; index < animations.length; index++) {\n                var animation = animations[index];\n                var isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this.speedRatio);\n                running = running || isRunning;\n            }\n            this.animationStarted = running;\n            if (!running) {\n                // Remove from active animatables\n                index = this._scene._activeAnimatables.indexOf(this);\n                this._scene._activeAnimatables.splice(index, 1);\n            }\n            if (!running && this.onAnimationEnd) {\n                this.onAnimationEnd();\n                this.onAnimationEnd = null;\n            }\n            return running;\n        };\n        return Animatable;\n    }());\n    BABYLON.Animatable = Animatable;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.animatable.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var EasingFunction = (function () {\n        function EasingFunction() {\n            // Properties\n            this._easingMode = EasingFunction.EASINGMODE_EASEIN;\n        }\n        Object.defineProperty(EasingFunction, \"EASINGMODE_EASEIN\", {\n            get: function () {\n                return EasingFunction._EASINGMODE_EASEIN;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EasingFunction, \"EASINGMODE_EASEOUT\", {\n            get: function () {\n                return EasingFunction._EASINGMODE_EASEOUT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EasingFunction, \"EASINGMODE_EASEINOUT\", {\n            get: function () {\n                return EasingFunction._EASINGMODE_EASEINOUT;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        EasingFunction.prototype.setEasingMode = function (easingMode) {\n            var n = Math.min(Math.max(easingMode, 0), 2);\n            this._easingMode = n;\n        };\n        EasingFunction.prototype.getEasingMode = function () {\n            return this._easingMode;\n        };\n        EasingFunction.prototype.easeInCore = function (gradient) {\n            throw new Error('You must implement this method');\n        };\n        EasingFunction.prototype.ease = function (gradient) {\n            switch (this._easingMode) {\n                case EasingFunction.EASINGMODE_EASEIN:\n                    return this.easeInCore(gradient);\n                case EasingFunction.EASINGMODE_EASEOUT:\n                    return (1 - this.easeInCore(1 - gradient));\n            }\n            if (gradient >= 0.5) {\n                return (((1 - this.easeInCore((1 - gradient) * 2)) * 0.5) + 0.5);\n            }\n            return (this.easeInCore(gradient * 2) * 0.5);\n        };\n        return EasingFunction;\n    }());\n    //Statics\n    EasingFunction._EASINGMODE_EASEIN = 0;\n    EasingFunction._EASINGMODE_EASEOUT = 1;\n    EasingFunction._EASINGMODE_EASEINOUT = 2;\n    BABYLON.EasingFunction = EasingFunction;\n    var CircleEase = (function (_super) {\n        __extends(CircleEase, _super);\n        function CircleEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CircleEase.prototype.easeInCore = function (gradient) {\n            gradient = Math.max(0, Math.min(1, gradient));\n            return (1.0 - Math.sqrt(1.0 - (gradient * gradient)));\n        };\n        return CircleEase;\n    }(EasingFunction));\n    BABYLON.CircleEase = CircleEase;\n    var BackEase = (function (_super) {\n        __extends(BackEase, _super);\n        function BackEase(amplitude) {\n            if (amplitude === void 0) { amplitude = 1; }\n            var _this = _super.call(this) || this;\n            _this.amplitude = amplitude;\n            return _this;\n        }\n        BackEase.prototype.easeInCore = function (gradient) {\n            var num = Math.max(0, this.amplitude);\n            return (Math.pow(gradient, 3.0) - ((gradient * num) * Math.sin(3.1415926535897931 * gradient)));\n        };\n        return BackEase;\n    }(EasingFunction));\n    BABYLON.BackEase = BackEase;\n    var BounceEase = (function (_super) {\n        __extends(BounceEase, _super);\n        function BounceEase(bounces, bounciness) {\n            if (bounces === void 0) { bounces = 3; }\n            if (bounciness === void 0) { bounciness = 2; }\n            var _this = _super.call(this) || this;\n            _this.bounces = bounces;\n            _this.bounciness = bounciness;\n            return _this;\n        }\n        BounceEase.prototype.easeInCore = function (gradient) {\n            var y = Math.max(0.0, this.bounces);\n            var bounciness = this.bounciness;\n            if (bounciness <= 1.0) {\n                bounciness = 1.001;\n            }\n            var num9 = Math.pow(bounciness, y);\n            var num5 = 1.0 - bounciness;\n            var num4 = ((1.0 - num9) / num5) + (num9 * 0.5);\n            var num15 = gradient * num4;\n            var num65 = Math.log((-num15 * (1.0 - bounciness)) + 1.0) / Math.log(bounciness);\n            var num3 = Math.floor(num65);\n            var num13 = num3 + 1.0;\n            var num8 = (1.0 - Math.pow(bounciness, num3)) / (num5 * num4);\n            var num12 = (1.0 - Math.pow(bounciness, num13)) / (num5 * num4);\n            var num7 = (num8 + num12) * 0.5;\n            var num6 = gradient - num7;\n            var num2 = num7 - num8;\n            return (((-Math.pow(1.0 / bounciness, y - num3) / (num2 * num2)) * (num6 - num2)) * (num6 + num2));\n        };\n        return BounceEase;\n    }(EasingFunction));\n    BABYLON.BounceEase = BounceEase;\n    var CubicEase = (function (_super) {\n        __extends(CubicEase, _super);\n        function CubicEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        CubicEase.prototype.easeInCore = function (gradient) {\n            return (gradient * gradient * gradient);\n        };\n        return CubicEase;\n    }(EasingFunction));\n    BABYLON.CubicEase = CubicEase;\n    var ElasticEase = (function (_super) {\n        __extends(ElasticEase, _super);\n        function ElasticEase(oscillations, springiness) {\n            if (oscillations === void 0) { oscillations = 3; }\n            if (springiness === void 0) { springiness = 3; }\n            var _this = _super.call(this) || this;\n            _this.oscillations = oscillations;\n            _this.springiness = springiness;\n            return _this;\n        }\n        ElasticEase.prototype.easeInCore = function (gradient) {\n            var num2;\n            var num3 = Math.max(0.0, this.oscillations);\n            var num = Math.max(0.0, this.springiness);\n            if (num == 0) {\n                num2 = gradient;\n            }\n            else {\n                num2 = (Math.exp(num * gradient) - 1.0) / (Math.exp(num) - 1.0);\n            }\n            return (num2 * Math.sin(((6.2831853071795862 * num3) + 1.5707963267948966) * gradient));\n        };\n        return ElasticEase;\n    }(EasingFunction));\n    BABYLON.ElasticEase = ElasticEase;\n    var ExponentialEase = (function (_super) {\n        __extends(ExponentialEase, _super);\n        function ExponentialEase(exponent) {\n            if (exponent === void 0) { exponent = 2; }\n            var _this = _super.call(this) || this;\n            _this.exponent = exponent;\n            return _this;\n        }\n        ExponentialEase.prototype.easeInCore = function (gradient) {\n            if (this.exponent <= 0) {\n                return gradient;\n            }\n            return ((Math.exp(this.exponent * gradient) - 1.0) / (Math.exp(this.exponent) - 1.0));\n        };\n        return ExponentialEase;\n    }(EasingFunction));\n    BABYLON.ExponentialEase = ExponentialEase;\n    var PowerEase = (function (_super) {\n        __extends(PowerEase, _super);\n        function PowerEase(power) {\n            if (power === void 0) { power = 2; }\n            var _this = _super.call(this) || this;\n            _this.power = power;\n            return _this;\n        }\n        PowerEase.prototype.easeInCore = function (gradient) {\n            var y = Math.max(0.0, this.power);\n            return Math.pow(gradient, y);\n        };\n        return PowerEase;\n    }(EasingFunction));\n    BABYLON.PowerEase = PowerEase;\n    var QuadraticEase = (function (_super) {\n        __extends(QuadraticEase, _super);\n        function QuadraticEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        QuadraticEase.prototype.easeInCore = function (gradient) {\n            return (gradient * gradient);\n        };\n        return QuadraticEase;\n    }(EasingFunction));\n    BABYLON.QuadraticEase = QuadraticEase;\n    var QuarticEase = (function (_super) {\n        __extends(QuarticEase, _super);\n        function QuarticEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        QuarticEase.prototype.easeInCore = function (gradient) {\n            return (gradient * gradient * gradient * gradient);\n        };\n        return QuarticEase;\n    }(EasingFunction));\n    BABYLON.QuarticEase = QuarticEase;\n    var QuinticEase = (function (_super) {\n        __extends(QuinticEase, _super);\n        function QuinticEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        QuinticEase.prototype.easeInCore = function (gradient) {\n            return (gradient * gradient * gradient * gradient * gradient);\n        };\n        return QuinticEase;\n    }(EasingFunction));\n    BABYLON.QuinticEase = QuinticEase;\n    var SineEase = (function (_super) {\n        __extends(SineEase, _super);\n        function SineEase() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        SineEase.prototype.easeInCore = function (gradient) {\n            return (1.0 - Math.sin(1.5707963267948966 * (1.0 - gradient)));\n        };\n        return SineEase;\n    }(EasingFunction));\n    BABYLON.SineEase = SineEase;\n    var BezierCurveEase = (function (_super) {\n        __extends(BezierCurveEase, _super);\n        function BezierCurveEase(x1, y1, x2, y2) {\n            if (x1 === void 0) { x1 = 0; }\n            if (y1 === void 0) { y1 = 0; }\n            if (x2 === void 0) { x2 = 1; }\n            if (y2 === void 0) { y2 = 1; }\n            var _this = _super.call(this) || this;\n            _this.x1 = x1;\n            _this.y1 = y1;\n            _this.x2 = x2;\n            _this.y2 = y2;\n            return _this;\n        }\n        BezierCurveEase.prototype.easeInCore = function (gradient) {\n            return BABYLON.BezierCurve.interpolate(gradient, this.x1, this.y1, this.x2, this.y2);\n        };\n        return BezierCurveEase;\n    }(EasingFunction));\n    BABYLON.BezierCurveEase = BezierCurveEase;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.easing.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Condition = (function () {\n        function Condition(actionManager) {\n            this._actionManager = actionManager;\n        }\n        Condition.prototype.isValid = function () {\n            return true;\n        };\n        Condition.prototype._getProperty = function (propertyPath) {\n            return this._actionManager._getProperty(propertyPath);\n        };\n        Condition.prototype._getEffectiveTarget = function (target, propertyPath) {\n            return this._actionManager._getEffectiveTarget(target, propertyPath);\n        };\n        Condition.prototype.serialize = function () {\n        };\n        Condition.prototype._serialize = function (serializedCondition) {\n            return {\n                type: 2,\n                children: [],\n                name: serializedCondition.name,\n                properties: serializedCondition.properties\n            };\n        };\n        return Condition;\n    }());\n    BABYLON.Condition = Condition;\n    var ValueCondition = (function (_super) {\n        __extends(ValueCondition, _super);\n        function ValueCondition(actionManager, target, propertyPath, value, operator) {\n            if (operator === void 0) { operator = ValueCondition.IsEqual; }\n            var _this = _super.call(this, actionManager) || this;\n            _this.propertyPath = propertyPath;\n            _this.value = value;\n            _this.operator = operator;\n            _this._target = target;\n            _this._effectiveTarget = _this._getEffectiveTarget(target, _this.propertyPath);\n            _this._property = _this._getProperty(_this.propertyPath);\n            return _this;\n        }\n        Object.defineProperty(ValueCondition, \"IsEqual\", {\n            get: function () {\n                return ValueCondition._IsEqual;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueCondition, \"IsDifferent\", {\n            get: function () {\n                return ValueCondition._IsDifferent;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueCondition, \"IsGreater\", {\n            get: function () {\n                return ValueCondition._IsGreater;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueCondition, \"IsLesser\", {\n            get: function () {\n                return ValueCondition._IsLesser;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        ValueCondition.prototype.isValid = function () {\n            switch (this.operator) {\n                case ValueCondition.IsGreater:\n                    return this._effectiveTarget[this._property] > this.value;\n                case ValueCondition.IsLesser:\n                    return this._effectiveTarget[this._property] < this.value;\n                case ValueCondition.IsEqual:\n                case ValueCondition.IsDifferent:\n                    var check;\n                    if (this.value.equals) {\n                        check = this.value.equals(this._effectiveTarget[this._property]);\n                    }\n                    else {\n                        check = this.value === this._effectiveTarget[this._property];\n                    }\n                    return this.operator === ValueCondition.IsEqual ? check : !check;\n            }\n            return false;\n        };\n        ValueCondition.prototype.serialize = function () {\n            return this._serialize({\n                name: \"ValueCondition\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"propertyPath\", value: this.propertyPath },\n                    { name: \"value\", value: BABYLON.Action._SerializeValueAsString(this.value) },\n                    { name: \"operator\", value: ValueCondition.GetOperatorName(this.operator) }\n                ]\n            });\n        };\n        ValueCondition.GetOperatorName = function (operator) {\n            switch (operator) {\n                case ValueCondition._IsEqual: return \"IsEqual\";\n                case ValueCondition._IsDifferent: return \"IsDifferent\";\n                case ValueCondition._IsGreater: return \"IsGreater\";\n                case ValueCondition._IsLesser: return \"IsLesser\";\n                default: return \"\";\n            }\n        };\n        return ValueCondition;\n    }(Condition));\n    // Statics\n    ValueCondition._IsEqual = 0;\n    ValueCondition._IsDifferent = 1;\n    ValueCondition._IsGreater = 2;\n    ValueCondition._IsLesser = 3;\n    BABYLON.ValueCondition = ValueCondition;\n    var PredicateCondition = (function (_super) {\n        __extends(PredicateCondition, _super);\n        function PredicateCondition(actionManager, predicate) {\n            var _this = _super.call(this, actionManager) || this;\n            _this.predicate = predicate;\n            return _this;\n        }\n        PredicateCondition.prototype.isValid = function () {\n            return this.predicate();\n        };\n        return PredicateCondition;\n    }(Condition));\n    BABYLON.PredicateCondition = PredicateCondition;\n    var StateCondition = (function (_super) {\n        __extends(StateCondition, _super);\n        function StateCondition(actionManager, target, value) {\n            var _this = _super.call(this, actionManager) || this;\n            _this.value = value;\n            _this._target = target;\n            return _this;\n        }\n        // Methods\n        StateCondition.prototype.isValid = function () {\n            return this._target.state === this.value;\n        };\n        StateCondition.prototype.serialize = function () {\n            return this._serialize({\n                name: \"StateCondition\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"value\", value: this.value }\n                ]\n            });\n        };\n        return StateCondition;\n    }(Condition));\n    BABYLON.StateCondition = StateCondition;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.condition.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Action = (function () {\n        function Action(triggerOptions, condition) {\n            this.triggerOptions = triggerOptions;\n            if (triggerOptions.parameter) {\n                this.trigger = triggerOptions.trigger;\n                this._triggerParameter = triggerOptions.parameter;\n            }\n            else {\n                this.trigger = triggerOptions;\n            }\n            this._nextActiveAction = this;\n            this._condition = condition;\n        }\n        // Methods\n        Action.prototype._prepare = function () {\n        };\n        Action.prototype.getTriggerParameter = function () {\n            return this._triggerParameter;\n        };\n        Action.prototype._executeCurrent = function (evt) {\n            if (this._nextActiveAction._condition) {\n                var condition = this._nextActiveAction._condition;\n                var currentRenderId = this._actionManager.getScene().getRenderId();\n                // We cache the current evaluation for the current frame\n                if (condition._evaluationId === currentRenderId) {\n                    if (!condition._currentResult) {\n                        return;\n                    }\n                }\n                else {\n                    condition._evaluationId = currentRenderId;\n                    if (!condition.isValid()) {\n                        condition._currentResult = false;\n                        return;\n                    }\n                    condition._currentResult = true;\n                }\n            }\n            this._nextActiveAction.execute(evt);\n            this.skipToNextActiveAction();\n        };\n        Action.prototype.execute = function (evt) {\n        };\n        Action.prototype.skipToNextActiveAction = function () {\n            if (this._nextActiveAction._child) {\n                if (!this._nextActiveAction._child._actionManager) {\n                    this._nextActiveAction._child._actionManager = this._actionManager;\n                }\n                this._nextActiveAction = this._nextActiveAction._child;\n            }\n            else {\n                this._nextActiveAction = this;\n            }\n        };\n        Action.prototype.then = function (action) {\n            this._child = action;\n            action._actionManager = this._actionManager;\n            action._prepare();\n            return action;\n        };\n        Action.prototype._getProperty = function (propertyPath) {\n            return this._actionManager._getProperty(propertyPath);\n        };\n        Action.prototype._getEffectiveTarget = function (target, propertyPath) {\n            return this._actionManager._getEffectiveTarget(target, propertyPath);\n        };\n        Action.prototype.serialize = function (parent) {\n        };\n        // Called by BABYLON.Action objects in serialize(...). Internal use\n        Action.prototype._serialize = function (serializedAction, parent) {\n            var serializationObject = {\n                type: 1,\n                children: [],\n                name: serializedAction.name,\n                properties: serializedAction.properties || []\n            };\n            // Serialize child\n            if (this._child) {\n                this._child.serialize(serializationObject);\n            }\n            // Check if \"this\" has a condition\n            if (this._condition) {\n                var serializedCondition = this._condition.serialize();\n                serializedCondition.children.push(serializationObject);\n                if (parent) {\n                    parent.children.push(serializedCondition);\n                }\n                return serializedCondition;\n            }\n            if (parent) {\n                parent.children.push(serializationObject);\n            }\n            return serializationObject;\n        };\n        return Action;\n    }());\n    Action._SerializeValueAsString = function (value) {\n        if (typeof value === \"number\") {\n            return value.toString();\n        }\n        if (typeof value === \"boolean\") {\n            return value ? \"true\" : \"false\";\n        }\n        if (value instanceof BABYLON.Vector2) {\n            return value.x + \", \" + value.y;\n        }\n        if (value instanceof BABYLON.Vector3) {\n            return value.x + \", \" + value.y + \", \" + value.z;\n        }\n        if (value instanceof BABYLON.Color3) {\n            return value.r + \", \" + value.g + \", \" + value.b;\n        }\n        if (value instanceof BABYLON.Color4) {\n            return value.r + \", \" + value.g + \", \" + value.b + \", \" + value.a;\n        }\n        return value; // string\n    };\n    Action._GetTargetProperty = function (target) {\n        return {\n            name: \"target\",\n            targetType: target instanceof BABYLON.Mesh ? \"MeshProperties\"\n                : target instanceof BABYLON.Light ? \"LightProperties\"\n                    : target instanceof BABYLON.Camera ? \"CameraProperties\"\n                        : \"SceneProperties\",\n            value: target instanceof BABYLON.Scene ? \"Scene\" : target.name\n        };\n    };\n    BABYLON.Action = Action;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.action.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * ActionEvent is the event beint sent when an action is triggered.\n     */\n    var ActionEvent = (function () {\n        /**\n         * @constructor\n         * @param source The mesh or sprite that triggered the action.\n         * @param pointerX The X mouse cursor position at the time of the event\n         * @param pointerY The Y mouse cursor position at the time of the event\n         * @param meshUnderPointer The mesh that is currently pointed at (can be null)\n         * @param sourceEvent the original (browser) event that triggered the ActionEvent\n         */\n        function ActionEvent(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {\n            this.source = source;\n            this.pointerX = pointerX;\n            this.pointerY = pointerY;\n            this.meshUnderPointer = meshUnderPointer;\n            this.sourceEvent = sourceEvent;\n            this.additionalData = additionalData;\n        }\n        /**\n         * Helper function to auto-create an ActionEvent from a source mesh.\n         * @param source The source mesh that triggered the event\n         * @param evt {Event} The original (browser) event\n         */\n        ActionEvent.CreateNew = function (source, evt, additionalData) {\n            var scene = source.getScene();\n            return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);\n        };\n        /**\n         * Helper function to auto-create an ActionEvent from a source mesh.\n         * @param source The source sprite that triggered the event\n         * @param scene Scene associated with the sprite\n         * @param evt {Event} The original (browser) event\n         */\n        ActionEvent.CreateNewFromSprite = function (source, scene, evt, additionalData) {\n            return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);\n        };\n        /**\n         * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew\n         * @param scene the scene where the event occurred\n         * @param evt {Event} The original (browser) event\n         */\n        ActionEvent.CreateNewFromScene = function (scene, evt) {\n            return new ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);\n        };\n        ActionEvent.CreateNewFromPrimitive = function (prim, pointerPos, evt, additionalData) {\n            return new ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);\n        };\n        return ActionEvent;\n    }());\n    BABYLON.ActionEvent = ActionEvent;\n    /**\n     * Action Manager manages all events to be triggered on a given mesh or the global scene.\n     * A single scene can have many Action Managers to handle predefined actions on specific meshes.\n     */\n    var ActionManager = (function () {\n        function ActionManager(scene) {\n            // Members\n            this.actions = new Array();\n            this.hoverCursor = '';\n            this._scene = scene;\n            scene._actionManagers.push(this);\n        }\n        Object.defineProperty(ActionManager, \"NothingTrigger\", {\n            get: function () {\n                return ActionManager._NothingTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPickTrigger\", {\n            get: function () {\n                return ActionManager._OnPickTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnLeftPickTrigger\", {\n            get: function () {\n                return ActionManager._OnLeftPickTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnRightPickTrigger\", {\n            get: function () {\n                return ActionManager._OnRightPickTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnCenterPickTrigger\", {\n            get: function () {\n                return ActionManager._OnCenterPickTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPickDownTrigger\", {\n            get: function () {\n                return ActionManager._OnPickDownTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnDoublePickTrigger\", {\n            get: function () {\n                return ActionManager._OnDoublePickTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPickUpTrigger\", {\n            get: function () {\n                return ActionManager._OnPickUpTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPickOutTrigger\", {\n            /// This trigger will only be raised if you also declared a OnPickDown\n            get: function () {\n                return ActionManager._OnPickOutTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnLongPressTrigger\", {\n            get: function () {\n                return ActionManager._OnLongPressTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPointerOverTrigger\", {\n            get: function () {\n                return ActionManager._OnPointerOverTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnPointerOutTrigger\", {\n            get: function () {\n                return ActionManager._OnPointerOutTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnEveryFrameTrigger\", {\n            get: function () {\n                return ActionManager._OnEveryFrameTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnIntersectionEnterTrigger\", {\n            get: function () {\n                return ActionManager._OnIntersectionEnterTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnIntersectionExitTrigger\", {\n            get: function () {\n                return ActionManager._OnIntersectionExitTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnKeyDownTrigger\", {\n            get: function () {\n                return ActionManager._OnKeyDownTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"OnKeyUpTrigger\", {\n            get: function () {\n                return ActionManager._OnKeyUpTrigger;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        ActionManager.prototype.dispose = function () {\n            var index = this._scene._actionManagers.indexOf(this);\n            for (var i = 0; i < this.actions.length; i++) {\n                var action = this.actions[i];\n                ActionManager.Triggers[action.trigger]--;\n                if (ActionManager.Triggers[action.trigger] === 0) {\n                    delete ActionManager.Triggers[action.trigger];\n                }\n            }\n            if (index > -1) {\n                this._scene._actionManagers.splice(index, 1);\n            }\n        };\n        ActionManager.prototype.getScene = function () {\n            return this._scene;\n        };\n        /**\n         * Does this action manager handles actions of any of the given triggers\n         * @param {number[]} triggers - the triggers to be tested\n         * @return {boolean} whether one (or more) of the triggers is handeled\n         */\n        ActionManager.prototype.hasSpecificTriggers = function (triggers) {\n            for (var index = 0; index < this.actions.length; index++) {\n                var action = this.actions[index];\n                if (triggers.indexOf(action.trigger) > -1) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * Does this action manager handles actions of a given trigger\n         * @param {number} trigger - the trigger to be tested\n         * @return {boolean} whether the trigger is handeled\n         */\n        ActionManager.prototype.hasSpecificTrigger = function (trigger) {\n            for (var index = 0; index < this.actions.length; index++) {\n                var action = this.actions[index];\n                if (action.trigger === trigger) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        Object.defineProperty(ActionManager.prototype, \"hasPointerTriggers\", {\n            /**\n             * Does this action manager has pointer triggers\n             * @return {boolean} whether or not it has pointer triggers\n             */\n            get: function () {\n                for (var index = 0; index < this.actions.length; index++) {\n                    var action = this.actions[index];\n                    if (action.trigger >= ActionManager._OnPickTrigger && action.trigger <= ActionManager._OnPointerOutTrigger) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager.prototype, \"hasPickTriggers\", {\n            /**\n             * Does this action manager has pick triggers\n             * @return {boolean} whether or not it has pick triggers\n             */\n            get: function () {\n                for (var index = 0; index < this.actions.length; index++) {\n                    var action = this.actions[index];\n                    if (action.trigger >= ActionManager._OnPickTrigger && action.trigger <= ActionManager._OnPickUpTrigger) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"HasTriggers\", {\n            /**\n             * Does exist one action manager with at least one trigger\n             * @return {boolean} whether or not it exists one action manager with one trigger\n            **/\n            get: function () {\n                for (var t in ActionManager.Triggers) {\n                    if (ActionManager.Triggers.hasOwnProperty(t)) {\n                        return true;\n                    }\n                }\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ActionManager, \"HasPickTriggers\", {\n            /**\n             * Does exist one action manager with at least one pick trigger\n             * @return {boolean} whether or not it exists one action manager with one pick trigger\n            **/\n            get: function () {\n                for (var t in ActionManager.Triggers) {\n                    if (ActionManager.Triggers.hasOwnProperty(t)) {\n                        var t_int = parseInt(t);\n                        if (t_int >= ActionManager._OnPickTrigger && t_int <= ActionManager._OnPickUpTrigger) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Does exist one action manager that handles actions of a given trigger\n         * @param {number} trigger - the trigger to be tested\n         * @return {boolean} whether the trigger is handeled by at least one action manager\n        **/\n        ActionManager.HasSpecificTrigger = function (trigger) {\n            for (var t in ActionManager.Triggers) {\n                if (ActionManager.Triggers.hasOwnProperty(t)) {\n                    var t_int = parseInt(t);\n                    if (t_int === trigger) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        /**\n         * Registers an action to this action manager\n         * @param {BABYLON.Action} action - the action to be registered\n         * @return {BABYLON.Action} the action amended (prepared) after registration\n         */\n        ActionManager.prototype.registerAction = function (action) {\n            if (action.trigger === ActionManager.OnEveryFrameTrigger) {\n                if (this.getScene().actionManager !== this) {\n                    BABYLON.Tools.Warn(\"OnEveryFrameTrigger can only be used with scene.actionManager\");\n                    return null;\n                }\n            }\n            this.actions.push(action);\n            if (ActionManager.Triggers[action.trigger]) {\n                ActionManager.Triggers[action.trigger]++;\n            }\n            else {\n                ActionManager.Triggers[action.trigger] = 1;\n            }\n            action._actionManager = this;\n            action._prepare();\n            return action;\n        };\n        /**\n         * Process a specific trigger\n         * @param {number} trigger - the trigger to process\n         * @param evt {BABYLON.ActionEvent} the event details to be processed\n         */\n        ActionManager.prototype.processTrigger = function (trigger, evt) {\n            for (var index = 0; index < this.actions.length; index++) {\n                var action = this.actions[index];\n                if (action.trigger === trigger) {\n                    if (trigger === ActionManager.OnKeyUpTrigger\n                        || trigger === ActionManager.OnKeyDownTrigger) {\n                        var parameter = action.getTriggerParameter();\n                        if (parameter && parameter !== evt.sourceEvent.keyCode) {\n                            if (!parameter.toLowerCase) {\n                                continue;\n                            }\n                            var lowerCase = parameter.toLowerCase();\n                            if (lowerCase !== evt.sourceEvent.key) {\n                                var unicode = evt.sourceEvent.charCode ? evt.sourceEvent.charCode : evt.sourceEvent.keyCode;\n                                var actualkey = String.fromCharCode(unicode).toLowerCase();\n                                if (actualkey !== lowerCase) {\n                                    continue;\n                                }\n                            }\n                        }\n                    }\n                    action._executeCurrent(evt);\n                }\n            }\n        };\n        ActionManager.prototype._getEffectiveTarget = function (target, propertyPath) {\n            var properties = propertyPath.split(\".\");\n            for (var index = 0; index < properties.length - 1; index++) {\n                target = target[properties[index]];\n            }\n            return target;\n        };\n        ActionManager.prototype._getProperty = function (propertyPath) {\n            var properties = propertyPath.split(\".\");\n            return properties[properties.length - 1];\n        };\n        ActionManager.prototype.serialize = function (name) {\n            var root = {\n                children: [],\n                name: name,\n                type: 3,\n                properties: [] // Empty for root but required\n            };\n            for (var i = 0; i < this.actions.length; i++) {\n                var triggerObject = {\n                    type: 0,\n                    children: [],\n                    name: ActionManager.GetTriggerName(this.actions[i].trigger),\n                    properties: []\n                };\n                var triggerOptions = this.actions[i].triggerOptions;\n                if (triggerOptions && typeof triggerOptions !== \"number\") {\n                    if (triggerOptions.parameter instanceof BABYLON.Node) {\n                        triggerObject.properties.push(BABYLON.Action._GetTargetProperty(triggerOptions.parameter));\n                    }\n                    else {\n                        var parameter = {};\n                        BABYLON.Tools.DeepCopy(triggerOptions.parameter, parameter, [\"mesh\"]);\n                        if (triggerOptions.parameter.mesh) {\n                            parameter._meshId = triggerOptions.parameter.mesh.id;\n                        }\n                        triggerObject.properties.push({ name: \"parameter\", targetType: null, value: parameter });\n                    }\n                }\n                // Serialize child action, recursively\n                this.actions[i].serialize(triggerObject);\n                // Add serialized trigger\n                root.children.push(triggerObject);\n            }\n            return root;\n        };\n        ActionManager.Parse = function (parsedActions, object, scene) {\n            var actionManager = new BABYLON.ActionManager(scene);\n            if (object === null)\n                scene.actionManager = actionManager;\n            else\n                object.actionManager = actionManager;\n            // instanciate a new object\n            var instanciate = function (name, params) {\n                var newInstance = Object.create(BABYLON[name].prototype);\n                newInstance.constructor.apply(newInstance, params);\n                return newInstance;\n            };\n            var parseParameter = function (name, value, target, propertyPath) {\n                if (propertyPath === null) {\n                    // String, boolean or float\n                    var floatValue = parseFloat(value);\n                    if (value === \"true\" || value === \"false\")\n                        return value === \"true\";\n                    else\n                        return isNaN(floatValue) ? value : floatValue;\n                }\n                var effectiveTarget = propertyPath.split(\".\");\n                var values = value.split(\",\");\n                // Get effective Target\n                for (var i = 0; i < effectiveTarget.length; i++) {\n                    target = target[effectiveTarget[i]];\n                }\n                // Return appropriate value with its type\n                if (typeof (target) === \"boolean\")\n                    return values[0] === \"true\";\n                if (typeof (target) === \"string\")\n                    return values[0];\n                // Parameters with multiple values such as Vector3 etc.\n                var split = new Array();\n                for (var i = 0; i < values.length; i++)\n                    split.push(parseFloat(values[i]));\n                if (target instanceof BABYLON.Vector3)\n                    return BABYLON.Vector3.FromArray(split);\n                if (target instanceof BABYLON.Vector4)\n                    return BABYLON.Vector4.FromArray(split);\n                if (target instanceof BABYLON.Color3)\n                    return BABYLON.Color3.FromArray(split);\n                if (target instanceof BABYLON.Color4)\n                    return BABYLON.Color4.FromArray(split);\n                return parseFloat(values[0]);\n            };\n            // traverse graph per trigger\n            var traverse = function (parsedAction, trigger, condition, action, combineArray) {\n                if (combineArray === void 0) { combineArray = null; }\n                if (parsedAction.detached)\n                    return;\n                var parameters = new Array();\n                var target = null;\n                var propertyPath = null;\n                var combine = parsedAction.combine && parsedAction.combine.length > 0;\n                // Parameters\n                if (parsedAction.type === 2)\n                    parameters.push(actionManager);\n                else\n                    parameters.push(trigger);\n                if (combine) {\n                    var actions = new Array();\n                    for (var j = 0; j < parsedAction.combine.length; j++) {\n                        traverse(parsedAction.combine[j], ActionManager.NothingTrigger, condition, action, actions);\n                    }\n                    parameters.push(actions);\n                }\n                else {\n                    for (var i = 0; i < parsedAction.properties.length; i++) {\n                        var value = parsedAction.properties[i].value;\n                        var name = parsedAction.properties[i].name;\n                        var targetType = parsedAction.properties[i].targetType;\n                        if (name === \"target\")\n                            if (targetType !== null && targetType === \"SceneProperties\")\n                                value = target = scene;\n                            else\n                                value = target = scene.getNodeByName(value);\n                        else if (name === \"parent\")\n                            value = scene.getNodeByName(value);\n                        else if (name === \"sound\")\n                            value = scene.getSoundByName(value);\n                        else if (name !== \"propertyPath\") {\n                            if (parsedAction.type === 2 && name === \"operator\")\n                                value = BABYLON.ValueCondition[value];\n                            else\n                                value = parseParameter(name, value, target, name === \"value\" ? propertyPath : null);\n                        }\n                        else {\n                            propertyPath = value;\n                        }\n                        parameters.push(value);\n                    }\n                }\n                if (combineArray === null) {\n                    parameters.push(condition);\n                }\n                else {\n                    parameters.push(null);\n                }\n                // If interpolate value action\n                if (parsedAction.name === \"InterpolateValueAction\") {\n                    var param = parameters[parameters.length - 2];\n                    parameters[parameters.length - 1] = param;\n                    parameters[parameters.length - 2] = condition;\n                }\n                // Action or condition(s) and not CombineAction\n                var newAction = instanciate(parsedAction.name, parameters);\n                if (newAction instanceof BABYLON.Condition && condition !== null) {\n                    var nothing = new BABYLON.DoNothingAction(trigger, condition);\n                    if (action)\n                        action.then(nothing);\n                    else\n                        actionManager.registerAction(nothing);\n                    action = nothing;\n                }\n                if (combineArray === null) {\n                    if (newAction instanceof BABYLON.Condition) {\n                        condition = newAction;\n                        newAction = action;\n                    }\n                    else {\n                        condition = null;\n                        if (action)\n                            action.then(newAction);\n                        else\n                            actionManager.registerAction(newAction);\n                    }\n                }\n                else {\n                    combineArray.push(newAction);\n                }\n                for (var i = 0; i < parsedAction.children.length; i++)\n                    traverse(parsedAction.children[i], trigger, condition, newAction, null);\n            };\n            // triggers\n            for (var i = 0; i < parsedActions.children.length; i++) {\n                var triggerParams;\n                var trigger = parsedActions.children[i];\n                if (trigger.properties.length > 0) {\n                    var param = trigger.properties[0].value;\n                    var value = trigger.properties[0].targetType === null ? param : scene.getMeshByName(param);\n                    if (value._meshId) {\n                        value.mesh = scene.getMeshByID(value._meshId);\n                    }\n                    triggerParams = { trigger: BABYLON.ActionManager[trigger.name], parameter: value };\n                }\n                else\n                    triggerParams = BABYLON.ActionManager[trigger.name];\n                for (var j = 0; j < trigger.children.length; j++) {\n                    if (!trigger.detached)\n                        traverse(trigger.children[j], triggerParams, null, null);\n                }\n            }\n        };\n        ActionManager.GetTriggerName = function (trigger) {\n            switch (trigger) {\n                case 0: return \"NothingTrigger\";\n                case 1: return \"OnPickTrigger\";\n                case 2: return \"OnLeftPickTrigger\";\n                case 3: return \"OnRightPickTrigger\";\n                case 4: return \"OnCenterPickTrigger\";\n                case 5: return \"OnPickDownTrigger\";\n                case 6: return \"OnPickUpTrigger\";\n                case 7: return \"OnLongPressTrigger\";\n                case 8: return \"OnPointerOverTrigger\";\n                case 9: return \"OnPointerOutTrigger\";\n                case 10: return \"OnEveryFrameTrigger\";\n                case 11: return \"OnIntersectionEnterTrigger\";\n                case 12: return \"OnIntersectionExitTrigger\";\n                case 13: return \"OnKeyDownTrigger\";\n                case 14: return \"OnKeyUpTrigger\";\n                case 15: return \"OnPickOutTrigger\";\n                default: return \"\";\n            }\n        };\n        return ActionManager;\n    }());\n    // Statics\n    ActionManager._NothingTrigger = 0;\n    ActionManager._OnPickTrigger = 1;\n    ActionManager._OnLeftPickTrigger = 2;\n    ActionManager._OnRightPickTrigger = 3;\n    ActionManager._OnCenterPickTrigger = 4;\n    ActionManager._OnPickDownTrigger = 5;\n    ActionManager._OnDoublePickTrigger = 6;\n    ActionManager._OnPickUpTrigger = 7;\n    ActionManager._OnLongPressTrigger = 8;\n    ActionManager._OnPointerOverTrigger = 9;\n    ActionManager._OnPointerOutTrigger = 10;\n    ActionManager._OnEveryFrameTrigger = 11;\n    ActionManager._OnIntersectionEnterTrigger = 12;\n    ActionManager._OnIntersectionExitTrigger = 13;\n    ActionManager._OnKeyDownTrigger = 14;\n    ActionManager._OnKeyUpTrigger = 15;\n    ActionManager._OnPickOutTrigger = 16;\n    ActionManager.Triggers = {};\n    BABYLON.ActionManager = ActionManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.actionManager.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var InterpolateValueAction = (function (_super) {\n        __extends(InterpolateValueAction, _super);\n        function InterpolateValueAction(triggerOptions, target, propertyPath, value, duration, condition, stopOtherAnimations, onInterpolationDone) {\n            if (duration === void 0) { duration = 1000; }\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.propertyPath = propertyPath;\n            _this.value = value;\n            _this.duration = duration;\n            _this.stopOtherAnimations = stopOtherAnimations;\n            _this.onInterpolationDone = onInterpolationDone;\n            _this._target = _this._effectiveTarget = target;\n            return _this;\n        }\n        InterpolateValueAction.prototype._prepare = function () {\n            this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n            this._property = this._getProperty(this.propertyPath);\n        };\n        InterpolateValueAction.prototype.execute = function () {\n            var scene = this._actionManager.getScene();\n            var keys = [\n                {\n                    frame: 0,\n                    value: this._effectiveTarget[this._property]\n                }, {\n                    frame: 100,\n                    value: this.value\n                }\n            ];\n            var dataType;\n            if (typeof this.value === \"number\") {\n                dataType = BABYLON.Animation.ANIMATIONTYPE_FLOAT;\n            }\n            else if (this.value instanceof BABYLON.Color3) {\n                dataType = BABYLON.Animation.ANIMATIONTYPE_COLOR3;\n            }\n            else if (this.value instanceof BABYLON.Vector3) {\n                dataType = BABYLON.Animation.ANIMATIONTYPE_VECTOR3;\n            }\n            else if (this.value instanceof BABYLON.Matrix) {\n                dataType = BABYLON.Animation.ANIMATIONTYPE_MATRIX;\n            }\n            else if (this.value instanceof BABYLON.Quaternion) {\n                dataType = BABYLON.Animation.ANIMATIONTYPE_QUATERNION;\n            }\n            else {\n                BABYLON.Tools.Warn(\"InterpolateValueAction: Unsupported type (\" + typeof this.value + \")\");\n                return;\n            }\n            var animation = new BABYLON.Animation(\"InterpolateValueAction\", this._property, 100 * (1000.0 / this.duration), dataType, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);\n            animation.setKeys(keys);\n            if (this.stopOtherAnimations) {\n                scene.stopAnimation(this._effectiveTarget);\n            }\n            scene.beginDirectAnimation(this._effectiveTarget, [animation], 0, 100, false, 1, this.onInterpolationDone);\n        };\n        InterpolateValueAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"InterpolateValueAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"propertyPath\", value: this.propertyPath },\n                    { name: \"value\", value: BABYLON.Action._SerializeValueAsString(this.value) },\n                    { name: \"duration\", value: BABYLON.Action._SerializeValueAsString(this.duration) },\n                    { name: \"stopOtherAnimations\", value: BABYLON.Action._SerializeValueAsString(this.stopOtherAnimations) || false }\n                ]\n            }, parent);\n        };\n        return InterpolateValueAction;\n    }(BABYLON.Action));\n    BABYLON.InterpolateValueAction = InterpolateValueAction;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.interpolateValueAction.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var SwitchBooleanAction = (function (_super) {\n        __extends(SwitchBooleanAction, _super);\n        function SwitchBooleanAction(triggerOptions, target, propertyPath, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.propertyPath = propertyPath;\n            _this._target = _this._effectiveTarget = target;\n            return _this;\n        }\n        SwitchBooleanAction.prototype._prepare = function () {\n            this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n            this._property = this._getProperty(this.propertyPath);\n        };\n        SwitchBooleanAction.prototype.execute = function () {\n            this._effectiveTarget[this._property] = !this._effectiveTarget[this._property];\n        };\n        SwitchBooleanAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"SwitchBooleanAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"propertyPath\", value: this.propertyPath }\n                ]\n            }, parent);\n        };\n        return SwitchBooleanAction;\n    }(BABYLON.Action));\n    BABYLON.SwitchBooleanAction = SwitchBooleanAction;\n    var SetStateAction = (function (_super) {\n        __extends(SetStateAction, _super);\n        function SetStateAction(triggerOptions, target, value, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.value = value;\n            _this._target = target;\n            return _this;\n        }\n        SetStateAction.prototype.execute = function () {\n            this._target.state = this.value;\n        };\n        SetStateAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"SetStateAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"value\", value: this.value }\n                ]\n            }, parent);\n        };\n        return SetStateAction;\n    }(BABYLON.Action));\n    BABYLON.SetStateAction = SetStateAction;\n    var SetValueAction = (function (_super) {\n        __extends(SetValueAction, _super);\n        function SetValueAction(triggerOptions, target, propertyPath, value, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.propertyPath = propertyPath;\n            _this.value = value;\n            _this._target = _this._effectiveTarget = target;\n            return _this;\n        }\n        SetValueAction.prototype._prepare = function () {\n            this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n            this._property = this._getProperty(this.propertyPath);\n        };\n        SetValueAction.prototype.execute = function () {\n            this._effectiveTarget[this._property] = this.value;\n            if (this._target.markAsDirty) {\n                this._target.markAsDirty(this._property);\n            }\n        };\n        SetValueAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"SetValueAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"propertyPath\", value: this.propertyPath },\n                    { name: \"value\", value: BABYLON.Action._SerializeValueAsString(this.value) }\n                ]\n            }, parent);\n        };\n        return SetValueAction;\n    }(BABYLON.Action));\n    BABYLON.SetValueAction = SetValueAction;\n    var IncrementValueAction = (function (_super) {\n        __extends(IncrementValueAction, _super);\n        function IncrementValueAction(triggerOptions, target, propertyPath, value, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.propertyPath = propertyPath;\n            _this.value = value;\n            _this._target = _this._effectiveTarget = target;\n            return _this;\n        }\n        IncrementValueAction.prototype._prepare = function () {\n            this._effectiveTarget = this._getEffectiveTarget(this._effectiveTarget, this.propertyPath);\n            this._property = this._getProperty(this.propertyPath);\n            if (typeof this._effectiveTarget[this._property] !== \"number\") {\n                BABYLON.Tools.Warn(\"Warning: IncrementValueAction can only be used with number values\");\n            }\n        };\n        IncrementValueAction.prototype.execute = function () {\n            this._effectiveTarget[this._property] += this.value;\n            if (this._target.markAsDirty) {\n                this._target.markAsDirty(this._property);\n            }\n        };\n        IncrementValueAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"IncrementValueAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"propertyPath\", value: this.propertyPath },\n                    { name: \"value\", value: BABYLON.Action._SerializeValueAsString(this.value) }\n                ]\n            }, parent);\n        };\n        return IncrementValueAction;\n    }(BABYLON.Action));\n    BABYLON.IncrementValueAction = IncrementValueAction;\n    var PlayAnimationAction = (function (_super) {\n        __extends(PlayAnimationAction, _super);\n        function PlayAnimationAction(triggerOptions, target, from, to, loop, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.from = from;\n            _this.to = to;\n            _this.loop = loop;\n            _this._target = target;\n            return _this;\n        }\n        PlayAnimationAction.prototype._prepare = function () {\n        };\n        PlayAnimationAction.prototype.execute = function () {\n            var scene = this._actionManager.getScene();\n            scene.beginAnimation(this._target, this.from, this.to, this.loop);\n        };\n        PlayAnimationAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"PlayAnimationAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    { name: \"from\", value: String(this.from) },\n                    { name: \"to\", value: String(this.to) },\n                    { name: \"loop\", value: BABYLON.Action._SerializeValueAsString(this.loop) || false }\n                ]\n            }, parent);\n        };\n        return PlayAnimationAction;\n    }(BABYLON.Action));\n    BABYLON.PlayAnimationAction = PlayAnimationAction;\n    var StopAnimationAction = (function (_super) {\n        __extends(StopAnimationAction, _super);\n        function StopAnimationAction(triggerOptions, target, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this._target = target;\n            return _this;\n        }\n        StopAnimationAction.prototype._prepare = function () {\n        };\n        StopAnimationAction.prototype.execute = function () {\n            var scene = this._actionManager.getScene();\n            scene.stopAnimation(this._target);\n        };\n        StopAnimationAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"StopAnimationAction\",\n                properties: [BABYLON.Action._GetTargetProperty(this._target)]\n            }, parent);\n        };\n        return StopAnimationAction;\n    }(BABYLON.Action));\n    BABYLON.StopAnimationAction = StopAnimationAction;\n    var DoNothingAction = (function (_super) {\n        __extends(DoNothingAction, _super);\n        function DoNothingAction(triggerOptions, condition) {\n            if (triggerOptions === void 0) { triggerOptions = BABYLON.ActionManager.NothingTrigger; }\n            return _super.call(this, triggerOptions, condition) || this;\n        }\n        DoNothingAction.prototype.execute = function () {\n        };\n        DoNothingAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"DoNothingAction\",\n                properties: []\n            }, parent);\n        };\n        return DoNothingAction;\n    }(BABYLON.Action));\n    BABYLON.DoNothingAction = DoNothingAction;\n    var CombineAction = (function (_super) {\n        __extends(CombineAction, _super);\n        function CombineAction(triggerOptions, children, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.children = children;\n            return _this;\n        }\n        CombineAction.prototype._prepare = function () {\n            for (var index = 0; index < this.children.length; index++) {\n                this.children[index]._actionManager = this._actionManager;\n                this.children[index]._prepare();\n            }\n        };\n        CombineAction.prototype.execute = function (evt) {\n            for (var index = 0; index < this.children.length; index++) {\n                this.children[index].execute(evt);\n            }\n        };\n        CombineAction.prototype.serialize = function (parent) {\n            var serializationObject = _super.prototype._serialize.call(this, {\n                name: \"CombineAction\",\n                properties: [],\n                combine: []\n            }, parent);\n            for (var i = 0; i < this.children.length; i++) {\n                serializationObject.combine.push(this.children[i].serialize(null));\n            }\n            return serializationObject;\n        };\n        return CombineAction;\n    }(BABYLON.Action));\n    BABYLON.CombineAction = CombineAction;\n    var ExecuteCodeAction = (function (_super) {\n        __extends(ExecuteCodeAction, _super);\n        function ExecuteCodeAction(triggerOptions, func, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this.func = func;\n            return _this;\n        }\n        ExecuteCodeAction.prototype.execute = function (evt) {\n            this.func(evt);\n        };\n        return ExecuteCodeAction;\n    }(BABYLON.Action));\n    BABYLON.ExecuteCodeAction = ExecuteCodeAction;\n    var SetParentAction = (function (_super) {\n        __extends(SetParentAction, _super);\n        function SetParentAction(triggerOptions, target, parent, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this._target = target;\n            _this._parent = parent;\n            return _this;\n        }\n        SetParentAction.prototype._prepare = function () {\n        };\n        SetParentAction.prototype.execute = function () {\n            if (this._target.parent === this._parent) {\n                return;\n            }\n            var invertParentWorldMatrix = this._parent.getWorldMatrix().clone();\n            invertParentWorldMatrix.invert();\n            this._target.position = BABYLON.Vector3.TransformCoordinates(this._target.position, invertParentWorldMatrix);\n            this._target.parent = this._parent;\n        };\n        SetParentAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"SetParentAction\",\n                properties: [\n                    BABYLON.Action._GetTargetProperty(this._target),\n                    BABYLON.Action._GetTargetProperty(this._parent),\n                ]\n            }, parent);\n        };\n        return SetParentAction;\n    }(BABYLON.Action));\n    BABYLON.SetParentAction = SetParentAction;\n    var PlaySoundAction = (function (_super) {\n        __extends(PlaySoundAction, _super);\n        function PlaySoundAction(triggerOptions, sound, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this._sound = sound;\n            return _this;\n        }\n        PlaySoundAction.prototype._prepare = function () {\n        };\n        PlaySoundAction.prototype.execute = function () {\n            if (this._sound !== undefined)\n                this._sound.play();\n        };\n        PlaySoundAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"PlaySoundAction\",\n                properties: [{ name: \"sound\", value: this._sound.name }]\n            }, parent);\n        };\n        return PlaySoundAction;\n    }(BABYLON.Action));\n    BABYLON.PlaySoundAction = PlaySoundAction;\n    var StopSoundAction = (function (_super) {\n        __extends(StopSoundAction, _super);\n        function StopSoundAction(triggerOptions, sound, condition) {\n            var _this = _super.call(this, triggerOptions, condition) || this;\n            _this._sound = sound;\n            return _this;\n        }\n        StopSoundAction.prototype._prepare = function () {\n        };\n        StopSoundAction.prototype.execute = function () {\n            if (this._sound !== undefined)\n                this._sound.stop();\n        };\n        StopSoundAction.prototype.serialize = function (parent) {\n            return _super.prototype._serialize.call(this, {\n                name: \"StopSoundAction\",\n                properties: [{ name: \"sound\", value: this._sound.name }]\n            }, parent);\n        };\n        return StopSoundAction;\n    }(BABYLON.Action));\n    BABYLON.StopSoundAction = StopSoundAction;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.directActions.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SpriteManager = (function () {\n        function SpriteManager(name, imgUrl, capacity, cellSize, scene, epsilon, samplingMode) {\n            if (epsilon === void 0) { epsilon = 0.01; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            this.name = name;\n            this.sprites = new Array();\n            this.renderingGroupId = 0;\n            this.layerMask = 0x0FFFFFFF;\n            this.fogEnabled = true;\n            this.isPickable = false;\n            /**\n            * An event triggered when the manager is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            this._vertexBuffers = {};\n            this._capacity = capacity;\n            this._spriteTexture = new BABYLON.Texture(imgUrl, scene, true, false, samplingMode);\n            this._spriteTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._spriteTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            if (cellSize.width && cellSize.height) {\n                this.cellWidth = cellSize.width;\n                this.cellHeight = cellSize.height;\n            }\n            else if (cellSize !== undefined) {\n                this.cellWidth = cellSize;\n                this.cellHeight = cellSize;\n            }\n            else {\n                return;\n            }\n            this._epsilon = epsilon;\n            this._scene = scene;\n            this._scene.spriteManagers.push(this);\n            var indices = [];\n            var index = 0;\n            for (var count = 0; count < capacity; count++) {\n                indices.push(index);\n                indices.push(index + 1);\n                indices.push(index + 2);\n                indices.push(index);\n                indices.push(index + 2);\n                indices.push(index + 3);\n                index += 4;\n            }\n            this._indexBuffer = scene.getEngine().createIndexBuffer(indices);\n            // VBO\n            // 16 floats per sprite (x, y, z, angle, sizeX, sizeY, offsetX, offsetY, invertU, invertV, cellIndexX, cellIndexY, color r, color g, color b, color a)\n            this._vertexData = new Float32Array(capacity * 16 * 4);\n            this._buffer = new BABYLON.Buffer(scene.getEngine(), this._vertexData, true, 16);\n            var positions = this._buffer.createVertexBuffer(BABYLON.VertexBuffer.PositionKind, 0, 4);\n            var options = this._buffer.createVertexBuffer(\"options\", 4, 4);\n            var cellInfo = this._buffer.createVertexBuffer(\"cellInfo\", 8, 4);\n            var colors = this._buffer.createVertexBuffer(BABYLON.VertexBuffer.ColorKind, 12, 4);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = positions;\n            this._vertexBuffers[\"options\"] = options;\n            this._vertexBuffers[\"cellInfo\"] = cellInfo;\n            this._vertexBuffers[BABYLON.VertexBuffer.ColorKind] = colors;\n            // Effects\n            this._effectBase = this._scene.getEngine().createEffect(\"sprites\", [BABYLON.VertexBuffer.PositionKind, \"options\", \"cellInfo\", BABYLON.VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\"], [\"diffuseSampler\"], \"\");\n            this._effectFog = this._scene.getEngine().createEffect(\"sprites\", [BABYLON.VertexBuffer.PositionKind, \"options\", \"cellInfo\", BABYLON.VertexBuffer.ColorKind], [\"view\", \"projection\", \"textureInfos\", \"alphaTest\", \"vFogInfos\", \"vFogColor\"], [\"diffuseSampler\"], \"#define FOG\");\n        }\n        Object.defineProperty(SpriteManager.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SpriteManager.prototype, \"texture\", {\n            get: function () {\n                return this._spriteTexture;\n            },\n            set: function (value) {\n                this._spriteTexture = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        SpriteManager.prototype._appendSpriteVertex = function (index, sprite, offsetX, offsetY, rowSize) {\n            var arrayOffset = index * 16;\n            if (offsetX === 0)\n                offsetX = this._epsilon;\n            else if (offsetX === 1)\n                offsetX = 1 - this._epsilon;\n            if (offsetY === 0)\n                offsetY = this._epsilon;\n            else if (offsetY === 1)\n                offsetY = 1 - this._epsilon;\n            this._vertexData[arrayOffset] = sprite.position.x;\n            this._vertexData[arrayOffset + 1] = sprite.position.y;\n            this._vertexData[arrayOffset + 2] = sprite.position.z;\n            this._vertexData[arrayOffset + 3] = sprite.angle;\n            this._vertexData[arrayOffset + 4] = sprite.width;\n            this._vertexData[arrayOffset + 5] = sprite.height;\n            this._vertexData[arrayOffset + 6] = offsetX;\n            this._vertexData[arrayOffset + 7] = offsetY;\n            this._vertexData[arrayOffset + 8] = sprite.invertU ? 1 : 0;\n            this._vertexData[arrayOffset + 9] = sprite.invertV ? 1 : 0;\n            var offset = (sprite.cellIndex / rowSize) >> 0;\n            this._vertexData[arrayOffset + 10] = sprite.cellIndex - offset * rowSize;\n            this._vertexData[arrayOffset + 11] = offset;\n            // Color\n            this._vertexData[arrayOffset + 12] = sprite.color.r;\n            this._vertexData[arrayOffset + 13] = sprite.color.g;\n            this._vertexData[arrayOffset + 14] = sprite.color.b;\n            this._vertexData[arrayOffset + 15] = sprite.color.a;\n        };\n        SpriteManager.prototype.intersects = function (ray, camera, predicate, fastCheck) {\n            var count = Math.min(this._capacity, this.sprites.length);\n            var min = BABYLON.Vector3.Zero();\n            var max = BABYLON.Vector3.Zero();\n            var distance = Number.MAX_VALUE;\n            var currentSprite;\n            var cameraSpacePosition = BABYLON.Vector3.Zero();\n            var cameraView = camera.getViewMatrix();\n            for (var index = 0; index < count; index++) {\n                var sprite = this.sprites[index];\n                if (!sprite) {\n                    continue;\n                }\n                if (predicate) {\n                    if (!predicate(sprite)) {\n                        continue;\n                    }\n                }\n                else if (!sprite.isPickable) {\n                    continue;\n                }\n                BABYLON.Vector3.TransformCoordinatesToRef(sprite.position, cameraView, cameraSpacePosition);\n                min.copyFromFloats(cameraSpacePosition.x - sprite.width / 2, cameraSpacePosition.y - sprite.height / 2, cameraSpacePosition.z);\n                max.copyFromFloats(cameraSpacePosition.x + sprite.width / 2, cameraSpacePosition.y + sprite.height / 2, cameraSpacePosition.z);\n                if (ray.intersectsBoxMinMax(min, max)) {\n                    var currentDistance = BABYLON.Vector3.Distance(cameraSpacePosition, ray.origin);\n                    if (distance > currentDistance) {\n                        distance = currentDistance;\n                        currentSprite = sprite;\n                        if (fastCheck) {\n                            break;\n                        }\n                    }\n                }\n            }\n            if (currentSprite) {\n                var result = new BABYLON.PickingInfo();\n                result.hit = true;\n                result.pickedSprite = currentSprite;\n                result.distance = distance;\n                return result;\n            }\n            return null;\n        };\n        SpriteManager.prototype.render = function () {\n            // Check\n            if (!this._effectBase.isReady() || !this._effectFog.isReady() || !this._spriteTexture || !this._spriteTexture.isReady())\n                return;\n            var engine = this._scene.getEngine();\n            var baseSize = this._spriteTexture.getBaseSize();\n            // Sprites\n            var deltaTime = engine.getDeltaTime();\n            var max = Math.min(this._capacity, this.sprites.length);\n            var rowSize = baseSize.width / this.cellWidth;\n            var offset = 0;\n            for (var index = 0; index < max; index++) {\n                var sprite = this.sprites[index];\n                if (!sprite) {\n                    continue;\n                }\n                sprite._animate(deltaTime);\n                this._appendSpriteVertex(offset++, sprite, 0, 0, rowSize);\n                this._appendSpriteVertex(offset++, sprite, 1, 0, rowSize);\n                this._appendSpriteVertex(offset++, sprite, 1, 1, rowSize);\n                this._appendSpriteVertex(offset++, sprite, 0, 1, rowSize);\n            }\n            this._buffer.update(this._vertexData);\n            // Render\n            var effect = this._effectBase;\n            if (this._scene.fogEnabled && this._scene.fogMode !== BABYLON.Scene.FOGMODE_NONE && this.fogEnabled) {\n                effect = this._effectFog;\n            }\n            engine.enableEffect(effect);\n            var viewMatrix = this._scene.getViewMatrix();\n            effect.setTexture(\"diffuseSampler\", this._spriteTexture);\n            effect.setMatrix(\"view\", viewMatrix);\n            effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n            effect.setFloat2(\"textureInfos\", this.cellWidth / baseSize.width, this.cellHeight / baseSize.height);\n            // Fog\n            if (this._scene.fogEnabled && this._scene.fogMode !== BABYLON.Scene.FOGMODE_NONE && this.fogEnabled) {\n                effect.setFloat4(\"vFogInfos\", this._scene.fogMode, this._scene.fogStart, this._scene.fogEnd, this._scene.fogDensity);\n                effect.setColor3(\"vFogColor\", this._scene.fogColor);\n            }\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n            // Draw order\n            engine.setDepthFunctionToLessOrEqual();\n            effect.setBool(\"alphaTest\", true);\n            engine.setColorWrite(false);\n            engine.draw(true, 0, max * 6);\n            engine.setColorWrite(true);\n            effect.setBool(\"alphaTest\", false);\n            engine.setAlphaMode(BABYLON.Engine.ALPHA_COMBINE);\n            engine.draw(true, 0, max * 6);\n            engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n        };\n        SpriteManager.prototype.dispose = function () {\n            if (this._buffer) {\n                this._buffer.dispose();\n                this._buffer = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n            if (this._spriteTexture) {\n                this._spriteTexture.dispose();\n                this._spriteTexture = null;\n            }\n            // Remove from scene\n            var index = this._scene.spriteManagers.indexOf(this);\n            this._scene.spriteManagers.splice(index, 1);\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n        };\n        return SpriteManager;\n    }());\n    BABYLON.SpriteManager = SpriteManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.spriteManager.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Sprite = (function () {\n        function Sprite(name, manager) {\n            this.name = name;\n            this.color = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);\n            this.width = 1.0;\n            this.height = 1.0;\n            this.angle = 0;\n            this.cellIndex = 0;\n            this.invertU = 0;\n            this.invertV = 0;\n            this.animations = new Array();\n            this.isPickable = false;\n            this._animationStarted = false;\n            this._loopAnimation = false;\n            this._fromIndex = 0;\n            this._toIndex = 0;\n            this._delay = 0;\n            this._direction = 1;\n            this._frameCount = 0;\n            this._time = 0;\n            this._manager = manager;\n            this._manager.sprites.push(this);\n            this.position = BABYLON.Vector3.Zero();\n        }\n        Object.defineProperty(Sprite.prototype, \"size\", {\n            get: function () {\n                return this.width;\n            },\n            set: function (value) {\n                this.width = value;\n                this.height = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Sprite.prototype.playAnimation = function (from, to, loop, delay, onAnimationEnd) {\n            this._fromIndex = from;\n            this._toIndex = to;\n            this._loopAnimation = loop;\n            this._delay = delay;\n            this._animationStarted = true;\n            this._direction = from < to ? 1 : -1;\n            this.cellIndex = from;\n            this._time = 0;\n            this._onAnimationEnd = onAnimationEnd;\n        };\n        Sprite.prototype.stopAnimation = function () {\n            this._animationStarted = false;\n        };\n        Sprite.prototype._animate = function (deltaTime) {\n            if (!this._animationStarted)\n                return;\n            this._time += deltaTime;\n            if (this._time > this._delay) {\n                this._time = this._time % this._delay;\n                this.cellIndex += this._direction;\n                if (this.cellIndex === this._toIndex) {\n                    if (this._loopAnimation) {\n                        this.cellIndex = this._fromIndex;\n                    }\n                    else {\n                        this._animationStarted = false;\n                        if (this._onAnimationEnd) {\n                            this._onAnimationEnd();\n                        }\n                        if (this.disposeWhenFinishedAnimating) {\n                            this.dispose();\n                        }\n                    }\n                }\n            }\n        };\n        Sprite.prototype.dispose = function () {\n            for (var i = 0; i < this._manager.sprites.length; i++) {\n                if (this._manager.sprites[i] == this) {\n                    this._manager.sprites.splice(i, 1);\n                }\n            }\n        };\n        return Sprite;\n    }());\n    BABYLON.Sprite = Sprite;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sprite.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var IntersectionInfo = (function () {\n        function IntersectionInfo(bu, bv, distance) {\n            this.bu = bu;\n            this.bv = bv;\n            this.distance = distance;\n            this.faceId = 0;\n            this.subMeshId = 0;\n        }\n        return IntersectionInfo;\n    }());\n    BABYLON.IntersectionInfo = IntersectionInfo;\n    var PickingInfo = (function () {\n        function PickingInfo() {\n            this.hit = false;\n            this.distance = 0;\n            this.pickedPoint = null;\n            this.pickedMesh = null;\n            this.bu = 0;\n            this.bv = 0;\n            this.faceId = -1;\n            this.subMeshId = 0;\n            this.pickedSprite = null;\n        }\n        // Methods\n        PickingInfo.prototype.getNormal = function (useWorldCoordinates, useVerticesNormals) {\n            if (useWorldCoordinates === void 0) { useWorldCoordinates = false; }\n            if (useVerticesNormals === void 0) { useVerticesNormals = true; }\n            if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                return null;\n            }\n            var indices = this.pickedMesh.getIndices();\n            var result;\n            if (useVerticesNormals) {\n                var normals = this.pickedMesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n                var normal0 = BABYLON.Vector3.FromArray(normals, indices[this.faceId * 3] * 3);\n                var normal1 = BABYLON.Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);\n                var normal2 = BABYLON.Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);\n                normal0 = normal0.scale(this.bu);\n                normal1 = normal1.scale(this.bv);\n                normal2 = normal2.scale(1.0 - this.bu - this.bv);\n                result = new BABYLON.Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);\n            }\n            else {\n                var positions = this.pickedMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n                var vertex1 = BABYLON.Vector3.FromArray(positions, indices[this.faceId * 3] * 3);\n                var vertex2 = BABYLON.Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);\n                var vertex3 = BABYLON.Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);\n                var p1p2 = vertex1.subtract(vertex2);\n                var p3p2 = vertex3.subtract(vertex2);\n                result = BABYLON.Vector3.Cross(p1p2, p3p2);\n            }\n            if (useWorldCoordinates) {\n                result = BABYLON.Vector3.TransformNormal(result, this.pickedMesh.getWorldMatrix());\n            }\n            return BABYLON.Vector3.Normalize(result);\n        };\n        PickingInfo.prototype.getTextureCoordinates = function () {\n            if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                return null;\n            }\n            var indices = this.pickedMesh.getIndices();\n            var uvs = this.pickedMesh.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var uv0 = BABYLON.Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);\n            var uv1 = BABYLON.Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);\n            var uv2 = BABYLON.Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);\n            uv0 = uv0.scale(1.0 - this.bu - this.bv);\n            uv1 = uv1.scale(this.bu);\n            uv2 = uv2.scale(this.bv);\n            return new BABYLON.Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);\n        };\n        return PickingInfo;\n    }());\n    BABYLON.PickingInfo = PickingInfo;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.pickingInfo.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Ray = (function () {\n        function Ray(origin, direction, length) {\n            if (length === void 0) { length = Number.MAX_VALUE; }\n            this.origin = origin;\n            this.direction = direction;\n            this.length = length;\n        }\n        // Methods\n        Ray.prototype.intersectsBoxMinMax = function (minimum, maximum) {\n            var d = 0.0;\n            var maxValue = Number.MAX_VALUE;\n            var inv;\n            var min;\n            var max;\n            var temp;\n            if (Math.abs(this.direction.x) < 0.0000001) {\n                if (this.origin.x < minimum.x || this.origin.x > maximum.x) {\n                    return false;\n                }\n            }\n            else {\n                inv = 1.0 / this.direction.x;\n                min = (minimum.x - this.origin.x) * inv;\n                max = (maximum.x - this.origin.x) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            if (Math.abs(this.direction.y) < 0.0000001) {\n                if (this.origin.y < minimum.y || this.origin.y > maximum.y) {\n                    return false;\n                }\n            }\n            else {\n                inv = 1.0 / this.direction.y;\n                min = (minimum.y - this.origin.y) * inv;\n                max = (maximum.y - this.origin.y) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            if (Math.abs(this.direction.z) < 0.0000001) {\n                if (this.origin.z < minimum.z || this.origin.z > maximum.z) {\n                    return false;\n                }\n            }\n            else {\n                inv = 1.0 / this.direction.z;\n                min = (minimum.z - this.origin.z) * inv;\n                max = (maximum.z - this.origin.z) * inv;\n                if (max === -Infinity) {\n                    max = Infinity;\n                }\n                if (min > max) {\n                    temp = min;\n                    min = max;\n                    max = temp;\n                }\n                d = Math.max(min, d);\n                maxValue = Math.min(max, maxValue);\n                if (d > maxValue) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        Ray.prototype.intersectsBox = function (box) {\n            return this.intersectsBoxMinMax(box.minimum, box.maximum);\n        };\n        Ray.prototype.intersectsSphere = function (sphere) {\n            var x = sphere.center.x - this.origin.x;\n            var y = sphere.center.y - this.origin.y;\n            var z = sphere.center.z - this.origin.z;\n            var pyth = (x * x) + (y * y) + (z * z);\n            var rr = sphere.radius * sphere.radius;\n            if (pyth <= rr) {\n                return true;\n            }\n            var dot = (x * this.direction.x) + (y * this.direction.y) + (z * this.direction.z);\n            if (dot < 0.0) {\n                return false;\n            }\n            var temp = pyth - (dot * dot);\n            return temp <= rr;\n        };\n        Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {\n            if (!this._edge1) {\n                this._edge1 = BABYLON.Vector3.Zero();\n                this._edge2 = BABYLON.Vector3.Zero();\n                this._pvec = BABYLON.Vector3.Zero();\n                this._tvec = BABYLON.Vector3.Zero();\n                this._qvec = BABYLON.Vector3.Zero();\n            }\n            vertex1.subtractToRef(vertex0, this._edge1);\n            vertex2.subtractToRef(vertex0, this._edge2);\n            BABYLON.Vector3.CrossToRef(this.direction, this._edge2, this._pvec);\n            var det = BABYLON.Vector3.Dot(this._edge1, this._pvec);\n            if (det === 0) {\n                return null;\n            }\n            var invdet = 1 / det;\n            this.origin.subtractToRef(vertex0, this._tvec);\n            var bu = BABYLON.Vector3.Dot(this._tvec, this._pvec) * invdet;\n            if (bu < 0 || bu > 1.0) {\n                return null;\n            }\n            BABYLON.Vector3.CrossToRef(this._tvec, this._edge1, this._qvec);\n            var bv = BABYLON.Vector3.Dot(this.direction, this._qvec) * invdet;\n            if (bv < 0 || bu + bv > 1.0) {\n                return null;\n            }\n            //check if the distance is longer than the predefined length.\n            var distance = BABYLON.Vector3.Dot(this._edge2, this._qvec) * invdet;\n            if (distance > this.length) {\n                return null;\n            }\n            return new BABYLON.IntersectionInfo(bu, bv, distance);\n        };\n        Ray.prototype.intersectsPlane = function (plane) {\n            var distance;\n            var result1 = BABYLON.Vector3.Dot(plane.normal, this.direction);\n            if (Math.abs(result1) < 9.99999997475243E-07) {\n                return null;\n            }\n            else {\n                var result2 = BABYLON.Vector3.Dot(plane.normal, this.origin);\n                distance = (-plane.d - result2) / result1;\n                if (distance < 0.0) {\n                    if (distance < -9.99999997475243E-07) {\n                        return null;\n                    }\n                    else {\n                        return 0;\n                    }\n                }\n                return distance;\n            }\n        };\n        Ray.prototype.intersectsMesh = function (mesh, fastCheck) {\n            var tm = BABYLON.Tmp.Matrix[0];\n            mesh.getWorldMatrix().invertToRef(tm);\n            if (this._tmpRay) {\n                Ray.TransformToRef(this, tm, this._tmpRay);\n            }\n            else {\n                this._tmpRay = Ray.Transform(this, tm);\n            }\n            return mesh.intersects(this._tmpRay, fastCheck);\n        };\n        Ray.prototype.intersectsMeshes = function (meshes, fastCheck, results) {\n            if (results) {\n                results.length = 0;\n            }\n            else {\n                results = [];\n            }\n            for (var i = 0; i < meshes.length; i++) {\n                var pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n                if (pickInfo.hit) {\n                    results.push(pickInfo);\n                }\n            }\n            results.sort(this._comparePickingInfo);\n            return results;\n        };\n        Ray.prototype._comparePickingInfo = function (pickingInfoA, pickingInfoB) {\n            if (pickingInfoA.distance < pickingInfoB.distance) {\n                return -1;\n            }\n            else if (pickingInfoA.distance > pickingInfoB.distance) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        };\n        /**\n         * Intersection test between the ray and a given segment whithin a given tolerance (threshold)\n         * @param sega the first point of the segment to test the intersection against\n         * @param segb the second point of the segment to test the intersection against\n         * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n         * @return the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n         */\n        Ray.prototype.intersectionSegment = function (sega, segb, threshold) {\n            var rsegb = this.origin.add(this.direction.multiplyByFloats(Ray.rayl, Ray.rayl, Ray.rayl));\n            var u = segb.subtract(sega);\n            var v = rsegb.subtract(this.origin);\n            var w = sega.subtract(this.origin);\n            var a = BABYLON.Vector3.Dot(u, u); // always >= 0\n            var b = BABYLON.Vector3.Dot(u, v);\n            var c = BABYLON.Vector3.Dot(v, v); // always >= 0\n            var d = BABYLON.Vector3.Dot(u, w);\n            var e = BABYLON.Vector3.Dot(v, w);\n            var D = a * c - b * b; // always >= 0\n            var sc, sN, sD = D; // sc = sN / sD, default sD = D >= 0\n            var tc, tN, tD = D; // tc = tN / tD, default tD = D >= 0\n            // compute the line parameters of the two closest points\n            if (D < Ray.smallnum) {\n                sN = 0.0; // force using point P0 on segment S1\n                sD = 1.0; // to prevent possible division by 0.0 later\n                tN = e;\n                tD = c;\n            }\n            else {\n                sN = (b * e - c * d);\n                tN = (a * e - b * d);\n                if (sN < 0.0) {\n                    sN = 0.0;\n                    tN = e;\n                    tD = c;\n                }\n                else if (sN > sD) {\n                    sN = sD;\n                    tN = e + b;\n                    tD = c;\n                }\n            }\n            if (tN < 0.0) {\n                tN = 0.0;\n                // recompute sc for this edge\n                if (-d < 0.0) {\n                    sN = 0.0;\n                }\n                else if (-d > a)\n                    sN = sD;\n                else {\n                    sN = -d;\n                    sD = a;\n                }\n            }\n            else if (tN > tD) {\n                tN = tD;\n                // recompute sc for this edge\n                if ((-d + b) < 0.0) {\n                    sN = 0;\n                }\n                else if ((-d + b) > a) {\n                    sN = sD;\n                }\n                else {\n                    sN = (-d + b);\n                    sD = a;\n                }\n            }\n            // finally do the division to get sc and tc\n            sc = (Math.abs(sN) < Ray.smallnum ? 0.0 : sN / sD);\n            tc = (Math.abs(tN) < Ray.smallnum ? 0.0 : tN / tD);\n            // get the difference of the two closest points\n            var qtc = v.multiplyByFloats(tc, tc, tc);\n            var dP = w.add(u.multiplyByFloats(sc, sc, sc)).subtract(qtc); // = S1(sc) - S2(tc)\n            var isIntersected = (tc > 0) && (tc <= this.length) && (dP.lengthSquared() < (threshold * threshold)); // return intersection result\n            if (isIntersected) {\n                return qtc.length();\n            }\n            return -1;\n        };\n        // Statics\n        Ray.CreateNew = function (x, y, viewportWidth, viewportHeight, world, view, projection) {\n            var start = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 0), viewportWidth, viewportHeight, world, view, projection);\n            var end = BABYLON.Vector3.Unproject(new BABYLON.Vector3(x, y, 1), viewportWidth, viewportHeight, world, view, projection);\n            var direction = end.subtract(start);\n            direction.normalize();\n            return new Ray(start, direction);\n        };\n        /**\n        * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n        * transformed to the given world matrix.\n        * @param origin The origin point\n        * @param end The end point\n        * @param world a matrix to transform the ray to. Default is the identity matrix.\n        */\n        Ray.CreateNewFromTo = function (origin, end, world) {\n            if (world === void 0) { world = BABYLON.Matrix.Identity(); }\n            var direction = end.subtract(origin);\n            var length = Math.sqrt((direction.x * direction.x) + (direction.y * direction.y) + (direction.z * direction.z));\n            direction.normalize();\n            return Ray.Transform(new Ray(origin, direction, length), world);\n        };\n        Ray.Transform = function (ray, matrix) {\n            var result = new Ray(new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 0));\n            Ray.TransformToRef(ray, matrix, result);\n            return result;\n        };\n        Ray.TransformToRef = function (ray, matrix, result) {\n            BABYLON.Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n            BABYLON.Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n            result.length = ray.length;\n            var dir = result.direction;\n            var len = dir.length();\n            if (!(len === 0 || len === 1)) {\n                var num = 1.0 / len;\n                dir.x *= num;\n                dir.y *= num;\n                dir.z *= num;\n                result.length *= len;\n            }\n        };\n        return Ray;\n    }());\n    Ray.smallnum = 0.00000001;\n    Ray.rayl = 10e8;\n    BABYLON.Ray = Ray;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.ray.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var intersectBoxAASphere = function (boxMin, boxMax, sphereCenter, sphereRadius) {\n        if (boxMin.x > sphereCenter.x + sphereRadius)\n            return false;\n        if (sphereCenter.x - sphereRadius > boxMax.x)\n            return false;\n        if (boxMin.y > sphereCenter.y + sphereRadius)\n            return false;\n        if (sphereCenter.y - sphereRadius > boxMax.y)\n            return false;\n        if (boxMin.z > sphereCenter.z + sphereRadius)\n            return false;\n        if (sphereCenter.z - sphereRadius > boxMax.z)\n            return false;\n        return true;\n    };\n    var getLowestRoot = (function () {\n        var result = { root: 0, found: false };\n        return function (a, b, c, maxR) {\n            result.root = 0;\n            result.found = false;\n            var determinant = b * b - 4.0 * a * c;\n            if (determinant < 0)\n                return result;\n            var sqrtD = Math.sqrt(determinant);\n            var r1 = (-b - sqrtD) / (2.0 * a);\n            var r2 = (-b + sqrtD) / (2.0 * a);\n            if (r1 > r2) {\n                var temp = r2;\n                r2 = r1;\n                r1 = temp;\n            }\n            if (r1 > 0 && r1 < maxR) {\n                result.root = r1;\n                result.found = true;\n                return result;\n            }\n            if (r2 > 0 && r2 < maxR) {\n                result.root = r2;\n                result.found = true;\n                return result;\n            }\n            return result;\n        };\n    })();\n    var Collider = (function () {\n        function Collider() {\n            this.radius = BABYLON.Vector3.One();\n            this.retry = 0;\n            this.basePointWorld = BABYLON.Vector3.Zero();\n            this.velocityWorld = BABYLON.Vector3.Zero();\n            this.normalizedVelocity = BABYLON.Vector3.Zero();\n            this._collisionPoint = BABYLON.Vector3.Zero();\n            this._planeIntersectionPoint = BABYLON.Vector3.Zero();\n            this._tempVector = BABYLON.Vector3.Zero();\n            this._tempVector2 = BABYLON.Vector3.Zero();\n            this._tempVector3 = BABYLON.Vector3.Zero();\n            this._tempVector4 = BABYLON.Vector3.Zero();\n            this._edge = BABYLON.Vector3.Zero();\n            this._baseToVertex = BABYLON.Vector3.Zero();\n            this._destinationPoint = BABYLON.Vector3.Zero();\n            this._slidePlaneNormal = BABYLON.Vector3.Zero();\n            this._displacementVector = BABYLON.Vector3.Zero();\n            this._collisionMask = -1;\n        }\n        Object.defineProperty(Collider.prototype, \"collisionMask\", {\n            get: function () {\n                return this._collisionMask;\n            },\n            set: function (mask) {\n                this._collisionMask = !isNaN(mask) ? mask : -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        Collider.prototype._initialize = function (source, dir, e) {\n            this.velocity = dir;\n            BABYLON.Vector3.NormalizeToRef(dir, this.normalizedVelocity);\n            this.basePoint = source;\n            source.multiplyToRef(this.radius, this.basePointWorld);\n            dir.multiplyToRef(this.radius, this.velocityWorld);\n            this.velocityWorldLength = this.velocityWorld.length();\n            this.epsilon = e;\n            this.collisionFound = false;\n        };\n        Collider.prototype._checkPointInTriangle = function (point, pa, pb, pc, n) {\n            pa.subtractToRef(point, this._tempVector);\n            pb.subtractToRef(point, this._tempVector2);\n            BABYLON.Vector3.CrossToRef(this._tempVector, this._tempVector2, this._tempVector4);\n            var d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            if (d < 0)\n                return false;\n            pc.subtractToRef(point, this._tempVector3);\n            BABYLON.Vector3.CrossToRef(this._tempVector2, this._tempVector3, this._tempVector4);\n            d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            if (d < 0)\n                return false;\n            BABYLON.Vector3.CrossToRef(this._tempVector3, this._tempVector, this._tempVector4);\n            d = BABYLON.Vector3.Dot(this._tempVector4, n);\n            return d >= 0;\n        };\n        Collider.prototype._canDoCollision = function (sphereCenter, sphereRadius, vecMin, vecMax) {\n            var distance = BABYLON.Vector3.Distance(this.basePointWorld, sphereCenter);\n            var max = Math.max(this.radius.x, this.radius.y, this.radius.z);\n            if (distance > this.velocityWorldLength + max + sphereRadius) {\n                return false;\n            }\n            if (!intersectBoxAASphere(vecMin, vecMax, this.basePointWorld, this.velocityWorldLength + max))\n                return false;\n            return true;\n        };\n        Collider.prototype._testTriangle = function (faceIndex, trianglePlaneArray, p1, p2, p3, hasMaterial) {\n            var t0;\n            var embeddedInPlane = false;\n            //defensive programming, actually not needed.\n            if (!trianglePlaneArray) {\n                trianglePlaneArray = [];\n            }\n            if (!trianglePlaneArray[faceIndex]) {\n                trianglePlaneArray[faceIndex] = new BABYLON.Plane(0, 0, 0, 0);\n                trianglePlaneArray[faceIndex].copyFromPoints(p1, p2, p3);\n            }\n            var trianglePlane = trianglePlaneArray[faceIndex];\n            if ((!hasMaterial) && !trianglePlane.isFrontFacingTo(this.normalizedVelocity, 0))\n                return;\n            var signedDistToTrianglePlane = trianglePlane.signedDistanceTo(this.basePoint);\n            var normalDotVelocity = BABYLON.Vector3.Dot(trianglePlane.normal, this.velocity);\n            if (normalDotVelocity == 0) {\n                if (Math.abs(signedDistToTrianglePlane) >= 1.0)\n                    return;\n                embeddedInPlane = true;\n                t0 = 0;\n            }\n            else {\n                t0 = (-1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n                var t1 = (1.0 - signedDistToTrianglePlane) / normalDotVelocity;\n                if (t0 > t1) {\n                    var temp = t1;\n                    t1 = t0;\n                    t0 = temp;\n                }\n                if (t0 > 1.0 || t1 < 0.0)\n                    return;\n                if (t0 < 0)\n                    t0 = 0;\n                if (t0 > 1.0)\n                    t0 = 1.0;\n            }\n            this._collisionPoint.copyFromFloats(0, 0, 0);\n            var found = false;\n            var t = 1.0;\n            if (!embeddedInPlane) {\n                this.basePoint.subtractToRef(trianglePlane.normal, this._planeIntersectionPoint);\n                this.velocity.scaleToRef(t0, this._tempVector);\n                this._planeIntersectionPoint.addInPlace(this._tempVector);\n                if (this._checkPointInTriangle(this._planeIntersectionPoint, p1, p2, p3, trianglePlane.normal)) {\n                    found = true;\n                    t = t0;\n                    this._collisionPoint.copyFrom(this._planeIntersectionPoint);\n                }\n            }\n            if (!found) {\n                var velocitySquaredLength = this.velocity.lengthSquared();\n                var a = velocitySquaredLength;\n                this.basePoint.subtractToRef(p1, this._tempVector);\n                var b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                var c = this._tempVector.lengthSquared() - 1.0;\n                var lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p1);\n                }\n                this.basePoint.subtractToRef(p2, this._tempVector);\n                b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                c = this._tempVector.lengthSquared() - 1.0;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p2);\n                }\n                this.basePoint.subtractToRef(p3, this._tempVector);\n                b = 2.0 * (BABYLON.Vector3.Dot(this.velocity, this._tempVector));\n                c = this._tempVector.lengthSquared() - 1.0;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    t = lowestRoot.root;\n                    found = true;\n                    this._collisionPoint.copyFrom(p3);\n                }\n                p2.subtractToRef(p1, this._edge);\n                p1.subtractToRef(this.basePoint, this._baseToVertex);\n                var edgeSquaredLength = this._edge.lengthSquared();\n                var edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                var edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    var f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p1.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n                p3.subtractToRef(p2, this._edge);\n                p2.subtractToRef(this.basePoint, this._baseToVertex);\n                edgeSquaredLength = this._edge.lengthSquared();\n                edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p2.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n                p1.subtractToRef(p3, this._edge);\n                p3.subtractToRef(this.basePoint, this._baseToVertex);\n                edgeSquaredLength = this._edge.lengthSquared();\n                edgeDotVelocity = BABYLON.Vector3.Dot(this._edge, this.velocity);\n                edgeDotBaseToVertex = BABYLON.Vector3.Dot(this._edge, this._baseToVertex);\n                a = edgeSquaredLength * (-velocitySquaredLength) + edgeDotVelocity * edgeDotVelocity;\n                b = edgeSquaredLength * (2.0 * BABYLON.Vector3.Dot(this.velocity, this._baseToVertex)) - 2.0 * edgeDotVelocity * edgeDotBaseToVertex;\n                c = edgeSquaredLength * (1.0 - this._baseToVertex.lengthSquared()) + edgeDotBaseToVertex * edgeDotBaseToVertex;\n                lowestRoot = getLowestRoot(a, b, c, t);\n                if (lowestRoot.found) {\n                    f = (edgeDotVelocity * lowestRoot.root - edgeDotBaseToVertex) / edgeSquaredLength;\n                    if (f >= 0.0 && f <= 1.0) {\n                        t = lowestRoot.root;\n                        found = true;\n                        this._edge.scaleInPlace(f);\n                        p3.addToRef(this._edge, this._collisionPoint);\n                    }\n                }\n            }\n            if (found) {\n                var distToCollision = t * this.velocity.length();\n                if (!this.collisionFound || distToCollision < this.nearestDistance) {\n                    if (!this.intersectionPoint) {\n                        this.intersectionPoint = this._collisionPoint.clone();\n                    }\n                    else {\n                        this.intersectionPoint.copyFrom(this._collisionPoint);\n                    }\n                    this.nearestDistance = distToCollision;\n                    this.collisionFound = true;\n                }\n            }\n        };\n        Collider.prototype._collide = function (trianglePlaneArray, pts, indices, indexStart, indexEnd, decal, hasMaterial) {\n            for (var i = indexStart; i < indexEnd; i += 3) {\n                var p1 = pts[indices[i] - decal];\n                var p2 = pts[indices[i + 1] - decal];\n                var p3 = pts[indices[i + 2] - decal];\n                this._testTriangle(i, trianglePlaneArray, p3, p2, p1, hasMaterial);\n            }\n        };\n        Collider.prototype._getResponse = function (pos, vel) {\n            pos.addToRef(vel, this._destinationPoint);\n            vel.scaleInPlace((this.nearestDistance / vel.length()));\n            this.basePoint.addToRef(vel, pos);\n            pos.subtractToRef(this.intersectionPoint, this._slidePlaneNormal);\n            this._slidePlaneNormal.normalize();\n            this._slidePlaneNormal.scaleToRef(this.epsilon, this._displacementVector);\n            pos.addInPlace(this._displacementVector);\n            this.intersectionPoint.addInPlace(this._displacementVector);\n            this._slidePlaneNormal.scaleInPlace(BABYLON.Plane.SignedDistanceToPlaneFromPositionAndNormal(this.intersectionPoint, this._slidePlaneNormal, this._destinationPoint));\n            this._destinationPoint.subtractInPlace(this._slidePlaneNormal);\n            this._destinationPoint.subtractToRef(this.intersectionPoint, vel);\n        };\n        return Collider;\n    }());\n    BABYLON.Collider = Collider;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.collider.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    //WebWorker code will be inserted to this variable.\n    BABYLON.CollisionWorker = \"\";\n    var WorkerTaskType;\n    (function (WorkerTaskType) {\n        WorkerTaskType[WorkerTaskType[\"INIT\"] = 0] = \"INIT\";\n        WorkerTaskType[WorkerTaskType[\"UPDATE\"] = 1] = \"UPDATE\";\n        WorkerTaskType[WorkerTaskType[\"COLLIDE\"] = 2] = \"COLLIDE\";\n    })(WorkerTaskType = BABYLON.WorkerTaskType || (BABYLON.WorkerTaskType = {}));\n    var WorkerReplyType;\n    (function (WorkerReplyType) {\n        WorkerReplyType[WorkerReplyType[\"SUCCESS\"] = 0] = \"SUCCESS\";\n        WorkerReplyType[WorkerReplyType[\"UNKNOWN_ERROR\"] = 1] = \"UNKNOWN_ERROR\";\n    })(WorkerReplyType = BABYLON.WorkerReplyType || (BABYLON.WorkerReplyType = {}));\n    var CollisionCoordinatorWorker = (function () {\n        function CollisionCoordinatorWorker() {\n            var _this = this;\n            this._scaledPosition = BABYLON.Vector3.Zero();\n            this._scaledVelocity = BABYLON.Vector3.Zero();\n            this.onMeshUpdated = function (mesh) {\n                _this._addUpdateMeshesList[mesh.uniqueId] = CollisionCoordinatorWorker.SerializeMesh(mesh);\n            };\n            this.onGeometryUpdated = function (geometry) {\n                _this._addUpdateGeometriesList[geometry.id] = CollisionCoordinatorWorker.SerializeGeometry(geometry);\n            };\n            this._afterRender = function () {\n                if (!_this._init)\n                    return;\n                if (_this._toRemoveGeometryArray.length == 0 && _this._toRemoveMeshesArray.length == 0 && Object.keys(_this._addUpdateGeometriesList).length == 0 && Object.keys(_this._addUpdateMeshesList).length == 0) {\n                    return;\n                }\n                //5 concurrent updates were sent to the web worker and were not yet processed. Abort next update.\n                //TODO make sure update runs as fast as possible to be able to update 60 FPS.\n                if (_this._runningUpdated > 4) {\n                    return;\n                }\n                ++_this._runningUpdated;\n                var payload = {\n                    updatedMeshes: _this._addUpdateMeshesList,\n                    updatedGeometries: _this._addUpdateGeometriesList,\n                    removedGeometries: _this._toRemoveGeometryArray,\n                    removedMeshes: _this._toRemoveMeshesArray\n                };\n                var message = {\n                    payload: payload,\n                    taskType: WorkerTaskType.UPDATE\n                };\n                var serializable = [];\n                for (var id in payload.updatedGeometries) {\n                    if (payload.updatedGeometries.hasOwnProperty(id)) {\n                        //prepare transferables\n                        serializable.push(message.payload.updatedGeometries[id].indices.buffer);\n                        serializable.push(message.payload.updatedGeometries[id].normals.buffer);\n                        serializable.push(message.payload.updatedGeometries[id].positions.buffer);\n                    }\n                }\n                _this._worker.postMessage(message, serializable);\n                _this._addUpdateMeshesList = {};\n                _this._addUpdateGeometriesList = {};\n                _this._toRemoveGeometryArray = [];\n                _this._toRemoveMeshesArray = [];\n            };\n            this._onMessageFromWorker = function (e) {\n                var returnData = e.data;\n                if (returnData.error != WorkerReplyType.SUCCESS) {\n                    //TODO what errors can be returned from the worker?\n                    BABYLON.Tools.Warn(\"error returned from worker!\");\n                    return;\n                }\n                switch (returnData.taskType) {\n                    case WorkerTaskType.INIT:\n                        _this._init = true;\n                        //Update the worked with ALL of the scene's current state\n                        _this._scene.meshes.forEach(function (mesh) {\n                            _this.onMeshAdded(mesh);\n                        });\n                        _this._scene.getGeometries().forEach(function (geometry) {\n                            _this.onGeometryAdded(geometry);\n                        });\n                        break;\n                    case WorkerTaskType.UPDATE:\n                        _this._runningUpdated--;\n                        break;\n                    case WorkerTaskType.COLLIDE:\n                        _this._runningCollisionTask = false;\n                        var returnPayload = returnData.payload;\n                        if (!_this._collisionsCallbackArray[returnPayload.collisionId])\n                            return;\n                        _this._collisionsCallbackArray[returnPayload.collisionId](returnPayload.collisionId, BABYLON.Vector3.FromArray(returnPayload.newPosition), _this._scene.getMeshByUniqueID(returnPayload.collidedMeshUniqueId));\n                        //cleanup\n                        _this._collisionsCallbackArray[returnPayload.collisionId] = undefined;\n                        break;\n                }\n            };\n            this._collisionsCallbackArray = [];\n            this._init = false;\n            this._runningUpdated = 0;\n            this._runningCollisionTask = false;\n            this._addUpdateMeshesList = {};\n            this._addUpdateGeometriesList = {};\n            this._toRemoveGeometryArray = [];\n            this._toRemoveMeshesArray = [];\n        }\n        CollisionCoordinatorWorker.prototype.getNewPosition = function (position, velocity, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n            if (!this._init)\n                return;\n            if (this._collisionsCallbackArray[collisionIndex] || this._collisionsCallbackArray[collisionIndex + 100000])\n                return;\n            position.divideToRef(collider.radius, this._scaledPosition);\n            velocity.divideToRef(collider.radius, this._scaledVelocity);\n            this._collisionsCallbackArray[collisionIndex] = onNewPosition;\n            var payload = {\n                collider: {\n                    position: this._scaledPosition.asArray(),\n                    velocity: this._scaledVelocity.asArray(),\n                    radius: collider.radius.asArray()\n                },\n                collisionId: collisionIndex,\n                excludedMeshUniqueId: excludedMesh ? excludedMesh.uniqueId : null,\n                maximumRetry: maximumRetry\n            };\n            var message = {\n                payload: payload,\n                taskType: WorkerTaskType.COLLIDE\n            };\n            this._worker.postMessage(message);\n        };\n        CollisionCoordinatorWorker.prototype.init = function (scene) {\n            this._scene = scene;\n            this._scene.registerAfterRender(this._afterRender);\n            var workerUrl = BABYLON.WorkerIncluded ? BABYLON.Engine.CodeRepository + \"Collisions/babylon.collisionWorker.js\" : URL.createObjectURL(new Blob([BABYLON.CollisionWorker], { type: 'application/javascript' }));\n            this._worker = new Worker(workerUrl);\n            this._worker.onmessage = this._onMessageFromWorker;\n            var message = {\n                payload: {},\n                taskType: WorkerTaskType.INIT\n            };\n            this._worker.postMessage(message);\n        };\n        CollisionCoordinatorWorker.prototype.destroy = function () {\n            this._scene.unregisterAfterRender(this._afterRender);\n            this._worker.terminate();\n        };\n        CollisionCoordinatorWorker.prototype.onMeshAdded = function (mesh) {\n            mesh.registerAfterWorldMatrixUpdate(this.onMeshUpdated);\n            this.onMeshUpdated(mesh);\n        };\n        CollisionCoordinatorWorker.prototype.onMeshRemoved = function (mesh) {\n            this._toRemoveMeshesArray.push(mesh.uniqueId);\n        };\n        CollisionCoordinatorWorker.prototype.onGeometryAdded = function (geometry) {\n            //TODO this will break if the user uses his own function. This should be an array of callbacks!\n            geometry.onGeometryUpdated = this.onGeometryUpdated;\n            this.onGeometryUpdated(geometry);\n        };\n        CollisionCoordinatorWorker.prototype.onGeometryDeleted = function (geometry) {\n            this._toRemoveGeometryArray.push(geometry.id);\n        };\n        return CollisionCoordinatorWorker;\n    }());\n    CollisionCoordinatorWorker.SerializeMesh = function (mesh) {\n        var submeshes = [];\n        if (mesh.subMeshes) {\n            submeshes = mesh.subMeshes.map(function (sm, idx) {\n                return {\n                    position: idx,\n                    verticesStart: sm.verticesStart,\n                    verticesCount: sm.verticesCount,\n                    indexStart: sm.indexStart,\n                    indexCount: sm.indexCount,\n                    hasMaterial: !!sm.getMaterial(),\n                    sphereCenter: sm.getBoundingInfo().boundingSphere.centerWorld.asArray(),\n                    sphereRadius: sm.getBoundingInfo().boundingSphere.radiusWorld,\n                    boxMinimum: sm.getBoundingInfo().boundingBox.minimumWorld.asArray(),\n                    boxMaximum: sm.getBoundingInfo().boundingBox.maximumWorld.asArray()\n                };\n            });\n        }\n        var geometryId = null;\n        if (mesh instanceof BABYLON.Mesh) {\n            geometryId = mesh.geometry ? mesh.geometry.id : null;\n        }\n        else if (mesh instanceof BABYLON.InstancedMesh) {\n            geometryId = (mesh.sourceMesh && mesh.sourceMesh.geometry) ? mesh.sourceMesh.geometry.id : null;\n        }\n        return {\n            uniqueId: mesh.uniqueId,\n            id: mesh.id,\n            name: mesh.name,\n            geometryId: geometryId,\n            sphereCenter: mesh.getBoundingInfo().boundingSphere.centerWorld.asArray(),\n            sphereRadius: mesh.getBoundingInfo().boundingSphere.radiusWorld,\n            boxMinimum: mesh.getBoundingInfo().boundingBox.minimumWorld.asArray(),\n            boxMaximum: mesh.getBoundingInfo().boundingBox.maximumWorld.asArray(),\n            worldMatrixFromCache: mesh.worldMatrixFromCache.asArray(),\n            subMeshes: submeshes,\n            checkCollisions: mesh.checkCollisions\n        };\n    };\n    CollisionCoordinatorWorker.SerializeGeometry = function (geometry) {\n        return {\n            id: geometry.id,\n            positions: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.PositionKind) || []),\n            normals: new Float32Array(geometry.getVerticesData(BABYLON.VertexBuffer.NormalKind) || []),\n            indices: new Uint32Array(geometry.getIndices() || []),\n        };\n    };\n    BABYLON.CollisionCoordinatorWorker = CollisionCoordinatorWorker;\n    var CollisionCoordinatorLegacy = (function () {\n        function CollisionCoordinatorLegacy() {\n            this._scaledPosition = BABYLON.Vector3.Zero();\n            this._scaledVelocity = BABYLON.Vector3.Zero();\n            this._finalPosition = BABYLON.Vector3.Zero();\n        }\n        CollisionCoordinatorLegacy.prototype.getNewPosition = function (position, velocity, collider, maximumRetry, excludedMesh, onNewPosition, collisionIndex) {\n            position.divideToRef(collider.radius, this._scaledPosition);\n            velocity.divideToRef(collider.radius, this._scaledVelocity);\n            collider.collidedMesh = null;\n            collider.retry = 0;\n            collider.initialVelocity = this._scaledVelocity;\n            collider.initialPosition = this._scaledPosition;\n            this._collideWithWorld(this._scaledPosition, this._scaledVelocity, collider, maximumRetry, this._finalPosition, excludedMesh);\n            this._finalPosition.multiplyInPlace(collider.radius);\n            //run the callback\n            onNewPosition(collisionIndex, this._finalPosition, collider.collidedMesh);\n        };\n        CollisionCoordinatorLegacy.prototype.init = function (scene) {\n            this._scene = scene;\n        };\n        CollisionCoordinatorLegacy.prototype.destroy = function () {\n            //Legacy need no destruction method.\n        };\n        //No update in legacy mode\n        CollisionCoordinatorLegacy.prototype.onMeshAdded = function (mesh) { };\n        CollisionCoordinatorLegacy.prototype.onMeshUpdated = function (mesh) { };\n        CollisionCoordinatorLegacy.prototype.onMeshRemoved = function (mesh) { };\n        CollisionCoordinatorLegacy.prototype.onGeometryAdded = function (geometry) { };\n        CollisionCoordinatorLegacy.prototype.onGeometryUpdated = function (geometry) { };\n        CollisionCoordinatorLegacy.prototype.onGeometryDeleted = function (geometry) { };\n        CollisionCoordinatorLegacy.prototype._collideWithWorld = function (position, velocity, collider, maximumRetry, finalPosition, excludedMesh) {\n            if (excludedMesh === void 0) { excludedMesh = null; }\n            var closeDistance = BABYLON.Engine.CollisionsEpsilon * 10.0;\n            if (collider.retry >= maximumRetry) {\n                finalPosition.copyFrom(position);\n                return;\n            }\n            // Check if this is a mesh else camera or -1\n            var collisionMask = (excludedMesh ? excludedMesh.collisionMask : collider.collisionMask);\n            collider._initialize(position, velocity, closeDistance);\n            // Check all meshes\n            for (var index = 0; index < this._scene.meshes.length; index++) {\n                var mesh = this._scene.meshes[index];\n                if (mesh.isEnabled() && mesh.checkCollisions && mesh.subMeshes && mesh !== excludedMesh && ((collisionMask & mesh.collisionGroup) !== 0)) {\n                    mesh._checkCollision(collider);\n                }\n            }\n            if (!collider.collisionFound) {\n                position.addToRef(velocity, finalPosition);\n                return;\n            }\n            if (velocity.x !== 0 || velocity.y !== 0 || velocity.z !== 0) {\n                collider._getResponse(position, velocity);\n            }\n            if (velocity.length() <= closeDistance) {\n                finalPosition.copyFrom(position);\n                return;\n            }\n            collider.retry++;\n            this._collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, excludedMesh);\n        };\n        return CollisionCoordinatorLegacy;\n    }());\n    BABYLON.CollisionCoordinatorLegacy = CollisionCoordinatorLegacy;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.collisionCoordinator.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Particle = (function () {\n        function Particle() {\n            this.position = BABYLON.Vector3.Zero();\n            this.direction = BABYLON.Vector3.Zero();\n            this.color = new BABYLON.Color4(0, 0, 0, 0);\n            this.colorStep = new BABYLON.Color4(0, 0, 0, 0);\n            this.lifeTime = 1.0;\n            this.age = 0;\n            this.size = 0;\n            this.angle = 0;\n            this.angularSpeed = 0;\n        }\n        Particle.prototype.copyTo = function (other) {\n            other.position.copyFrom(this.position);\n            other.direction.copyFrom(this.direction);\n            other.color.copyFrom(this.color);\n            other.colorStep.copyFrom(this.colorStep);\n            other.lifeTime = this.lifeTime;\n            other.age = this.age;\n            other.size = this.size;\n            other.angle = this.angle;\n            other.angularSpeed = this.angularSpeed;\n        };\n        return Particle;\n    }());\n    BABYLON.Particle = Particle;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.particle.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var randomNumber = function (min, max) {\n        if (min === max) {\n            return (min);\n        }\n        var random = Math.random();\n        return ((random * (max - min)) + min);\n    };\n    var ParticleSystem = (function () {\n        function ParticleSystem(name, capacity, scene, customEffect) {\n            var _this = this;\n            this.name = name;\n            // Members\n            this.animations = [];\n            this.renderingGroupId = 0;\n            this.emitter = null;\n            this.emitRate = 10;\n            this.manualEmitCount = -1;\n            this.updateSpeed = 0.01;\n            this.targetStopDuration = 0;\n            this.disposeOnStop = false;\n            this.minEmitPower = 1;\n            this.maxEmitPower = 1;\n            this.minLifeTime = 1;\n            this.maxLifeTime = 1;\n            this.minSize = 1;\n            this.maxSize = 1;\n            this.minAngularSpeed = 0;\n            this.maxAngularSpeed = 0;\n            this.layerMask = 0x0FFFFFFF;\n            this.customShader = null;\n            this.preventAutoStart = false;\n            /**\n            * An event triggered when the system is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            this.blendMode = ParticleSystem.BLENDMODE_ONEONE;\n            this.forceDepthWrite = false;\n            this.gravity = BABYLON.Vector3.Zero();\n            this.direction1 = new BABYLON.Vector3(0, 1.0, 0);\n            this.direction2 = new BABYLON.Vector3(0, 1.0, 0);\n            this.minEmitBox = new BABYLON.Vector3(-0.5, -0.5, -0.5);\n            this.maxEmitBox = new BABYLON.Vector3(0.5, 0.5, 0.5);\n            this.color1 = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);\n            this.color2 = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);\n            this.colorDead = new BABYLON.Color4(0, 0, 0, 1.0);\n            this.textureMask = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0);\n            this.particles = new Array();\n            this._stockParticles = new Array();\n            this._newPartsExcess = 0;\n            this._vertexBuffers = {};\n            this._scaledColorStep = new BABYLON.Color4(0, 0, 0, 0);\n            this._colorDiff = new BABYLON.Color4(0, 0, 0, 0);\n            this._scaledDirection = BABYLON.Vector3.Zero();\n            this._scaledGravity = BABYLON.Vector3.Zero();\n            this._currentRenderId = -1;\n            this._started = false;\n            this._stopped = false;\n            this._actualFrame = 0;\n            this.id = name;\n            this._capacity = capacity;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._customEffect = customEffect;\n            scene.particleSystems.push(this);\n            var indices = [];\n            var index = 0;\n            for (var count = 0; count < capacity; count++) {\n                indices.push(index);\n                indices.push(index + 1);\n                indices.push(index + 2);\n                indices.push(index);\n                indices.push(index + 2);\n                indices.push(index + 3);\n                index += 4;\n            }\n            this._indexBuffer = scene.getEngine().createIndexBuffer(indices);\n            // 11 floats per particle (x, y, z, r, g, b, a, angle, size, offsetX, offsetY) + 1 filler\n            this._vertexData = new Float32Array(capacity * 11 * 4);\n            this._vertexBuffer = new BABYLON.Buffer(scene.getEngine(), this._vertexData, true, 11);\n            var positions = this._vertexBuffer.createVertexBuffer(BABYLON.VertexBuffer.PositionKind, 0, 3);\n            var colors = this._vertexBuffer.createVertexBuffer(BABYLON.VertexBuffer.ColorKind, 3, 4);\n            var options = this._vertexBuffer.createVertexBuffer(\"options\", 7, 4);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = positions;\n            this._vertexBuffers[BABYLON.VertexBuffer.ColorKind] = colors;\n            this._vertexBuffers[\"options\"] = options;\n            // Default behaviors\n            this.startDirectionFunction = function (emitPower, worldMatrix, directionToUpdate, particle) {\n                var randX = randomNumber(_this.direction1.x, _this.direction2.x);\n                var randY = randomNumber(_this.direction1.y, _this.direction2.y);\n                var randZ = randomNumber(_this.direction1.z, _this.direction2.z);\n                BABYLON.Vector3.TransformNormalFromFloatsToRef(randX * emitPower, randY * emitPower, randZ * emitPower, worldMatrix, directionToUpdate);\n            };\n            this.startPositionFunction = function (worldMatrix, positionToUpdate, particle) {\n                var randX = randomNumber(_this.minEmitBox.x, _this.maxEmitBox.x);\n                var randY = randomNumber(_this.minEmitBox.y, _this.maxEmitBox.y);\n                var randZ = randomNumber(_this.minEmitBox.z, _this.maxEmitBox.z);\n                BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);\n            };\n            this.updateFunction = function (particles) {\n                for (var index = 0; index < particles.length; index++) {\n                    var particle = particles[index];\n                    particle.age += _this._scaledUpdateSpeed;\n                    if (particle.age >= particle.lifeTime) {\n                        _this.recycleParticle(particle);\n                        index--;\n                        continue;\n                    }\n                    else {\n                        particle.colorStep.scaleToRef(_this._scaledUpdateSpeed, _this._scaledColorStep);\n                        particle.color.addInPlace(_this._scaledColorStep);\n                        if (particle.color.a < 0)\n                            particle.color.a = 0;\n                        particle.angle += particle.angularSpeed * _this._scaledUpdateSpeed;\n                        particle.direction.scaleToRef(_this._scaledUpdateSpeed, _this._scaledDirection);\n                        particle.position.addInPlace(_this._scaledDirection);\n                        _this.gravity.scaleToRef(_this._scaledUpdateSpeed, _this._scaledGravity);\n                        particle.direction.addInPlace(_this._scaledGravity);\n                    }\n                }\n            };\n        }\n        Object.defineProperty(ParticleSystem.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ParticleSystem.prototype.recycleParticle = function (particle) {\n            var lastParticle = this.particles.pop();\n            if (lastParticle !== particle) {\n                lastParticle.copyTo(particle);\n                this._stockParticles.push(lastParticle);\n            }\n        };\n        ParticleSystem.prototype.getCapacity = function () {\n            return this._capacity;\n        };\n        ParticleSystem.prototype.isAlive = function () {\n            return this._alive;\n        };\n        ParticleSystem.prototype.isStarted = function () {\n            return this._started;\n        };\n        ParticleSystem.prototype.start = function () {\n            this._started = true;\n            this._stopped = false;\n            this._actualFrame = 0;\n        };\n        ParticleSystem.prototype.stop = function () {\n            this._stopped = true;\n        };\n        ParticleSystem.prototype._appendParticleVertex = function (index, particle, offsetX, offsetY) {\n            var offset = index * 11;\n            this._vertexData[offset] = particle.position.x;\n            this._vertexData[offset + 1] = particle.position.y;\n            this._vertexData[offset + 2] = particle.position.z;\n            this._vertexData[offset + 3] = particle.color.r;\n            this._vertexData[offset + 4] = particle.color.g;\n            this._vertexData[offset + 5] = particle.color.b;\n            this._vertexData[offset + 6] = particle.color.a;\n            this._vertexData[offset + 7] = particle.angle;\n            this._vertexData[offset + 8] = particle.size;\n            this._vertexData[offset + 9] = offsetX;\n            this._vertexData[offset + 10] = offsetY;\n        };\n        ParticleSystem.prototype._update = function (newParticles) {\n            // Update current\n            this._alive = this.particles.length > 0;\n            this.updateFunction(this.particles);\n            // Add new ones\n            var worldMatrix;\n            if (this.emitter.position) {\n                worldMatrix = this.emitter.getWorldMatrix();\n            }\n            else {\n                worldMatrix = BABYLON.Matrix.Translation(this.emitter.x, this.emitter.y, this.emitter.z);\n            }\n            var particle;\n            for (var index = 0; index < newParticles; index++) {\n                if (this.particles.length === this._capacity) {\n                    break;\n                }\n                if (this._stockParticles.length !== 0) {\n                    particle = this._stockParticles.pop();\n                    particle.age = 0;\n                }\n                else {\n                    particle = new BABYLON.Particle();\n                }\n                this.particles.push(particle);\n                var emitPower = randomNumber(this.minEmitPower, this.maxEmitPower);\n                this.startDirectionFunction(emitPower, worldMatrix, particle.direction, particle);\n                particle.lifeTime = randomNumber(this.minLifeTime, this.maxLifeTime);\n                particle.size = randomNumber(this.minSize, this.maxSize);\n                particle.angularSpeed = randomNumber(this.minAngularSpeed, this.maxAngularSpeed);\n                this.startPositionFunction(worldMatrix, particle.position, particle);\n                var step = randomNumber(0, 1.0);\n                BABYLON.Color4.LerpToRef(this.color1, this.color2, step, particle.color);\n                this.colorDead.subtractToRef(particle.color, this._colorDiff);\n                this._colorDiff.scaleToRef(1.0 / particle.lifeTime, particle.colorStep);\n            }\n        };\n        ParticleSystem.prototype._getEffect = function () {\n            if (this._customEffect) {\n                return this._customEffect;\n            }\n            ;\n            var defines = [];\n            if (this._scene.clipPlane) {\n                defines.push(\"#define CLIPPLANE\");\n            }\n            // Effect\n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._effect = this._scene.getEngine().createEffect(\"particles\", [BABYLON.VertexBuffer.PositionKind, BABYLON.VertexBuffer.ColorKind, \"options\"], [\"invView\", \"view\", \"projection\", \"vClipPlane\", \"textureMask\"], [\"diffuseSampler\"], join);\n            }\n            return this._effect;\n        };\n        ParticleSystem.prototype.animate = function () {\n            if (!this._started)\n                return;\n            var effect = this._getEffect();\n            // Check\n            if (!this.emitter || !effect.isReady() || !this.particleTexture || !this.particleTexture.isReady())\n                return;\n            if (this._currentRenderId === this._scene.getRenderId()) {\n                return;\n            }\n            this._currentRenderId = this._scene.getRenderId();\n            this._scaledUpdateSpeed = this.updateSpeed * this._scene.getAnimationRatio();\n            // determine the number of particles we need to create   \n            var newParticles;\n            if (this.manualEmitCount > -1) {\n                newParticles = this.manualEmitCount;\n                this._newPartsExcess = 0;\n                this.manualEmitCount = 0;\n            }\n            else {\n                newParticles = ((this.emitRate * this._scaledUpdateSpeed) >> 0);\n                this._newPartsExcess += this.emitRate * this._scaledUpdateSpeed - newParticles;\n            }\n            if (this._newPartsExcess > 1.0) {\n                newParticles += this._newPartsExcess >> 0;\n                this._newPartsExcess -= this._newPartsExcess >> 0;\n            }\n            this._alive = false;\n            if (!this._stopped) {\n                this._actualFrame += this._scaledUpdateSpeed;\n                if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration)\n                    this.stop();\n            }\n            else {\n                newParticles = 0;\n            }\n            this._update(newParticles);\n            // Stopped?\n            if (this._stopped) {\n                if (!this._alive) {\n                    this._started = false;\n                    if (this.disposeOnStop) {\n                        this._scene._toBeDisposed.push(this);\n                    }\n                }\n            }\n            // Update VBO\n            var offset = 0;\n            for (var index = 0; index < this.particles.length; index++) {\n                var particle = this.particles[index];\n                this._appendParticleVertex(offset++, particle, 0, 0);\n                this._appendParticleVertex(offset++, particle, 1, 0);\n                this._appendParticleVertex(offset++, particle, 1, 1);\n                this._appendParticleVertex(offset++, particle, 0, 1);\n            }\n            this._vertexBuffer.update(this._vertexData);\n        };\n        ParticleSystem.prototype.render = function () {\n            var effect = this._getEffect();\n            // Check\n            if (!this.emitter || !effect.isReady() || !this.particleTexture || !this.particleTexture.isReady() || !this.particles.length)\n                return 0;\n            var engine = this._scene.getEngine();\n            // Render\n            engine.enableEffect(effect);\n            engine.setState(false);\n            var viewMatrix = this._scene.getViewMatrix();\n            effect.setTexture(\"diffuseSampler\", this.particleTexture);\n            effect.setMatrix(\"view\", viewMatrix);\n            effect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n            effect.setFloat4(\"textureMask\", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);\n            if (this._scene.clipPlane) {\n                var clipPlane = this._scene.clipPlane;\n                var invView = viewMatrix.clone();\n                invView.invert();\n                effect.setMatrix(\"invView\", invView);\n                effect.setFloat4(\"vClipPlane\", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\n            }\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);\n            // Draw order\n            if (this.blendMode === ParticleSystem.BLENDMODE_ONEONE) {\n                engine.setAlphaMode(BABYLON.Engine.ALPHA_ONEONE);\n            }\n            else {\n                engine.setAlphaMode(BABYLON.Engine.ALPHA_COMBINE);\n            }\n            if (this.forceDepthWrite) {\n                engine.setDepthWrite(true);\n            }\n            engine.draw(true, 0, this.particles.length * 6);\n            engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n            return this.particles.length;\n        };\n        ParticleSystem.prototype.dispose = function () {\n            if (this._vertexBuffer) {\n                this._vertexBuffer.dispose();\n                this._vertexBuffer = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n            if (this.particleTexture) {\n                this.particleTexture.dispose();\n                this.particleTexture = null;\n            }\n            // Remove from scene\n            var index = this._scene.particleSystems.indexOf(this);\n            this._scene.particleSystems.splice(index, 1);\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n        };\n        // Clone\n        ParticleSystem.prototype.clone = function (name, newEmitter) {\n            var custom = null;\n            var program = null;\n            if (this.customShader != null) {\n                program = this.customShader;\n                var defines = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n                custom = this._scene.getEngine().createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n            }\n            var result = new ParticleSystem(name, this._capacity, this._scene, custom);\n            result.customShader = program;\n            BABYLON.Tools.DeepCopy(this, result, [\"particles\", \"customShader\"]);\n            if (newEmitter === undefined) {\n                newEmitter = this.emitter;\n            }\n            result.emitter = newEmitter;\n            if (this.particleTexture) {\n                result.particleTexture = new BABYLON.Texture(this.particleTexture.url, this._scene);\n            }\n            if (!this.preventAutoStart) {\n                result.start();\n            }\n            return result;\n        };\n        ParticleSystem.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.id = this.id;\n            // Emitter\n            if (this.emitter.position) {\n                serializationObject.emitterId = this.emitter.id;\n            }\n            else {\n                serializationObject.emitter = this.emitter.asArray();\n            }\n            serializationObject.capacity = this.getCapacity();\n            if (this.particleTexture) {\n                serializationObject.textureName = this.particleTexture.name;\n            }\n            // Animations\n            BABYLON.Animation.AppendSerializedAnimations(this, serializationObject);\n            // Particle system\n            serializationObject.minAngularSpeed = this.minAngularSpeed;\n            serializationObject.maxAngularSpeed = this.maxAngularSpeed;\n            serializationObject.minSize = this.minSize;\n            serializationObject.maxSize = this.maxSize;\n            serializationObject.minEmitPower = this.minEmitPower;\n            serializationObject.maxEmitPower = this.maxEmitPower;\n            serializationObject.minLifeTime = this.minLifeTime;\n            serializationObject.maxLifeTime = this.maxLifeTime;\n            serializationObject.emitRate = this.emitRate;\n            serializationObject.minEmitBox = this.minEmitBox.asArray();\n            serializationObject.maxEmitBox = this.maxEmitBox.asArray();\n            serializationObject.gravity = this.gravity.asArray();\n            serializationObject.direction1 = this.direction1.asArray();\n            serializationObject.direction2 = this.direction2.asArray();\n            serializationObject.color1 = this.color1.asArray();\n            serializationObject.color2 = this.color2.asArray();\n            serializationObject.colorDead = this.colorDead.asArray();\n            serializationObject.updateSpeed = this.updateSpeed;\n            serializationObject.targetStopDuration = this.targetStopDuration;\n            serializationObject.textureMask = this.textureMask.asArray();\n            serializationObject.blendMode = this.blendMode;\n            serializationObject.customShader = this.customShader;\n            serializationObject.preventAutoStart = this.preventAutoStart;\n            return serializationObject;\n        };\n        ParticleSystem.Parse = function (parsedParticleSystem, scene, rootUrl) {\n            var name = parsedParticleSystem.name;\n            var custom = null;\n            var program = null;\n            if (parsedParticleSystem.customShader) {\n                program = parsedParticleSystem.customShader;\n                var defines = (program.shaderOptions.defines.length > 0) ? program.shaderOptions.defines.join(\"\\n\") : \"\";\n                custom = scene.getEngine().createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);\n            }\n            var particleSystem = new ParticleSystem(name, parsedParticleSystem.capacity, scene, custom);\n            particleSystem.customShader = program;\n            if (parsedParticleSystem.id) {\n                particleSystem.id = parsedParticleSystem.id;\n            }\n            // Auto start\n            if (parsedParticleSystem.preventAutoStart) {\n                particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;\n            }\n            // Texture\n            if (parsedParticleSystem.textureName) {\n                particleSystem.particleTexture = new BABYLON.Texture(rootUrl + parsedParticleSystem.textureName, scene);\n                particleSystem.particleTexture.name = parsedParticleSystem.textureName;\n            }\n            // Emitter\n            if (parsedParticleSystem.emitterId) {\n                particleSystem.emitter = scene.getLastMeshByID(parsedParticleSystem.emitterId);\n            }\n            else {\n                particleSystem.emitter = BABYLON.Vector3.FromArray(parsedParticleSystem.emitter);\n            }\n            // Animations\n            if (parsedParticleSystem.animations) {\n                for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedParticleSystem.animations[animationIndex];\n                    particleSystem.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n            }\n            if (parsedParticleSystem.autoAnimate) {\n                scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1.0);\n            }\n            // Particle system\n            particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;\n            particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;\n            particleSystem.minSize = parsedParticleSystem.minSize;\n            particleSystem.maxSize = parsedParticleSystem.maxSize;\n            particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;\n            particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;\n            particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;\n            particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;\n            particleSystem.emitRate = parsedParticleSystem.emitRate;\n            particleSystem.minEmitBox = BABYLON.Vector3.FromArray(parsedParticleSystem.minEmitBox);\n            particleSystem.maxEmitBox = BABYLON.Vector3.FromArray(parsedParticleSystem.maxEmitBox);\n            particleSystem.gravity = BABYLON.Vector3.FromArray(parsedParticleSystem.gravity);\n            particleSystem.direction1 = BABYLON.Vector3.FromArray(parsedParticleSystem.direction1);\n            particleSystem.direction2 = BABYLON.Vector3.FromArray(parsedParticleSystem.direction2);\n            particleSystem.color1 = BABYLON.Color4.FromArray(parsedParticleSystem.color1);\n            particleSystem.color2 = BABYLON.Color4.FromArray(parsedParticleSystem.color2);\n            particleSystem.colorDead = BABYLON.Color4.FromArray(parsedParticleSystem.colorDead);\n            particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;\n            particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;\n            particleSystem.textureMask = BABYLON.Color4.FromArray(parsedParticleSystem.textureMask);\n            particleSystem.blendMode = parsedParticleSystem.blendMode;\n            if (!particleSystem.preventAutoStart) {\n                particleSystem.start();\n            }\n            return particleSystem;\n        };\n        return ParticleSystem;\n    }());\n    // Statics\n    ParticleSystem.BLENDMODE_ONEONE = 0;\n    ParticleSystem.BLENDMODE_STANDARD = 1;\n    BABYLON.ParticleSystem = ParticleSystem;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.particleSystem.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SolidParticle = (function () {\n        /**\n         * Creates a Solid Particle object.\n         * Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()\n         * `particleIndex` (integer) is the particle index in the Solid Particle System pool. It's also the particle identifier.\n         * `positionIndex` (integer) is the starting index of the particle vertices in the SPS \"positions\" array.\n         *  `model` (ModelShape) is a reference to the model shape on what the particle is designed.\n         * `shapeId` (integer) is the model shape identifier in the SPS.\n         * `idxInShape` (integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))\n         * `modelBoundingInfo` is the reference to the model BoundingInfo used for intersection computations.\n         */\n        function SolidParticle(particleIndex, positionIndex, model, shapeId, idxInShape, sps, modelBoundingInfo) {\n            this.idx = 0; // particle global index\n            this.color = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0); // color\n            this.position = BABYLON.Vector3.Zero(); // position\n            this.rotation = BABYLON.Vector3.Zero(); // rotation\n            this.scaling = BABYLON.Vector3.One(); // scaling\n            this.uvs = new BABYLON.Vector4(0.0, 0.0, 1.0, 1.0); // uvs\n            this.velocity = BABYLON.Vector3.Zero(); // velocity\n            this.alive = true; // alive\n            this.isVisible = true; // visibility\n            this._pos = 0; // index of this particle in the global \"positions\" array\n            this.shapeId = 0; // model shape id\n            this.idxInShape = 0; // index of the particle in its shape id\n            this.idx = particleIndex;\n            this._pos = positionIndex;\n            this._model = model;\n            this.shapeId = shapeId;\n            this.idxInShape = idxInShape;\n            this._sps = sps;\n            if (modelBoundingInfo) {\n                this._modelBoundingInfo = modelBoundingInfo;\n                this._boundingInfo = new BABYLON.BoundingInfo(modelBoundingInfo.minimum, modelBoundingInfo.maximum);\n            }\n        }\n        Object.defineProperty(SolidParticle.prototype, \"scale\", {\n            /**\n             * legacy support, changed scale to scaling\n             */\n            get: function () {\n                return this.scaling;\n            },\n            set: function (scale) {\n                this.scaling = scale;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticle.prototype, \"quaternion\", {\n            /**\n             * legacy support, changed quaternion to rotationQuaternion\n             */\n            get: function () {\n                return this.rotationQuaternion;\n            },\n            set: function (q) {\n                this.rotationQuaternion = q;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns a boolean. True if the particle intersects another particle or another mesh, else false.\n         * The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)\n         * `target` is the object (solid particle or mesh) what the intersection is computed against.\n         */\n        SolidParticle.prototype.intersectsMesh = function (target) {\n            if (!this._boundingInfo || !target._boundingInfo) {\n                return false;\n            }\n            if (this._sps._bSphereOnly) {\n                return BABYLON.BoundingSphere.Intersects(this._boundingInfo.boundingSphere, target._boundingInfo.boundingSphere);\n            }\n            return this._boundingInfo.intersects(target._boundingInfo, false);\n        };\n        return SolidParticle;\n    }());\n    BABYLON.SolidParticle = SolidParticle;\n    var ModelShape = (function () {\n        /**\n         * Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.\n         * SPS internal tool, don't use it manually.\n         */\n        function ModelShape(id, shape, shapeUV, posFunction, vtxFunction) {\n            this.shapeID = id;\n            this._shape = shape;\n            this._shapeUV = shapeUV;\n            this._positionFunction = posFunction;\n            this._vertexFunction = vtxFunction;\n        }\n        return ModelShape;\n    }());\n    BABYLON.ModelShape = ModelShape;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.solidParticle.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n    * Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System\n    */\n    var SolidParticleSystem = (function () {\n        /**\n        * Creates a SPS (Solid Particle System) object.\n        * `name` (String) is the SPS name, this will be the underlying mesh name.\n        * `scene` (Scene) is the scene in which the SPS is added.\n        * `updatable` (optional boolean, default true) : if the SPS must be updatable or immutable.\n        * `isPickable` (optional boolean, default false) : if the solid particles must be pickable.\n        * `particleIntersection` (optional boolean, default false) : if the solid particle intersections must be computed.\n        * `boundingSphereOnly` (optional boolean, default false) : if the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster).\n        * `bSphereRadiusFactor` (optional float, default 1.0) : a number to multiply the boundind sphere radius by in order to reduce it for instance.\n        *  Example : bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.\n        */\n        function SolidParticleSystem(name, scene, options) {\n            // public members\n            /**\n            *  The SPS array of Solid Particle objects. Just access each particle as with any classic array.\n            *  Example : var p = SPS.particles[i];\n            */\n            this.particles = new Array();\n            /**\n            * The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.\n            */\n            this.nbParticles = 0;\n            /**\n            * If the particles must ever face the camera (default false). Useful for planar particles.\n            */\n            this.billboard = false;\n            /**\n             * Recompute normals when adding a shape\n             */\n            this.recomputeNormals = true;\n            /**\n            * This a counter ofr your own usage. It's not set by any SPS functions.\n            */\n            this.counter = 0;\n            /**\n            * This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.\n            * Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns\n            */\n            this.vars = {};\n            this._positions = new Array();\n            this._indices = new Array();\n            this._normals = new Array();\n            this._colors = new Array();\n            this._uvs = new Array();\n            this._index = 0; // indices index\n            this._updatable = true;\n            this._pickable = false;\n            this._isVisibilityBoxLocked = false;\n            this._alwaysVisible = false;\n            this._shapeCounter = 0;\n            this._copy = new BABYLON.SolidParticle(null, null, null, null, null, null);\n            this._color = new BABYLON.Color4(0, 0, 0, 0);\n            this._computeParticleColor = true;\n            this._computeParticleTexture = true;\n            this._computeParticleRotation = true;\n            this._computeParticleVertex = false;\n            this._computeBoundingBox = false;\n            this._cam_axisZ = BABYLON.Vector3.Zero();\n            this._cam_axisY = BABYLON.Vector3.Zero();\n            this._cam_axisX = BABYLON.Vector3.Zero();\n            this._axisX = BABYLON.Axis.X;\n            this._axisY = BABYLON.Axis.Y;\n            this._axisZ = BABYLON.Axis.Z;\n            this._camDir = BABYLON.Vector3.Zero();\n            this._rotMatrix = new BABYLON.Matrix();\n            this._invertMatrix = new BABYLON.Matrix();\n            this._rotated = BABYLON.Vector3.Zero();\n            this._quaternion = new BABYLON.Quaternion();\n            this._vertex = BABYLON.Vector3.Zero();\n            this._normal = BABYLON.Vector3.Zero();\n            this._yaw = 0.0;\n            this._pitch = 0.0;\n            this._roll = 0.0;\n            this._halfroll = 0.0;\n            this._halfpitch = 0.0;\n            this._halfyaw = 0.0;\n            this._sinRoll = 0.0;\n            this._cosRoll = 0.0;\n            this._sinPitch = 0.0;\n            this._cosPitch = 0.0;\n            this._sinYaw = 0.0;\n            this._cosYaw = 0.0;\n            this._w = 0.0;\n            this._mustUnrotateFixedNormals = false;\n            this._minimum = BABYLON.Tmp.Vector3[0];\n            this._maximum = BABYLON.Tmp.Vector3[1];\n            this._scale = BABYLON.Tmp.Vector3[2];\n            this._translation = BABYLON.Tmp.Vector3[3];\n            this._minBbox = BABYLON.Tmp.Vector3[4];\n            this._maxBbox = BABYLON.Tmp.Vector3[5];\n            this._particlesIntersect = false;\n            this._bSphereOnly = false;\n            this._bSphereRadiusFactor = 1.0;\n            this.name = name;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._camera = scene.activeCamera;\n            this._pickable = options ? options.isPickable : false;\n            this._particlesIntersect = options ? options.particleIntersection : false;\n            this._bSphereOnly = options ? options.boundingSphereOnly : false;\n            this._bSphereRadiusFactor = (options && options.bSphereRadiusFactor) ? options.bSphereRadiusFactor : 1.0;\n            if (options && options.updatable) {\n                this._updatable = options.updatable;\n            }\n            else {\n                this._updatable = true;\n            }\n            if (this._pickable) {\n                this.pickedParticles = [];\n            }\n        }\n        /**\n        * Builds the SPS underlying mesh. Returns a standard Mesh.\n        * If no model shape was added to the SPS, the returned mesh is just a single triangular plane.\n        */\n        SolidParticleSystem.prototype.buildMesh = function () {\n            if (this.nbParticles === 0) {\n                var triangle = BABYLON.MeshBuilder.CreateDisc(\"\", { radius: 1, tessellation: 3 }, this._scene);\n                this.addShape(triangle, 1);\n                triangle.dispose();\n            }\n            this._positions32 = new Float32Array(this._positions);\n            this._uvs32 = new Float32Array(this._uvs);\n            this._colors32 = new Float32Array(this._colors);\n            if (this.recomputeNormals) {\n                BABYLON.VertexData.ComputeNormals(this._positions32, this._indices, this._normals);\n            }\n            this._normals32 = new Float32Array(this._normals);\n            this._fixedNormal32 = new Float32Array(this._normals);\n            if (this._mustUnrotateFixedNormals) {\n                this._unrotateFixedNormals();\n            }\n            var vertexData = new BABYLON.VertexData();\n            vertexData.set(this._positions32, BABYLON.VertexBuffer.PositionKind);\n            vertexData.indices = this._indices;\n            vertexData.set(this._normals32, BABYLON.VertexBuffer.NormalKind);\n            if (this._uvs32) {\n                vertexData.set(this._uvs32, BABYLON.VertexBuffer.UVKind);\n                ;\n            }\n            if (this._colors32) {\n                vertexData.set(this._colors32, BABYLON.VertexBuffer.ColorKind);\n            }\n            var mesh = new BABYLON.Mesh(this.name, this._scene);\n            vertexData.applyToMesh(mesh, this._updatable);\n            this.mesh = mesh;\n            this.mesh.isPickable = this._pickable;\n            // free memory\n            this._positions = null;\n            this._normals = null;\n            this._uvs = null;\n            this._colors = null;\n            if (!this._updatable) {\n                this.particles.length = 0;\n            }\n            return mesh;\n        };\n        /**\n        * Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.\n        * These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.\n        * Thus the particles generated from `digest()` have their property `position` set yet.\n        * `mesh` ( Mesh ) is the mesh to be digested\n        * `facetNb` (optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any\n        * `delta` (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets\n        * `number` (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets\n        */\n        SolidParticleSystem.prototype.digest = function (mesh, options) {\n            var size = (options && options.facetNb) || 1;\n            var number = (options && options.number);\n            var delta = (options && options.delta) || 0;\n            var meshPos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var meshInd = mesh.getIndices();\n            var meshUV = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var meshCol = mesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);\n            var meshNor = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var f = 0; // facet counter\n            var totalFacets = meshInd.length / 3; // a facet is a triangle, so 3 indices\n            // compute size from number\n            if (number) {\n                number = (number > totalFacets) ? totalFacets : number;\n                size = Math.round(totalFacets / number);\n                delta = 0;\n            }\n            else {\n                size = (size > totalFacets) ? totalFacets : size;\n            }\n            var facetPos = []; // submesh positions\n            var facetInd = []; // submesh indices\n            var facetUV = []; // submesh UV\n            var facetCol = []; // submesh colors\n            var barycenter = BABYLON.Tmp.Vector3[0];\n            var rand;\n            var sizeO = size;\n            while (f < totalFacets) {\n                size = sizeO + Math.floor((1 + delta) * Math.random());\n                if (f > totalFacets - size) {\n                    size = totalFacets - f;\n                }\n                // reset temp arrays\n                facetPos.length = 0;\n                facetInd.length = 0;\n                facetUV.length = 0;\n                facetCol.length = 0;\n                // iterate over \"size\" facets\n                var fi = 0;\n                for (var j = f * 3; j < (f + size) * 3; j++) {\n                    facetInd.push(fi);\n                    var i = meshInd[j];\n                    facetPos.push(meshPos[i * 3], meshPos[i * 3 + 1], meshPos[i * 3 + 2]);\n                    if (meshUV) {\n                        facetUV.push(meshUV[i * 2], meshUV[i * 2 + 1]);\n                    }\n                    if (meshCol) {\n                        facetCol.push(meshCol[i * 4], meshCol[i * 4 + 1], meshCol[i * 4 + 2], meshCol[i * 4 + 3]);\n                    }\n                    fi++;\n                }\n                // create a model shape for each single particle\n                var idx = this.nbParticles;\n                var shape = this._posToShape(facetPos);\n                var shapeUV = this._uvsToShapeUV(facetUV);\n                // compute the barycenter of the shape\n                var v;\n                for (v = 0; v < shape.length; v++) {\n                    barycenter.addInPlace(shape[v]);\n                }\n                barycenter.scaleInPlace(1 / shape.length);\n                // shift the shape from its barycenter to the origin\n                for (v = 0; v < shape.length; v++) {\n                    shape[v].subtractInPlace(barycenter);\n                }\n                var bInfo;\n                if (this._particlesIntersect) {\n                    bInfo = new BABYLON.BoundingInfo(barycenter, barycenter);\n                }\n                var modelShape = new BABYLON.ModelShape(this._shapeCounter, shape, shapeUV, null, null);\n                // add the particle in the SPS\n                var currentPos = this._positions.length;\n                this._meshBuilder(this._index, shape, this._positions, facetInd, this._indices, facetUV, this._uvs, facetCol, this._colors, meshNor, this._normals, idx, 0, null);\n                this._addParticle(idx, currentPos, modelShape, this._shapeCounter, 0, bInfo);\n                // initialize the particle position\n                this.particles[this.nbParticles].position.addInPlace(barycenter);\n                this._index += shape.length;\n                idx++;\n                this.nbParticles++;\n                this._shapeCounter++;\n                f += size;\n            }\n            return this;\n        };\n        // unrotate the fixed normals in case the mesh was built with pre-rotated particles, ex : use of positionFunction in addShape()\n        SolidParticleSystem.prototype._unrotateFixedNormals = function () {\n            var index = 0;\n            var idx = 0;\n            for (var p = 0; p < this.particles.length; p++) {\n                this._particle = this.particles[p];\n                this._shape = this._particle._model._shape;\n                if (this._particle.rotationQuaternion) {\n                    this._quaternion.copyFrom(this._particle.rotationQuaternion);\n                }\n                else {\n                    this._yaw = this._particle.rotation.y;\n                    this._pitch = this._particle.rotation.x;\n                    this._roll = this._particle.rotation.z;\n                    this._quaternionRotationYPR();\n                }\n                this._quaternionToRotationMatrix();\n                this._rotMatrix.invertToRef(this._invertMatrix);\n                for (var pt = 0; pt < this._shape.length; pt++) {\n                    idx = index + pt * 3;\n                    BABYLON.Vector3.TransformNormalFromFloatsToRef(this._normals32[idx], this._normals32[idx + 1], this._normals32[idx + 2], this._invertMatrix, this._normal);\n                    this._fixedNormal32[idx] = this._normal.x;\n                    this._fixedNormal32[idx + 1] = this._normal.y;\n                    this._fixedNormal32[idx + 2] = this._normal.z;\n                }\n                index = idx + 3;\n            }\n        };\n        //reset copy\n        SolidParticleSystem.prototype._resetCopy = function () {\n            this._copy.position.x = 0;\n            this._copy.position.y = 0;\n            this._copy.position.z = 0;\n            this._copy.rotation.x = 0;\n            this._copy.rotation.y = 0;\n            this._copy.rotation.z = 0;\n            this._copy.rotationQuaternion = null;\n            this._copy.scaling.x = 1;\n            this._copy.scaling.y = 1;\n            this._copy.scaling.z = 1;\n            this._copy.uvs.x = 0;\n            this._copy.uvs.y = 0;\n            this._copy.uvs.z = 1;\n            this._copy.uvs.w = 1;\n            this._copy.color = null;\n        };\n        // _meshBuilder : inserts the shape model in the global SPS mesh\n        SolidParticleSystem.prototype._meshBuilder = function (p, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options) {\n            var i;\n            var u = 0;\n            var c = 0;\n            var n = 0;\n            this._resetCopy();\n            if (options && options.positionFunction) {\n                options.positionFunction(this._copy, idx, idxInShape);\n                this._mustUnrotateFixedNormals = true;\n            }\n            if (this._copy.rotationQuaternion) {\n                this._quaternion.copyFrom(this._copy.rotationQuaternion);\n            }\n            else {\n                this._yaw = this._copy.rotation.y;\n                this._pitch = this._copy.rotation.x;\n                this._roll = this._copy.rotation.z;\n                this._quaternionRotationYPR();\n            }\n            this._quaternionToRotationMatrix();\n            for (i = 0; i < shape.length; i++) {\n                this._vertex.x = shape[i].x;\n                this._vertex.y = shape[i].y;\n                this._vertex.z = shape[i].z;\n                if (options && options.vertexFunction) {\n                    options.vertexFunction(this._copy, this._vertex, i);\n                }\n                this._vertex.x *= this._copy.scaling.x;\n                this._vertex.y *= this._copy.scaling.y;\n                this._vertex.z *= this._copy.scaling.z;\n                BABYLON.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated);\n                positions.push(this._copy.position.x + this._rotated.x, this._copy.position.y + this._rotated.y, this._copy.position.z + this._rotated.z);\n                if (meshUV) {\n                    uvs.push((this._copy.uvs.z - this._copy.uvs.x) * meshUV[u] + this._copy.uvs.x, (this._copy.uvs.w - this._copy.uvs.y) * meshUV[u + 1] + this._copy.uvs.y);\n                    u += 2;\n                }\n                if (this._copy.color) {\n                    this._color = this._copy.color;\n                }\n                else if (meshCol && meshCol[c] !== undefined) {\n                    this._color.r = meshCol[c];\n                    this._color.g = meshCol[c + 1];\n                    this._color.b = meshCol[c + 2];\n                    this._color.a = meshCol[c + 3];\n                }\n                else {\n                    this._color.r = 1;\n                    this._color.g = 1;\n                    this._color.b = 1;\n                    this._color.a = 1;\n                }\n                colors.push(this._color.r, this._color.g, this._color.b, this._color.a);\n                c += 4;\n                if (!this.recomputeNormals && meshNor) {\n                    this._normal.x = meshNor[n];\n                    this._normal.y = meshNor[n + 1];\n                    this._normal.z = meshNor[n + 2];\n                    BABYLON.Vector3.TransformNormalToRef(this._normal, this._rotMatrix, this._normal);\n                    normals.push(this._normal.x, this._normal.y, this._normal.z);\n                    n += 3;\n                }\n            }\n            for (i = 0; i < meshInd.length; i++) {\n                indices.push(p + meshInd[i]);\n            }\n            if (this._pickable) {\n                var nbfaces = meshInd.length / 3;\n                for (i = 0; i < nbfaces; i++) {\n                    this.pickedParticles.push({ idx: idx, faceId: i });\n                }\n            }\n            return this._copy;\n        };\n        // returns a shape array from positions array\n        SolidParticleSystem.prototype._posToShape = function (positions) {\n            var shape = [];\n            for (var i = 0; i < positions.length; i += 3) {\n                shape.push(new BABYLON.Vector3(positions[i], positions[i + 1], positions[i + 2]));\n            }\n            return shape;\n        };\n        // returns a shapeUV array from a Vector4 uvs\n        SolidParticleSystem.prototype._uvsToShapeUV = function (uvs) {\n            var shapeUV = [];\n            if (uvs) {\n                for (var i = 0; i < uvs.length; i++)\n                    shapeUV.push(uvs[i]);\n            }\n            return shapeUV;\n        };\n        // adds a new particle object in the particles array\n        SolidParticleSystem.prototype._addParticle = function (idx, idxpos, model, shapeId, idxInShape, bInfo) {\n            var sp = new BABYLON.SolidParticle(idx, idxpos, model, shapeId, idxInShape, this, bInfo);\n            this.particles.push(sp);\n            return sp;\n        };\n        /**\n        * Adds some particles to the SPS from the model shape. Returns the shape id.\n        * Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps\n        * `mesh` is any Mesh object that will be used as a model for the solid particles.\n        * `nb` (positive integer) the number of particles to be created from this model\n        * `positionFunction` is an optional javascript function to called for each particle on SPS creation.\n        * `vertexFunction` is an optional javascript function to called for each vertex of each particle on SPS creation\n        */\n        SolidParticleSystem.prototype.addShape = function (mesh, nb, options) {\n            var meshPos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var meshInd = mesh.getIndices();\n            var meshUV = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var meshCol = mesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);\n            var meshNor = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var bbInfo;\n            if (this._particlesIntersect) {\n                bbInfo = mesh.getBoundingInfo();\n            }\n            var shape = this._posToShape(meshPos);\n            var shapeUV = this._uvsToShapeUV(meshUV);\n            var posfunc = options ? options.positionFunction : null;\n            var vtxfunc = options ? options.vertexFunction : null;\n            var modelShape = new BABYLON.ModelShape(this._shapeCounter, shape, shapeUV, posfunc, vtxfunc);\n            // particles\n            var sp;\n            var currentCopy;\n            var idx = this.nbParticles;\n            for (var i = 0; i < nb; i++) {\n                var currentPos = this._positions.length;\n                currentCopy = this._meshBuilder(this._index, shape, this._positions, meshInd, this._indices, meshUV, this._uvs, meshCol, this._colors, meshNor, this._normals, idx, i, options);\n                if (this._updatable) {\n                    sp = this._addParticle(idx, currentPos, modelShape, this._shapeCounter, i, bbInfo);\n                    sp.position.copyFrom(currentCopy.position);\n                    sp.rotation.copyFrom(currentCopy.rotation);\n                    if (currentCopy.rotationQuaternion) {\n                        sp.rotationQuaternion.copyFrom(currentCopy.rotationQuaternion);\n                    }\n                    if (currentCopy.color) {\n                        sp.color.copyFrom(currentCopy.color);\n                    }\n                    sp.scaling.copyFrom(currentCopy.scaling);\n                    sp.uvs.copyFrom(currentCopy.uvs);\n                }\n                this._index += shape.length;\n                idx++;\n            }\n            this.nbParticles += nb;\n            this._shapeCounter++;\n            return this._shapeCounter - 1;\n        };\n        // rebuilds a particle back to its just built status : if needed, recomputes the custom positions and vertices\n        SolidParticleSystem.prototype._rebuildParticle = function (particle) {\n            this._resetCopy();\n            if (particle._model._positionFunction) {\n                particle._model._positionFunction(this._copy, particle.idx, particle.idxInShape);\n            }\n            if (this._copy.rotationQuaternion) {\n                this._quaternion.copyFrom(this._copy.rotationQuaternion);\n            }\n            else {\n                this._yaw = this._copy.rotation.y;\n                this._pitch = this._copy.rotation.x;\n                this._roll = this._copy.rotation.z;\n                this._quaternionRotationYPR();\n            }\n            this._quaternionToRotationMatrix();\n            this._shape = particle._model._shape;\n            for (var pt = 0; pt < this._shape.length; pt++) {\n                this._vertex.x = this._shape[pt].x;\n                this._vertex.y = this._shape[pt].y;\n                this._vertex.z = this._shape[pt].z;\n                if (particle._model._vertexFunction) {\n                    particle._model._vertexFunction(this._copy, this._vertex, pt); // recall to stored vertexFunction\n                }\n                this._vertex.x *= this._copy.scaling.x;\n                this._vertex.y *= this._copy.scaling.y;\n                this._vertex.z *= this._copy.scaling.z;\n                BABYLON.Vector3.TransformCoordinatesToRef(this._vertex, this._rotMatrix, this._rotated);\n                this._positions32[particle._pos + pt * 3] = this._copy.position.x + this._rotated.x;\n                this._positions32[particle._pos + pt * 3 + 1] = this._copy.position.y + this._rotated.y;\n                this._positions32[particle._pos + pt * 3 + 2] = this._copy.position.z + this._rotated.z;\n            }\n            particle.position.x = 0.0;\n            particle.position.y = 0.0;\n            particle.position.z = 0.0;\n            particle.rotation.x = 0.0;\n            particle.rotation.y = 0.0;\n            particle.rotation.z = 0.0;\n            particle.rotationQuaternion = null;\n            particle.scaling.x = 1.0;\n            particle.scaling.y = 1.0;\n            particle.scaling.z = 1.0;\n        };\n        /**\n        * Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.\n        * Returns the SPS.\n        */\n        SolidParticleSystem.prototype.rebuildMesh = function () {\n            for (var p = 0; p < this.particles.length; p++) {\n                this._rebuildParticle(this.particles[p]);\n            }\n            this.mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, this._positions32, false, false);\n            return this;\n        };\n        /**\n        *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n        *  This method calls `updateParticle()` for each particle of the SPS.\n        *  For an animated SPS, it is usually called within the render loop.\n        * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n        * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n        * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n        * Returns the SPS.\n        */\n        SolidParticleSystem.prototype.setParticles = function (start, end, update) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = this.nbParticles - 1; }\n            if (update === void 0) { update = true; }\n            if (!this._updatable) {\n                return;\n            }\n            // custom beforeUpdate\n            this.beforeUpdateParticles(start, end, update);\n            this._cam_axisX.x = 1.0;\n            this._cam_axisX.y = 0.0;\n            this._cam_axisX.z = 0.0;\n            this._cam_axisY.x = 0.0;\n            this._cam_axisY.y = 1.0;\n            this._cam_axisY.z = 0.0;\n            this._cam_axisZ.x = 0.0;\n            this._cam_axisZ.y = 0.0;\n            this._cam_axisZ.z = 1.0;\n            // if the particles will always face the camera\n            if (this.billboard) {\n                this.mesh.computeWorldMatrix(true);\n                // compute the camera position and un-rotate it by the current mesh rotation\n                if (this.mesh._worldMatrix.decompose(this._scale, this._quaternion, this._translation)) {\n                    this._quaternionToRotationMatrix();\n                    this._rotMatrix.invertToRef(this._invertMatrix);\n                    this._camera.getDirectionToRef(this._axisZ, this._camDir);\n                    BABYLON.Vector3.TransformNormalToRef(this._camDir, this._invertMatrix, this._cam_axisZ);\n                    this._cam_axisZ.normalize();\n                    // same for camera up vector extracted from the cam view matrix\n                    var view = this._camera.getViewMatrix(true);\n                    BABYLON.Vector3.TransformNormalFromFloatsToRef(view.m[1], view.m[5], view.m[9], this._invertMatrix, this._cam_axisY);\n                    BABYLON.Vector3.CrossToRef(this._cam_axisY, this._cam_axisZ, this._cam_axisX);\n                    this._cam_axisY.normalize();\n                    this._cam_axisX.normalize();\n                }\n            }\n            BABYLON.Matrix.IdentityToRef(this._rotMatrix);\n            var idx = 0; // current position index in the global array positions32\n            var index = 0; // position start index in the global array positions32 of the current particle\n            var colidx = 0; // current color index in the global array colors32\n            var colorIndex = 0; // color start index in the global array colors32 of the current particle\n            var uvidx = 0; // current uv index in the global array uvs32\n            var uvIndex = 0; // uv start index in the global array uvs32 of the current particle\n            var pt = 0; // current index in the particle model shape\n            if (this.mesh.isFacetDataEnabled) {\n                this._computeBoundingBox = true;\n            }\n            end = (end >= this.nbParticles) ? this.nbParticles - 1 : end;\n            if (this._computeBoundingBox) {\n                if (start == 0 && end == this.nbParticles - 1) {\n                    BABYLON.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this._minimum);\n                    BABYLON.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this._maximum);\n                }\n                else {\n                    this._minimum.copyFrom(this.mesh._boundingInfo.boundingBox.minimum);\n                    this._maximum.copyFrom(this.mesh._boundingInfo.boundingBox.maximum);\n                }\n            }\n            // particle loop\n            index = this.particles[start]._pos;\n            var vpos = (index / 3) | 0;\n            colorIndex = vpos * 4;\n            uvIndex = vpos * 2;\n            for (var p = start; p <= end; p++) {\n                this._particle = this.particles[p];\n                this._shape = this._particle._model._shape;\n                this._shapeUV = this._particle._model._shapeUV;\n                // call to custom user function to update the particle properties\n                this.updateParticle(this._particle);\n                if (this._particle.isVisible) {\n                    // particle rotation matrix\n                    if (this.billboard) {\n                        this._particle.rotation.x = 0.0;\n                        this._particle.rotation.y = 0.0;\n                    }\n                    if (this._computeParticleRotation || this.billboard) {\n                        if (this._particle.rotationQuaternion) {\n                            this._quaternion.copyFrom(this._particle.rotationQuaternion);\n                        }\n                        else {\n                            this._yaw = this._particle.rotation.y;\n                            this._pitch = this._particle.rotation.x;\n                            this._roll = this._particle.rotation.z;\n                            this._quaternionRotationYPR();\n                        }\n                        this._quaternionToRotationMatrix();\n                    }\n                    // particle vertex loop\n                    for (pt = 0; pt < this._shape.length; pt++) {\n                        idx = index + pt * 3;\n                        colidx = colorIndex + pt * 4;\n                        uvidx = uvIndex + pt * 2;\n                        this._vertex.x = this._shape[pt].x;\n                        this._vertex.y = this._shape[pt].y;\n                        this._vertex.z = this._shape[pt].z;\n                        if (this._computeParticleVertex) {\n                            this.updateParticleVertex(this._particle, this._vertex, pt);\n                        }\n                        // positions\n                        this._vertex.x *= this._particle.scaling.x;\n                        this._vertex.y *= this._particle.scaling.y;\n                        this._vertex.z *= this._particle.scaling.z;\n                        this._w = (this._vertex.x * this._rotMatrix.m[3]) + (this._vertex.y * this._rotMatrix.m[7]) + (this._vertex.z * this._rotMatrix.m[11]) + this._rotMatrix.m[15];\n                        this._rotated.x = ((this._vertex.x * this._rotMatrix.m[0]) + (this._vertex.y * this._rotMatrix.m[4]) + (this._vertex.z * this._rotMatrix.m[8]) + this._rotMatrix.m[12]) / this._w;\n                        this._rotated.y = ((this._vertex.x * this._rotMatrix.m[1]) + (this._vertex.y * this._rotMatrix.m[5]) + (this._vertex.z * this._rotMatrix.m[9]) + this._rotMatrix.m[13]) / this._w;\n                        this._rotated.z = ((this._vertex.x * this._rotMatrix.m[2]) + (this._vertex.y * this._rotMatrix.m[6]) + (this._vertex.z * this._rotMatrix.m[10]) + this._rotMatrix.m[14]) / this._w;\n                        this._positions32[idx] = this._particle.position.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z;\n                        this._positions32[idx + 1] = this._particle.position.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z;\n                        this._positions32[idx + 2] = this._particle.position.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z;\n                        if (this._computeBoundingBox) {\n                            if (this._positions32[idx] < this._minimum.x) {\n                                this._minimum.x = this._positions32[idx];\n                            }\n                            if (this._positions32[idx] > this._maximum.x) {\n                                this._maximum.x = this._positions32[idx];\n                            }\n                            if (this._positions32[idx + 1] < this._minimum.y) {\n                                this._minimum.y = this._positions32[idx + 1];\n                            }\n                            if (this._positions32[idx + 1] > this._maximum.y) {\n                                this._maximum.y = this._positions32[idx + 1];\n                            }\n                            if (this._positions32[idx + 2] < this._minimum.z) {\n                                this._minimum.z = this._positions32[idx + 2];\n                            }\n                            if (this._positions32[idx + 2] > this._maximum.z) {\n                                this._maximum.z = this._positions32[idx + 2];\n                            }\n                        }\n                        // normals : if the particles can't be morphed then just rotate the normals, what is much more faster than ComputeNormals()\n                        if (!this._computeParticleVertex) {\n                            this._normal.x = this._fixedNormal32[idx];\n                            this._normal.y = this._fixedNormal32[idx + 1];\n                            this._normal.z = this._fixedNormal32[idx + 2];\n                            this._rotated.x = ((this._normal.x * this._rotMatrix.m[0]) + (this._normal.y * this._rotMatrix.m[4]) + (this._normal.z * this._rotMatrix.m[8]) + this._rotMatrix.m[12]);\n                            this._rotated.y = ((this._normal.x * this._rotMatrix.m[1]) + (this._normal.y * this._rotMatrix.m[5]) + (this._normal.z * this._rotMatrix.m[9]) + this._rotMatrix.m[13]);\n                            this._rotated.z = ((this._normal.x * this._rotMatrix.m[2]) + (this._normal.y * this._rotMatrix.m[6]) + (this._normal.z * this._rotMatrix.m[10]) + this._rotMatrix.m[14]);\n                            this._normals32[idx] = this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z;\n                            this._normals32[idx + 1] = this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z;\n                            this._normals32[idx + 2] = this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z;\n                        }\n                        if (this._computeParticleColor) {\n                            this._colors32[colidx] = this._particle.color.r;\n                            this._colors32[colidx + 1] = this._particle.color.g;\n                            this._colors32[colidx + 2] = this._particle.color.b;\n                            this._colors32[colidx + 3] = this._particle.color.a;\n                        }\n                        if (this._computeParticleTexture) {\n                            this._uvs32[uvidx] = this._shapeUV[pt * 2] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x;\n                            this._uvs32[uvidx + 1] = this._shapeUV[pt * 2 + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y;\n                        }\n                    }\n                }\n                else {\n                    for (pt = 0; pt < this._shape.length; pt++) {\n                        idx = index + pt * 3;\n                        colidx = colorIndex + pt * 4;\n                        uvidx = uvIndex + pt * 2;\n                        this._positions32[idx] = this._camera.globalPosition.x;\n                        this._positions32[idx + 1] = this._camera.globalPosition.y;\n                        this._positions32[idx + 2] = this._camera.globalPosition.z;\n                        this._normals32[idx] = 0.0;\n                        this._normals32[idx + 1] = 0.0;\n                        this._normals32[idx + 2] = 0.0;\n                        if (this._computeParticleColor) {\n                            this._colors32[colidx] = this._particle.color.r;\n                            this._colors32[colidx + 1] = this._particle.color.g;\n                            this._colors32[colidx + 2] = this._particle.color.b;\n                            this._colors32[colidx + 3] = this._particle.color.a;\n                        }\n                        if (this._computeParticleTexture) {\n                            this._uvs32[uvidx] = this._shapeUV[pt * 2] * (this._particle.uvs.z - this._particle.uvs.x) + this._particle.uvs.x;\n                            this._uvs32[uvidx + 1] = this._shapeUV[pt * 2 + 1] * (this._particle.uvs.w - this._particle.uvs.y) + this._particle.uvs.y;\n                        }\n                    }\n                }\n                // if the particle intersections must be computed : update the bbInfo\n                if (this._particlesIntersect) {\n                    var bInfo = this._particle._boundingInfo;\n                    var bBox = bInfo.boundingBox;\n                    var bSphere = bInfo.boundingSphere;\n                    if (!this._bSphereOnly) {\n                        // place, scale and rotate the particle bbox within the SPS local system, then update it\n                        for (var b = 0; b < bBox.vectors.length; b++) {\n                            this._vertex.x = this._particle._modelBoundingInfo.boundingBox.vectors[b].x * this._particle.scaling.x;\n                            this._vertex.y = this._particle._modelBoundingInfo.boundingBox.vectors[b].y * this._particle.scaling.y;\n                            this._vertex.z = this._particle._modelBoundingInfo.boundingBox.vectors[b].z * this._particle.scaling.z;\n                            this._w = (this._vertex.x * this._rotMatrix.m[3]) + (this._vertex.y * this._rotMatrix.m[7]) + (this._vertex.z * this._rotMatrix.m[11]) + this._rotMatrix.m[15];\n                            this._rotated.x = ((this._vertex.x * this._rotMatrix.m[0]) + (this._vertex.y * this._rotMatrix.m[4]) + (this._vertex.z * this._rotMatrix.m[8]) + this._rotMatrix.m[12]) / this._w;\n                            this._rotated.y = ((this._vertex.x * this._rotMatrix.m[1]) + (this._vertex.y * this._rotMatrix.m[5]) + (this._vertex.z * this._rotMatrix.m[9]) + this._rotMatrix.m[13]) / this._w;\n                            this._rotated.z = ((this._vertex.x * this._rotMatrix.m[2]) + (this._vertex.y * this._rotMatrix.m[6]) + (this._vertex.z * this._rotMatrix.m[10]) + this._rotMatrix.m[14]) / this._w;\n                            bBox.vectors[b].x = this._particle.position.x + this._cam_axisX.x * this._rotated.x + this._cam_axisY.x * this._rotated.y + this._cam_axisZ.x * this._rotated.z;\n                            bBox.vectors[b].y = this._particle.position.y + this._cam_axisX.y * this._rotated.x + this._cam_axisY.y * this._rotated.y + this._cam_axisZ.y * this._rotated.z;\n                            bBox.vectors[b].z = this._particle.position.z + this._cam_axisX.z * this._rotated.x + this._cam_axisY.z * this._rotated.y + this._cam_axisZ.z * this._rotated.z;\n                        }\n                        bBox._update(this.mesh._worldMatrix);\n                    }\n                    // place and scale the particle bouding sphere in the SPS local system, then update it\n                    this._minBbox.x = this._particle._modelBoundingInfo.minimum.x * this._particle.scaling.x;\n                    this._minBbox.y = this._particle._modelBoundingInfo.minimum.y * this._particle.scaling.y;\n                    this._minBbox.z = this._particle._modelBoundingInfo.minimum.z * this._particle.scaling.z;\n                    this._maxBbox.x = this._particle._modelBoundingInfo.maximum.x * this._particle.scaling.x;\n                    this._maxBbox.y = this._particle._modelBoundingInfo.maximum.y * this._particle.scaling.y;\n                    this._maxBbox.z = this._particle._modelBoundingInfo.maximum.z * this._particle.scaling.z;\n                    bSphere.center.x = this._particle.position.x + (this._minBbox.x + this._maxBbox.x) * 0.5;\n                    bSphere.center.y = this._particle.position.y + (this._minBbox.y + this._maxBbox.y) * 0.5;\n                    bSphere.center.z = this._particle.position.z + (this._minBbox.z + this._maxBbox.z) * 0.5;\n                    bSphere.radius = this._bSphereRadiusFactor * 0.5 * Math.sqrt((this._maxBbox.x - this._minBbox.x) * (this._maxBbox.x - this._minBbox.x) + (this._maxBbox.y - this._minBbox.y) * (this._maxBbox.y - this._minBbox.y) + (this._maxBbox.z - this._minBbox.z) * (this._maxBbox.z - this._minBbox.z));\n                    bSphere._update(this.mesh._worldMatrix);\n                }\n                // increment indexes for the next particle\n                index = idx + 3;\n                colorIndex = colidx + 4;\n                uvIndex = uvidx + 2;\n            }\n            // if the VBO must be updated\n            if (update) {\n                if (this._computeParticleColor) {\n                    this.mesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, this._colors32, false, false);\n                }\n                if (this._computeParticleTexture) {\n                    this.mesh.updateVerticesData(BABYLON.VertexBuffer.UVKind, this._uvs32, false, false);\n                }\n                this.mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, this._positions32, false, false);\n                if (!this.mesh.areNormalsFrozen || this.mesh.isFacetDataEnabled) {\n                    if (this._computeParticleVertex || this.mesh.isFacetDataEnabled) {\n                        // recompute the normals only if the particles can be morphed, update then also the normal reference array _fixedNormal32[]\n                        var params = this.mesh.isFacetDataEnabled ? this.mesh.getFacetDataParameters() : null;\n                        BABYLON.VertexData.ComputeNormals(this._positions32, this._indices, this._normals32, params);\n                        for (var i = 0; i < this._normals32.length; i++) {\n                            this._fixedNormal32[i] = this._normals32[i];\n                        }\n                    }\n                    if (!this.mesh.areNormalsFrozen) {\n                        this.mesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, this._normals32, false, false);\n                    }\n                }\n            }\n            if (this._computeBoundingBox) {\n                this.mesh._boundingInfo = new BABYLON.BoundingInfo(this._minimum, this._maximum);\n                this.mesh._boundingInfo.update(this.mesh._worldMatrix);\n            }\n            this.afterUpdateParticles(start, end, update);\n            return this;\n        };\n        SolidParticleSystem.prototype._quaternionRotationYPR = function () {\n            this._halfroll = this._roll * 0.5;\n            this._halfpitch = this._pitch * 0.5;\n            this._halfyaw = this._yaw * 0.5;\n            this._sinRoll = Math.sin(this._halfroll);\n            this._cosRoll = Math.cos(this._halfroll);\n            this._sinPitch = Math.sin(this._halfpitch);\n            this._cosPitch = Math.cos(this._halfpitch);\n            this._sinYaw = Math.sin(this._halfyaw);\n            this._cosYaw = Math.cos(this._halfyaw);\n            this._quaternion.x = (this._cosYaw * this._sinPitch * this._cosRoll) + (this._sinYaw * this._cosPitch * this._sinRoll);\n            this._quaternion.y = (this._sinYaw * this._cosPitch * this._cosRoll) - (this._cosYaw * this._sinPitch * this._sinRoll);\n            this._quaternion.z = (this._cosYaw * this._cosPitch * this._sinRoll) - (this._sinYaw * this._sinPitch * this._cosRoll);\n            this._quaternion.w = (this._cosYaw * this._cosPitch * this._cosRoll) + (this._sinYaw * this._sinPitch * this._sinRoll);\n        };\n        SolidParticleSystem.prototype._quaternionToRotationMatrix = function () {\n            this._rotMatrix.m[0] = 1.0 - (2.0 * (this._quaternion.y * this._quaternion.y + this._quaternion.z * this._quaternion.z));\n            this._rotMatrix.m[1] = 2.0 * (this._quaternion.x * this._quaternion.y + this._quaternion.z * this._quaternion.w);\n            this._rotMatrix.m[2] = 2.0 * (this._quaternion.z * this._quaternion.x - this._quaternion.y * this._quaternion.w);\n            this._rotMatrix.m[3] = 0;\n            this._rotMatrix.m[4] = 2.0 * (this._quaternion.x * this._quaternion.y - this._quaternion.z * this._quaternion.w);\n            this._rotMatrix.m[5] = 1.0 - (2.0 * (this._quaternion.z * this._quaternion.z + this._quaternion.x * this._quaternion.x));\n            this._rotMatrix.m[6] = 2.0 * (this._quaternion.y * this._quaternion.z + this._quaternion.x * this._quaternion.w);\n            this._rotMatrix.m[7] = 0;\n            this._rotMatrix.m[8] = 2.0 * (this._quaternion.z * this._quaternion.x + this._quaternion.y * this._quaternion.w);\n            this._rotMatrix.m[9] = 2.0 * (this._quaternion.y * this._quaternion.z - this._quaternion.x * this._quaternion.w);\n            this._rotMatrix.m[10] = 1.0 - (2.0 * (this._quaternion.y * this._quaternion.y + this._quaternion.x * this._quaternion.x));\n            this._rotMatrix.m[11] = 0;\n            this._rotMatrix.m[12] = 0;\n            this._rotMatrix.m[13] = 0;\n            this._rotMatrix.m[14] = 0;\n            this._rotMatrix.m[15] = 1.0;\n        };\n        /**\n        * Disposes the SPS.\n        * Returns nothing.\n        */\n        SolidParticleSystem.prototype.dispose = function () {\n            this.mesh.dispose();\n            this.vars = null;\n            // drop references to internal big arrays for the GC\n            this._positions = null;\n            this._indices = null;\n            this._normals = null;\n            this._uvs = null;\n            this._colors = null;\n            this._positions32 = null;\n            this._normals32 = null;\n            this._fixedNormal32 = null;\n            this._uvs32 = null;\n            this._colors32 = null;\n            this.pickedParticles = null;\n        };\n        /**\n        * Visibilty helper : Recomputes the visible size according to the mesh bounding box\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\n        * Returns the SPS.\n        */\n        SolidParticleSystem.prototype.refreshVisibleSize = function () {\n            if (!this._isVisibilityBoxLocked) {\n                this.mesh.refreshBoundingInfo();\n            }\n            return this;\n        };\n        /**\n        * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n        * @param size the size (float) of the visibility box\n        * note : this doesn't lock the SPS mesh bounding box.\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\n        */\n        SolidParticleSystem.prototype.setVisibilityBox = function (size) {\n            var vis = size / 2;\n            this.mesh._boundingInfo = new BABYLON.BoundingInfo(new BABYLON.Vector3(-vis, -vis, -vis), new BABYLON.Vector3(vis, vis, vis));\n        };\n        Object.defineProperty(SolidParticleSystem.prototype, \"isAlwaysVisible\", {\n            // getter and setter\n            get: function () {\n                return this._alwaysVisible;\n            },\n            /**\n            * Sets the SPS as always visible or not\n            * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\n            */\n            set: function (val) {\n                this._alwaysVisible = val;\n                this.mesh.alwaysSelectAsActiveMesh = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"isVisibilityBoxLocked\", {\n            get: function () {\n                return this._isVisibilityBoxLocked;\n            },\n            /**\n            * Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.\n            * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility\n            */\n            set: function (val) {\n                this._isVisibilityBoxLocked = val;\n                this.mesh.getBoundingInfo().isLocked = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleRotation\", {\n            // getters\n            get: function () {\n                return this._computeParticleRotation;\n            },\n            // Optimizer setters\n            /**\n            * Tells to `setParticles()` to compute the particle rotations or not.\n            * Default value : true. The SPS is faster when it's set to false.\n            * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.\n            */\n            set: function (val) {\n                this._computeParticleRotation = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleColor\", {\n            get: function () {\n                return this._computeParticleColor;\n            },\n            /**\n            * Tells to `setParticles()` to compute the particle colors or not.\n            * Default value : true. The SPS is faster when it's set to false.\n            * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n            */\n            set: function (val) {\n                this._computeParticleColor = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleTexture\", {\n            get: function () {\n                return this._computeParticleTexture;\n            },\n            /**\n            * Tells to `setParticles()` to compute the particle textures or not.\n            * Default value : true. The SPS is faster when it's set to false.\n            * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n            */\n            set: function (val) {\n                this._computeParticleTexture = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"computeParticleVertex\", {\n            get: function () {\n                return this._computeParticleVertex;\n            },\n            /**\n            * Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.\n            * Default value : false. The SPS is faster when it's set to false.\n            * Note : the particle custom vertex positions aren't stored values.\n            */\n            set: function (val) {\n                this._computeParticleVertex = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SolidParticleSystem.prototype, \"computeBoundingBox\", {\n            get: function () {\n                return this._computeBoundingBox;\n            },\n            /**\n            * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n            */\n            set: function (val) {\n                this._computeBoundingBox = val;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // =======================================================================\n        // Particle behavior logic\n        // these following methods may be overwritten by the user to fit his needs\n        /**\n        * This function does nothing. It may be overwritten to set all the particle first values.\n        * The SPS doesn't call this function, you may have to call it by your own.\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\n        */\n        SolidParticleSystem.prototype.initParticles = function () {\n        };\n        /**\n        * This function does nothing. It may be overwritten to recycle a particle.\n        * The SPS doesn't call this function, you may have to call it by your own.\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\n        */\n        SolidParticleSystem.prototype.recycleParticle = function (particle) {\n            return particle;\n        };\n        /**\n        * Updates a particle : this function should  be overwritten by the user.\n        * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management\n        * ex : just set a particle position or velocity and recycle conditions\n        */\n        SolidParticleSystem.prototype.updateParticle = function (particle) {\n            return particle;\n        };\n        /**\n        * Updates a vertex of a particle : it can be overwritten by the user.\n        * This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.\n        * @param particle the current particle\n        * @param vertex the current index of the current particle\n        * @param pt the index of the current vertex in the particle shape\n        * doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape\n        * ex : just set a vertex particle position\n        */\n        SolidParticleSystem.prototype.updateParticleVertex = function (particle, vertex, pt) {\n            return vertex;\n        };\n        /**\n        * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n        * This does nothing and may be overwritten by the user.\n        * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n        * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n        * @param update the boolean update value actually passed to setParticles()\n        */\n        SolidParticleSystem.prototype.beforeUpdateParticles = function (start, stop, update) {\n        };\n        /**\n        * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n        * This will be passed three parameters.\n        * This does nothing and may be overwritten by the user.\n        * @param start the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n        * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n        * @param update the boolean update value actually passed to setParticles()\n        */\n        SolidParticleSystem.prototype.afterUpdateParticles = function (start, stop, update) {\n        };\n        return SolidParticleSystem;\n    }());\n    BABYLON.SolidParticleSystem = SolidParticleSystem;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.solidParticleSystem.js.map\n\n/// <reference path=\"babylon.mesh.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var GroundMesh = (function (_super) {\n        __extends(GroundMesh, _super);\n        function GroundMesh(name, scene) {\n            var _this = _super.call(this, name, scene) || this;\n            _this.generateOctree = false;\n            _this._worldInverse = new BABYLON.Matrix();\n            return _this;\n        }\n        GroundMesh.prototype.getClassName = function () {\n            return \"GroundMesh\";\n        };\n        Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\n            get: function () {\n                return Math.min(this._subdivisionsX, this._subdivisionsY);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\n            get: function () {\n                return this._subdivisionsX;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\n            get: function () {\n                return this._subdivisionsY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\n            if (octreeBlocksSize === void 0) { octreeBlocksSize = 32; }\n            this._subdivisionsX = chunksCount;\n            this._subdivisionsY = chunksCount;\n            this.subdivide(chunksCount);\n            this.createOrUpdateSubmeshesOctree(octreeBlocksSize);\n        };\n        /**\n         * Returns a height (y) value in the Worl system :\n         * the ground altitude at the coordinates (x, z) expressed in the World system.\n         * Returns the ground y position if (x, z) are outside the ground surface.\n         */\n        GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\n            var world = this.getWorldMatrix();\n            var invMat = BABYLON.Tmp.Matrix[5];\n            world.invertToRef(invMat);\n            var tmpVect = BABYLON.Tmp.Vector3[8];\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\n            x = tmpVect.x;\n            z = tmpVect.z;\n            if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n                return this.position.y;\n            }\n            if (!this._heightQuads || this._heightQuads.length == 0) {\n                this._initHeightQuads();\n                this._computeHeightQuads();\n            }\n            var facet = this._getFacetAt(x, z);\n            var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\n            // return y in the World system\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\n            return tmpVect.y;\n        };\n        /**\n         * Returns a normalized vector (Vector3) orthogonal to the ground\n         * at the ground coordinates (x, z) expressed in the World system.\n         * Returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\n         */\n        GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\n            var normal = new BABYLON.Vector3(0.0, 1.0, 0.0);\n            this.getNormalAtCoordinatesToRef(x, z, normal);\n            return normal;\n        };\n        /**\n         * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\n         * at the ground coordinates (x, z) expressed in the World system.\n         * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\n         * Returns the GroundMesh.\n         */\n        GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\n            var world = this.getWorldMatrix();\n            var tmpMat = BABYLON.Tmp.Matrix[5];\n            world.invertToRef(tmpMat);\n            var tmpVect = BABYLON.Tmp.Vector3[8];\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\n            x = tmpVect.x;\n            z = tmpVect.z;\n            if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\n                return this;\n            }\n            if (!this._heightQuads || this._heightQuads.length == 0) {\n                this._initHeightQuads();\n                this._computeHeightQuads();\n            }\n            var facet = this._getFacetAt(x, z);\n            BABYLON.Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\n            return this;\n        };\n        /**\n        * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\n        * if the ground has been updated.\n        * This can be used in the render loop.\n        * Returns the GroundMesh.\n        */\n        GroundMesh.prototype.updateCoordinateHeights = function () {\n            if (!this._heightQuads || this._heightQuads.length == 0) {\n                this._initHeightQuads();\n            }\n            this._computeHeightQuads();\n            return this;\n        };\n        // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\n        GroundMesh.prototype._getFacetAt = function (x, z) {\n            // retrieve col and row from x, z coordinates in the ground local system\n            var subdivisionsX = this._subdivisionsX;\n            var subdivisionsY = this._subdivisionsY;\n            var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\n            var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\n            var quad = this._heightQuads[row * this._subdivisionsX + col];\n            var facet;\n            if (z < quad.slope.x * x + quad.slope.y) {\n                facet = quad.facet1;\n            }\n            else {\n                facet = quad.facet2;\n            }\n            return facet;\n        };\n        //  Creates and populates the heightMap array with \"facet\" elements :\n        // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\n        // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n        // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n        // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0  \n        // Returns the GroundMesh.  \n        GroundMesh.prototype._initHeightQuads = function () {\n            var subdivisionsX = this._subdivisionsX;\n            var subdivisionsY = this._subdivisionsY;\n            this._heightQuads = new Array();\n            for (var row = 0; row < subdivisionsY; row++) {\n                for (var col = 0; col < subdivisionsX; col++) {\n                    var quad = { slope: BABYLON.Vector2.Zero(), facet1: new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0), facet2: new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0) };\n                    this._heightQuads[row * subdivisionsX + col] = quad;\n                }\n            }\n            return this;\n        };\n        // Compute each quad element values and update the the heightMap array :\n        // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\n        // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\n        // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0  \n        // Returns the GroundMesh.  \n        GroundMesh.prototype._computeHeightQuads = function () {\n            var positions = this.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var v1 = BABYLON.Tmp.Vector3[3];\n            var v2 = BABYLON.Tmp.Vector3[2];\n            var v3 = BABYLON.Tmp.Vector3[1];\n            var v4 = BABYLON.Tmp.Vector3[0];\n            var v1v2 = BABYLON.Tmp.Vector3[4];\n            var v1v3 = BABYLON.Tmp.Vector3[5];\n            var v1v4 = BABYLON.Tmp.Vector3[6];\n            var norm1 = BABYLON.Tmp.Vector3[7];\n            var norm2 = BABYLON.Tmp.Vector3[8];\n            var i = 0;\n            var j = 0;\n            var k = 0;\n            var cd = 0; // 2D slope coefficient : z = cd * x + h\n            var h = 0;\n            var d1 = 0; // facet plane equation : ax + by + cz + d = 0\n            var d2 = 0;\n            var subdivisionsX = this._subdivisionsX;\n            var subdivisionsY = this._subdivisionsY;\n            for (var row = 0; row < subdivisionsY; row++) {\n                for (var col = 0; col < subdivisionsX; col++) {\n                    i = col * 3;\n                    j = row * (subdivisionsX + 1) * 3;\n                    k = (row + 1) * (subdivisionsX + 1) * 3;\n                    v1.x = positions[j + i];\n                    v1.y = positions[j + i + 1];\n                    v1.z = positions[j + i + 2];\n                    v2.x = positions[j + i + 3];\n                    v2.y = positions[j + i + 4];\n                    v2.z = positions[j + i + 5];\n                    v3.x = positions[k + i];\n                    v3.y = positions[k + i + 1];\n                    v3.z = positions[k + i + 2];\n                    v4.x = positions[k + i + 3];\n                    v4.y = positions[k + i + 4];\n                    v4.z = positions[k + i + 5];\n                    // 2D slope V1V4\n                    cd = (v4.z - v1.z) / (v4.x - v1.x);\n                    h = v1.z - cd * v1.x; // v1 belongs to the slope\n                    // facet equations :\n                    // we compute each facet normal vector\n                    // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\n                    // we compute the value d by applying the equation to v1 which belongs to the plane\n                    // then we store the facet equation in a Vector4\n                    v2.subtractToRef(v1, v1v2);\n                    v3.subtractToRef(v1, v1v3);\n                    v4.subtractToRef(v1, v1v4);\n                    BABYLON.Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\n                    BABYLON.Vector3.CrossToRef(v1v2, v1v4, norm2);\n                    norm1.normalize();\n                    norm2.normalize();\n                    d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\n                    d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\n                    var quad = this._heightQuads[row * subdivisionsX + col];\n                    quad.slope.copyFromFloats(cd, h);\n                    quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\n                    quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\n                }\n            }\n            return this;\n        };\n        GroundMesh.prototype.serialize = function (serializationObject) {\n            _super.prototype.serialize.call(this, serializationObject);\n            serializationObject.subdivisionsX = this._subdivisionsX;\n            serializationObject.subdivisionsY = this._subdivisionsY;\n            serializationObject.minX = this._minX;\n            serializationObject.maxX = this._maxX;\n            serializationObject.minZ = this._minZ;\n            serializationObject.maxZ = this._maxZ;\n            serializationObject.width = this._width;\n            serializationObject.height = this._height;\n        };\n        GroundMesh.Parse = function (parsedMesh, scene) {\n            var result = new GroundMesh(parsedMesh.name, scene);\n            result._subdivisionsX = parsedMesh.subdivisionsX || 1;\n            result._subdivisionsY = parsedMesh.subdivisionsY || 1;\n            result._minX = parsedMesh.minX;\n            result._maxX = parsedMesh.maxX;\n            result._minZ = parsedMesh.minZ;\n            result._maxZ = parsedMesh.maxZ;\n            result._width = parsedMesh.width;\n            result._height = parsedMesh.height;\n            return result;\n        };\n        return GroundMesh;\n    }(BABYLON.Mesh));\n    BABYLON.GroundMesh = GroundMesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.groundMesh.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * Creates an instance based on a source mesh.\n     */\n    var InstancedMesh = (function (_super) {\n        __extends(InstancedMesh, _super);\n        function InstancedMesh(name, source) {\n            var _this = _super.call(this, name, source.getScene()) || this;\n            source.instances.push(_this);\n            _this._sourceMesh = source;\n            _this.position.copyFrom(source.position);\n            _this.rotation.copyFrom(source.rotation);\n            _this.scaling.copyFrom(source.scaling);\n            if (source.rotationQuaternion) {\n                _this.rotationQuaternion = source.rotationQuaternion.clone();\n            }\n            _this.infiniteDistance = source.infiniteDistance;\n            _this.setPivotMatrix(source.getPivotMatrix());\n            _this.refreshBoundingInfo();\n            _this._syncSubMeshes();\n            return _this;\n        }\n        /**\n         * Returns the string \"InstancedMesh\".\n         */\n        InstancedMesh.prototype.getClassName = function () {\n            return \"InstancedMesh\";\n        };\n        Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\n            // Methods\n            get: function () {\n                return this._sourceMesh.receiveShadows;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstancedMesh.prototype, \"material\", {\n            get: function () {\n                return this._sourceMesh.material;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\n            get: function () {\n                return this._sourceMesh.visibility;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\n            get: function () {\n                return this._sourceMesh.skeleton;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\n            get: function () {\n                return this._sourceMesh.renderingGroupId;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the total number of vertices (integer).\n         */\n        InstancedMesh.prototype.getTotalVertices = function () {\n            return this._sourceMesh.getTotalVertices();\n        };\n        Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\n            get: function () {\n                return this._sourceMesh;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\n         */\n        InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\n            return this._sourceMesh.getVerticesData(kind, copyWhenShared);\n        };\n        /**\n         * Sets the vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\n         * The `data` are either a numeric array either a Float32Array.\n         * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\n         * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\n         * Note that a new underlying VertexBuffer object is created each call.\n         * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\n            if (this.sourceMesh) {\n                this.sourceMesh.setVerticesData(kind, data, updatable, stride);\n            }\n            return this.sourceMesh;\n        };\n        /**\n         * Updates the existing vertex data of the mesh geometry for the requested `kind`.\n         * If the mesh has no geometry, it is simply returned as it is.\n         * The `data` are either a numeric array either a Float32Array.\n         * No new underlying VertexBuffer object is created.\n         * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\n         * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\n         *\n         * Possible `kind` values :\n         * - BABYLON.VertexBuffer.PositionKind\n         * - BABYLON.VertexBuffer.UVKind\n         * - BABYLON.VertexBuffer.UV2Kind\n         * - BABYLON.VertexBuffer.UV3Kind\n         * - BABYLON.VertexBuffer.UV4Kind\n         * - BABYLON.VertexBuffer.UV5Kind\n         * - BABYLON.VertexBuffer.UV6Kind\n         * - BABYLON.VertexBuffer.ColorKind\n         * - BABYLON.VertexBuffer.MatricesIndicesKind\n         * - BABYLON.VertexBuffer.MatricesIndicesExtraKind\n         * - BABYLON.VertexBuffer.MatricesWeightsKind\n         * - BABYLON.VertexBuffer.MatricesWeightsExtraKind\n         *\n         * Returns the Mesh.\n         */\n        InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\n            if (this.sourceMesh) {\n                this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\n            }\n            return this.sourceMesh;\n        };\n        /**\n         * Sets the mesh indices.\n         * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\n         * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\n         * This method creates a new index buffer each call.\n         * Returns the Mesh.\n         */\n        InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\n            if (this.sourceMesh) {\n                this.sourceMesh.setIndices(indices, totalVertices);\n            }\n            return this.sourceMesh;\n        };\n        /**\n         * Boolean : True if the mesh owns the requested kind of data.\n         */\n        InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\n            return this._sourceMesh.isVerticesDataPresent(kind);\n        };\n        /**\n         * Returns an array of indices (IndicesArray).\n         */\n        InstancedMesh.prototype.getIndices = function () {\n            return this._sourceMesh.getIndices();\n        };\n        Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\n            get: function () {\n                return this._sourceMesh._positions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Sets a new updated BoundingInfo to the mesh.\n         * Returns the mesh.\n         */\n        InstancedMesh.prototype.refreshBoundingInfo = function () {\n            var meshBB = this._sourceMesh.getBoundingInfo();\n            this._boundingInfo = new BABYLON.BoundingInfo(meshBB.minimum.clone(), meshBB.maximum.clone());\n            this._updateBoundingInfo();\n            return this;\n        };\n        InstancedMesh.prototype._preActivate = function () {\n            if (this._currentLOD) {\n                this._currentLOD._preActivate();\n            }\n            return this;\n        };\n        InstancedMesh.prototype._activate = function (renderId) {\n            if (this._currentLOD) {\n                this._currentLOD._registerInstanceForRenderId(this, renderId);\n            }\n            return this;\n        };\n        /**\n         * Returns the current associated LOD AbstractMesh.\n         */\n        InstancedMesh.prototype.getLOD = function (camera) {\n            this._currentLOD = this.sourceMesh.getLOD(this.getScene().activeCamera, this.getBoundingInfo().boundingSphere);\n            if (this._currentLOD === this.sourceMesh) {\n                return this;\n            }\n            return this._currentLOD;\n        };\n        InstancedMesh.prototype._syncSubMeshes = function () {\n            this.releaseSubMeshes();\n            if (this._sourceMesh.subMeshes) {\n                for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\n                    this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\n                }\n            }\n            return this;\n        };\n        InstancedMesh.prototype._generatePointsArray = function () {\n            return this._sourceMesh._generatePointsArray();\n        };\n        /**\n         * Creates a new InstancedMesh from the current mesh.\n         * - name (string) : the cloned mesh name\n         * - newParent (optional Node) : the optional Node to parent the clone to.\n         * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\n         *\n         * Returns the clone.\n         */\n        InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n            var result = this._sourceMesh.createInstance(name);\n            // Deep copy\n            BABYLON.Tools.DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\"], []);\n            // Bounding info\n            this.refreshBoundingInfo();\n            // Parent\n            if (newParent) {\n                result.parent = newParent;\n            }\n            if (!doNotCloneChildren) {\n                // Children\n                for (var index = 0; index < this.getScene().meshes.length; index++) {\n                    var mesh = this.getScene().meshes[index];\n                    if (mesh.parent === this) {\n                        mesh.clone(mesh.name, result);\n                    }\n                }\n            }\n            result.computeWorldMatrix(true);\n            return result;\n        };\n        /**\n         * Disposes the InstancedMesh.\n         * Returns nothing.\n         */\n        InstancedMesh.prototype.dispose = function (doNotRecurse) {\n            // Remove from mesh\n            var index = this._sourceMesh.instances.indexOf(this);\n            this._sourceMesh.instances.splice(index, 1);\n            _super.prototype.dispose.call(this, doNotRecurse);\n        };\n        return InstancedMesh;\n    }(BABYLON.AbstractMesh));\n    BABYLON.InstancedMesh = InstancedMesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.instancedMesh.js.map\n\n/// <reference path=\"babylon.mesh.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var LinesMesh = (function (_super) {\n        __extends(LinesMesh, _super);\n        function LinesMesh(name, scene, parent, source, doNotCloneChildren, useVertexColor) {\n            if (parent === void 0) { parent = null; }\n            var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\n            _this.useVertexColor = useVertexColor;\n            _this.color = new BABYLON.Color3(1, 1, 1);\n            _this.alpha = 1;\n            if (source) {\n                _this.color = source.color.clone();\n                _this.alpha = source.alpha;\n                _this.useVertexColor = source.useVertexColor;\n            }\n            _this._intersectionThreshold = 0.1;\n            var options = {\n                attributes: [BABYLON.VertexBuffer.PositionKind],\n                uniforms: [\"world\", \"viewProjection\"],\n                needAlphaBlending: false,\n            };\n            if (!useVertexColor) {\n                options.uniforms.push(\"color\");\n                options.needAlphaBlending = true;\n            }\n            _this._colorShader = new BABYLON.ShaderMaterial(\"colorShader\", scene, \"color\", options);\n            return _this;\n        }\n        Object.defineProperty(LinesMesh.prototype, \"intersectionThreshold\", {\n            /**\n             * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\n             * This margin is expressed in world space coordinates, so its value may vary.\n             * Default value is 0.1\n             * @returns the intersection Threshold value.\n             */\n            get: function () {\n                return this._intersectionThreshold;\n            },\n            /**\n             * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\n             * This margin is expressed in world space coordinates, so its value may vary.\n             * @param value the new threshold to apply\n             */\n            set: function (value) {\n                if (this._intersectionThreshold === value) {\n                    return;\n                }\n                this._intersectionThreshold = value;\n                if (this.geometry) {\n                    this.geometry.boundingBias = new BABYLON.Vector2(0, value);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the string \"LineMesh\"\n         */\n        LinesMesh.prototype.getClassName = function () {\n            return \"LinesMesh\";\n        };\n        Object.defineProperty(LinesMesh.prototype, \"material\", {\n            get: function () {\n                return this._colorShader;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinesMesh.prototype.createInstance = function (name) {\n            BABYLON.Tools.Log(\"LinesMeshes do not support createInstance.\");\n            return null;\n        };\n        LinesMesh.prototype._bind = function (subMesh, effect, fillMode) {\n            // VBOs\n            this._geometry._bind(this._colorShader.getEffect());\n            // Color\n            if (!this.useVertexColor) {\n                this._colorShader.setColor4(\"color\", this.color.toColor4(this.alpha));\n            }\n            return this;\n        };\n        LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\n            if (!this._geometry || !this._geometry.getVertexBuffers() || !this._geometry.getIndexBuffer()) {\n                return this;\n            }\n            var engine = this.getScene().getEngine();\n            // Draw order\n            engine.draw(false, subMesh.indexStart, subMesh.indexCount);\n            return this;\n        };\n        LinesMesh.prototype.dispose = function (doNotRecurse) {\n            this._colorShader.dispose();\n            _super.prototype.dispose.call(this, doNotRecurse);\n        };\n        /**\n         * Returns a new LineMesh object cloned from the current one.\n         */\n        LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\n            return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\n        };\n        return LinesMesh;\n    }(BABYLON.Mesh));\n    BABYLON.LinesMesh = LinesMesh;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.linesMesh.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ShaderMaterial = (function (_super) {\n        __extends(ShaderMaterial, _super);\n        function ShaderMaterial(name, scene, shaderPath, options) {\n            var _this = _super.call(this, name, scene) || this;\n            _this._textures = {};\n            _this._textureArrays = {};\n            _this._floats = {};\n            _this._floatsArrays = {};\n            _this._colors3 = {};\n            _this._colors4 = {};\n            _this._vectors2 = {};\n            _this._vectors3 = {};\n            _this._vectors4 = {};\n            _this._matrices = {};\n            _this._matrices3x3 = {};\n            _this._matrices2x2 = {};\n            _this._vectors3Arrays = {};\n            _this._cachedWorldViewMatrix = new BABYLON.Matrix();\n            _this._shaderPath = shaderPath;\n            options.needAlphaBlending = options.needAlphaBlending || false;\n            options.needAlphaTesting = options.needAlphaTesting || false;\n            options.attributes = options.attributes || [\"position\", \"normal\", \"uv\"];\n            options.uniforms = options.uniforms || [\"worldViewProjection\"];\n            options.uniformBuffers = options.uniformBuffers || [];\n            options.samplers = options.samplers || [];\n            options.defines = options.defines || [];\n            _this._options = options;\n            return _this;\n        }\n        ShaderMaterial.prototype.getClassName = function () {\n            return \"ShaderMaterial\";\n        };\n        ShaderMaterial.prototype.needAlphaBlending = function () {\n            return this._options.needAlphaBlending;\n        };\n        ShaderMaterial.prototype.needAlphaTesting = function () {\n            return this._options.needAlphaTesting;\n        };\n        ShaderMaterial.prototype._checkUniform = function (uniformName) {\n            if (this._options.uniforms.indexOf(uniformName) === -1) {\n                this._options.uniforms.push(uniformName);\n            }\n        };\n        ShaderMaterial.prototype.setTexture = function (name, texture) {\n            if (this._options.samplers.indexOf(name) === -1) {\n                this._options.samplers.push(name);\n            }\n            this._textures[name] = texture;\n            return this;\n        };\n        ShaderMaterial.prototype.setTextureArray = function (name, textures) {\n            if (this._options.samplers.indexOf(name) === -1) {\n                this._options.samplers.push(name);\n            }\n            this._checkUniform(name);\n            this._textureArrays[name] = textures;\n            return this;\n        };\n        ShaderMaterial.prototype.setFloat = function (name, value) {\n            this._checkUniform(name);\n            this._floats[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setFloats = function (name, value) {\n            this._checkUniform(name);\n            this._floatsArrays[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setColor3 = function (name, value) {\n            this._checkUniform(name);\n            this._colors3[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setColor4 = function (name, value) {\n            this._checkUniform(name);\n            this._colors4[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setVector2 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors2[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setVector3 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors3[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setVector4 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors4[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setMatrix = function (name, value) {\n            this._checkUniform(name);\n            this._matrices[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setMatrix3x3 = function (name, value) {\n            this._checkUniform(name);\n            this._matrices3x3[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setMatrix2x2 = function (name, value) {\n            this._checkUniform(name);\n            this._matrices2x2[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype.setArray3 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors3Arrays[name] = value;\n            return this;\n        };\n        ShaderMaterial.prototype._checkCache = function (scene, mesh, useInstances) {\n            if (!mesh) {\n                return true;\n            }\n            if (this._effect && (this._effect.defines.indexOf(\"#define INSTANCES\") !== -1) !== useInstances) {\n                return false;\n            }\n            return false;\n        };\n        ShaderMaterial.prototype.isReady = function (mesh, useInstances) {\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            if (!this.checkReadyOnEveryCall) {\n                if (this._renderId === scene.getRenderId()) {\n                    if (this._checkCache(scene, mesh, useInstances)) {\n                        return true;\n                    }\n                }\n            }\n            // Instances\n            var defines = [];\n            var attribs = [];\n            var fallbacks = new BABYLON.EffectFallbacks();\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n            }\n            for (var index = 0; index < this._options.defines.length; index++) {\n                defines.push(this._options.defines[index]);\n            }\n            for (var index = 0; index < this._options.attributes.length; index++) {\n                attribs.push(this._options.attributes[index]);\n            }\n            if (mesh && mesh.isVerticesDataPresent(BABYLON.VertexBuffer.ColorKind)) {\n                attribs.push(BABYLON.VertexBuffer.ColorKind);\n                defines.push(\"#define VERTEXCOLOR\");\n            }\n            // Bones\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n                fallbacks.addCPUSkinningFallback(0, mesh);\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\n                    this._options.uniforms.push(\"mBones\");\n                }\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Textures\n            for (var name in this._textures) {\n                if (!this._textures[name].isReady()) {\n                    return false;\n                }\n            }\n            // Alpha test\n            if (engine.getAlphaTesting()) {\n                defines.push(\"#define ALPHATEST\");\n            }\n            var previousEffect = this._effect;\n            var join = defines.join(\"\\n\");\n            this._effect = engine.createEffect(this._shaderPath, {\n                attributes: attribs,\n                uniformsNames: this._options.uniforms,\n                uniformBuffersNames: this._options.uniformBuffers,\n                samplers: this._options.samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError\n            }, engine);\n            if (!this._effect.isReady()) {\n                return false;\n            }\n            if (previousEffect !== this._effect) {\n                scene.resetCachedMaterial();\n            }\n            this._renderId = scene.getRenderId();\n            return true;\n        };\n        ShaderMaterial.prototype.bindOnlyWorldMatrix = function (world) {\n            var scene = this.getScene();\n            if (this._options.uniforms.indexOf(\"world\") !== -1) {\n                this._effect.setMatrix(\"world\", world);\n            }\n            if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\n                world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n                this._effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n            }\n            if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\n                this._effect.setMatrix(\"worldViewProjection\", world.multiply(scene.getTransformMatrix()));\n            }\n        };\n        ShaderMaterial.prototype.bind = function (world, mesh) {\n            // Std values\n            this.bindOnlyWorldMatrix(world);\n            if (this.getScene().getCachedMaterial() !== this) {\n                if (this._options.uniforms.indexOf(\"view\") !== -1) {\n                    this._effect.setMatrix(\"view\", this.getScene().getViewMatrix());\n                }\n                if (this._options.uniforms.indexOf(\"projection\") !== -1) {\n                    this._effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\n                }\n                if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n                    this._effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\n                }\n                // Bones\n                BABYLON.MaterialHelper.BindBonesParameters(mesh, this._effect);\n                var name;\n                // Texture\n                for (name in this._textures) {\n                    this._effect.setTexture(name, this._textures[name]);\n                }\n                // Texture arrays\n                for (name in this._textureArrays) {\n                    this._effect.setTextureArray(name, this._textureArrays[name]);\n                }\n                // Float    \n                for (name in this._floats) {\n                    this._effect.setFloat(name, this._floats[name]);\n                }\n                // Float s   \n                for (name in this._floatsArrays) {\n                    this._effect.setArray(name, this._floatsArrays[name]);\n                }\n                // Color3        \n                for (name in this._colors3) {\n                    this._effect.setColor3(name, this._colors3[name]);\n                }\n                // Color4      \n                for (name in this._colors4) {\n                    var color = this._colors4[name];\n                    this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\n                }\n                // Vector2        \n                for (name in this._vectors2) {\n                    this._effect.setVector2(name, this._vectors2[name]);\n                }\n                // Vector3        \n                for (name in this._vectors3) {\n                    this._effect.setVector3(name, this._vectors3[name]);\n                }\n                // Vector4        \n                for (name in this._vectors4) {\n                    this._effect.setVector4(name, this._vectors4[name]);\n                }\n                // Matrix      \n                for (name in this._matrices) {\n                    this._effect.setMatrix(name, this._matrices[name]);\n                }\n                // Matrix 3x3\n                for (name in this._matrices3x3) {\n                    this._effect.setMatrix3x3(name, this._matrices3x3[name]);\n                }\n                // Matrix 2x2\n                for (name in this._matrices2x2) {\n                    this._effect.setMatrix2x2(name, this._matrices2x2[name]);\n                }\n                // Vector3Array   \n                for (name in this._vectors3Arrays) {\n                    this._effect.setArray3(name, this._vectors3Arrays[name]);\n                }\n            }\n            this._afterBind(mesh);\n        };\n        ShaderMaterial.prototype.getActiveTextures = function () {\n            var activeTextures = _super.prototype.getActiveTextures.call(this);\n            for (var name in this._textures) {\n                activeTextures.push(this._textures[name]);\n            }\n            for (var name in this._textureArrays) {\n                var array = this._textureArrays[name];\n                for (var index = 0; index < array.length; index++) {\n                    activeTextures.push(array[index]);\n                }\n            }\n            return activeTextures;\n        };\n        ShaderMaterial.prototype.hasTexture = function (texture) {\n            if (_super.prototype.hasTexture.call(this, texture)) {\n                return true;\n            }\n            for (var name in this._textures) {\n                if (this._textures[name] === texture) {\n                    return true;\n                }\n            }\n            for (var name in this._textureArrays) {\n                var array = this._textureArrays[name];\n                for (var index = 0; index < array.length; index++) {\n                    if (array[index] === texture) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        ShaderMaterial.prototype.clone = function (name) {\n            var newShaderMaterial = new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options);\n            return newShaderMaterial;\n        };\n        ShaderMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures) {\n            if (forceDisposeTextures) {\n                var name;\n                for (name in this._textures) {\n                    this._textures[name].dispose();\n                }\n                for (name in this._textureArrays) {\n                    var array = this._textureArrays[name];\n                    for (var index = 0; index < array.length; index++) {\n                        array[index].dispose();\n                    }\n                }\n            }\n            this._textures = {};\n            _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);\n        };\n        ShaderMaterial.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"BABYLON.ShaderMaterial\";\n            serializationObject.options = this._options;\n            serializationObject.shaderPath = this._shaderPath;\n            var name;\n            // Texture\n            serializationObject.textures = {};\n            for (name in this._textures) {\n                serializationObject.textures[name] = this._textures[name].serialize();\n            }\n            // Texture arrays\n            serializationObject.textureArrays = {};\n            for (name in this._textureArrays) {\n                serializationObject.textureArrays[name] = [];\n                var array = this._textureArrays[name];\n                for (var index = 0; index < array.length; index++) {\n                    serializationObject.textureArrays[name].push(array[index].serialize());\n                }\n            }\n            // Float    \n            serializationObject.floats = {};\n            for (name in this._floats) {\n                serializationObject.floats[name] = this._floats[name];\n            }\n            // Float s   \n            serializationObject.floatArrays = {};\n            for (name in this._floatsArrays) {\n                serializationObject.floatArrays[name] = this._floatsArrays[name];\n            }\n            // Color3    \n            serializationObject.colors3 = {};\n            for (name in this._colors3) {\n                serializationObject.colors3[name] = this._colors3[name].asArray();\n            }\n            // Color4  \n            serializationObject.colors4 = {};\n            for (name in this._colors4) {\n                serializationObject.colors4[name] = this._colors4[name].asArray();\n            }\n            // Vector2  \n            serializationObject.vectors2 = {};\n            for (name in this._vectors2) {\n                serializationObject.vectors2[name] = this._vectors2[name].asArray();\n            }\n            // Vector3        \n            serializationObject.vectors3 = {};\n            for (name in this._vectors3) {\n                serializationObject.vectors3[name] = this._vectors3[name].asArray();\n            }\n            // Vector4        \n            serializationObject.vectors4 = {};\n            for (name in this._vectors4) {\n                serializationObject.vectors4[name] = this._vectors4[name].asArray();\n            }\n            // Matrix      \n            serializationObject.matrices = {};\n            for (name in this._matrices) {\n                serializationObject.matrices[name] = this._matrices[name].asArray();\n            }\n            // Matrix 3x3\n            serializationObject.matrices3x3 = {};\n            for (name in this._matrices3x3) {\n                serializationObject.matrices3x3[name] = this._matrices3x3[name];\n            }\n            // Matrix 2x2\n            serializationObject.matrices2x2 = {};\n            for (name in this._matrices2x2) {\n                serializationObject.matrices2x2[name] = this._matrices2x2[name];\n            }\n            // Vector3Array\n            serializationObject.vectors3Arrays = {};\n            for (name in this._vectors3Arrays) {\n                serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n            }\n            return serializationObject;\n        };\n        ShaderMaterial.Parse = function (source, scene, rootUrl) {\n            var material = BABYLON.SerializationHelper.Parse(function () { return new ShaderMaterial(source.name, scene, source.shaderPath, source.options); }, source, scene, rootUrl);\n            var name;\n            // Texture\n            for (name in source.textures) {\n                material.setTexture(name, BABYLON.Texture.Parse(source.textures[name], scene, rootUrl));\n            }\n            // Texture arrays\n            for (name in source.textureArrays) {\n                var array = source.textureArrays[name];\n                var textureArray = new Array();\n                for (var index = 0; index < array.length; index++) {\n                    textureArray.push(BABYLON.Texture.Parse(array[index], scene, rootUrl));\n                }\n                material.setTextureArray(name, textureArray);\n            }\n            // Float    \n            for (name in source.floats) {\n                material.setFloat(name, source.floats[name]);\n            }\n            // Float s   \n            for (name in source.floatsArrays) {\n                material.setFloats(name, source.floatsArrays[name]);\n            }\n            // Color3        \n            for (name in source.colors3) {\n                material.setColor3(name, BABYLON.Color3.FromArray(source.colors3[name]));\n            }\n            // Color4      \n            for (name in source.colors4) {\n                material.setColor4(name, BABYLON.Color4.FromArray(source.colors4[name]));\n            }\n            // Vector2        \n            for (name in source.vectors2) {\n                material.setVector2(name, BABYLON.Vector2.FromArray(source.vectors2[name]));\n            }\n            // Vector3        \n            for (name in source.vectors3) {\n                material.setVector3(name, BABYLON.Vector3.FromArray(source.vectors3[name]));\n            }\n            // Vector4        \n            for (name in source.vectors4) {\n                material.setVector4(name, BABYLON.Vector4.FromArray(source.vectors4[name]));\n            }\n            // Matrix      \n            for (name in source.matrices) {\n                material.setMatrix(name, BABYLON.Matrix.FromArray(source.matrices[name]));\n            }\n            // Matrix 3x3\n            for (name in source.matrices3x3) {\n                material.setMatrix3x3(name, source.matrices3x3[name]);\n            }\n            // Matrix 2x2\n            for (name in source.matrices2x2) {\n                material.setMatrix2x2(name, source.matrices2x2[name]);\n            }\n            // Vector3Array\n            for (name in source.vectors3Arrays) {\n                material.setArray3(name, source.vectors3Arrays[name]);\n            }\n            return material;\n        };\n        return ShaderMaterial;\n    }(BABYLON.Material));\n    BABYLON.ShaderMaterial = ShaderMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.shaderMaterial.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var MeshBuilder = (function () {\n        function MeshBuilder() {\n        }\n        MeshBuilder.updateSideOrientation = function (orientation, scene) {\n            if (orientation == BABYLON.Mesh.DOUBLESIDE) {\n                return BABYLON.Mesh.DOUBLESIDE;\n            }\n            if (orientation === undefined || orientation === null) {\n                return BABYLON.Mesh.FRONTSIDE;\n            }\n            return orientation;\n        };\n        /**\n         * Creates a box mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#box\n         * The parameter `size` sets the size (float) of each box side (default 1).\n         * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value than `size`).\n         * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements).\n         * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateBox = function (name, options, scene) {\n            var box = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            box.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateBox(options);\n            vertexData.applyToMesh(box, options.updatable);\n            return box;\n        };\n        /**\n         * Creates a sphere mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#sphere\n         * The parameter `diameter` sets the diameter size (float) of the sphere (default 1).\n         * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value than `diameter`).\n         * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32).\n         * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\n         * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateSphere = function (name, options, scene) {\n            var sphere = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            sphere.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateSphere(options);\n            vertexData.applyToMesh(sphere, options.updatable);\n            return sphere;\n        };\n        /**\n         * Creates a plane polygonal mesh.  By default, this is a disc.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#disc\n         * The parameter `radius` sets the radius size (float) of the polygon (default 0.5).\n         * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc.\n         * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateDisc = function (name, options, scene) {\n            var disc = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            disc.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateDisc(options);\n            vertexData.applyToMesh(disc, options.updatable);\n            return disc;\n        };\n        /**\n         * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#icosphere\n         * The parameter `radius` sets the radius size (float) of the icosphere (default 1).\n         * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`).\n         * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size.\n         * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateIcoSphere = function (name, options, scene) {\n            var sphere = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            sphere.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateIcoSphere(options);\n            vertexData.applyToMesh(sphere, options.updatable);\n            return sphere;\n        };\n        ;\n        /**\n         * Creates a ribbon mesh.\n         * The ribbon is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         *\n         * Please read this full tutorial to understand how to design a ribbon : http://doc.babylonjs.com/tutorials/Ribbon_Tutorial\n         * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.\n         * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array.\n         * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array.\n         * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path.\n         * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11.\n         * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n         * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones.\n         * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values.\n         * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that\n         * if you set `closePath` to `true`, there's one extra vertex per path in the geometry.\n         * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateRibbon = function (name, options, scene) {\n            var pathArray = options.pathArray;\n            var closeArray = options.closeArray;\n            var closePath = options.closePath;\n            var offset = options.offset;\n            var sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var instance = options.instance;\n            var updatable = options.updatable;\n            if (instance) {\n                // positionFunction : ribbon case\n                // only pathArray and sideOrientation parameters are taken into account for positions update\n                BABYLON.Vector3.FromFloatsToRef(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, BABYLON.Tmp.Vector3[0]); // minimum\n                BABYLON.Vector3.FromFloatsToRef(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, BABYLON.Tmp.Vector3[1]);\n                var positionFunction = function (positions) {\n                    var minlg = pathArray[0].length;\n                    var i = 0;\n                    var ns = (instance.sideOrientation === BABYLON.Mesh.DOUBLESIDE) ? 2 : 1;\n                    for (var si = 1; si <= ns; si++) {\n                        for (var p = 0; p < pathArray.length; p++) {\n                            var path = pathArray[p];\n                            var l = path.length;\n                            minlg = (minlg < l) ? minlg : l;\n                            var j = 0;\n                            while (j < minlg) {\n                                positions[i] = path[j].x;\n                                positions[i + 1] = path[j].y;\n                                positions[i + 2] = path[j].z;\n                                if (path[j].x < BABYLON.Tmp.Vector3[0].x) {\n                                    BABYLON.Tmp.Vector3[0].x = path[j].x;\n                                }\n                                if (path[j].x > BABYLON.Tmp.Vector3[1].x) {\n                                    BABYLON.Tmp.Vector3[1].x = path[j].x;\n                                }\n                                if (path[j].y < BABYLON.Tmp.Vector3[0].y) {\n                                    BABYLON.Tmp.Vector3[0].y = path[j].y;\n                                }\n                                if (path[j].y > BABYLON.Tmp.Vector3[1].y) {\n                                    BABYLON.Tmp.Vector3[1].y = path[j].y;\n                                }\n                                if (path[j].z < BABYLON.Tmp.Vector3[0].z) {\n                                    BABYLON.Tmp.Vector3[0].z = path[j].z;\n                                }\n                                if (path[j].z > BABYLON.Tmp.Vector3[1].z) {\n                                    BABYLON.Tmp.Vector3[1].z = path[j].z;\n                                }\n                                j++;\n                                i += 3;\n                            }\n                            if (instance._closePath) {\n                                positions[i] = path[0].x;\n                                positions[i + 1] = path[0].y;\n                                positions[i + 2] = path[0].z;\n                                i += 3;\n                            }\n                        }\n                    }\n                };\n                var positions = instance.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n                positionFunction(positions);\n                instance._boundingInfo = new BABYLON.BoundingInfo(BABYLON.Tmp.Vector3[0], BABYLON.Tmp.Vector3[1]);\n                instance._boundingInfo.update(instance._worldMatrix);\n                instance.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions, false, false);\n                if (options.colors) {\n                    var colors = instance.getVerticesData(BABYLON.VertexBuffer.ColorKind);\n                    for (var c = 0; c < options.colors.length; c++) {\n                        colors[c * 4] = options.colors[c].r;\n                        colors[c * 4 + 1] = options.colors[c].g;\n                        colors[c * 4 + 2] = options.colors[c].b;\n                        colors[c * 4 + 3] = options.colors[c].a;\n                    }\n                    instance.updateVerticesData(BABYLON.VertexBuffer.ColorKind, colors, false, false);\n                }\n                if (options.uvs) {\n                    var uvs = instance.getVerticesData(BABYLON.VertexBuffer.UVKind);\n                    for (var i = 0; i < options.uvs.length; i++) {\n                        uvs[i * 2] = options.uvs[i].x;\n                        uvs[i * 2 + 1] = options.uvs[i].y;\n                    }\n                    instance.updateVerticesData(BABYLON.VertexBuffer.UVKind, uvs, false, false);\n                }\n                if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\n                    var indices = instance.getIndices();\n                    var normals = instance.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n                    var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\n                    BABYLON.VertexData.ComputeNormals(positions, indices, normals, params);\n                    if (instance._closePath) {\n                        var indexFirst = 0;\n                        var indexLast = 0;\n                        for (var p = 0; p < pathArray.length; p++) {\n                            indexFirst = instance._idx[p] * 3;\n                            if (p + 1 < pathArray.length) {\n                                indexLast = (instance._idx[p + 1] - 1) * 3;\n                            }\n                            else {\n                                indexLast = normals.length - 3;\n                            }\n                            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\n                            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\n                            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\n                            normals[indexLast] = normals[indexFirst];\n                            normals[indexLast + 1] = normals[indexFirst + 1];\n                            normals[indexLast + 2] = normals[indexFirst + 2];\n                        }\n                    }\n                    if (!(instance.areNormalsFrozen)) {\n                        instance.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals, false, false);\n                    }\n                }\n                return instance;\n            }\n            else {\n                var ribbon = new BABYLON.Mesh(name, scene);\n                ribbon.sideOrientation = sideOrientation;\n                var vertexData = BABYLON.VertexData.CreateRibbon(options);\n                if (closePath) {\n                    ribbon._idx = vertexData._idx;\n                }\n                ribbon._closePath = closePath;\n                ribbon._closeArray = closeArray;\n                vertexData.applyToMesh(ribbon, updatable);\n                return ribbon;\n            }\n        };\n        /**\n         * Creates a cylinder or a cone mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#cylinder-or-cone\n         * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\n         * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\n         * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\n         * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\n         * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\n         * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\n         * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\n         * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\n         * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\n         * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\n         * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\n         * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\n         * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\n         * If `enclose` is false, a ring surface is one element.\n         * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\n         * Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateCylinder = function (name, options, scene) {\n            var cylinder = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            cylinder.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateCylinder(options);\n            vertexData.applyToMesh(cylinder, options.updatable);\n            return cylinder;\n        };\n        /**\n         * Creates a torus mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus\n         * The parameter `diameter` sets the diameter size (float) of the torus (default 1).\n         * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5).\n         * The parameter `tessellation` sets the number of torus sides (postive integer, default 16).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateTorus = function (name, options, scene) {\n            var torus = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            torus.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateTorus(options);\n            vertexData.applyToMesh(torus, options.updatable);\n            return torus;\n        };\n        /**\n         * Creates a torus knot mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus-knot\n         * The parameter `radius` sets the global radius size (float) of the torus knot (default 2).\n         * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32).\n         * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32).\n         * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3).\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateTorusKnot = function (name, options, scene) {\n            var torusKnot = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            torusKnot.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreateTorusKnot(options);\n            vertexData.applyToMesh(torusKnot, options.updatable);\n            return torusKnot;\n        };\n        /**\n         * Creates a line system mesh.\n         * A line system is a pool of many lines gathered in a single mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#linesystem\n         * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter.\n         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function.\n         * The parameter `lines` is an array of lines, each line being an array of successive Vector3.\n         * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter. The way to update it is the same than for\n         * updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n         * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateLineSystem = function (name, options, scene) {\n            var instance = options.instance;\n            var lines = options.lines;\n            if (instance) {\n                var positionFunction = function (positions) {\n                    var i = 0;\n                    for (var l = 0; l < lines.length; l++) {\n                        var points = lines[l];\n                        for (var p = 0; p < points.length; p++) {\n                            positions[i] = points[p].x;\n                            positions[i + 1] = points[p].y;\n                            positions[i + 2] = points[p].z;\n                            i += 3;\n                        }\n                    }\n                };\n                instance.updateMeshPositions(positionFunction, false);\n                return instance;\n            }\n            // line system creation\n            var lineSystem = new BABYLON.LinesMesh(name, scene);\n            var vertexData = BABYLON.VertexData.CreateLineSystem(options);\n            vertexData.applyToMesh(lineSystem, options.updatable);\n            return lineSystem;\n        };\n        /**\n         * Creates a line mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#lines\n         * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.\n         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.\n         * The parameter `points` is an array successive Vector3.\n         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n         * When updating an instance, remember that only point positions can change, not the number of points.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateLines = function (name, options, scene) {\n            var lines = MeshBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance }, scene);\n            return lines;\n        };\n        /**\n         * Creates a dashed line mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#dashed-lines\n         * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.\n         * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.\n         * The parameter `points` is an array successive Vector3.\n         * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200).\n         * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3).\n         * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1).\n         * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines\n         * When updating an instance, remember that only point positions can change, not the number of points.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateDashedLines = function (name, options, scene) {\n            var points = options.points;\n            var instance = options.instance;\n            var gapSize = options.gapSize;\n            var dashNb = options.dashNb;\n            var dashSize = options.dashSize;\n            if (instance) {\n                var positionFunction = function (positions) {\n                    var curvect = BABYLON.Vector3.Zero();\n                    var nbSeg = positions.length / 6;\n                    var lg = 0;\n                    var nb = 0;\n                    var shft = 0;\n                    var dashshft = 0;\n                    var curshft = 0;\n                    var p = 0;\n                    var i = 0;\n                    var j = 0;\n                    for (i = 0; i < points.length - 1; i++) {\n                        points[i + 1].subtractToRef(points[i], curvect);\n                        lg += curvect.length();\n                    }\n                    shft = lg / nbSeg;\n                    dashshft = instance.dashSize * shft / (instance.dashSize + instance.gapSize);\n                    for (i = 0; i < points.length - 1; i++) {\n                        points[i + 1].subtractToRef(points[i], curvect);\n                        nb = Math.floor(curvect.length() / shft);\n                        curvect.normalize();\n                        j = 0;\n                        while (j < nb && p < positions.length) {\n                            curshft = shft * j;\n                            positions[p] = points[i].x + curshft * curvect.x;\n                            positions[p + 1] = points[i].y + curshft * curvect.y;\n                            positions[p + 2] = points[i].z + curshft * curvect.z;\n                            positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\n                            positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\n                            positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\n                            p += 6;\n                            j++;\n                        }\n                    }\n                    while (p < positions.length) {\n                        positions[p] = points[i].x;\n                        positions[p + 1] = points[i].y;\n                        positions[p + 2] = points[i].z;\n                        p += 3;\n                    }\n                };\n                instance.updateMeshPositions(positionFunction, false);\n                return instance;\n            }\n            // dashed lines creation\n            var dashedLines = new BABYLON.LinesMesh(name, scene);\n            var vertexData = BABYLON.VertexData.CreateDashedLines(options);\n            vertexData.applyToMesh(dashedLines, options.updatable);\n            dashedLines.dashSize = dashSize;\n            dashedLines.gapSize = gapSize;\n            return dashedLines;\n        };\n        /**\n         * Creates an extruded shape mesh.\n         * The extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#extruded-shapes\n         *\n         * Please read this full tutorial to understand how to design an extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be\n         * extruded along the Z axis.\n         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n         * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\n         * The parameter `scale` (float, default 1) is the value to scale the shape.\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape\n         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.ExtrudeShape = function (name, options, scene) {\n            var path = options.path;\n            var shape = options.shape;\n            var scale = options.scale || 1;\n            var rotation = options.rotation || 0;\n            var cap = (options.cap === 0) ? 0 : options.cap || BABYLON.Mesh.NO_CAP;\n            var updatable = options.updatable;\n            var sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var instance = options.instance;\n            var invertUV = options.invertUV || false;\n            return MeshBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable, sideOrientation, instance, invertUV, options.frontUVs, options.backUVs);\n        };\n        /**\n         * Creates an custom extruded shape mesh.\n         * The custom extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         * tuto :http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#custom-extruded-shapes\n         *\n         * Please read this full tutorial to understand how to design a custom extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be\n         * extruded along the Z axis.\n         * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\n         * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path\n         * and the distance of this point from the begining of the path :\n         * ```javascript\n         * var rotationFunction = function(i, distance) {\n         *     // do things\n         *     return rotationValue; }\n         * ```\n         * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\n         * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path\n         * and the distance of this point from the begining of the path :\n         * ```javascript\n         * var scaleFunction = function(i, distance) {\n         *     // do things\n         *     return scaleValue;}\n         * ```\n         * It must returns a float value that will be the scale value applied to the shape on each path point.\n         * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`.\n         * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`.\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape\n         * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.ExtrudeShapeCustom = function (name, options, scene) {\n            var path = options.path;\n            var shape = options.shape;\n            var scaleFunction = options.scaleFunction || (function () { return 1; });\n            var rotationFunction = options.rotationFunction || (function () { return 0; });\n            var ribbonCloseArray = options.ribbonCloseArray || false;\n            var ribbonClosePath = options.ribbonClosePath || false;\n            var cap = (options.cap === 0) ? 0 : options.cap || BABYLON.Mesh.NO_CAP;\n            var updatable = options.updatable;\n            var sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var instance = options.instance;\n            var invertUV = options.invertUV || false;\n            return MeshBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable, sideOrientation, instance, invertUV, options.frontUVs, options.backUVs);\n        };\n        /**\n         * Creates lathe mesh.\n         * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#lathe\n         *\n         * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be\n         * rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero.\n         * The parameter `radius` (positive float, default 1) is the radius value of the lathe.\n         * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe.\n         * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape.\n         * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\".\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateLathe = function (name, options, scene) {\n            var arc = options.arc ? ((options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc) : 1.0;\n            var closed = (options.closed === undefined) ? true : options.closed;\n            var shape = options.shape;\n            var radius = options.radius || 1;\n            var tessellation = options.tessellation || 64;\n            var updatable = options.updatable;\n            var sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var cap = options.cap || BABYLON.Mesh.NO_CAP;\n            var pi2 = Math.PI * 2;\n            var paths = new Array();\n            var invertUV = options.invertUV || false;\n            var i = 0;\n            var p = 0;\n            var step = pi2 / tessellation * arc;\n            var rotated;\n            var path = new Array();\n            ;\n            for (i = 0; i <= tessellation; i++) {\n                var path = [];\n                if (cap == BABYLON.Mesh.CAP_START || cap == BABYLON.Mesh.CAP_ALL) {\n                    path.push(new BABYLON.Vector3(0, shape[0].y, 0));\n                    path.push(new BABYLON.Vector3(Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\n                }\n                for (p = 0; p < shape.length; p++) {\n                    rotated = new BABYLON.Vector3(Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\n                    path.push(rotated);\n                }\n                if (cap == BABYLON.Mesh.CAP_END || cap == BABYLON.Mesh.CAP_ALL) {\n                    path.push(new BABYLON.Vector3(Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\n                    path.push(new BABYLON.Vector3(0, shape[shape.length - 1].y, 0));\n                }\n                paths.push(path);\n            }\n            // lathe ribbon\n            var lathe = MeshBuilder.CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\n            return lathe;\n        };\n        /**\n         * Creates a plane mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane\n         * The parameter `size` sets the size (float) of both sides of the plane at once (default 1).\n         * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value than `size`).\n         * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreatePlane = function (name, options, scene) {\n            var plane = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            plane.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreatePlane(options);\n            vertexData.applyToMesh(plane, options.updatable);\n            if (options.sourcePlane) {\n                plane.translate(options.sourcePlane.normal, options.sourcePlane.d);\n                var product = Math.acos(BABYLON.Vector3.Dot(options.sourcePlane.normal, BABYLON.Axis.Z));\n                var vectorProduct = BABYLON.Vector3.Cross(BABYLON.Axis.Z, options.sourcePlane.normal);\n                plane.rotate(vectorProduct, product);\n            }\n            return plane;\n        };\n        /**\n         * Creates a ground mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane\n         * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground.\n         * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateGround = function (name, options, scene) {\n            var ground = new BABYLON.GroundMesh(name, scene);\n            ground._setReady(false);\n            ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\n            ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\n            ground._width = options.width || 1;\n            ground._height = options.height || 1;\n            ground._maxX = ground._width / 2;\n            ground._maxZ = ground._height / 2;\n            ground._minX = -ground._maxX;\n            ground._minZ = -ground._maxZ;\n            var vertexData = BABYLON.VertexData.CreateGround(options);\n            vertexData.applyToMesh(ground, options.updatable);\n            ground._setReady(true);\n            return ground;\n        };\n        /**\n         * Creates a tiled ground mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tiled-ground\n         * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates.\n         * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates.\n         * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the\n         * numbers of subdivisions on the ground width and height. Each subdivision is called a tile.\n         * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the\n         * numbers of subdivisions on the ground width and height of each tile.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateTiledGround = function (name, options, scene) {\n            var tiledGround = new BABYLON.Mesh(name, scene);\n            var vertexData = BABYLON.VertexData.CreateTiledGround(options);\n            vertexData.applyToMesh(tiledGround, options.updatable);\n            return tiledGround;\n        };\n        /**\n         * Creates a ground mesh from a height map.\n         * tuto : http://doc.babylonjs.com/tutorials/14._Height_Map\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#ground-from-a-height-map\n         * The parameter `url` sets the URL of the height map image resource.\n         * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\n         * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\n         * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\n         * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\n         * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\n         * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\n         * This function is passed the newly built mesh :\n         * ```javascript\n         * function(mesh) { // do things\n         *     return; }\n         * ```\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {\n            var width = options.width || 10.0;\n            var height = options.height || 10.0;\n            var subdivisions = options.subdivisions || 1 | 0;\n            var minHeight = options.minHeight || 0.0;\n            var maxHeight = options.maxHeight || 10.0;\n            var filter = options.colorFilter || new BABYLON.Color3(0.3, 0.59, 0.11);\n            var updatable = options.updatable;\n            var onReady = options.onReady;\n            var ground = new BABYLON.GroundMesh(name, scene);\n            ground._subdivisionsX = subdivisions;\n            ground._subdivisionsY = subdivisions;\n            ground._width = width;\n            ground._height = height;\n            ground._maxX = ground._width / 2.0;\n            ground._maxZ = ground._height / 2.0;\n            ground._minX = -ground._maxX;\n            ground._minZ = -ground._maxZ;\n            ground._setReady(false);\n            var onload = function (img) {\n                // Getting height map data\n                var canvas = document.createElement(\"canvas\");\n                var context = canvas.getContext(\"2d\");\n                var bufferWidth = img.width;\n                var bufferHeight = img.height;\n                canvas.width = bufferWidth;\n                canvas.height = bufferHeight;\n                context.drawImage(img, 0, 0);\n                // Create VertexData from map data\n                // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n                var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\n                var vertexData = BABYLON.VertexData.CreateGroundFromHeightMap({\n                    width: width, height: height,\n                    subdivisions: subdivisions,\n                    minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,\n                    buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight\n                });\n                vertexData.applyToMesh(ground, updatable);\n                ground._setReady(true);\n                //execute ready callback, if set\n                if (onReady) {\n                    onReady(ground);\n                }\n            };\n            BABYLON.Tools.LoadImage(url, onload, function () { }, scene.database);\n            return ground;\n        };\n        /**\n         * Creates a polygon mesh.\n         * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.\n         * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.\n         * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Remember you can only change the shape positions, not their number when updating a polygon.\n         */\n        MeshBuilder.CreatePolygon = function (name, options, scene) {\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var shape = options.shape;\n            var holes = options.holes || [];\n            var depth = options.depth || 0;\n            var contours = [];\n            var hole = [];\n            for (var i = 0; i < shape.length; i++) {\n                contours[i] = new BABYLON.Vector2(shape[i].x, shape[i].z);\n            }\n            var epsilon = 0.00000001;\n            if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\n                contours.pop();\n            }\n            var polygonTriangulation = new BABYLON.PolygonMeshBuilder(name, contours, scene);\n            for (var hNb = 0; hNb < holes.length; hNb++) {\n                hole = [];\n                for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\n                    hole.push(new BABYLON.Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\n                }\n                polygonTriangulation.addHole(hole);\n            }\n            var polygon = polygonTriangulation.build(options.updatable, depth);\n            polygon.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs);\n            vertexData.applyToMesh(polygon, options.updatable);\n            return polygon;\n        };\n        ;\n        /**\n         * Creates an extruded polygon mesh, with depth in the Y direction.\n         * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements).\n         * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n        */\n        MeshBuilder.ExtrudePolygon = function (name, options, scene) {\n            return MeshBuilder.CreatePolygon(name, options, scene);\n        };\n        ;\n        /**\n         * Creates a tube mesh.\n         * The tube is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.\n         *\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tube\n         * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube.\n         * The parameter `radius` (positive float, default 1) sets the tube radius size.\n         * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface.\n         * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`.\n         * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path.\n         * It must return a radius value (positive float) :\n         * ```javascript\n         * var radiusFunction = function(i, distance) {\n         *     // do things\n         *     return radius; }\n         * ```\n         * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc.\n         * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\n         * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreateTube = function (name, options, scene) {\n            var path = options.path;\n            var radius = options.radius || 1.0;\n            var tessellation = options.tessellation || 64 | 0;\n            var radiusFunction = options.radiusFunction;\n            var cap = options.cap || BABYLON.Mesh.NO_CAP;\n            var invertUV = options.invertUV || false;\n            var updatable = options.updatable;\n            var sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            var instance = options.instance;\n            options.arc = (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\n            // tube geometry\n            var tubePathArray = function (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\n                var tangents = path3D.getTangents();\n                var normals = path3D.getNormals();\n                var distances = path3D.getDistances();\n                var pi2 = Math.PI * 2;\n                var step = pi2 / tessellation * arc;\n                var returnRadius = function () { return radius; };\n                var radiusFunctionFinal = radiusFunction || returnRadius;\n                var circlePath;\n                var rad;\n                var normal;\n                var rotated;\n                var rotationMatrix = BABYLON.Tmp.Matrix[0];\n                var index = (cap === BABYLON.Mesh._NO_CAP || cap === BABYLON.Mesh.CAP_END) ? 0 : 2;\n                for (var i = 0; i < path.length; i++) {\n                    rad = radiusFunctionFinal(i, distances[i]); // current radius\n                    circlePath = Array(); // current circle array\n                    normal = normals[i]; // current normal\n                    for (var t = 0; t < tessellation; t++) {\n                        BABYLON.Matrix.RotationAxisToRef(tangents[i], step * t, rotationMatrix);\n                        rotated = circlePath[t] ? circlePath[t] : BABYLON.Vector3.Zero();\n                        BABYLON.Vector3.TransformCoordinatesToRef(normal, rotationMatrix, rotated);\n                        rotated.scaleInPlace(rad).addInPlace(path[i]);\n                        circlePath[t] = rotated;\n                    }\n                    circlePaths[index] = circlePath;\n                    index++;\n                }\n                // cap\n                var capPath = function (nbPoints, pathIndex) {\n                    var pointCap = Array();\n                    for (var i = 0; i < nbPoints; i++) {\n                        pointCap.push(path[pathIndex]);\n                    }\n                    return pointCap;\n                };\n                switch (cap) {\n                    case BABYLON.Mesh.NO_CAP:\n                        break;\n                    case BABYLON.Mesh.CAP_START:\n                        circlePaths[0] = capPath(tessellation, 0);\n                        circlePaths[1] = circlePaths[2].slice(0);\n                        break;\n                    case BABYLON.Mesh.CAP_END:\n                        circlePaths[index] = circlePaths[index - 1].slice(0);\n                        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                        break;\n                    case BABYLON.Mesh.CAP_ALL:\n                        circlePaths[0] = capPath(tessellation, 0);\n                        circlePaths[1] = circlePaths[2].slice(0);\n                        circlePaths[index] = circlePaths[index - 1].slice(0);\n                        circlePaths[index + 1] = capPath(tessellation, path.length - 1);\n                        break;\n                    default:\n                        break;\n                }\n                return circlePaths;\n            };\n            var path3D;\n            var pathArray;\n            if (instance) {\n                var arc = options.arc || instance.arc;\n                path3D = (instance.path3D).update(path);\n                pathArray = tubePathArray(path, path3D, instance.pathArray, radius, instance.tessellation, radiusFunction, instance.cap, arc);\n                instance = MeshBuilder.CreateRibbon(null, { pathArray: pathArray, instance: instance });\n                instance.path3D = path3D;\n                instance.pathArray = pathArray;\n                instance.arc = arc;\n                return instance;\n            }\n            // tube creation\n            path3D = new BABYLON.Path3D(path);\n            var newPathArray = new Array();\n            cap = (cap < 0 || cap > 3) ? 0 : cap;\n            pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\n            var tube = MeshBuilder.CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\n            tube.pathArray = pathArray;\n            tube.path3D = path3D;\n            tube.tessellation = tessellation;\n            tube.cap = cap;\n            tube.arc = options.arc;\n            return tube;\n        };\n        /**\n         * Creates a polyhedron mesh.\n         *\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#polyhedron\n         * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial\n         *  to choose the wanted type.\n         * The parameter `size` (positive float, default 1) sets the polygon size.\n         * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value).\n         * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`.\n         * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\n         * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`).\n         * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors\n         * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored.\n         * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\n         * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4).\n         * Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation\n         * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\n         */\n        MeshBuilder.CreatePolyhedron = function (name, options, scene) {\n            var polyhedron = new BABYLON.Mesh(name, scene);\n            options.sideOrientation = MeshBuilder.updateSideOrientation(options.sideOrientation, scene);\n            polyhedron.sideOrientation = options.sideOrientation;\n            var vertexData = BABYLON.VertexData.CreatePolyhedron(options);\n            vertexData.applyToMesh(polyhedron, options.updatable);\n            return polyhedron;\n        };\n        /**\n         * Creates a decal mesh.\n         * tuto : http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#decals\n         * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal.\n         * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates.\n         * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates.\n         * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling.\n         * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal.\n         */\n        MeshBuilder.CreateDecal = function (name, sourceMesh, options) {\n            var indices = sourceMesh.getIndices();\n            var positions = sourceMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var normals = sourceMesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var position = options.position || BABYLON.Vector3.Zero();\n            var normal = options.normal || BABYLON.Vector3.Up();\n            var size = options.size || BABYLON.Vector3.One();\n            var angle = options.angle || 0;\n            // Getting correct rotation\n            if (!normal) {\n                var target = new BABYLON.Vector3(0, 0, 1);\n                var camera = sourceMesh.getScene().activeCamera;\n                var cameraWorldTarget = BABYLON.Vector3.TransformCoordinates(target, camera.getWorldMatrix());\n                normal = camera.globalPosition.subtract(cameraWorldTarget);\n            }\n            var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\n            var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\n            var pitch = Math.atan2(normal.y, len);\n            // Matrix\n            var decalWorldMatrix = BABYLON.Matrix.RotationYawPitchRoll(yaw, pitch, angle).multiply(BABYLON.Matrix.Translation(position.x, position.y, position.z));\n            var inverseDecalWorldMatrix = BABYLON.Matrix.Invert(decalWorldMatrix);\n            var meshWorldMatrix = sourceMesh.getWorldMatrix();\n            var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\n            var vertexData = new BABYLON.VertexData();\n            vertexData.indices = [];\n            vertexData.positions = [];\n            vertexData.normals = [];\n            vertexData.uvs = [];\n            var currentVertexDataIndex = 0;\n            var extractDecalVector3 = function (indexId) {\n                var vertexId = indices[indexId];\n                var result = new BABYLON.PositionNormalVertex();\n                result.position = new BABYLON.Vector3(positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\n                // Send vector to decal local world\n                result.position = BABYLON.Vector3.TransformCoordinates(result.position, transformMatrix);\n                // Get normal\n                result.normal = new BABYLON.Vector3(normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\n                result.normal = BABYLON.Vector3.TransformNormal(result.normal, transformMatrix);\n                return result;\n            }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\n            var clip = function (vertices, axis) {\n                if (vertices.length === 0) {\n                    return vertices;\n                }\n                var clipSize = 0.5 * Math.abs(BABYLON.Vector3.Dot(size, axis));\n                var clipVertices = function (v0, v1) {\n                    var clipFactor = BABYLON.Vector3.GetClipFactor(v0.position, v1.position, axis, clipSize);\n                    return new BABYLON.PositionNormalVertex(BABYLON.Vector3.Lerp(v0.position, v1.position, clipFactor), BABYLON.Vector3.Lerp(v0.normal, v1.normal, clipFactor));\n                };\n                var result = new Array();\n                for (var index = 0; index < vertices.length; index += 3) {\n                    var v1Out;\n                    var v2Out;\n                    var v3Out;\n                    var total = 0;\n                    var nV1, nV2, nV3, nV4;\n                    var d1 = BABYLON.Vector3.Dot(vertices[index].position, axis) - clipSize;\n                    var d2 = BABYLON.Vector3.Dot(vertices[index + 1].position, axis) - clipSize;\n                    var d3 = BABYLON.Vector3.Dot(vertices[index + 2].position, axis) - clipSize;\n                    v1Out = d1 > 0;\n                    v2Out = d2 > 0;\n                    v3Out = d3 > 0;\n                    total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\n                    switch (total) {\n                        case 0:\n                            result.push(vertices[index]);\n                            result.push(vertices[index + 1]);\n                            result.push(vertices[index + 2]);\n                            break;\n                        case 1:\n                            if (v1Out) {\n                                nV1 = vertices[index + 1];\n                                nV2 = vertices[index + 2];\n                                nV3 = clipVertices(vertices[index], nV1);\n                                nV4 = clipVertices(vertices[index], nV2);\n                            }\n                            if (v2Out) {\n                                nV1 = vertices[index];\n                                nV2 = vertices[index + 2];\n                                nV3 = clipVertices(vertices[index + 1], nV1);\n                                nV4 = clipVertices(vertices[index + 1], nV2);\n                                result.push(nV3);\n                                result.push(nV2.clone());\n                                result.push(nV1.clone());\n                                result.push(nV2.clone());\n                                result.push(nV3.clone());\n                                result.push(nV4);\n                                break;\n                            }\n                            if (v3Out) {\n                                nV1 = vertices[index];\n                                nV2 = vertices[index + 1];\n                                nV3 = clipVertices(vertices[index + 2], nV1);\n                                nV4 = clipVertices(vertices[index + 2], nV2);\n                            }\n                            result.push(nV1.clone());\n                            result.push(nV2.clone());\n                            result.push(nV3);\n                            result.push(nV4);\n                            result.push(nV3.clone());\n                            result.push(nV2.clone());\n                            break;\n                        case 2:\n                            if (!v1Out) {\n                                nV1 = vertices[index].clone();\n                                nV2 = clipVertices(nV1, vertices[index + 1]);\n                                nV3 = clipVertices(nV1, vertices[index + 2]);\n                                result.push(nV1);\n                                result.push(nV2);\n                                result.push(nV3);\n                            }\n                            if (!v2Out) {\n                                nV1 = vertices[index + 1].clone();\n                                nV2 = clipVertices(nV1, vertices[index + 2]);\n                                nV3 = clipVertices(nV1, vertices[index]);\n                                result.push(nV1);\n                                result.push(nV2);\n                                result.push(nV3);\n                            }\n                            if (!v3Out) {\n                                nV1 = vertices[index + 2].clone();\n                                nV2 = clipVertices(nV1, vertices[index]);\n                                nV3 = clipVertices(nV1, vertices[index + 1]);\n                                result.push(nV1);\n                                result.push(nV2);\n                                result.push(nV3);\n                            }\n                            break;\n                        case 3:\n                            break;\n                    }\n                }\n                return result;\n            };\n            for (var index = 0; index < indices.length; index += 3) {\n                var faceVertices = new Array();\n                faceVertices.push(extractDecalVector3(index));\n                faceVertices.push(extractDecalVector3(index + 1));\n                faceVertices.push(extractDecalVector3(index + 2));\n                // Clip\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(1, 0, 0));\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(-1, 0, 0));\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(0, 1, 0));\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(0, -1, 0));\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(0, 0, 1));\n                faceVertices = clip(faceVertices, new BABYLON.Vector3(0, 0, -1));\n                if (faceVertices.length === 0) {\n                    continue;\n                }\n                // Add UVs and get back to world\n                for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\n                    var vertex = faceVertices[vIndex];\n                    //TODO check for Int32Array | Uint32Array | Uint16Array\n                    vertexData.indices.push(currentVertexDataIndex);\n                    vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\n                    vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\n                    vertexData.uvs.push(0.5 + vertex.position.x / size.x);\n                    vertexData.uvs.push(0.5 + vertex.position.y / size.y);\n                    currentVertexDataIndex++;\n                }\n            }\n            // Return mesh\n            var decal = new BABYLON.Mesh(name, sourceMesh.getScene());\n            vertexData.applyToMesh(decal);\n            decal.position = position.clone();\n            decal.rotation = new BABYLON.Vector3(pitch, yaw, angle);\n            return decal;\n        };\n        // Privates\n        MeshBuilder._ExtrudeShapeGeneric = function (name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\n            // extrusion geometry\n            var extrusionPathArray = function (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\n                var tangents = path3D.getTangents();\n                var normals = path3D.getNormals();\n                var binormals = path3D.getBinormals();\n                var distances = path3D.getDistances();\n                var angle = 0;\n                var returnScale = function () { return scale; };\n                var returnRotation = function () { return rotation; };\n                var rotate = custom ? rotateFunction : returnRotation;\n                var scl = custom ? scaleFunction : returnScale;\n                var index = (cap === BABYLON.Mesh.NO_CAP || cap === BABYLON.Mesh.CAP_END) ? 0 : 2;\n                var rotationMatrix = BABYLON.Tmp.Matrix[0];\n                for (var i = 0; i < curve.length; i++) {\n                    var shapePath = new Array();\n                    var angleStep = rotate(i, distances[i]);\n                    var scaleRatio = scl(i, distances[i]);\n                    for (var p = 0; p < shape.length; p++) {\n                        BABYLON.Matrix.RotationAxisToRef(tangents[i], angle, rotationMatrix);\n                        var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));\n                        var rotated = shapePath[p] ? shapePath[p] : BABYLON.Vector3.Zero();\n                        BABYLON.Vector3.TransformCoordinatesToRef(planed, rotationMatrix, rotated);\n                        rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\n                        shapePath[p] = rotated;\n                    }\n                    shapePaths[index] = shapePath;\n                    angle += angleStep;\n                    index++;\n                }\n                // cap\n                var capPath = function (shapePath) {\n                    var pointCap = Array();\n                    var barycenter = BABYLON.Vector3.Zero();\n                    var i;\n                    for (i = 0; i < shapePath.length; i++) {\n                        barycenter.addInPlace(shapePath[i]);\n                    }\n                    barycenter.scaleInPlace(1.0 / shapePath.length);\n                    for (i = 0; i < shapePath.length; i++) {\n                        pointCap.push(barycenter);\n                    }\n                    return pointCap;\n                };\n                switch (cap) {\n                    case BABYLON.Mesh.NO_CAP:\n                        break;\n                    case BABYLON.Mesh.CAP_START:\n                        shapePaths[0] = capPath(shapePaths[2]);\n                        shapePaths[1] = shapePaths[2];\n                        break;\n                    case BABYLON.Mesh.CAP_END:\n                        shapePaths[index] = shapePaths[index - 1];\n                        shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                        break;\n                    case BABYLON.Mesh.CAP_ALL:\n                        shapePaths[0] = capPath(shapePaths[2]);\n                        shapePaths[1] = shapePaths[2];\n                        shapePaths[index] = shapePaths[index - 1];\n                        shapePaths[index + 1] = capPath(shapePaths[index - 1]);\n                        break;\n                    default:\n                        break;\n                }\n                return shapePaths;\n            };\n            var path3D;\n            var pathArray;\n            if (instance) {\n                path3D = (instance.path3D).update(curve);\n                pathArray = extrusionPathArray(shape, curve, instance.path3D, instance.pathArray, scale, rotation, scaleFunction, rotateFunction, instance.cap, custom);\n                instance = BABYLON.Mesh.CreateRibbon(null, pathArray, null, null, null, scene, null, null, instance);\n                return instance;\n            }\n            // extruded shape creation\n            path3D = new BABYLON.Path3D(curve);\n            var newShapePaths = new Array();\n            cap = (cap < 0 || cap > 3) ? 0 : cap;\n            pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\n            var extrudedGeneric = MeshBuilder.CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs, backUVs: backUVs }, scene);\n            extrudedGeneric.pathArray = pathArray;\n            extrudedGeneric.path3D = path3D;\n            extrudedGeneric.cap = cap;\n            return extrudedGeneric;\n        };\n        return MeshBuilder;\n    }());\n    BABYLON.MeshBuilder = MeshBuilder;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.meshBuilder.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var AudioEngine = (function () {\n        function AudioEngine() {\n            this._audioContext = null;\n            this._audioContextInitialized = false;\n            this.canUseWebAudio = false;\n            this.WarnedWebAudioUnsupported = false;\n            this.unlocked = false;\n            this.isMP3supported = false;\n            this.isOGGsupported = false;\n            if (typeof window.AudioContext !== 'undefined' || typeof window.webkitAudioContext !== 'undefined') {\n                window.AudioContext = window.AudioContext || window.webkitAudioContext;\n                this.canUseWebAudio = true;\n            }\n            var audioElem = document.createElement('audio');\n            try {\n                if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, '')) {\n                    this.isMP3supported = true;\n                }\n            }\n            catch (e) {\n                // protect error during capability check.\n            }\n            try {\n                if (audioElem && !!audioElem.canPlayType && audioElem.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')) {\n                    this.isOGGsupported = true;\n                }\n            }\n            catch (e) {\n                // protect error during capability check.\n            }\n            if (/iPad|iPhone|iPod/.test(navigator.platform)) {\n                this._unlockiOSaudio();\n            }\n            else {\n                this.unlocked = true;\n            }\n        }\n        Object.defineProperty(AudioEngine.prototype, \"audioContext\", {\n            get: function () {\n                if (!this._audioContextInitialized) {\n                    this._initializeAudioContext();\n                }\n                return this._audioContext;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        AudioEngine.prototype._unlockiOSaudio = function () {\n            var _this = this;\n            var unlockaudio = function () {\n                var buffer = _this.audioContext.createBuffer(1, 1, 22050);\n                var source = _this.audioContext.createBufferSource();\n                source.buffer = buffer;\n                source.connect(_this.audioContext.destination);\n                source.start(0);\n                setTimeout(function () {\n                    if ((source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE)) {\n                        _this.unlocked = true;\n                        window.removeEventListener('touchend', unlockaudio, false);\n                        if (_this.onAudioUnlocked) {\n                            _this.onAudioUnlocked();\n                        }\n                    }\n                }, 0);\n            };\n            window.addEventListener('touchend', unlockaudio, false);\n        };\n        AudioEngine.prototype._initializeAudioContext = function () {\n            try {\n                if (this.canUseWebAudio) {\n                    this._audioContext = new AudioContext();\n                    // create a global volume gain node \n                    this.masterGain = this._audioContext.createGain();\n                    this.masterGain.gain.value = 1;\n                    this.masterGain.connect(this._audioContext.destination);\n                    this._audioContextInitialized = true;\n                }\n            }\n            catch (e) {\n                this.canUseWebAudio = false;\n                BABYLON.Tools.Error(\"Web Audio: \" + e.message);\n            }\n        };\n        AudioEngine.prototype.dispose = function () {\n            if (this.canUseWebAudio && this._audioContextInitialized) {\n                if (this._connectedAnalyser) {\n                    this._connectedAnalyser.stopDebugCanvas();\n                    this._connectedAnalyser.dispose();\n                    this.masterGain.disconnect();\n                    this.masterGain.connect(this._audioContext.destination);\n                    this._connectedAnalyser = null;\n                }\n                this.masterGain.gain.value = 1;\n            }\n            this.WarnedWebAudioUnsupported = false;\n        };\n        AudioEngine.prototype.getGlobalVolume = function () {\n            if (this.canUseWebAudio && this._audioContextInitialized) {\n                return this.masterGain.gain.value;\n            }\n            else {\n                return -1;\n            }\n        };\n        AudioEngine.prototype.setGlobalVolume = function (newVolume) {\n            if (this.canUseWebAudio && this._audioContextInitialized) {\n                this.masterGain.gain.value = newVolume;\n            }\n        };\n        AudioEngine.prototype.connectToAnalyser = function (analyser) {\n            if (this._connectedAnalyser) {\n                this._connectedAnalyser.stopDebugCanvas();\n            }\n            if (this.canUseWebAudio && this._audioContextInitialized) {\n                this._connectedAnalyser = analyser;\n                this.masterGain.disconnect();\n                this._connectedAnalyser.connectAudioNodes(this.masterGain, this._audioContext.destination);\n            }\n        };\n        return AudioEngine;\n    }());\n    BABYLON.AudioEngine = AudioEngine;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.audioEngine.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Sound = (function () {\n        /**\n        * Create a sound and attach it to a scene\n        * @param name Name of your sound\n        * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer\n        * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n        * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n        */\n        function Sound(name, urlOrArrayBuffer, scene, readyToPlayCallback, options) {\n            var _this = this;\n            this.autoplay = false;\n            this.loop = false;\n            this.useCustomAttenuation = false;\n            this.spatialSound = false;\n            this.refDistance = 1;\n            this.rolloffFactor = 1;\n            this.maxDistance = 100;\n            this.distanceModel = \"linear\";\n            this._panningModel = \"equalpower\";\n            this._playbackRate = 1;\n            this._streaming = false;\n            this._startTime = 0;\n            this._startOffset = 0;\n            this._position = BABYLON.Vector3.Zero();\n            this._localDirection = new BABYLON.Vector3(1, 0, 0);\n            this._volume = 1;\n            this._isLoaded = false;\n            this._isReadyToPlay = false;\n            this.isPlaying = false;\n            this.isPaused = false;\n            this._isDirectional = false;\n            // Used if you'd like to create a directional sound.\n            // If not set, the sound will be omnidirectional\n            this._coneInnerAngle = 360;\n            this._coneOuterAngle = 360;\n            this._coneOuterGain = 0;\n            this._isOutputConnected = false;\n            this._urlType = \"Unknown\";\n            this.name = name;\n            this._scene = scene;\n            this._readyToPlayCallback = readyToPlayCallback;\n            // Default custom attenuation function is a linear attenuation\n            this._customAttenuationFunction = function (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) {\n                if (currentDistance < maxDistance) {\n                    return currentVolume * (1 - currentDistance / maxDistance);\n                }\n                else {\n                    return 0;\n                }\n            };\n            if (options) {\n                this.autoplay = options.autoplay || false;\n                this.loop = options.loop || false;\n                // if volume === 0, we need another way to check this option\n                if (options.volume !== undefined) {\n                    this._volume = options.volume;\n                }\n                this.spatialSound = options.spatialSound || false;\n                this.maxDistance = options.maxDistance || 100;\n                this.useCustomAttenuation = options.useCustomAttenuation || false;\n                this.rolloffFactor = options.rolloffFactor || 1;\n                this.refDistance = options.refDistance || 1;\n                this.distanceModel = options.distanceModel || \"linear\";\n                this._playbackRate = options.playbackRate || 1;\n                this._streaming = options.streaming || false;\n            }\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                this._soundGain = BABYLON.Engine.audioEngine.audioContext.createGain();\n                this._soundGain.gain.value = this._volume;\n                this._inputAudioNode = this._soundGain;\n                this._ouputAudioNode = this._soundGain;\n                if (this.spatialSound) {\n                    this._createSpatialParameters();\n                }\n                this._scene.mainSoundTrack.AddSound(this);\n                var validParameter = true;\n                // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\n                if (urlOrArrayBuffer) {\n                    if (typeof (urlOrArrayBuffer) === \"string\")\n                        this._urlType = \"String\";\n                    if (Array.isArray(urlOrArrayBuffer))\n                        this._urlType = \"Array\";\n                    if (urlOrArrayBuffer instanceof ArrayBuffer)\n                        this._urlType = \"ArrayBuffer\";\n                    var urls = [];\n                    var codecSupportedFound = false;\n                    switch (this._urlType) {\n                        case \"ArrayBuffer\":\n                            if (urlOrArrayBuffer.byteLength > 0) {\n                                codecSupportedFound = true;\n                                this._soundLoaded(urlOrArrayBuffer);\n                            }\n                            break;\n                        case \"String\":\n                            urls.push(urlOrArrayBuffer);\n                        case \"Array\":\n                            if (urls.length === 0)\n                                urls = urlOrArrayBuffer;\n                            // If we found a supported format, we load it immediately and stop the loop\n                            for (var i = 0; i < urls.length; i++) {\n                                var url = urls[i];\n                                if (url.indexOf(\".mp3\", url.length - 4) !== -1 && BABYLON.Engine.audioEngine.isMP3supported) {\n                                    codecSupportedFound = true;\n                                }\n                                if (url.indexOf(\".ogg\", url.length - 4) !== -1 && BABYLON.Engine.audioEngine.isOGGsupported) {\n                                    codecSupportedFound = true;\n                                }\n                                if (url.indexOf(\".wav\", url.length - 4) !== -1) {\n                                    codecSupportedFound = true;\n                                }\n                                if (codecSupportedFound) {\n                                    // Loading sound using XHR2\n                                    if (!this._streaming) {\n                                        BABYLON.Tools.LoadFile(url, function (data) { _this._soundLoaded(data); }, null, this._scene.database, true);\n                                    }\n                                    else {\n                                        this._htmlAudioElement = new Audio(url);\n                                        this._htmlAudioElement.controls = false;\n                                        this._htmlAudioElement.loop = this.loop;\n                                        this._htmlAudioElement.crossOrigin = \"anonymous\";\n                                        this._htmlAudioElement.preload = \"auto\";\n                                        this._htmlAudioElement.addEventListener(\"canplaythrough\", function () {\n                                            _this._isReadyToPlay = true;\n                                            if (_this.autoplay) {\n                                                _this.play();\n                                            }\n                                            if (_this._readyToPlayCallback) {\n                                                _this._readyToPlayCallback();\n                                            }\n                                        });\n                                        document.body.appendChild(this._htmlAudioElement);\n                                    }\n                                    break;\n                                }\n                            }\n                            break;\n                        default:\n                            validParameter = false;\n                            break;\n                    }\n                    if (!validParameter) {\n                        BABYLON.Tools.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n                    }\n                    else {\n                        if (!codecSupportedFound) {\n                            this._isReadyToPlay = true;\n                            // Simulating a ready to play event to avoid breaking code path\n                            if (this._readyToPlayCallback) {\n                                window.setTimeout(function () {\n                                    _this._readyToPlayCallback();\n                                }, 1000);\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\n                this._scene.mainSoundTrack.AddSound(this);\n                if (!BABYLON.Engine.audioEngine.WarnedWebAudioUnsupported) {\n                    BABYLON.Tools.Error(\"Web Audio is not supported by your browser.\");\n                    BABYLON.Engine.audioEngine.WarnedWebAudioUnsupported = true;\n                }\n                // Simulating a ready to play event to avoid breaking code for non web audio browsers\n                if (this._readyToPlayCallback) {\n                    window.setTimeout(function () {\n                        _this._readyToPlayCallback();\n                    }, 1000);\n                }\n            }\n        }\n        Sound.prototype.dispose = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this._isReadyToPlay) {\n                if (this.isPlaying) {\n                    this.stop();\n                }\n                this._isReadyToPlay = false;\n                if (this.soundTrackId === -1) {\n                    this._scene.mainSoundTrack.RemoveSound(this);\n                }\n                else {\n                    this._scene.soundTracks[this.soundTrackId].RemoveSound(this);\n                }\n                if (this._soundGain) {\n                    this._soundGain.disconnect();\n                    this._soundGain = null;\n                }\n                if (this._soundPanner) {\n                    this._soundPanner.disconnect();\n                    this._soundPanner = null;\n                }\n                if (this._soundSource) {\n                    this._soundSource.disconnect();\n                    this._soundSource = null;\n                }\n                this._audioBuffer = null;\n                if (this._htmlAudioElement) {\n                    this._htmlAudioElement.pause();\n                    this._htmlAudioElement.src = \"\";\n                    document.body.removeChild(this._htmlAudioElement);\n                }\n                if (this._connectedMesh) {\n                    this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n                    this._connectedMesh = null;\n                }\n            }\n        };\n        Sound.prototype.isReady = function () {\n            return this._isReadyToPlay;\n        };\n        Sound.prototype._soundLoaded = function (audioData) {\n            var _this = this;\n            this._isLoaded = true;\n            BABYLON.Engine.audioEngine.audioContext.decodeAudioData(audioData, function (buffer) {\n                _this._audioBuffer = buffer;\n                _this._isReadyToPlay = true;\n                if (_this.autoplay) {\n                    _this.play();\n                }\n                if (_this._readyToPlayCallback) {\n                    _this._readyToPlayCallback();\n                }\n            }, function (err) { BABYLON.Tools.Error(\"Error while decoding audio data for: \" + _this.name + \" / Error: \" + err); });\n        };\n        Sound.prototype.setAudioBuffer = function (audioBuffer) {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                this._audioBuffer = audioBuffer;\n                this._isReadyToPlay = true;\n            }\n        };\n        Sound.prototype.updateOptions = function (options) {\n            if (options) {\n                this.loop = options.loop || this.loop;\n                this.maxDistance = options.maxDistance || this.maxDistance;\n                this.useCustomAttenuation = options.useCustomAttenuation || this.useCustomAttenuation;\n                this.rolloffFactor = options.rolloffFactor || this.rolloffFactor;\n                this.refDistance = options.refDistance || this.refDistance;\n                this.distanceModel = options.distanceModel || this.distanceModel;\n                this._playbackRate = options.playbackRate || this._playbackRate;\n                this._updateSpatialParameters();\n                if (this.isPlaying) {\n                    if (this._streaming) {\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\n                    }\n                    else {\n                        this._soundSource.playbackRate.value = this._playbackRate;\n                    }\n                }\n            }\n        };\n        Sound.prototype._createSpatialParameters = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                if (this._scene.headphone) {\n                    this._panningModel = \"HRTF\";\n                }\n                this._soundPanner = BABYLON.Engine.audioEngine.audioContext.createPanner();\n                this._updateSpatialParameters();\n                this._soundPanner.connect(this._ouputAudioNode);\n                this._inputAudioNode = this._soundPanner;\n            }\n        };\n        Sound.prototype._updateSpatialParameters = function () {\n            if (this.spatialSound) {\n                if (this.useCustomAttenuation) {\n                    // Tricks to disable in a way embedded Web Audio attenuation \n                    this._soundPanner.distanceModel = \"linear\";\n                    this._soundPanner.maxDistance = Number.MAX_VALUE;\n                    this._soundPanner.refDistance = 1;\n                    this._soundPanner.rolloffFactor = 1;\n                    this._soundPanner.panningModel = this._panningModel;\n                }\n                else {\n                    this._soundPanner.distanceModel = this.distanceModel;\n                    this._soundPanner.maxDistance = this.maxDistance;\n                    this._soundPanner.refDistance = this.refDistance;\n                    this._soundPanner.rolloffFactor = this.rolloffFactor;\n                    this._soundPanner.panningModel = this._panningModel;\n                }\n            }\n        };\n        Sound.prototype.switchPanningModelToHRTF = function () {\n            this._panningModel = \"HRTF\";\n            this._switchPanningModel();\n        };\n        Sound.prototype.switchPanningModelToEqualPower = function () {\n            this._panningModel = \"equalpower\";\n            this._switchPanningModel();\n        };\n        Sound.prototype._switchPanningModel = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this.spatialSound) {\n                this._soundPanner.panningModel = this._panningModel;\n            }\n        };\n        Sound.prototype.connectToSoundTrackAudioNode = function (soundTrackAudioNode) {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                if (this._isOutputConnected) {\n                    this._ouputAudioNode.disconnect();\n                }\n                this._ouputAudioNode.connect(soundTrackAudioNode);\n                this._isOutputConnected = true;\n            }\n        };\n        /**\n        * Transform this sound into a directional source\n        * @param coneInnerAngle Size of the inner cone in degree\n        * @param coneOuterAngle Size of the outer cone in degree\n        * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n        */\n        Sound.prototype.setDirectionalCone = function (coneInnerAngle, coneOuterAngle, coneOuterGain) {\n            if (coneOuterAngle < coneInnerAngle) {\n                BABYLON.Tools.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneInnerAngle = coneInnerAngle;\n            this._coneOuterAngle = coneOuterAngle;\n            this._coneOuterGain = coneOuterGain;\n            this._isDirectional = true;\n            if (this.isPlaying && this.loop) {\n                this.stop();\n                this.play();\n            }\n        };\n        Sound.prototype.setPosition = function (newPosition) {\n            this._position = newPosition;\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this.spatialSound) {\n                this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n            }\n        };\n        Sound.prototype.setLocalDirectionToMesh = function (newLocalDirection) {\n            this._localDirection = newLocalDirection;\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.isPlaying) {\n                this._updateDirection();\n            }\n        };\n        Sound.prototype._updateDirection = function () {\n            var mat = this._connectedMesh.getWorldMatrix();\n            var direction = BABYLON.Vector3.TransformNormal(this._localDirection, mat);\n            direction.normalize();\n            this._soundPanner.setOrientation(direction.x, direction.y, direction.z);\n        };\n        Sound.prototype.updateDistanceFromListener = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this._connectedMesh && this.useCustomAttenuation) {\n                var distance = this._connectedMesh.getDistanceToCamera(this._scene.activeCamera);\n                this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n            }\n        };\n        Sound.prototype.setAttenuationFunction = function (callback) {\n            this._customAttenuationFunction = callback;\n        };\n        /**\n        * Play the sound\n        * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n        * @param offset (optional) Start the sound setting it at a specific time\n        */\n        Sound.prototype.play = function (time, offset) {\n            var _this = this;\n            if (this._isReadyToPlay && this._scene.audioEnabled) {\n                try {\n                    if (this._startOffset < 0) {\n                        time = -this._startOffset;\n                        this._startOffset = 0;\n                    }\n                    var startTime = time ? BABYLON.Engine.audioEngine.audioContext.currentTime + time : BABYLON.Engine.audioEngine.audioContext.currentTime;\n                    if (!this._soundSource || !this._streamingSource) {\n                        if (this.spatialSound) {\n                            this._soundPanner.setPosition(this._position.x, this._position.y, this._position.z);\n                            if (this._isDirectional) {\n                                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\n                                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\n                                this._soundPanner.coneOuterGain = this._coneOuterGain;\n                                if (this._connectedMesh) {\n                                    this._updateDirection();\n                                }\n                                else {\n                                    this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\n                                }\n                            }\n                        }\n                    }\n                    if (this._streaming) {\n                        if (!this._streamingSource) {\n                            this._streamingSource = BABYLON.Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\n                            this._htmlAudioElement.onended = function () { _this._onended(); };\n                            this._htmlAudioElement.playbackRate = this._playbackRate;\n                        }\n                        this._streamingSource.disconnect();\n                        this._streamingSource.connect(this._inputAudioNode);\n                        this._htmlAudioElement.play();\n                    }\n                    else {\n                        this._soundSource = BABYLON.Engine.audioEngine.audioContext.createBufferSource();\n                        this._soundSource.buffer = this._audioBuffer;\n                        this._soundSource.connect(this._inputAudioNode);\n                        this._soundSource.loop = this.loop;\n                        this._soundSource.playbackRate.value = this._playbackRate;\n                        this._soundSource.onended = function () { _this._onended(); };\n                        this._soundSource.start(startTime, this.isPaused ? this._startOffset % this._soundSource.buffer.duration : offset ? offset : 0);\n                    }\n                    this._startTime = startTime;\n                    this.isPlaying = true;\n                    this.isPaused = false;\n                }\n                catch (ex) {\n                    BABYLON.Tools.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n                }\n            }\n        };\n        Sound.prototype._onended = function () {\n            this.isPlaying = false;\n            if (this.onended) {\n                this.onended();\n            }\n        };\n        /**\n        * Stop the sound\n        * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n        */\n        Sound.prototype.stop = function (time) {\n            if (this.isPlaying) {\n                if (this._streaming) {\n                    this._htmlAudioElement.pause();\n                    // Test needed for Firefox or it will generate an Invalid State Error\n                    if (this._htmlAudioElement.currentTime > 0) {\n                        this._htmlAudioElement.currentTime = 0;\n                    }\n                }\n                else {\n                    var stopTime = time ? BABYLON.Engine.audioEngine.audioContext.currentTime + time : BABYLON.Engine.audioEngine.audioContext.currentTime;\n                    this._soundSource.stop(stopTime);\n                    this._soundSource.onended = null;\n                    if (!this.isPaused) {\n                        this._startOffset = 0;\n                    }\n                }\n                this.isPlaying = false;\n            }\n        };\n        Sound.prototype.pause = function () {\n            if (this.isPlaying) {\n                this.isPaused = true;\n                if (this._streaming) {\n                    this._htmlAudioElement.pause();\n                }\n                else {\n                    this.stop(0);\n                    this._startOffset += BABYLON.Engine.audioEngine.audioContext.currentTime - this._startTime;\n                }\n            }\n        };\n        Sound.prototype.setVolume = function (newVolume, time) {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                if (time) {\n                    this._soundGain.gain.cancelScheduledValues(BABYLON.Engine.audioEngine.audioContext.currentTime);\n                    this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, BABYLON.Engine.audioEngine.audioContext.currentTime);\n                    this._soundGain.gain.linearRampToValueAtTime(newVolume, BABYLON.Engine.audioEngine.audioContext.currentTime + time);\n                }\n                else {\n                    this._soundGain.gain.value = newVolume;\n                }\n            }\n            this._volume = newVolume;\n        };\n        Sound.prototype.setPlaybackRate = function (newPlaybackRate) {\n            this._playbackRate = newPlaybackRate;\n            if (this.isPlaying) {\n                if (this._streaming) {\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\n                }\n                else {\n                    this._soundSource.playbackRate.value = this._playbackRate;\n                }\n            }\n        };\n        Sound.prototype.getVolume = function () {\n            return this._volume;\n        };\n        Sound.prototype.attachToMesh = function (meshToConnectTo) {\n            var _this = this;\n            if (this._connectedMesh) {\n                this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n                this._registerFunc = null;\n            }\n            this._connectedMesh = meshToConnectTo;\n            if (!this.spatialSound) {\n                this.spatialSound = true;\n                this._createSpatialParameters();\n                if (this.isPlaying && this.loop) {\n                    this.stop();\n                    this.play();\n                }\n            }\n            this._onRegisterAfterWorldMatrixUpdate(this._connectedMesh);\n            this._registerFunc = function (connectedMesh) { return _this._onRegisterAfterWorldMatrixUpdate(connectedMesh); };\n            meshToConnectTo.registerAfterWorldMatrixUpdate(this._registerFunc);\n        };\n        Sound.prototype.detachFromMesh = function () {\n            if (this._connectedMesh) {\n                this._connectedMesh.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n                this._registerFunc = null;\n                this._connectedMesh = null;\n            }\n        };\n        Sound.prototype._onRegisterAfterWorldMatrixUpdate = function (connectedMesh) {\n            this.setPosition(connectedMesh.getBoundingInfo().boundingSphere.centerWorld);\n            if (BABYLON.Engine.audioEngine.canUseWebAudio && this._isDirectional && this.isPlaying) {\n                this._updateDirection();\n            }\n        };\n        Sound.prototype.clone = function () {\n            var _this = this;\n            if (!this._streaming) {\n                var setBufferAndRun = function () {\n                    if (_this._isReadyToPlay) {\n                        clonedSound._audioBuffer = _this.getAudioBuffer();\n                        clonedSound._isReadyToPlay = true;\n                        if (clonedSound.autoplay) {\n                            clonedSound.play();\n                        }\n                    }\n                    else {\n                        window.setTimeout(setBufferAndRun, 300);\n                    }\n                };\n                var currentOptions = {\n                    autoplay: this.autoplay, loop: this.loop,\n                    volume: this._volume, spatialSound: this.spatialSound, maxDistance: this.maxDistance,\n                    useCustomAttenuation: this.useCustomAttenuation, rolloffFactor: this.rolloffFactor,\n                    refDistance: this.refDistance, distanceModel: this.distanceModel\n                };\n                var clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\n                if (this.useCustomAttenuation) {\n                    clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n                }\n                clonedSound.setPosition(this._position);\n                clonedSound.setPlaybackRate(this._playbackRate);\n                setBufferAndRun();\n                return clonedSound;\n            }\n            else {\n                return null;\n            }\n        };\n        Sound.prototype.getAudioBuffer = function () {\n            return this._audioBuffer;\n        };\n        Sound.prototype.serialize = function () {\n            var serializationObject = {\n                name: this.name,\n                url: this.name,\n                autoplay: this.autoplay,\n                loop: this.loop,\n                volume: this._volume,\n                spatialSound: this.spatialSound,\n                maxDistance: this.maxDistance,\n                rolloffFactor: this.rolloffFactor,\n                refDistance: this.refDistance,\n                distanceModel: this.distanceModel,\n                playbackRate: this._playbackRate,\n                panningModel: this._panningModel,\n                soundTrackId: this.soundTrackId\n            };\n            if (this.spatialSound) {\n                if (this._connectedMesh)\n                    serializationObject.connectedMeshId = this._connectedMesh.id;\n                serializationObject.position = this._position.asArray();\n                serializationObject.refDistance = this.refDistance;\n                serializationObject.distanceModel = this.distanceModel;\n                serializationObject.isDirectional = this._isDirectional;\n                serializationObject.localDirectionToMesh = this._localDirection.asArray();\n                serializationObject.coneInnerAngle = this._coneInnerAngle;\n                serializationObject.coneOuterAngle = this._coneOuterAngle;\n                serializationObject.coneOuterGain = this._coneOuterGain;\n            }\n            return serializationObject;\n        };\n        Sound.Parse = function (parsedSound, scene, rootUrl, sourceSound) {\n            var soundName = parsedSound.name;\n            var soundUrl;\n            if (parsedSound.url) {\n                soundUrl = rootUrl + parsedSound.url;\n            }\n            else {\n                soundUrl = rootUrl + soundName;\n            }\n            var options = {\n                autoplay: parsedSound.autoplay, loop: parsedSound.loop, volume: parsedSound.volume,\n                spatialSound: parsedSound.spatialSound, maxDistance: parsedSound.maxDistance,\n                rolloffFactor: parsedSound.rolloffFactor,\n                refDistance: parsedSound.refDistance,\n                distanceModel: parsedSound.distanceModel,\n                playbackRate: parsedSound.playbackRate\n            };\n            var newSound;\n            if (!sourceSound) {\n                newSound = new Sound(soundName, soundUrl, scene, function () { scene._removePendingData(newSound); }, options);\n                scene._addPendingData(newSound);\n            }\n            else {\n                var setBufferAndRun = function () {\n                    if (sourceSound._isReadyToPlay) {\n                        newSound._audioBuffer = sourceSound.getAudioBuffer();\n                        newSound._isReadyToPlay = true;\n                        if (newSound.autoplay) {\n                            newSound.play();\n                        }\n                    }\n                    else {\n                        window.setTimeout(setBufferAndRun, 300);\n                    }\n                };\n                newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n                setBufferAndRun();\n            }\n            if (parsedSound.position) {\n                var soundPosition = BABYLON.Vector3.FromArray(parsedSound.position);\n                newSound.setPosition(soundPosition);\n            }\n            if (parsedSound.isDirectional) {\n                newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n                if (parsedSound.localDirectionToMesh) {\n                    var localDirectionToMesh = BABYLON.Vector3.FromArray(parsedSound.localDirectionToMesh);\n                    newSound.setLocalDirectionToMesh(localDirectionToMesh);\n                }\n            }\n            if (parsedSound.connectedMeshId) {\n                var connectedMesh = scene.getMeshByID(parsedSound.connectedMeshId);\n                if (connectedMesh) {\n                    newSound.attachToMesh(connectedMesh);\n                }\n            }\n            return newSound;\n        };\n        return Sound;\n    }());\n    BABYLON.Sound = Sound;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sound.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SoundTrack = (function () {\n        function SoundTrack(scene, options) {\n            this.id = -1;\n            this._isMainTrack = false;\n            this._isInitialized = false;\n            this._scene = scene;\n            this.soundCollection = new Array();\n            this._options = options;\n            if (!this._isMainTrack) {\n                this._scene.soundTracks.push(this);\n                this.id = this._scene.soundTracks.length - 1;\n            }\n        }\n        SoundTrack.prototype._initializeSoundTrackAudioGraph = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                this._outputAudioNode = BABYLON.Engine.audioEngine.audioContext.createGain();\n                this._outputAudioNode.connect(BABYLON.Engine.audioEngine.masterGain);\n                if (this._options) {\n                    if (this._options.volume) {\n                        this._outputAudioNode.gain.value = this._options.volume;\n                    }\n                    if (this._options.mainTrack) {\n                        this._isMainTrack = this._options.mainTrack;\n                    }\n                }\n                this._isInitialized = true;\n            }\n        };\n        SoundTrack.prototype.dispose = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                if (this._connectedAnalyser) {\n                    this._connectedAnalyser.stopDebugCanvas();\n                }\n                while (this.soundCollection.length) {\n                    this.soundCollection[0].dispose();\n                }\n                if (this._outputAudioNode) {\n                    this._outputAudioNode.disconnect();\n                }\n                this._outputAudioNode = null;\n            }\n        };\n        SoundTrack.prototype.AddSound = function (sound) {\n            if (!this._isInitialized) {\n                this._initializeSoundTrackAudioGraph();\n            }\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                sound.connectToSoundTrackAudioNode(this._outputAudioNode);\n            }\n            if (sound.soundTrackId) {\n                if (sound.soundTrackId === -1) {\n                    this._scene.mainSoundTrack.RemoveSound(sound);\n                }\n                else {\n                    this._scene.soundTracks[sound.soundTrackId].RemoveSound(sound);\n                }\n            }\n            this.soundCollection.push(sound);\n            sound.soundTrackId = this.id;\n        };\n        SoundTrack.prototype.RemoveSound = function (sound) {\n            var index = this.soundCollection.indexOf(sound);\n            if (index !== -1) {\n                this.soundCollection.splice(index, 1);\n            }\n        };\n        SoundTrack.prototype.setVolume = function (newVolume) {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                this._outputAudioNode.gain.value = newVolume;\n            }\n        };\n        SoundTrack.prototype.switchPanningModelToHRTF = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                for (var i = 0; i < this.soundCollection.length; i++) {\n                    this.soundCollection[i].switchPanningModelToHRTF();\n                }\n            }\n        };\n        SoundTrack.prototype.switchPanningModelToEqualPower = function () {\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                for (var i = 0; i < this.soundCollection.length; i++) {\n                    this.soundCollection[i].switchPanningModelToEqualPower();\n                }\n            }\n        };\n        SoundTrack.prototype.connectToAnalyser = function (analyser) {\n            if (this._connectedAnalyser) {\n                this._connectedAnalyser.stopDebugCanvas();\n            }\n            this._connectedAnalyser = analyser;\n            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                this._outputAudioNode.disconnect();\n                this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, BABYLON.Engine.audioEngine.masterGain);\n            }\n        };\n        return SoundTrack;\n    }());\n    BABYLON.SoundTrack = SoundTrack;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.soundtrack.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Analyser = (function () {\n        function Analyser(scene) {\n            this.SMOOTHING = 0.75;\n            this.FFT_SIZE = 512;\n            this.BARGRAPHAMPLITUDE = 256;\n            this.DEBUGCANVASPOS = { x: 20, y: 20 };\n            this.DEBUGCANVASSIZE = { width: 320, height: 200 };\n            this._scene = scene;\n            this._audioEngine = BABYLON.Engine.audioEngine;\n            if (this._audioEngine.canUseWebAudio) {\n                this._webAudioAnalyser = this._audioEngine.audioContext.createAnalyser();\n                this._webAudioAnalyser.minDecibels = -140;\n                this._webAudioAnalyser.maxDecibels = 0;\n                this._byteFreqs = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);\n                this._byteTime = new Uint8Array(this._webAudioAnalyser.frequencyBinCount);\n                this._floatFreqs = new Float32Array(this._webAudioAnalyser.frequencyBinCount);\n            }\n        }\n        Analyser.prototype.getFrequencyBinCount = function () {\n            if (this._audioEngine.canUseWebAudio) {\n                return this._webAudioAnalyser.frequencyBinCount;\n            }\n            else {\n                return 0;\n            }\n        };\n        Analyser.prototype.getByteFrequencyData = function () {\n            if (this._audioEngine.canUseWebAudio) {\n                this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n                this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n                this._webAudioAnalyser.getByteFrequencyData(this._byteFreqs);\n            }\n            return this._byteFreqs;\n        };\n        Analyser.prototype.getByteTimeDomainData = function () {\n            if (this._audioEngine.canUseWebAudio) {\n                this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n                this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n                this._webAudioAnalyser.getByteTimeDomainData(this._byteTime);\n            }\n            return this._byteTime;\n        };\n        Analyser.prototype.getFloatFrequencyData = function () {\n            if (this._audioEngine.canUseWebAudio) {\n                this._webAudioAnalyser.smoothingTimeConstant = this.SMOOTHING;\n                this._webAudioAnalyser.fftSize = this.FFT_SIZE;\n                this._webAudioAnalyser.getFloatFrequencyData(this._floatFreqs);\n            }\n            return this._floatFreqs;\n        };\n        Analyser.prototype.drawDebugCanvas = function () {\n            var _this = this;\n            if (this._audioEngine.canUseWebAudio) {\n                if (!this._debugCanvas) {\n                    this._debugCanvas = document.createElement(\"canvas\");\n                    this._debugCanvas.width = this.DEBUGCANVASSIZE.width;\n                    this._debugCanvas.height = this.DEBUGCANVASSIZE.height;\n                    this._debugCanvas.style.position = \"absolute\";\n                    this._debugCanvas.style.top = this.DEBUGCANVASPOS.y + \"px\";\n                    this._debugCanvas.style.left = this.DEBUGCANVASPOS.x + \"px\";\n                    this._debugCanvasContext = this._debugCanvas.getContext(\"2d\");\n                    document.body.appendChild(this._debugCanvas);\n                    this._registerFunc = function () {\n                        _this.drawDebugCanvas();\n                    };\n                    this._scene.registerBeforeRender(this._registerFunc);\n                }\n                if (this._registerFunc) {\n                    var workingArray = this.getByteFrequencyData();\n                    this._debugCanvasContext.fillStyle = 'rgb(0, 0, 0)';\n                    this._debugCanvasContext.fillRect(0, 0, this.DEBUGCANVASSIZE.width, this.DEBUGCANVASSIZE.height);\n                    // Draw the frequency domain chart.\n                    for (var i = 0; i < this.getFrequencyBinCount(); i++) {\n                        var value = workingArray[i];\n                        var percent = value / this.BARGRAPHAMPLITUDE;\n                        var height = this.DEBUGCANVASSIZE.height * percent;\n                        var offset = this.DEBUGCANVASSIZE.height - height - 1;\n                        var barWidth = this.DEBUGCANVASSIZE.width / this.getFrequencyBinCount();\n                        var hue = i / this.getFrequencyBinCount() * 360;\n                        this._debugCanvasContext.fillStyle = 'hsl(' + hue + ', 100%, 50%)';\n                        this._debugCanvasContext.fillRect(i * barWidth, offset, barWidth, height);\n                    }\n                }\n            }\n        };\n        Analyser.prototype.stopDebugCanvas = function () {\n            if (this._debugCanvas) {\n                this._scene.unregisterBeforeRender(this._registerFunc);\n                this._registerFunc = null;\n                document.body.removeChild(this._debugCanvas);\n                this._debugCanvas = null;\n                this._debugCanvasContext = null;\n            }\n        };\n        Analyser.prototype.connectAudioNodes = function (inputAudioNode, outputAudioNode) {\n            if (this._audioEngine.canUseWebAudio) {\n                inputAudioNode.connect(this._webAudioAnalyser);\n                this._webAudioAnalyser.connect(outputAudioNode);\n            }\n        };\n        Analyser.prototype.dispose = function () {\n            if (this._audioEngine.canUseWebAudio) {\n                this._webAudioAnalyser.disconnect();\n            }\n        };\n        return Analyser;\n    }());\n    BABYLON.Analyser = Analyser;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.analyser.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var CubeTexture = (function (_super) {\n        __extends(CubeTexture, _super);\n        function CubeTexture(rootUrl, scene, extensions, noMipmap, files, onLoad, onError, format, prefiltered) {\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            if (format === void 0) { format = BABYLON.Engine.TEXTUREFORMAT_RGBA; }\n            if (prefiltered === void 0) { prefiltered = false; }\n            var _this = _super.call(this, scene) || this;\n            _this.coordinatesMode = BABYLON.Texture.CUBIC_MODE;\n            _this.name = rootUrl;\n            _this.url = rootUrl;\n            _this._noMipmap = noMipmap;\n            _this.hasAlpha = false;\n            _this._format = format;\n            _this._prefiltered = prefiltered;\n            if (!rootUrl && !files) {\n                return _this;\n            }\n            _this._texture = _this._getFromCache(rootUrl, noMipmap);\n            if (!files) {\n                if (!extensions) {\n                    extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n                }\n                files = [];\n                for (var index = 0; index < extensions.length; index++) {\n                    files.push(rootUrl + extensions[index]);\n                }\n                _this._extensions = extensions;\n            }\n            _this._files = files;\n            if (!_this._texture) {\n                if (!scene.useDelayedTextureLoading) {\n                    if (prefiltered) {\n                        _this._texture = scene.getEngine().createPrefilteredCubeTexture(rootUrl, scene, _this.lodGenerationScale, _this.lodGenerationOffset, onLoad, onError, format);\n                    }\n                    else {\n                        _this._texture = scene.getEngine().createCubeTexture(rootUrl, scene, files, noMipmap, onLoad, onError, _this._format);\n                    }\n                }\n                else {\n                    _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                }\n            }\n            else if (onLoad) {\n                if (_this._texture.isReady) {\n                    BABYLON.Tools.SetImmediate(function () { return onLoad(); });\n                }\n                else {\n                    _this._texture.onLoadedCallbacks.push(onLoad);\n                }\n            }\n            _this.isCube = true;\n            _this._textureMatrix = BABYLON.Matrix.Identity();\n            if (prefiltered) {\n                _this.gammaSpace = false;\n            }\n            return _this;\n        }\n        CubeTexture.CreateFromImages = function (files, scene, noMipmap) {\n            return new CubeTexture(\"\", scene, null, noMipmap, files);\n        };\n        CubeTexture.CreateFromPrefilteredData = function (url, scene) {\n            return new CubeTexture(url, scene, null, false, null, null, null, undefined, true);\n        };\n        // Methods\n        CubeTexture.prototype.delayLoad = function () {\n            if (this.delayLoadState !== BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                return;\n            }\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n            this._texture = this._getFromCache(this.url, this._noMipmap);\n            if (!this._texture) {\n                if (this._prefiltered) {\n                    this._texture = this.getScene().getEngine().createPrefilteredCubeTexture(this.url, this.getScene(), this.lodGenerationScale, this.lodGenerationOffset, undefined, undefined, this._format);\n                }\n                else {\n                    this._texture = this.getScene().getEngine().createCubeTexture(this.url, this.getScene(), this._files, this._noMipmap, undefined, undefined, this._format);\n                }\n            }\n        };\n        CubeTexture.prototype.getReflectionTextureMatrix = function () {\n            return this._textureMatrix;\n        };\n        CubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n            this._textureMatrix = value;\n        };\n        CubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n            var texture = BABYLON.SerializationHelper.Parse(function () {\n                return new BABYLON.CubeTexture(rootUrl + parsedTexture.name, scene, parsedTexture.extensions);\n            }, parsedTexture, scene);\n            // Animations\n            if (parsedTexture.animations) {\n                for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                    var parsedAnimation = parsedTexture.animations[animationIndex];\n                    texture.animations.push(BABYLON.Animation.Parse(parsedAnimation));\n                }\n            }\n            return texture;\n        };\n        CubeTexture.prototype.clone = function () {\n            var _this = this;\n            return BABYLON.SerializationHelper.Clone(function () {\n                return new CubeTexture(_this.url, _this.getScene(), _this._extensions, _this._noMipmap, _this._files);\n            }, this);\n        };\n        return CubeTexture;\n    }(BABYLON.BaseTexture));\n    BABYLON.CubeTexture = CubeTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.cubeTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var RenderTargetTexture = (function (_super) {\n        __extends(RenderTargetTexture, _super);\n        function RenderTargetTexture(name, size, scene, generateMipMaps, doNotChangeAspectRatio, type, isCube, samplingMode, generateDepthBuffer, generateStencilBuffer, isMulti) {\n            if (doNotChangeAspectRatio === void 0) { doNotChangeAspectRatio = true; }\n            if (type === void 0) { type = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            if (isCube === void 0) { isCube = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            if (generateDepthBuffer === void 0) { generateDepthBuffer = true; }\n            if (generateStencilBuffer === void 0) { generateStencilBuffer = false; }\n            if (isMulti === void 0) { isMulti = false; }\n            var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n            _this.isCube = isCube;\n            /**\n            * Use this list to define the list of mesh you want to render.\n            */\n            _this.renderList = new Array();\n            _this.renderParticles = true;\n            _this.renderSprites = false;\n            _this.coordinatesMode = BABYLON.Texture.PROJECTION_MODE;\n            // Events\n            /**\n            * An event triggered when the texture is unbind.\n            * @type {BABYLON.Observable}\n            */\n            _this.onAfterUnbindObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before rendering the texture\n            * @type {BABYLON.Observable}\n            */\n            _this.onBeforeRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering the texture\n            * @type {BABYLON.Observable}\n            */\n            _this.onAfterRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after the texture clear\n            * @type {BABYLON.Observable}\n            */\n            _this.onClearObservable = new BABYLON.Observable();\n            _this._currentRefreshId = -1;\n            _this._refreshRate = 1;\n            _this._samples = 1;\n            scene = _this.getScene();\n            _this.name = name;\n            _this.isRenderTarget = true;\n            _this._size = size;\n            _this._generateMipMaps = generateMipMaps;\n            _this._doNotChangeAspectRatio = doNotChangeAspectRatio;\n            // Rendering groups\n            _this._renderingManager = new BABYLON.RenderingManager(scene);\n            if (isMulti) {\n                return _this;\n            }\n            _this._renderTargetOptions = {\n                generateMipMaps: generateMipMaps,\n                type: type,\n                samplingMode: samplingMode,\n                generateDepthBuffer: generateDepthBuffer,\n                generateStencilBuffer: generateStencilBuffer\n            };\n            if (samplingMode === BABYLON.Texture.NEAREST_SAMPLINGMODE) {\n                _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            }\n            if (isCube) {\n                _this._texture = scene.getEngine().createRenderTargetCubeTexture(size, _this._renderTargetOptions);\n                _this.coordinatesMode = BABYLON.Texture.INVCUBIC_MODE;\n                _this._textureMatrix = BABYLON.Matrix.Identity();\n            }\n            else {\n                _this._texture = scene.getEngine().createRenderTargetTexture(size, _this._renderTargetOptions);\n            }\n            return _this;\n        }\n        Object.defineProperty(RenderTargetTexture, \"REFRESHRATE_RENDER_ONCE\", {\n            get: function () {\n                return RenderTargetTexture._REFRESHRATE_RENDER_ONCE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture, \"REFRESHRATE_RENDER_ONEVERYFRAME\", {\n            get: function () {\n                return RenderTargetTexture._REFRESHRATE_RENDER_ONEVERYFRAME;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture, \"REFRESHRATE_RENDER_ONEVERYTWOFRAMES\", {\n            get: function () {\n                return RenderTargetTexture._REFRESHRATE_RENDER_ONEVERYTWOFRAMES;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"onAfterUnbind\", {\n            set: function (callback) {\n                if (this._onAfterUnbindObserver) {\n                    this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);\n                }\n                this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"onBeforeRender\", {\n            set: function (callback) {\n                if (this._onBeforeRenderObserver) {\n                    this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n                }\n                this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"onAfterRender\", {\n            set: function (callback) {\n                if (this._onAfterRenderObserver) {\n                    this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n                }\n                this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"onClear\", {\n            set: function (callback) {\n                if (this._onClearObserver) {\n                    this.onClearObservable.remove(this._onClearObserver);\n                }\n                this._onClearObserver = this.onClearObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"renderTargetOptions\", {\n            get: function () {\n                return this._renderTargetOptions;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(RenderTargetTexture.prototype, \"samples\", {\n            get: function () {\n                return this._samples;\n            },\n            set: function (value) {\n                if (this._samples === value) {\n                    return;\n                }\n                this._samples = this.getScene().getEngine().updateRenderTargetTextureSampleCount(this._texture, value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RenderTargetTexture.prototype.resetRefreshCounter = function () {\n            this._currentRefreshId = -1;\n        };\n        Object.defineProperty(RenderTargetTexture.prototype, \"refreshRate\", {\n            get: function () {\n                return this._refreshRate;\n            },\n            // Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n            set: function (value) {\n                this._refreshRate = value;\n                this.resetRefreshCounter();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RenderTargetTexture.prototype.addPostProcess = function (postProcess) {\n            if (!this._postProcessManager) {\n                this._postProcessManager = new BABYLON.PostProcessManager(this.getScene());\n                this._postProcesses = new Array();\n            }\n            this._postProcesses.push(postProcess);\n            this._postProcesses[0].autoClear = false;\n        };\n        RenderTargetTexture.prototype.clearPostProcesses = function (dispose) {\n            if (!this._postProcesses) {\n                return;\n            }\n            if (dispose) {\n                for (var _i = 0, _a = this._postProcesses; _i < _a.length; _i++) {\n                    var postProcess = _a[_i];\n                    postProcess.dispose();\n                    postProcess = null;\n                }\n            }\n            this._postProcesses = [];\n        };\n        RenderTargetTexture.prototype.removePostProcess = function (postProcess) {\n            if (!this._postProcesses) {\n                return;\n            }\n            var index = this._postProcesses.indexOf(postProcess);\n            if (index === -1) {\n                return;\n            }\n            this._postProcesses.splice(index, 1);\n            if (this._postProcesses.length > 0) {\n                this._postProcesses[0].autoClear = false;\n            }\n        };\n        RenderTargetTexture.prototype._shouldRender = function () {\n            if (this._currentRefreshId === -1) {\n                this._currentRefreshId = 1;\n                return true;\n            }\n            if (this.refreshRate === this._currentRefreshId) {\n                this._currentRefreshId = 1;\n                return true;\n            }\n            this._currentRefreshId++;\n            return false;\n        };\n        RenderTargetTexture.prototype.isReady = function () {\n            if (!this.getScene().renderTargetsEnabled) {\n                return false;\n            }\n            return _super.prototype.isReady.call(this);\n        };\n        RenderTargetTexture.prototype.getRenderSize = function () {\n            return this._size;\n        };\n        Object.defineProperty(RenderTargetTexture.prototype, \"canRescale\", {\n            get: function () {\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RenderTargetTexture.prototype.scale = function (ratio) {\n            var newSize = this._size * ratio;\n            this.resize(newSize);\n        };\n        RenderTargetTexture.prototype.getReflectionTextureMatrix = function () {\n            if (this.isCube) {\n                return this._textureMatrix;\n            }\n            return _super.prototype.getReflectionTextureMatrix.call(this);\n        };\n        RenderTargetTexture.prototype.resize = function (size) {\n            this.releaseInternalTexture();\n            if (this.isCube) {\n                this._texture = this.getScene().getEngine().createRenderTargetCubeTexture(size, this._renderTargetOptions);\n            }\n            else {\n                this._texture = this.getScene().getEngine().createRenderTargetTexture(size, this._renderTargetOptions);\n            }\n        };\n        RenderTargetTexture.prototype.render = function (useCameraPostProcess, dumpForDebug) {\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            if (this.useCameraPostProcesses !== undefined) {\n                useCameraPostProcess = this.useCameraPostProcesses;\n            }\n            if (this._waitingRenderList) {\n                this.renderList = [];\n                for (var index = 0; index < this._waitingRenderList.length; index++) {\n                    var id = this._waitingRenderList[index];\n                    this.renderList.push(scene.getMeshByID(id));\n                }\n                delete this._waitingRenderList;\n            }\n            // Is predicate defined?\n            if (this.renderListPredicate) {\n                this.renderList.splice(0); // Clear previous renderList\n                var sceneMeshes = this.getScene().meshes;\n                for (var index = 0; index < sceneMeshes.length; index++) {\n                    var mesh = sceneMeshes[index];\n                    if (this.renderListPredicate(mesh)) {\n                        this.renderList.push(mesh);\n                    }\n                }\n            }\n            if (this.renderList && this.renderList.length === 0) {\n                return;\n            }\n            // Set custom projection.\n            // Needs to be before binding to prevent changing the aspect ratio.\n            var camera;\n            if (this.activeCamera) {\n                camera = this.activeCamera;\n                engine.setViewport(this.activeCamera.viewport);\n                if (this.activeCamera !== scene.activeCamera) {\n                    scene.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(true));\n                }\n            }\n            else {\n                camera = scene.activeCamera;\n                engine.setViewport(scene.activeCamera.viewport);\n            }\n            // Prepare renderingManager\n            this._renderingManager.reset();\n            var currentRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;\n            var currentRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;\n            var sceneRenderId = scene.getRenderId();\n            for (var meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {\n                var mesh = currentRenderList[meshIndex];\n                if (mesh) {\n                    if (!mesh.isReady()) {\n                        // Reset _currentRefreshId\n                        this.resetRefreshCounter();\n                        continue;\n                    }\n                    mesh._preActivateForIntermediateRendering(sceneRenderId);\n                    var isMasked = void 0;\n                    if (!this.renderList) {\n                        isMasked = ((mesh.layerMask & camera.layerMask) === 0);\n                    }\n                    else {\n                        isMasked = false;\n                    }\n                    if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {\n                        mesh._activate(sceneRenderId);\n                        for (var subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                            var subMesh = mesh.subMeshes[subIndex];\n                            scene._activeIndices.addCount(subMesh.indexCount, false);\n                            this._renderingManager.dispatch(subMesh);\n                        }\n                    }\n                }\n            }\n            for (var particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {\n                var particleSystem = scene.particleSystems[particleIndex];\n                if (!particleSystem.isStarted() || !particleSystem.emitter || !particleSystem.emitter.position || !particleSystem.emitter.isEnabled()) {\n                    continue;\n                }\n                if (currentRenderList.indexOf(particleSystem.emitter) >= 0) {\n                    this._renderingManager.dispatchParticles(particleSystem);\n                }\n            }\n            if (this.isCube) {\n                for (var face = 0; face < 6; face++) {\n                    this.renderToTarget(face, currentRenderList, currentRenderListLength, useCameraPostProcess, dumpForDebug);\n                    scene.incrementRenderId();\n                    scene.resetCachedMaterial();\n                }\n            }\n            else {\n                this.renderToTarget(0, currentRenderList, currentRenderListLength, useCameraPostProcess, dumpForDebug);\n            }\n            this.onAfterUnbindObservable.notifyObservers(this);\n            if (this.activeCamera && this.activeCamera !== scene.activeCamera) {\n                scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));\n            }\n            engine.setViewport(scene.activeCamera.viewport);\n            scene.resetCachedMaterial();\n        };\n        RenderTargetTexture.prototype.renderToTarget = function (faceIndex, currentRenderList, currentRenderListLength, useCameraPostProcess, dumpForDebug) {\n            var _this = this;\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            // Bind\n            if (this._postProcessManager) {\n                this._postProcessManager._prepareFrame(this._texture, this._postProcesses);\n            }\n            else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {\n                if (this.isCube) {\n                    engine.bindFramebuffer(this._texture, faceIndex);\n                }\n                else {\n                    engine.bindFramebuffer(this._texture);\n                }\n            }\n            this.onBeforeRenderObservable.notifyObservers(faceIndex);\n            // Clear\n            if (this.onClearObservable.hasObservers()) {\n                this.onClearObservable.notifyObservers(engine);\n            }\n            else {\n                engine.clear(scene.clearColor, true, true, true);\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Render\n            this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);\n            if (this._postProcessManager) {\n                this._postProcessManager._finalizeFrame(false, this._texture, faceIndex, this._postProcesses);\n            }\n            else if (useCameraPostProcess) {\n                scene.postProcessManager._finalizeFrame(false, this._texture, faceIndex);\n            }\n            if (!this._doNotChangeAspectRatio) {\n                scene.updateTransformMatrix(true);\n            }\n            // Dump ?\n            if (dumpForDebug) {\n                BABYLON.Tools.DumpFramebuffer(this._size, this._size, engine);\n            }\n            // Unbind\n            if (!this.isCube || faceIndex === 5) {\n                if (this.isCube) {\n                    if (faceIndex === 5) {\n                        engine.generateMipMapsForCubemap(this._texture);\n                    }\n                }\n                engine.unBindFramebuffer(this._texture, this.isCube, function () {\n                    _this.onAfterRenderObservable.notifyObservers(faceIndex);\n                });\n            }\n            else {\n                this.onAfterRenderObservable.notifyObservers(faceIndex);\n            }\n        };\n        /**\n         * Overrides the default sort function applied in the renderging group to prepare the meshes.\n         * This allowed control for front to back rendering or reversly depending of the special needs.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n         * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n         * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n         */\n        RenderTargetTexture.prototype.setRenderingOrder = function (renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {\n            if (opaqueSortCompareFn === void 0) { opaqueSortCompareFn = null; }\n            if (alphaTestSortCompareFn === void 0) { alphaTestSortCompareFn = null; }\n            if (transparentSortCompareFn === void 0) { transparentSortCompareFn = null; }\n            this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n        };\n        /**\n         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n         */\n        RenderTargetTexture.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n            this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n        };\n        RenderTargetTexture.prototype.clone = function () {\n            var textureSize = this.getSize();\n            var newTexture = new RenderTargetTexture(this.name, textureSize.width, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer);\n            // Base texture\n            newTexture.hasAlpha = this.hasAlpha;\n            newTexture.level = this.level;\n            // RenderTarget Texture\n            newTexture.coordinatesMode = this.coordinatesMode;\n            newTexture.renderList = this.renderList.slice(0);\n            return newTexture;\n        };\n        RenderTargetTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = _super.prototype.serialize.call(this);\n            serializationObject.renderTargetSize = this.getRenderSize();\n            serializationObject.renderList = [];\n            for (var index = 0; index < this.renderList.length; index++) {\n                serializationObject.renderList.push(this.renderList[index].id);\n            }\n            return serializationObject;\n        };\n        // This will remove the attached framebuffer objects. The texture will not be able to be used as render target anymore\n        RenderTargetTexture.prototype.disposeFramebufferObjects = function () {\n            this.getScene().getEngine()._releaseFramebufferObjects(this.getInternalTexture());\n        };\n        RenderTargetTexture.prototype.dispose = function () {\n            if (this._postProcessManager) {\n                this._postProcessManager.dispose();\n                this._postProcessManager = null;\n            }\n            this.clearPostProcesses(true);\n            // Remove from custom render targets\n            var scene = this.getScene();\n            var index = scene.customRenderTargets.indexOf(this);\n            if (index >= 0) {\n                scene.customRenderTargets.splice(index, 1);\n            }\n            for (var _i = 0, _a = scene.cameras; _i < _a.length; _i++) {\n                var camera = _a[_i];\n                index = camera.customRenderTargets.indexOf(this);\n                if (index >= 0) {\n                    camera.customRenderTargets.splice(index, 1);\n                }\n            }\n            _super.prototype.dispose.call(this);\n        };\n        return RenderTargetTexture;\n    }(BABYLON.Texture));\n    RenderTargetTexture._REFRESHRATE_RENDER_ONCE = 0;\n    RenderTargetTexture._REFRESHRATE_RENDER_ONEVERYFRAME = 1;\n    RenderTargetTexture._REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;\n    BABYLON.RenderTargetTexture = RenderTargetTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.renderTargetTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    ;\n    var MultiRenderTarget = (function (_super) {\n        __extends(MultiRenderTarget, _super);\n        function MultiRenderTarget(name, size, count, scene, options) {\n            var _this = this;\n            options = options || {};\n            var generateMipMaps = options.generateMipMaps ? options.generateMipMaps : false;\n            var generateDepthTexture = options.generateDepthTexture ? options.generateDepthTexture : false;\n            var doNotChangeAspectRatio = options.doNotChangeAspectRatio === undefined ? true : options.doNotChangeAspectRatio;\n            _this = _super.call(this, name, size, scene, generateMipMaps, doNotChangeAspectRatio) || this;\n            if (!_this.isSupported) {\n                _this.dispose();\n                return;\n            }\n            var types = [];\n            var samplingModes = [];\n            for (var i = 0; i < count; i++) {\n                if (options.types && options.types[i]) {\n                    types.push(options.types[i]);\n                }\n                else {\n                    types.push(BABYLON.Engine.TEXTURETYPE_FLOAT);\n                }\n                if (options.samplingModes && options.samplingModes[i]) {\n                    samplingModes.push(options.samplingModes[i]);\n                }\n                else {\n                    samplingModes.push(BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n                }\n            }\n            var generateDepthBuffer = options.generateDepthBuffer === undefined ? true : options.generateDepthBuffer;\n            var generateStencilBuffer = options.generateStencilBuffer === undefined ? false : options.generateStencilBuffer;\n            _this._count = count;\n            _this._size = size;\n            _this._multiRenderTargetOptions = {\n                samplingModes: samplingModes,\n                generateMipMaps: generateMipMaps,\n                generateDepthBuffer: generateDepthBuffer,\n                generateStencilBuffer: generateStencilBuffer,\n                generateDepthTexture: generateDepthTexture,\n                types: types,\n                textureCount: count\n            };\n            _this._webGLTextures = scene.getEngine().createMultipleRenderTarget(size, _this._multiRenderTargetOptions);\n            _this._createInternalTextures();\n            return _this;\n        }\n        Object.defineProperty(MultiRenderTarget.prototype, \"isSupported\", {\n            get: function () {\n                var engine = this.getScene().getEngine();\n                return engine.webGLVersion > 1 || engine.getCaps().drawBuffersExtension;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MultiRenderTarget.prototype, \"textures\", {\n            get: function () {\n                return this._textures;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MultiRenderTarget.prototype, \"depthTexture\", {\n            get: function () {\n                return this._textures[this._textures.length - 1];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MultiRenderTarget.prototype._createInternalTextures = function () {\n            this._textures = [];\n            for (var i = 0; i < this._webGLTextures.length; i++) {\n                var texture = new BABYLON.Texture(null, this.getScene());\n                texture._texture = this._webGLTextures[i];\n                this._textures.push(texture);\n            }\n            // Keeps references to frame buffer and stencil/depth buffer\n            this._texture = this._webGLTextures[0];\n        };\n        Object.defineProperty(MultiRenderTarget.prototype, \"samples\", {\n            get: function () {\n                return this._samples;\n            },\n            set: function (value) {\n                if (this._samples === value) {\n                    return;\n                }\n                for (var i = 0; i < this._webGLTextures.length; i++) {\n                    this._samples = this.getScene().getEngine().updateRenderTargetTextureSampleCount(this._webGLTextures[i], value);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MultiRenderTarget.prototype.resize = function (size) {\n            this.releaseInternalTextures();\n            this._webGLTextures = this.getScene().getEngine().createMultipleRenderTarget(size, this._multiRenderTargetOptions);\n            this._createInternalTextures();\n        };\n        MultiRenderTarget.prototype.dispose = function () {\n            this.releaseInternalTextures();\n            _super.prototype.dispose.call(this);\n        };\n        MultiRenderTarget.prototype.releaseInternalTextures = function () {\n            if (!this._webGLTextures) {\n                return;\n            }\n            for (var i = this._webGLTextures.length - 1; i >= 0; i--) {\n                if (this._webGLTextures[i] !== undefined) {\n                    this.getScene().getEngine().releaseInternalTexture(this._webGLTextures[i]);\n                    this._webGLTextures.splice(i, 1);\n                }\n            }\n        };\n        return MultiRenderTarget;\n    }(BABYLON.RenderTargetTexture));\n    BABYLON.MultiRenderTarget = MultiRenderTarget;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.multiRenderTarget.js.map\n\n/// <reference path=\"babylon.renderTargetTexture.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var MirrorTexture = (function (_super) {\n        __extends(MirrorTexture, _super);\n        function MirrorTexture(name, size, scene, generateMipMaps, type, samplingMode, generateDepthBuffer) {\n            if (type === void 0) { type = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.BILINEAR_SAMPLINGMODE; }\n            if (generateDepthBuffer === void 0) { generateDepthBuffer = true; }\n            var _this = _super.call(this, name, size, scene, generateMipMaps, true, type, false, samplingMode, generateDepthBuffer) || this;\n            _this.mirrorPlane = new BABYLON.Plane(0, 1, 0, 1);\n            _this._transformMatrix = BABYLON.Matrix.Zero();\n            _this._mirrorMatrix = BABYLON.Matrix.Zero();\n            _this._blurKernelX = 0;\n            _this._blurKernelY = 0;\n            _this._blurRatio = 1.0;\n            _this.onBeforeRenderObservable.add(function () {\n                BABYLON.Matrix.ReflectionToRef(_this.mirrorPlane, _this._mirrorMatrix);\n                _this._savedViewMatrix = scene.getViewMatrix();\n                _this._mirrorMatrix.multiplyToRef(_this._savedViewMatrix, _this._transformMatrix);\n                scene.setTransformMatrix(_this._transformMatrix, scene.getProjectionMatrix());\n                scene.clipPlane = _this.mirrorPlane;\n                scene.getEngine().cullBackFaces = false;\n                scene._mirroredCameraPosition = BABYLON.Vector3.TransformCoordinates(scene.activeCamera.position, _this._mirrorMatrix);\n            });\n            _this.onAfterRenderObservable.add(function () {\n                scene.setTransformMatrix(_this._savedViewMatrix, scene.getProjectionMatrix());\n                scene.getEngine().cullBackFaces = true;\n                scene._mirroredCameraPosition = null;\n                delete scene.clipPlane;\n            });\n            return _this;\n        }\n        Object.defineProperty(MirrorTexture.prototype, \"blurRatio\", {\n            get: function () {\n                return this._blurRatio;\n            },\n            set: function (value) {\n                if (this._blurRatio === value) {\n                    return;\n                }\n                this._blurRatio = value;\n                this._preparePostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MirrorTexture.prototype, \"blurKernel\", {\n            set: function (value) {\n                this.blurKernelX = value;\n                this.blurKernelY = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MirrorTexture.prototype, \"blurKernelX\", {\n            get: function () {\n                return this._blurKernelX;\n            },\n            set: function (value) {\n                if (this._blurKernelX === value) {\n                    return;\n                }\n                this._blurKernelX = value;\n                this._preparePostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MirrorTexture.prototype, \"blurKernelY\", {\n            get: function () {\n                return this._blurKernelY;\n            },\n            set: function (value) {\n                if (this._blurKernelY === value) {\n                    return;\n                }\n                this._blurKernelY = value;\n                this._preparePostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MirrorTexture.prototype._preparePostProcesses = function () {\n            this.clearPostProcesses(true);\n            if (this._blurKernelX && this._blurKernelY) {\n                var engine = this.getScene().getEngine();\n                var textureType = engine.getCaps().textureFloatRender ? BABYLON.Engine.TEXTURETYPE_FLOAT : BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                this._blurX = new BABYLON.BlurPostProcess(\"horizontal blur\", new BABYLON.Vector2(1.0, 0), this._blurKernelX, this._blurRatio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n                this._blurX.autoClear = false;\n                if (this._blurRatio === 1 && this.samples < 2) {\n                    this._blurX.outputTexture = this._texture;\n                }\n                else {\n                    this._blurX.alwaysForcePOT = true;\n                }\n                this._blurY = new BABYLON.BlurPostProcess(\"vertical blur\", new BABYLON.Vector2(0, 1.0), this._blurKernelY, this._blurRatio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, textureType);\n                this._blurY.autoClear = false;\n                this._blurY.alwaysForcePOT = this._blurRatio !== 1;\n                this.addPostProcess(this._blurX);\n                this.addPostProcess(this._blurY);\n            }\n        };\n        MirrorTexture.prototype.clone = function () {\n            var textureSize = this.getSize();\n            var newTexture = new MirrorTexture(this.name, textureSize.width, this.getScene(), this._renderTargetOptions.generateMipMaps, this._renderTargetOptions.type, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer);\n            // Base texture\n            newTexture.hasAlpha = this.hasAlpha;\n            newTexture.level = this.level;\n            // Mirror Texture\n            newTexture.mirrorPlane = this.mirrorPlane.clone();\n            newTexture.renderList = this.renderList.slice(0);\n            return newTexture;\n        };\n        MirrorTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = _super.prototype.serialize.call(this);\n            serializationObject.mirrorPlane = this.mirrorPlane.asArray();\n            return serializationObject;\n        };\n        return MirrorTexture;\n    }(BABYLON.RenderTargetTexture));\n    BABYLON.MirrorTexture = MirrorTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.mirrorTexture.js.map\n\n/// <reference path=\"babylon.renderTargetTexture.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n    * Creates a refraction texture used by refraction channel of the standard material.\n    * @param name the texture name\n    * @param size size of the underlying texture\n    * @param scene root scene\n    */\n    var RefractionTexture = (function (_super) {\n        __extends(RefractionTexture, _super);\n        function RefractionTexture(name, size, scene, generateMipMaps) {\n            var _this = _super.call(this, name, size, scene, generateMipMaps, true) || this;\n            _this.refractionPlane = new BABYLON.Plane(0, 1, 0, 1);\n            _this.depth = 2.0;\n            _this.onBeforeRenderObservable.add(function () {\n                scene.clipPlane = _this.refractionPlane;\n            });\n            _this.onAfterRenderObservable.add(function () {\n                delete scene.clipPlane;\n            });\n            return _this;\n        }\n        RefractionTexture.prototype.clone = function () {\n            var textureSize = this.getSize();\n            var newTexture = new RefractionTexture(this.name, textureSize.width, this.getScene(), this._generateMipMaps);\n            // Base texture\n            newTexture.hasAlpha = this.hasAlpha;\n            newTexture.level = this.level;\n            // Refraction Texture\n            newTexture.refractionPlane = this.refractionPlane.clone();\n            newTexture.renderList = this.renderList.slice(0);\n            newTexture.depth = this.depth;\n            return newTexture;\n        };\n        RefractionTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = _super.prototype.serialize.call(this);\n            serializationObject.mirrorPlane = this.refractionPlane.asArray();\n            serializationObject.depth = this.depth;\n            return serializationObject;\n        };\n        return RefractionTexture;\n    }(BABYLON.RenderTargetTexture));\n    BABYLON.RefractionTexture = RefractionTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.refractionTexture.js.map\n\n/// <reference path=\"babylon.texture.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var DynamicTexture = (function (_super) {\n        __extends(DynamicTexture, _super);\n        function DynamicTexture(name, options, scene, generateMipMaps, samplingMode, format) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            if (format === void 0) { format = BABYLON.Engine.TEXTUREFORMAT_RGBA; }\n            var _this = _super.call(this, null, scene, !generateMipMaps, undefined, samplingMode, undefined, undefined, undefined, undefined, format) || this;\n            _this.name = name;\n            var engine = _this.getScene().getEngine();\n            _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this._generateMipMaps = generateMipMaps;\n            if (options.getContext) {\n                _this._canvas = options;\n                _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n            }\n            else {\n                _this._canvas = document.createElement(\"canvas\");\n                if (options.width) {\n                    _this._texture = engine.createDynamicTexture(options.width, options.height, generateMipMaps, samplingMode);\n                }\n                else {\n                    _this._texture = engine.createDynamicTexture(options, options, generateMipMaps, samplingMode);\n                }\n            }\n            var textureSize = _this.getSize();\n            _this._canvas.width = textureSize.width;\n            _this._canvas.height = textureSize.height;\n            _this._context = _this._canvas.getContext(\"2d\");\n            return _this;\n        }\n        Object.defineProperty(DynamicTexture.prototype, \"canRescale\", {\n            get: function () {\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DynamicTexture.prototype._recreate = function (textureSize) {\n            this._canvas.width = textureSize.width;\n            this._canvas.height = textureSize.height;\n            this.releaseInternalTexture();\n            this._texture = this.getScene().getEngine().createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this._samplingMode);\n        };\n        DynamicTexture.prototype.scale = function (ratio) {\n            var textureSize = this.getSize();\n            textureSize.width *= ratio;\n            textureSize.height *= ratio;\n            this._recreate(textureSize);\n        };\n        DynamicTexture.prototype.scaleTo = function (width, height) {\n            var textureSize = this.getSize();\n            textureSize.width = width;\n            textureSize.height = height;\n            this._recreate(textureSize);\n        };\n        DynamicTexture.prototype.getContext = function () {\n            return this._context;\n        };\n        DynamicTexture.prototype.clear = function () {\n            var size = this.getSize();\n            this._context.fillRect(0, 0, size.width, size.height);\n        };\n        DynamicTexture.prototype.update = function (invertY) {\n            this.getScene().getEngine().updateDynamicTexture(this._texture, this._canvas, invertY === undefined ? true : invertY, undefined, this._format);\n        };\n        DynamicTexture.prototype.drawText = function (text, x, y, font, color, clearColor, invertY, update) {\n            if (update === void 0) { update = true; }\n            var size = this.getSize();\n            if (clearColor) {\n                this._context.fillStyle = clearColor;\n                this._context.fillRect(0, 0, size.width, size.height);\n            }\n            this._context.font = font;\n            if (x === null || x === undefined) {\n                var textSize = this._context.measureText(text);\n                x = (size.width - textSize.width) / 2;\n            }\n            if (y === null || y === undefined) {\n                var fontSize = parseInt((font.replace(/\\D/g, '')));\n                ;\n                y = (size.height / 2) + (fontSize / 3.65);\n            }\n            this._context.fillStyle = color;\n            this._context.fillText(text, x, y);\n            if (update) {\n                this.update(invertY);\n            }\n        };\n        DynamicTexture.prototype.clone = function () {\n            var textureSize = this.getSize();\n            var newTexture = new DynamicTexture(this.name, textureSize, this.getScene(), this._generateMipMaps);\n            // Base texture\n            newTexture.hasAlpha = this.hasAlpha;\n            newTexture.level = this.level;\n            // Dynamic Texture\n            newTexture.wrapU = this.wrapU;\n            newTexture.wrapV = this.wrapV;\n            return newTexture;\n        };\n        return DynamicTexture;\n    }(BABYLON.Texture));\n    BABYLON.DynamicTexture = DynamicTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.dynamicTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var VideoTexture = (function (_super) {\n        __extends(VideoTexture, _super);\n        /**\n         * Creates a video texture.\n         * Sample : https://doc.babylonjs.com/tutorials/01._Advanced_Texturing\n         * @param {Array} urlsOrVideo can be used to provide an array of urls or an already setup HTML video element.\n         * @param {BABYLON.Scene} scene is obviously the current scene.\n         * @param {boolean} generateMipMaps can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).\n         * @param {boolean} invertY is false by default but can be used to invert video on Y axis\n         * @param {number} samplingMode controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default\n         */\n        function VideoTexture(name, urlsOrVideo, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = false; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n            _this._autoLaunch = true;\n            var urls;\n            _this.name = name;\n            if (urlsOrVideo instanceof HTMLVideoElement) {\n                _this.video = urlsOrVideo;\n            }\n            else {\n                urls = urlsOrVideo;\n                _this.video = document.createElement(\"video\");\n                _this.video.autoplay = false;\n                _this.video.loop = true;\n            }\n            _this._generateMipMaps = generateMipMaps;\n            _this._samplingMode = samplingMode;\n            if (BABYLON.Tools.IsExponentOfTwo(_this.video.videoWidth) && BABYLON.Tools.IsExponentOfTwo(_this.video.videoHeight)) {\n                _this.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;\n                _this.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;\n            }\n            else {\n                _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                _this._generateMipMaps = false;\n            }\n            if (urls) {\n                _this.video.addEventListener(\"canplay\", function () {\n                    _this._createTexture();\n                });\n                urls.forEach(function (url) {\n                    var source = document.createElement(\"source\");\n                    source.src = url;\n                    _this.video.appendChild(source);\n                });\n            }\n            else {\n                _this._createTexture();\n            }\n            _this._lastUpdate = BABYLON.Tools.Now;\n            return _this;\n        }\n        VideoTexture.prototype.__setTextureReady = function () {\n            this._texture.isReady = true;\n        };\n        VideoTexture.prototype._createTexture = function () {\n            this._texture = this.getScene().getEngine().createDynamicTexture(this.video.videoWidth, this.video.videoHeight, this._generateMipMaps, this._samplingMode);\n            if (this._autoLaunch) {\n                this._autoLaunch = false;\n                this.video.play();\n            }\n            this._setTextureReady = this.__setTextureReady.bind(this);\n            this.video.addEventListener(\"playing\", this._setTextureReady);\n        };\n        VideoTexture.prototype.update = function () {\n            var now = BABYLON.Tools.Now;\n            if (now - this._lastUpdate < 15 || this.video.readyState !== this.video.HAVE_ENOUGH_DATA) {\n                return false;\n            }\n            this._lastUpdate = now;\n            this.getScene().getEngine().updateVideoTexture(this._texture, this.video, this._invertY);\n            return true;\n        };\n        VideoTexture.prototype.dispose = function () {\n            _super.prototype.dispose.call(this);\n            this.video.removeEventListener(\"playing\", this._setTextureReady);\n        };\n        VideoTexture.CreateFromWebCam = function (scene, onReady, constraints) {\n            var video = document.createElement(\"video\");\n            var constraintsDeviceId;\n            if (constraints && constraints.deviceId) {\n                constraintsDeviceId = {\n                    exact: constraints.deviceId\n                };\n            }\n            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\n            window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n            if (navigator.getUserMedia) {\n                navigator.getUserMedia({\n                    video: {\n                        deviceId: constraintsDeviceId,\n                        width: {\n                            min: (constraints && constraints.minWidth) || 256,\n                            max: (constraints && constraints.maxWidth) || 640\n                        },\n                        height: {\n                            min: (constraints && constraints.minHeight) || 256,\n                            max: (constraints && constraints.maxHeight) || 480\n                        }\n                    }\n                }, function (stream) {\n                    if (video.mozSrcObject !== undefined) {\n                        video.mozSrcObject = stream;\n                    }\n                    else {\n                        video.src = (window.URL && window.URL.createObjectURL(stream)) || stream;\n                    }\n                    video.play();\n                    if (onReady) {\n                        onReady(new BABYLON.VideoTexture(\"video\", video, scene, true, true));\n                    }\n                }, function (e) {\n                    BABYLON.Tools.Error(e.name);\n                });\n            }\n        };\n        return VideoTexture;\n    }(BABYLON.Texture));\n    BABYLON.VideoTexture = VideoTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.videoTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var RawTexture = (function (_super) {\n        __extends(RawTexture, _super);\n        function RawTexture(data, width, height, format, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            var _this = _super.call(this, null, scene, !generateMipMaps, invertY) || this;\n            _this.format = format;\n            _this._texture = scene.getEngine().createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode);\n            _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            return _this;\n        }\n        RawTexture.prototype.update = function (data) {\n            this.getScene().getEngine().updateRawTexture(this._texture, data, this.format, this._invertY);\n        };\n        // Statics\n        RawTexture.CreateLuminanceTexture = function (data, width, height, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            return new RawTexture(data, width, height, BABYLON.Engine.TEXTUREFORMAT_LUMINANCE, scene, generateMipMaps, invertY, samplingMode);\n        };\n        RawTexture.CreateLuminanceAlphaTexture = function (data, width, height, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            return new RawTexture(data, width, height, BABYLON.Engine.TEXTUREFORMAT_LUMINANCE_ALPHA, scene, generateMipMaps, invertY, samplingMode);\n        };\n        RawTexture.CreateAlphaTexture = function (data, width, height, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            return new RawTexture(data, width, height, BABYLON.Engine.TEXTUREFORMAT_ALPHA, scene, generateMipMaps, invertY, samplingMode);\n        };\n        RawTexture.CreateRGBTexture = function (data, width, height, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            return new RawTexture(data, width, height, BABYLON.Engine.TEXTUREFORMAT_RGB, scene, generateMipMaps, invertY, samplingMode);\n        };\n        RawTexture.CreateRGBATexture = function (data, width, height, scene, generateMipMaps, invertY, samplingMode) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (invertY === void 0) { invertY = false; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            return new RawTexture(data, width, height, BABYLON.Engine.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode);\n        };\n        return RawTexture;\n    }(BABYLON.Texture));\n    BABYLON.RawTexture = RawTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.rawTexture.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcess = (function () {\n        function PostProcess(name, fragmentUrl, parameters, samplers, options, camera, samplingMode, engine, reusable, defines, textureType, vertexUrl, indexParameters, blockCompilation) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.NEAREST_SAMPLINGMODE; }\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            if (vertexUrl === void 0) { vertexUrl = \"postprocess\"; }\n            if (blockCompilation === void 0) { blockCompilation = false; }\n            this.name = name;\n            this.width = -1;\n            this.height = -1;\n            this.autoClear = true;\n            this.alphaMode = BABYLON.Engine.ALPHA_DISABLE;\n            /*\n                Enable Pixel Perfect mode where texture is not scaled to be power of 2.\n                Can only be used on a single postprocess or on the last one of a chain.\n            */\n            this.enablePixelPerfectMode = false;\n            this.scaleMode = BABYLON.Engine.SCALEMODE_FLOOR;\n            this.alwaysForcePOT = false;\n            this.samples = 1;\n            this._reusable = false;\n            this._textures = new BABYLON.SmartArray(2);\n            this._currentRenderTextureInd = 0;\n            this._scaleRatio = new BABYLON.Vector2(1, 1);\n            this._texelSize = BABYLON.Vector2.Zero();\n            // Events\n            /**\n            * An event triggered when the postprocess is activated.\n            * @type {BABYLON.Observable}\n            */\n            this.onActivateObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the postprocess changes its size.\n            * @type {BABYLON.Observable}\n            */\n            this.onSizeChangedObservable = new BABYLON.Observable();\n            /**\n            * An event triggered when the postprocess applies its effect.\n            * @type {BABYLON.Observable}\n            */\n            this.onApplyObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before rendering the postprocess\n            * @type {BABYLON.Observable}\n            */\n            this.onBeforeRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering the postprocess\n            * @type {BABYLON.Observable}\n            */\n            this.onAfterRenderObservable = new BABYLON.Observable();\n            if (camera != null) {\n                this._camera = camera;\n                this._scene = camera.getScene();\n                camera.attachPostProcess(this);\n                this._engine = this._scene.getEngine();\n            }\n            else {\n                this._engine = engine;\n            }\n            this._options = options;\n            this.renderTargetSamplingMode = samplingMode ? samplingMode : BABYLON.Texture.NEAREST_SAMPLINGMODE;\n            this._reusable = reusable || false;\n            this._textureType = textureType;\n            this._samplers = samplers || [];\n            this._samplers.push(\"textureSampler\");\n            this._fragmentUrl = fragmentUrl;\n            this._vertexUrl = vertexUrl;\n            this._parameters = parameters || [];\n            this._parameters.push(\"scale\");\n            this._indexParameters = indexParameters;\n            if (!blockCompilation) {\n                this.updateEffect(defines);\n            }\n        }\n        Object.defineProperty(PostProcess.prototype, \"onActivate\", {\n            set: function (callback) {\n                if (this._onActivateObserver) {\n                    this.onActivateObservable.remove(this._onActivateObserver);\n                }\n                this._onActivateObserver = this.onActivateObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"onSizeChanged\", {\n            set: function (callback) {\n                if (this._onSizeChangedObserver) {\n                    this.onSizeChangedObservable.remove(this._onSizeChangedObserver);\n                }\n                this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"onApply\", {\n            set: function (callback) {\n                if (this._onApplyObserver) {\n                    this.onApplyObservable.remove(this._onApplyObserver);\n                }\n                this._onApplyObserver = this.onApplyObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"onBeforeRender\", {\n            set: function (callback) {\n                if (this._onBeforeRenderObserver) {\n                    this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n                }\n                this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"onAfterRender\", {\n            set: function (callback) {\n                if (this._onAfterRenderObserver) {\n                    this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n                }\n                this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"outputTexture\", {\n            get: function () {\n                return this._textures.data[this._currentRenderTextureInd];\n            },\n            set: function (value) {\n                this._forcedOutputTexture = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PostProcess.prototype.getCamera = function () {\n            return this._camera;\n        };\n        Object.defineProperty(PostProcess.prototype, \"texelSize\", {\n            get: function () {\n                if (this._shareOutputWithPostProcess) {\n                    return this._shareOutputWithPostProcess.texelSize;\n                }\n                if (this._forcedOutputTexture) {\n                    this._texelSize.copyFromFloats(1.0 / this._forcedOutputTexture._width, 1.0 / this._forcedOutputTexture._height);\n                }\n                return this._texelSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PostProcess.prototype.getEngine = function () {\n            return this._engine;\n        };\n        PostProcess.prototype.getEffect = function () {\n            return this._effect;\n        };\n        PostProcess.prototype.shareOutputWith = function (postProcess) {\n            this._disposeTextures();\n            this._shareOutputWithPostProcess = postProcess;\n            return this;\n        };\n        PostProcess.prototype.updateEffect = function (defines, uniforms, samplers, indexParameters, onCompiled, onError) {\n            this._effect = this._engine.createEffect({ vertex: this._vertexUrl, fragment: this._fragmentUrl }, [\"position\"], uniforms || this._parameters, samplers || this._samplers, defines !== undefined ? defines : \"\", null, onCompiled, onError, indexParameters || this._indexParameters);\n        };\n        PostProcess.prototype.isReusable = function () {\n            return this._reusable;\n        };\n        /** invalidate frameBuffer to hint the postprocess to create a depth buffer */\n        PostProcess.prototype.markTextureDirty = function () {\n            this.width = -1;\n        };\n        PostProcess.prototype.activate = function (camera, sourceTexture, forceDepthStencil) {\n            var _this = this;\n            if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {\n                camera = camera || this._camera;\n                var scene = camera.getScene();\n                var maxSize = camera.getEngine().getCaps().maxTextureSize;\n                var requiredWidth = ((sourceTexture ? sourceTexture._width : this._engine.getRenderingCanvas().width) * this._options) | 0;\n                var requiredHeight = ((sourceTexture ? sourceTexture._height : this._engine.getRenderingCanvas().height) * this._options) | 0;\n                var desiredWidth = this._options.width || requiredWidth;\n                var desiredHeight = this._options.height || requiredHeight;\n                if (this.renderTargetSamplingMode === BABYLON.Texture.TRILINEAR_SAMPLINGMODE || this.alwaysForcePOT) {\n                    if (!this._options.width) {\n                        desiredWidth = BABYLON.Tools.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode);\n                    }\n                    if (!this._options.height) {\n                        desiredHeight = BABYLON.Tools.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode);\n                    }\n                }\n                if (this.width !== desiredWidth || this.height !== desiredHeight) {\n                    if (this._textures.length > 0) {\n                        for (var i = 0; i < this._textures.length; i++) {\n                            this._engine._releaseTexture(this._textures.data[i]);\n                        }\n                        this._textures.reset();\n                    }\n                    this.width = desiredWidth;\n                    this.height = desiredHeight;\n                    var textureSize = { width: this.width, height: this.height };\n                    var textureOptions = {\n                        generateMipMaps: false,\n                        generateDepthBuffer: forceDepthStencil || camera._postProcesses.indexOf(this) === 0,\n                        generateStencilBuffer: (forceDepthStencil || camera._postProcesses.indexOf(this) === 0) && this._engine.isStencilEnable,\n                        samplingMode: this.renderTargetSamplingMode,\n                        type: this._textureType\n                    };\n                    this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n                    if (this._reusable) {\n                        this._textures.push(this._engine.createRenderTargetTexture(textureSize, textureOptions));\n                    }\n                    this._texelSize.copyFromFloats(1.0 / this.width, 1.0 / this.height);\n                    this.onSizeChangedObservable.notifyObservers(this);\n                }\n                this._textures.forEach(function (texture) {\n                    if (texture.samples !== _this.samples) {\n                        _this._engine.updateRenderTargetTextureSampleCount(texture, _this.samples);\n                    }\n                });\n            }\n            var target;\n            if (this._shareOutputWithPostProcess) {\n                target = this._shareOutputWithPostProcess.outputTexture;\n            }\n            else if (this._forcedOutputTexture) {\n                target = this._forcedOutputTexture;\n                this.width = this._forcedOutputTexture._width;\n                this.height = this._forcedOutputTexture._height;\n            }\n            else {\n                target = this.outputTexture;\n            }\n            if (this.enablePixelPerfectMode) {\n                this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);\n                this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight);\n            }\n            else {\n                this._scaleRatio.copyFromFloats(1, 1);\n                this._engine.bindFramebuffer(target);\n            }\n            this.onActivateObservable.notifyObservers(camera);\n            // Clear\n            if (this.autoClear && this.alphaMode === BABYLON.Engine.ALPHA_DISABLE) {\n                this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, true, true, true);\n            }\n            if (this._reusable) {\n                this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;\n            }\n        };\n        Object.defineProperty(PostProcess.prototype, \"isSupported\", {\n            get: function () {\n                return this._effect.isSupported;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PostProcess.prototype, \"aspectRatio\", {\n            get: function () {\n                if (this._shareOutputWithPostProcess) {\n                    return this._shareOutputWithPostProcess.aspectRatio;\n                }\n                if (this._forcedOutputTexture) {\n                    var size = this._forcedOutputTexture._width / this._forcedOutputTexture._height;\n                }\n                return this.width / this.height;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PostProcess.prototype.apply = function () {\n            // Check\n            if (!this._effect || !this._effect.isReady())\n                return null;\n            // States\n            this._engine.enableEffect(this._effect);\n            this._engine.setState(false);\n            this._engine.setDepthBuffer(false);\n            this._engine.setDepthWrite(false);\n            // Alpha\n            this._engine.setAlphaMode(this.alphaMode);\n            if (this.alphaConstants) {\n                this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);\n            }\n            // Texture            \n            var source;\n            if (this._shareOutputWithPostProcess) {\n                source = this._shareOutputWithPostProcess.outputTexture;\n            }\n            else if (this._forcedOutputTexture) {\n                source = this._forcedOutputTexture;\n            }\n            else {\n                source = this.outputTexture;\n            }\n            this._effect._bindTexture(\"textureSampler\", source);\n            // Parameters\n            this._effect.setVector2(\"scale\", this._scaleRatio);\n            this.onApplyObservable.notifyObservers(this._effect);\n            return this._effect;\n        };\n        PostProcess.prototype._disposeTextures = function () {\n            if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {\n                return;\n            }\n            if (this._textures.length > 0) {\n                for (var i = 0; i < this._textures.length; i++) {\n                    this._engine._releaseTexture(this._textures.data[i]);\n                }\n            }\n            this._textures.dispose();\n        };\n        PostProcess.prototype.dispose = function (camera) {\n            camera = camera || this._camera;\n            this._disposeTextures();\n            if (!camera) {\n                return;\n            }\n            camera.detachPostProcess(this);\n            var index = camera._postProcesses.indexOf(this);\n            if (index === 0 && camera._postProcesses.length > 0) {\n                this._camera._postProcesses[0].markTextureDirty();\n            }\n            this.onActivateObservable.clear();\n            this.onAfterRenderObservable.clear();\n            this.onApplyObservable.clear();\n            this.onBeforeRenderObservable.clear();\n            this.onSizeChangedObservable.clear();\n        };\n        return PostProcess;\n    }());\n    BABYLON.PostProcess = PostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PassPostProcess = (function (_super) {\n        __extends(PassPostProcess, _super);\n        function PassPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            return _super.call(this, name, \"pass\", null, null, options, camera, samplingMode, engine, reusable, null, textureType) || this;\n        }\n        return PassPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.PassPostProcess = PassPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.passPostProcess.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var ShadowGenerator = (function () {\n        /**\n         * Creates a ShadowGenerator object.\n         * A ShadowGenerator is the required tool to use the shadows.\n         * Each light casting shadows needs to use its own ShadowGenerator.\n         * Required parameters :\n         * - `mapSize` (integer): the size of the texture what stores the shadows. Example : 1024.\n         * - `light`: the light object generating the shadows.\n         * - `useFullFloatFirst`: by default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.\n         * Documentation : http://doc.babylonjs.com/tutorials/shadows\n         */\n        function ShadowGenerator(mapSize, light, useFullFloatFirst) {\n            // Members\n            this._bias = 0.00005;\n            this._blurBoxOffset = 1;\n            this._blurScale = 2;\n            this._blurKernel = 1;\n            this._useKernelBlur = false;\n            this._filter = ShadowGenerator.FILTER_NONE;\n            this._darkness = 0;\n            this._transparencyShadow = false;\n            this.forceBackFacesOnly = false;\n            this._lightDirection = BABYLON.Vector3.Zero();\n            this._viewMatrix = BABYLON.Matrix.Zero();\n            this._projectionMatrix = BABYLON.Matrix.Zero();\n            this._transformMatrix = BABYLON.Matrix.Zero();\n            this._worldViewProjection = BABYLON.Matrix.Zero();\n            this._currentFaceIndex = 0;\n            this._currentFaceIndexCache = 0;\n            this._isCube = false;\n            this._defaultTextureMatrix = BABYLON.Matrix.Identity();\n            this._mapSize = mapSize;\n            this._light = light;\n            this._scene = light.getScene();\n            light._shadowGenerator = this;\n            // Texture type fallback from float to int if not supported.\n            var caps = this._scene.getEngine().getCaps();\n            if (!useFullFloatFirst) {\n                if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                }\n                else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                }\n                else {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                }\n            }\n            else {\n                if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                }\n                else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                }\n                else {\n                    this._textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                }\n            }\n            this._initializeGenerator();\n        }\n        Object.defineProperty(ShadowGenerator, \"FILTER_NONE\", {\n            // Static\n            get: function () {\n                return ShadowGenerator._FILTER_NONE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator, \"FILTER_POISSONSAMPLING\", {\n            get: function () {\n                return ShadowGenerator._FILTER_POISSONSAMPLING;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator, \"FILTER_EXPONENTIALSHADOWMAP\", {\n            get: function () {\n                return ShadowGenerator._FILTER_EXPONENTIALSHADOWMAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator, \"FILTER_BLUREXPONENTIALSHADOWMAP\", {\n            get: function () {\n                return ShadowGenerator._FILTER_BLUREXPONENTIALSHADOWMAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator, \"FILTER_CLOSEEXPONENTIALSHADOWMAP\", {\n            get: function () {\n                return ShadowGenerator._FILTER_CLOSEEXPONENTIALSHADOWMAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator, \"FILTER_BLURCLOSEEXPONENTIALSHADOWMAP\", {\n            get: function () {\n                return ShadowGenerator._FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"bias\", {\n            get: function () {\n                return this._bias;\n            },\n            set: function (bias) {\n                this._bias = bias;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"blurBoxOffset\", {\n            get: function () {\n                return this._blurBoxOffset;\n            },\n            set: function (value) {\n                if (this._blurBoxOffset === value) {\n                    return;\n                }\n                this._blurBoxOffset = value;\n                this._disposeBlurPostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"blurScale\", {\n            get: function () {\n                return this._blurScale;\n            },\n            set: function (value) {\n                if (this._blurScale === value) {\n                    return;\n                }\n                this._blurScale = value;\n                this._disposeBlurPostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"blurKernel\", {\n            get: function () {\n                return this._blurKernel;\n            },\n            set: function (value) {\n                if (this._blurKernel === value) {\n                    return;\n                }\n                this._blurKernel = value;\n                this._disposeBlurPostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useKernelBlur\", {\n            get: function () {\n                return this._useKernelBlur;\n            },\n            set: function (value) {\n                if (this._useKernelBlur === value) {\n                    return;\n                }\n                this._useKernelBlur = value;\n                this._disposeBlurPostProcesses();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"depthScale\", {\n            get: function () {\n                return this._depthScale !== undefined ? this._depthScale : this._light.getDepthScale();\n            },\n            set: function (value) {\n                this._depthScale = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"filter\", {\n            get: function () {\n                return this._filter;\n            },\n            set: function (value) {\n                // Blurring the cubemap is going to be too expensive. Reverting to unblurred version\n                if (this._light.needCube()) {\n                    if (value === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {\n                        this.useExponentialShadowMap = true;\n                        return;\n                    }\n                    else if (value === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {\n                        this.useCloseExponentialShadowMap = true;\n                        return;\n                    }\n                }\n                if (this._filter === value) {\n                    return;\n                }\n                this._filter = value;\n                this._disposeBlurPostProcesses();\n                this._applyFilterValues();\n                this._light._markMeshesAsLightDirty();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"usePoissonSampling\", {\n            get: function () {\n                return this.filter === ShadowGenerator.FILTER_POISSONSAMPLING;\n            },\n            set: function (value) {\n                this.filter = (value ? ShadowGenerator.FILTER_POISSONSAMPLING : ShadowGenerator.FILTER_NONE);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useVarianceShadowMap\", {\n            get: function () {\n                BABYLON.Tools.Warn(\"VSM are now replaced by ESM. Please use useExponentialShadowMap instead.\");\n                return this.useExponentialShadowMap;\n            },\n            set: function (value) {\n                BABYLON.Tools.Warn(\"VSM are now replaced by ESM. Please use useExponentialShadowMap instead.\");\n                this.useExponentialShadowMap = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useBlurVarianceShadowMap\", {\n            get: function () {\n                BABYLON.Tools.Warn(\"VSM are now replaced by ESM. Please use useBlurExponentialShadowMap instead.\");\n                return this.useBlurExponentialShadowMap;\n            },\n            set: function (value) {\n                BABYLON.Tools.Warn(\"VSM are now replaced by ESM. Please use useBlurExponentialShadowMap instead.\");\n                this.useBlurExponentialShadowMap = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useExponentialShadowMap\", {\n            get: function () {\n                return this.filter === ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;\n            },\n            set: function (value) {\n                this.filter = (value ? ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useBlurExponentialShadowMap\", {\n            get: function () {\n                return this.filter === ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;\n            },\n            set: function (value) {\n                this.filter = (value ? ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useCloseExponentialShadowMap\", {\n            get: function () {\n                return this.filter === ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;\n            },\n            set: function (value) {\n                this.filter = (value ? ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ShadowGenerator.prototype, \"useBlurCloseExponentialShadowMap\", {\n            get: function () {\n                return this.filter === ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;\n            },\n            set: function (value) {\n                this.filter = (value ? ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP : ShadowGenerator.FILTER_NONE);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Returns the darkness value (float).\n         */\n        ShadowGenerator.prototype.getDarkness = function () {\n            return this._darkness;\n        };\n        /**\n         * Sets the ShadowGenerator darkness value (float <= 1.0).\n         * Returns the ShadowGenerator.\n         */\n        ShadowGenerator.prototype.setDarkness = function (darkness) {\n            if (darkness >= 1.0)\n                this._darkness = 1.0;\n            else if (darkness <= 0.0)\n                this._darkness = 0.0;\n            else\n                this._darkness = darkness;\n            return this;\n        };\n        /**\n         * Sets the ability to have transparent shadow (boolean).\n         * Returns the ShadowGenerator.\n         */\n        ShadowGenerator.prototype.setTransparencyShadow = function (hasShadow) {\n            this._transparencyShadow = hasShadow;\n            return this;\n        };\n        /**\n         * Returns a RenderTargetTexture object : the shadow map texture.\n         */\n        ShadowGenerator.prototype.getShadowMap = function () {\n            return this._shadowMap;\n        };\n        /**\n         * Returns the most ready computed shadow map as a RenderTargetTexture object.\n         */\n        ShadowGenerator.prototype.getShadowMapForRendering = function () {\n            if (this._shadowMap2) {\n                return this._shadowMap2;\n            }\n            return this._shadowMap;\n        };\n        /**\n         * Returns the associated light object.\n         */\n        ShadowGenerator.prototype.getLight = function () {\n            return this._light;\n        };\n        ShadowGenerator.prototype._initializeGenerator = function () {\n            this._light._markMeshesAsLightDirty();\n            this._initializeShadowMap();\n        };\n        ShadowGenerator.prototype._initializeShadowMap = function () {\n            var _this = this;\n            // Render target\n            this._shadowMap = new BABYLON.RenderTargetTexture(this._light.name + \"_shadowMap\", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());\n            this._shadowMap.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._shadowMap.anisotropicFilteringLevel = 1;\n            this._shadowMap.updateSamplingMode(BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            this._shadowMap.renderParticles = false;\n            // Record Face Index before render.\n            this._shadowMap.onBeforeRenderObservable.add(function (faceIndex) {\n                _this._currentFaceIndex = faceIndex;\n            });\n            // Custom render function.\n            this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this);\n            // Blur if required afer render.\n            this._shadowMap.onAfterUnbindObservable.add(function () {\n                if (!_this.useBlurExponentialShadowMap && !_this.useBlurCloseExponentialShadowMap) {\n                    return;\n                }\n                if (!_this._blurPostProcesses) {\n                    _this._initializeBlurRTTAndPostProcesses();\n                }\n                _this._scene.postProcessManager.directRender(_this._blurPostProcesses, _this.getShadowMapForRendering().getInternalTexture());\n            });\n            // Clear according to the chosen filter.\n            this._shadowMap.onClearObservable.add(function (engine) {\n                if (_this.useExponentialShadowMap || _this.useBlurExponentialShadowMap) {\n                    engine.clear(new BABYLON.Color4(0, 0, 0, 0), true, true, true);\n                }\n                else {\n                    engine.clear(new BABYLON.Color4(1.0, 1.0, 1.0, 1.0), true, true, true);\n                }\n            });\n        };\n        ShadowGenerator.prototype._initializeBlurRTTAndPostProcesses = function () {\n            var _this = this;\n            var engine = this._scene.getEngine();\n            var targetSize = this._mapSize / this.blurScale;\n            if (!this.useKernelBlur || this.blurScale !== 1.0) {\n                this._shadowMap2 = new BABYLON.RenderTargetTexture(this._light.name + \"_shadowMap2\", targetSize, this._scene, false, true, this._textureType);\n                this._shadowMap2.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                this._shadowMap2.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                this._shadowMap2.updateSamplingMode(BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            }\n            if (this.useKernelBlur) {\n                this._kernelBlurXPostprocess = new BABYLON.BlurPostProcess(this._light.name + \"KernelBlurX\", new BABYLON.Vector2(1, 0), this.blurKernel, 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n                this._kernelBlurXPostprocess.width = targetSize;\n                this._kernelBlurXPostprocess.height = targetSize;\n                this._kernelBlurXPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setTexture(\"textureSampler\", _this._shadowMap);\n                });\n                this._kernelBlurYPostprocess = new BABYLON.BlurPostProcess(this._light.name + \"KernelBlurY\", new BABYLON.Vector2(0, 1), this.blurKernel, 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);\n                this._kernelBlurXPostprocess.autoClear = false;\n                this._kernelBlurYPostprocess.autoClear = false;\n                if (this._textureType === BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT) {\n                    this._kernelBlurXPostprocess.packedFloat = true;\n                    this._kernelBlurYPostprocess.packedFloat = true;\n                }\n                this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];\n            }\n            else {\n                this._boxBlurPostprocess = new BABYLON.PostProcess(this._light.name + \"DepthBoxBlur\", \"depthBoxBlur\", [\"screenSize\", \"boxOffset\"], [], 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, \"#define OFFSET \" + this._blurBoxOffset, this._textureType);\n                this._boxBlurPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setFloat2(\"screenSize\", targetSize, targetSize);\n                    effect.setTexture(\"textureSampler\", _this._shadowMap);\n                });\n                this._boxBlurPostprocess.autoClear = false;\n                this._blurPostProcesses = [this._boxBlurPostprocess];\n            }\n        };\n        ShadowGenerator.prototype._renderForShadowMap = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes) {\n            var index;\n            for (index = 0; index < opaqueSubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);\n            }\n            for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);\n            }\n            if (this._transparencyShadow) {\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    this._renderSubMeshForShadowMap(transparentSubMeshes.data[index]);\n                }\n            }\n        };\n        ShadowGenerator.prototype._renderSubMeshForShadowMap = function (subMesh) {\n            var _this = this;\n            var mesh = subMesh.getRenderingMesh();\n            var scene = this._scene;\n            var engine = scene.getEngine();\n            // Culling\n            engine.setState(subMesh.getMaterial().backFaceCulling);\n            // Managing instances\n            var batch = mesh._getInstancesRenderList(subMesh._id);\n            if (batch.mustReturn) {\n                return;\n            }\n            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);\n            if (this.isReady(subMesh, hardwareInstancedRendering)) {\n                engine.enableEffect(this._effect);\n                mesh._bind(subMesh, this._effect, BABYLON.Material.TriangleFillMode);\n                var material = subMesh.getMaterial();\n                this._effect.setFloat2(\"biasAndScale\", this.bias, this.depthScale);\n                this._effect.setMatrix(\"viewProjection\", this.getTransformMatrix());\n                this._effect.setVector3(\"lightPosition\", this.getLight().position);\n                this._effect.setFloat2(\"depthValues\", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera));\n                // Alpha test\n                if (material && material.needAlphaTesting()) {\n                    var alphaTexture = material.getAlphaTestTexture();\n                    if (alphaTexture) {\n                        this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix() || this._defaultTextureMatrix);\n                    }\n                }\n                // Bones\n                if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                    this._effect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n                }\n                if (this.forceBackFacesOnly) {\n                    engine.setState(true, 0, false, true);\n                }\n                // Draw\n                mesh._processRendering(subMesh, this._effect, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix(\"world\", world); });\n                if (this.forceBackFacesOnly) {\n                    engine.setState(true, 0, false, false);\n                }\n            }\n            else {\n                // Need to reset refresh rate of the shadowMap\n                this._shadowMap.resetRefreshCounter();\n            }\n        };\n        ShadowGenerator.prototype._applyFilterValues = function () {\n            if (this.filter === ShadowGenerator.FILTER_NONE) {\n                this._shadowMap.updateSamplingMode(BABYLON.Texture.NEAREST_SAMPLINGMODE);\n            }\n            else {\n                this._shadowMap.updateSamplingMode(BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            }\n        };\n        /**\n         * Boolean : true when the ShadowGenerator is finally computed.\n         */\n        ShadowGenerator.prototype.isReady = function (subMesh, useInstances) {\n            var defines = [];\n            if (this._textureType !== BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT) {\n                defines.push(\"#define FLOAT\");\n            }\n            if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n                defines.push(\"#define ESM\");\n            }\n            var attribs = [BABYLON.VertexBuffer.PositionKind];\n            var mesh = subMesh.getMesh();\n            var material = subMesh.getMaterial();\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                var alphaTexture = material.getAlphaTestTexture();\n                if (alphaTexture) {\n                    defines.push(\"#define ALPHATEST\");\n                    if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                        attribs.push(BABYLON.VertexBuffer.UVKind);\n                        defines.push(\"#define UV1\");\n                    }\n                    if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                        if (alphaTexture.coordinatesIndex === 1) {\n                            attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                            defines.push(\"#define UV2\");\n                        }\n                    }\n                }\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect\n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._effect = this._scene.getEngine().createEffect(\"shadowMap\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"lightPosition\", \"depthValues\", \"biasAndScale\"], [\"diffuseSampler\"], join);\n            }\n            return this._effect.isReady();\n        };\n        /**\n         * This creates the defines related to the standard BJS materials.\n         */\n        ShadowGenerator.prototype.prepareDefines = function (defines, lightIndex) {\n            var scene = this._scene;\n            var light = this._light;\n            if (!scene.shadowsEnabled || !light.shadowEnabled) {\n                return;\n            }\n            defines[\"SHADOW\" + lightIndex] = true;\n            if (this.usePoissonSampling) {\n                defines[\"SHADOWPCF\" + lightIndex] = true;\n            }\n            else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {\n                defines[\"SHADOWESM\" + lightIndex] = true;\n            }\n            else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {\n                defines[\"SHADOWCLOSEESM\" + lightIndex] = true;\n            }\n            if (light.needCube()) {\n                defines[\"SHADOWCUBE\" + lightIndex] = true;\n            }\n        };\n        /**\n         * This binds shadow lights related to the standard BJS materials.\n         * It implies the unifroms available on the materials are the standard BJS ones.\n         */\n        ShadowGenerator.prototype.bindShadowLight = function (lightIndex, effect) {\n            var light = this._light;\n            var scene = this._scene;\n            if (!scene.shadowsEnabled || !light.shadowEnabled) {\n                return;\n            }\n            if (!light.needCube()) {\n                effect.setMatrix(\"lightMatrix\" + lightIndex, this.getTransformMatrix());\n            }\n            effect.setTexture(\"shadowSampler\" + lightIndex, this.getShadowMapForRendering());\n            light._uniformBuffer.updateFloat3(\"shadowsInfo\", this.getDarkness(), this.blurScale / this.getShadowMap().getSize().width, this.depthScale, lightIndex);\n            light._uniformBuffer.updateFloat2(\"depthValues\", this.getLight().getDepthMinZ(scene.activeCamera), this.getLight().getDepthMinZ(scene.activeCamera) + this.getLight().getDepthMaxZ(scene.activeCamera), lightIndex);\n        };\n        // Methods\n        /**\n         * Returns a Matrix object : the updated transformation matrix.\n         */\n        ShadowGenerator.prototype.getTransformMatrix = function () {\n            var scene = this._scene;\n            if (this._currentRenderID === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {\n                return this._transformMatrix;\n            }\n            this._currentRenderID = scene.getRenderId();\n            this._currentFaceIndexCache = this._currentFaceIndex;\n            var lightPosition = this._light.position;\n            if (this._light.computeTransformedInformation()) {\n                lightPosition = this._light.transformedPosition;\n            }\n            BABYLON.Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);\n            if (Math.abs(BABYLON.Vector3.Dot(this._lightDirection, BABYLON.Vector3.Up())) === 1.0) {\n                this._lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\n            }\n            if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {\n                this._cachedPosition = lightPosition.clone();\n                this._cachedDirection = this._lightDirection.clone();\n                BABYLON.Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), BABYLON.Vector3.Up(), this._viewMatrix);\n                this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, this.getShadowMap().renderList);\n                this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);\n            }\n            return this._transformMatrix;\n        };\n        ShadowGenerator.prototype.recreateShadowMap = function () {\n            // Track render list.\n            var renderList = this._shadowMap.renderList;\n            // Clean up existing data.\n            this._disposeRTTandPostProcesses();\n            // Reinitializes.\n            this._initializeGenerator();\n            // Reaffect the filter to ensure a correct fallback if necessary.\n            this.filter = this.filter;\n            // Reaffect the filter.\n            this._applyFilterValues();\n            // Reaffect Render List.\n            this._shadowMap.renderList = renderList;\n        };\n        ShadowGenerator.prototype._disposeBlurPostProcesses = function () {\n            if (this._shadowMap2) {\n                this._shadowMap2.dispose();\n                this._shadowMap2 = null;\n            }\n            if (this._downSamplePostprocess) {\n                this._downSamplePostprocess.dispose();\n                this._downSamplePostprocess = null;\n            }\n            if (this._boxBlurPostprocess) {\n                this._boxBlurPostprocess.dispose();\n                this._boxBlurPostprocess = null;\n            }\n            if (this._kernelBlurXPostprocess) {\n                this._kernelBlurXPostprocess.dispose();\n                this._kernelBlurXPostprocess = null;\n            }\n            if (this._kernelBlurYPostprocess) {\n                this._kernelBlurYPostprocess.dispose();\n                this._kernelBlurYPostprocess = null;\n            }\n            this._blurPostProcesses = null;\n        };\n        ShadowGenerator.prototype._disposeRTTandPostProcesses = function () {\n            if (this._shadowMap) {\n                this._shadowMap.dispose();\n                this._shadowMap = null;\n            }\n            this._disposeBlurPostProcesses();\n        };\n        /**\n         * Disposes the ShadowGenerator.\n         * Returns nothing.\n         */\n        ShadowGenerator.prototype.dispose = function () {\n            this._disposeRTTandPostProcesses();\n            this._light._shadowGenerator = null;\n            this._light._markMeshesAsLightDirty();\n        };\n        /**\n         * Serializes the ShadowGenerator and returns a serializationObject.\n         */\n        ShadowGenerator.prototype.serialize = function () {\n            var serializationObject = {};\n            var shadowMap = this.getShadowMap();\n            serializationObject.lightId = this._light.id;\n            serializationObject.mapSize = shadowMap.getRenderSize();\n            serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;\n            serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;\n            serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n            serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;\n            serializationObject.usePoissonSampling = this.usePoissonSampling;\n            serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;\n            serializationObject.depthScale = this.depthScale;\n            serializationObject.darkness = this.getDarkness();\n            serializationObject.blurBoxOffset = this.blurBoxOffset;\n            serializationObject.blurKernel = this.blurKernel;\n            serializationObject.blurScale = this.blurScale;\n            serializationObject.useKernelBlur = this.useKernelBlur;\n            serializationObject.transparencyShadow = this._transparencyShadow;\n            serializationObject.renderList = [];\n            for (var meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {\n                var mesh = shadowMap.renderList[meshIndex];\n                serializationObject.renderList.push(mesh.id);\n            }\n            return serializationObject;\n        };\n        /**\n         * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.\n         */\n        ShadowGenerator.Parse = function (parsedShadowGenerator, scene) {\n            //casting to point light, as light is missing the position attr and typescript complains.\n            var light = scene.getLightByID(parsedShadowGenerator.lightId);\n            var shadowGenerator = new ShadowGenerator(parsedShadowGenerator.mapSize, light);\n            var shadowMap = shadowGenerator.getShadowMap();\n            for (var meshIndex = 0; meshIndex < parsedShadowGenerator.renderList.length; meshIndex++) {\n                var meshes = scene.getMeshesByID(parsedShadowGenerator.renderList[meshIndex]);\n                meshes.forEach(function (mesh) {\n                    shadowMap.renderList.push(mesh);\n                });\n            }\n            if (parsedShadowGenerator.usePoissonSampling) {\n                shadowGenerator.usePoissonSampling = true;\n            }\n            else if (parsedShadowGenerator.useExponentialShadowMap) {\n                shadowGenerator.useExponentialShadowMap = true;\n            }\n            else if (parsedShadowGenerator.useBlurExponentialShadowMap) {\n                shadowGenerator.useBlurExponentialShadowMap = true;\n            }\n            else if (parsedShadowGenerator.useCloseExponentialShadowMap) {\n                shadowGenerator.useCloseExponentialShadowMap = true;\n            }\n            else if (parsedShadowGenerator.useBlurExponentialShadowMap) {\n                shadowGenerator.useBlurCloseExponentialShadowMap = true;\n            }\n            else if (parsedShadowGenerator.useVarianceShadowMap) {\n                shadowGenerator.useExponentialShadowMap = true;\n            }\n            else if (parsedShadowGenerator.useBlurVarianceShadowMap) {\n                shadowGenerator.useBlurExponentialShadowMap = true;\n            }\n            if (parsedShadowGenerator.depthScale) {\n                shadowGenerator.depthScale = parsedShadowGenerator.depthScale;\n            }\n            if (parsedShadowGenerator.blurScale) {\n                shadowGenerator.blurScale = parsedShadowGenerator.blurScale;\n            }\n            if (parsedShadowGenerator.blurBoxOffset) {\n                shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;\n            }\n            if (parsedShadowGenerator.useKernelBlur) {\n                shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;\n            }\n            if (parsedShadowGenerator.blurKernel) {\n                shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;\n            }\n            if (parsedShadowGenerator.bias !== undefined) {\n                shadowGenerator.bias = parsedShadowGenerator.bias;\n            }\n            if (parsedShadowGenerator.darkness) {\n                shadowGenerator.setDarkness(parsedShadowGenerator.darkness);\n            }\n            if (parsedShadowGenerator.transparencyShadow) {\n                shadowGenerator.setTransparencyShadow(true);\n            }\n            shadowGenerator.forceBackFacesOnly = parsedShadowGenerator.forceBackFacesOnly;\n            return shadowGenerator;\n        };\n        return ShadowGenerator;\n    }());\n    ShadowGenerator._FILTER_NONE = 0;\n    ShadowGenerator._FILTER_EXPONENTIALSHADOWMAP = 1;\n    ShadowGenerator._FILTER_POISSONSAMPLING = 2;\n    ShadowGenerator._FILTER_BLUREXPONENTIALSHADOWMAP = 3;\n    ShadowGenerator._FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;\n    ShadowGenerator._FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;\n    BABYLON.ShadowGenerator = ShadowGenerator;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.shadowGenerator.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var DefaultLoadingScreen = (function () {\n        function DefaultLoadingScreen(_renderingCanvas, _loadingText, _loadingDivBackgroundColor) {\n            if (_loadingText === void 0) { _loadingText = \"\"; }\n            if (_loadingDivBackgroundColor === void 0) { _loadingDivBackgroundColor = \"black\"; }\n            var _this = this;\n            this._renderingCanvas = _renderingCanvas;\n            this._loadingText = _loadingText;\n            this._loadingDivBackgroundColor = _loadingDivBackgroundColor;\n            // Resize\n            this._resizeLoadingUI = function () {\n                var canvasRect = _this._renderingCanvas.getBoundingClientRect();\n                var canvasPositioning = window.getComputedStyle(_this._renderingCanvas).position;\n                _this._loadingDiv.style.position = (canvasPositioning === \"fixed\") ? \"fixed\" : \"absolute\";\n                _this._loadingDiv.style.left = canvasRect.left + \"px\";\n                _this._loadingDiv.style.top = canvasRect.top + \"px\";\n                _this._loadingDiv.style.width = canvasRect.width + \"px\";\n                _this._loadingDiv.style.height = canvasRect.height + \"px\";\n            };\n        }\n        DefaultLoadingScreen.prototype.displayLoadingUI = function () {\n            if (this._loadingDiv) {\n                // Do not add a loading screen if there is already one  \n                return;\n            }\n            this._loadingDiv = document.createElement(\"div\");\n            this._loadingDiv.id = \"babylonjsLoadingDiv\";\n            this._loadingDiv.style.opacity = \"0\";\n            this._loadingDiv.style.transition = \"opacity 1.5s ease\";\n            // Loading text\n            this._loadingTextDiv = document.createElement(\"div\");\n            this._loadingTextDiv.style.position = \"absolute\";\n            this._loadingTextDiv.style.left = \"0\";\n            this._loadingTextDiv.style.top = \"50%\";\n            this._loadingTextDiv.style.marginTop = \"80px\";\n            this._loadingTextDiv.style.width = \"100%\";\n            this._loadingTextDiv.style.height = \"20px\";\n            this._loadingTextDiv.style.fontFamily = \"Arial\";\n            this._loadingTextDiv.style.fontSize = \"14px\";\n            this._loadingTextDiv.style.color = \"white\";\n            this._loadingTextDiv.style.textAlign = \"center\";\n            this._loadingTextDiv.innerHTML = \"Loading\";\n            this._loadingDiv.appendChild(this._loadingTextDiv);\n            //set the predefined text\n            this._loadingTextDiv.innerHTML = this._loadingText;\n            // Generating keyframes\n            var style = document.createElement('style');\n            style.type = 'text/css';\n            var keyFrames = \"@-webkit-keyframes spin1 {                    0% { -webkit-transform: rotate(0deg);}\\n                    100% { -webkit-transform: rotate(360deg);}\\n                }                @keyframes spin1 {                    0% { transform: rotate(0deg);}\\n                    100% { transform: rotate(360deg);}\\n                }\";\n            style.innerHTML = keyFrames;\n            document.getElementsByTagName('head')[0].appendChild(style);\n            // Loading img\n            var imgBack = new Image();\n            imgBack.src = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAYq0lEQVR4Xu2dCZRcVZnHScAJUZSwjSOIbAJmEAZwQCCMoAInYRGIg8AwegQx7AFzUBBmzAFlE4EAwxz2GRk2w7AnAURZBiEOZgyEQDAQAjmEJqTpNd3V1V3Vmd+/6utKV7/1vnpVXd2p/zn3vOV+27vfu/fd/W3QQAPrBZqbm7fJZrN79vf3T+/r67uf4wO9vb37WXQDIwWtra0Tenp6voQTv5XP56/BkfcR3iLk1g6B7hEeI+zP5V+ZiAbqBZ2dnZ8lV+6Gg87CobfhpOc4byf0FjwYE9DneBkWcXrM2tmzNzTxDdQKJPyETCazI46YgiMuI9zJuXJltuChFIHsP/PSfIfTjU19A2mira1tcxy3ey6XO5vEnkV4kes11XBmENDVj97XOT2O03FmWgMuoNLzGRJva8IUnPkzjjcT/kLoKCZzfQB7XiX8M2G8md7AUJgzJ+Z6e88gZ1xGuj3HsY17PcVkrG9gp7CUF/F8PUvxqdZDrFq1ahNVfKjwTCYxZuDE2wjKlc2WViMePM+HPNsFPOdf22OPblD5OZQHvphnV65cjTMzxaQY3eA5V9OO/hmnm1lSjE7woFsQbiXki4++foHnXkW4mLC1JUl947333tsMY3emqfB9jtPJlXN5U0+bOXPmWCPxgOccSy4+AfqPio+9/oFnbyatbqVE28GSZfjQ1NT0KQzaHMcdyPfyaNoE12HcvdxT29K3Fkv8A2vWrPmcifAFZNtD91yRY+SBZ+9UsMtEgD+jTpeenp6JXI6xpKkuUDqRcA6Kr0Wpens+InQTnIpV6Fdi+BQT64ulS5eOIzefD62na7CeoGcnLCM8ykt5OWlzcPv772/BS/w3nP+K+xU11+DvQe5dcrQlTfWAwbNMb8XA8AyGX80xtLlA6TAJuteMbVhhia1v5VMcr+LWMeoZ4xiYw7q6urbhHbgG+paCkIRQehHu4pO3O5fVydEomF5Ulx548JfVD2wqfKE2I3R3ob/f2GoC1DWhdz7HG3i5j2pvb9+Z24m6HvVZQtYsZFWcowlzePEP4jJdR/OQhxTVpAs9NMXxmZxuZKo8IG4s+v8R2tUFphSBTBWzH+OAFwn/gS3TuN55xYoVqfc6dXd3fwHZ1xFaTX0iyGbwjJqXXAammxP00EXx6UMGEx7ram7+vKnzBZ/87Xiwp40tEdDTgYwlHG/CmadSjO7L+XiialOZAej7POFG2VK0Khngl6Pn8/LL0YEtlFh4n8oDAqvaAYH8tzH2iNDm1IIFn8Ax50G7xtgCAU07CfAG4RHOz+vLZL7e0dGxlYlKHaj8BHo25xgrsfV5wrYH4KmouxV+ZZDnCUdwmXxMGgFvFUVWD+jQuOot6rI0tb4gcfaG9v+MrcAn+wj38gL8C7cObmlp2ZRjOkWYD6ypuAf6zjFHLSJ0c/6YQ813DM/yZXgehreiVgP8cvSfsOeExYsXuzs6n8v9j8mqBRZQmdjXVPuira1NHSpn8UDf4Xu0vd2uCtDzacJOlDDf5ng94X8JTWarB8R1EK7ju7udiYgEz/v3pLFKm4oHUHhh3iZdfshpaEYpA4pvKLLXBujLYKRq71XLhUHg27z12rW9B6L/QhLrWWxRH7nzeDK8awi/5HRTEx0K6MZQ694LHk0DqrgfADkreIYz1q5c+UlTEQzesIuMryrggYQWjNL3RGO7p2tuFMeqjaOidgzyCz1yJMTJ6L6d66WEVCcHIO/dQkI75Chs2g97Hoc3jRz9Lge1ED5l4r0gckqRPB0gTw34t1B+h3IqxZkmrn2SULUa7ezZszdE5xfR9130Xsm5ilrnHrmkQOcKvrkncxqrIiY6wlewbw7BOUfDo/b84zzvj9C7J7eCS0NrUiRKCPjUE7ScMBdlF/B2HqBi0ERXBcuXL99YnQz9fX2ah3Up4UnsWGEmDRuUhoTn+Z5PfvbZZ2N/fuCZRJgnfhNVBu73EZoIKt7l0L2UBsYeDZg016nb5EUCWuXQewinUtTuyq2aTStF14a8SD+VDQVj6hDYxjuXf4Hjl83sSMCmTp8j4FtoMuRQ5dAZcii3kk/0s2bBhxIcBxjxUlib1hWInEDO/6qKV+y4geO5HAMntEE/pq+nZyo0ywsG1SmwL4Orf+0yqGCfmvR73LAn9lAeBjQTEhkA+1h49a08iRflcq4H5iuXFU9cz4lqihC/LXS/NZa6Bc+pz5gql5ub6VXD2tZWTSPeyS7XgeLhXrMnEhj6MSHSwaIhFGZH8oA/JzzFeexvJbRN2HW03moT6cEChx6w4QY2rurn85JWrxsiCy0FwjcIqos8w7GZNPulkawDEbFHlaBtjzODEDrVztuKXMmADPWA3RaljyJeNdKq98ilAez8iJdyGqfO31V4NoV/EvyaCqR54V2EshE5Lqcb+TrkstkTLD4WKB4PNNZQ8P05HAelMXNSPWChC8JsYvwthJo0jSoF6fIqjjqe08Aat+LIkd+AVjn09zxbZFqK3tjXAUbXUaWDjTUSyN4J45YZX2Igo4cEOVfFson2ALIxSjR0jog5YNgpfNHM90BxIjDyWIB8Z2NfB01HISJ20wPaw4w1FlavXq1v8aPGXhFw9JNRFTDItifU/RwwpfmKxYsDK180kU4x0lhAXvOSJUs+bezlIDL2N4xi4GpjK4MGCuzUA+SPxzn3m4iKgKyV2DCV08DeMWg0B+zHHOt2DpjS3Mz1BfFOM25C5ZH4LxldJBB0g7GVARkaXgv8VsKqZtIMPpN9RUnJgRzU5Wfp22vifcG3+2vQvmdsdQXsX2pm+oKX+GYjjQXkPWqsXshpRhcJ0RpbGShSHiSuheP37ZYHsGusVHOrU1lMxkO9od4eE+8LlSzQqfetpnPAooBN/2Um+gISp89MkF8K4G3RrMJYoOhbYGxlQEGhSOGogfoLwipExGtUZVVBYIVAluaAaUpuWA+YujlPF22Ra/iBLYEOsV6tV4w0FiitfmLsXiBMU0NiAVrfsp77Zd8MHPgbDoHtva6uLs1jiv1piAKy5tCG+4KJ9wVO/p6RDzvy+b5rzSwP9Okh/WKPERiCWzfk4K8bUSTiOljAyCdx5DZG4gE8W5Dov+NYUfsV/j50fUC4dmXIQDh0qQ6PVgJsOcLM8oA410Ggvo6Ojr81di+g2TKuQOiyJOKWxlpCJpM5zUjKAL3awTsamQfEbYhjtDGKa5tPsyn/wAuiURftlBO56h6aunEwCMxxvV1d+2Fr7Jce2vAu5LUtLeoGi/19gtbToCaR97BoD6BvUs+WkXqgbw6OuhC6wH5l4rRGaCFOvYnjYbyxnpcsCvDVhYOxo6+zszNwSNHVTtJEmSiwzlMAQmNPwIPW42Dds2hfEK/5WJo0Fth+5VNxFHSlkoTzFRh/N3wnq0OGWxXtdoO8enFwaI4jsyidYgNZTxhrMEjEJ4w+En65ESWRXZ7Q4K/COqDAPlhka87WedB8KawmngTIHREOJs5pMiRp+p/GGgxL1FiA9hxjK6G1tVVdhJGAV15+cPXq1f7dahVC20Wg4miCp0uTe3Xh4Hwu93rY1B7SR/t7xQbP5R1FGgpy8IlKe+MJhZ9Aa7u5jPm+pGLX2BMDOZ+hDXgQiXIJ5xoXHZg96anEEFcvOTi0SMUXS4w0FijSTzTWYEA3hkTSEtDI2qw6RoytDLA6jctCvzKqJ8oPFOO7kAhnYe9cZGiWiZ/N9ezguWaSL4h3TUfvKJIfoN0I4sjigYSdZyxlcDVMgEczEY41ER6oZFBOh2Yqegf2zYoziFC3DuZZrjSTPLDtMlxaNPmPP/54W2OPxksrVozP5fLPGr8vEOpbxJCr3jQSJyDvGRNRhv7iHh8vE5LMpKznHBz4zSTOaXwe+mXGGh9tbWvVQf+iyfCAON/ZlTj4v43ECfB94Le4CuMrWVpTtw7O9fZOM5M8oD7xVSOLBdLuNWN1g7bgJUF8+4qpBjf7Te9M6hD4tBDc0289Wh2MHbuaSR7gsHOMLBaQ9W/G6o5MJrNDPu9dcYdQ33Yc95I6OFV5hnp2cGCliDingX5KU+9MShd0dmqta/k8J4zwnV2JsuuNxAnI83VwNpO52kiSoC4djA255cuXBzYPycGzjTQWkPdNY00OfRcQVLafRnd39ySLLsG1i20AyPZ3cDb7AyNJgnp1cOhUHUhcFiL045v9jTUa8Gjlm29fsQQhb3DzJLUEhC+oiK7EISPOwapoEh+7JQJti5YfGXs0YNC62ouC1h9lsrlToClsjc/RM7uSe0kd3EmlzTO/Kqk8Q106mM/Yw2aOB9jnOg6sWTHxJ9FraSJMy6nGz7RbZUDYmN7e3BnQ5Gisez7u3J9c0JwA6Pb0aCFvNObgwKk6NoU59uJwaJ8y1viAT4vCtEFXYO8SFQGtCZpllyXQtNqL+4lmZ/BN/5qJKQFZozEHe9JtAGSaw4wsFnie4JmUQcjleh8yZq0Fnmq3y0D02IzPMgnonYqYIfA4pC+TcXrgIahLB+PEb5s5HrjaR0b7kbHGB0pK7TDO1/T39x1lUZGAPlUH0xTbz+KSoC4dDDx2DQCHzTCaWOB5zjbW+KCSpW0IS0BIJmy6zWCk7WDuxZ4r5oO6dHB7e/sBZo4H2OfUsYOv9jHW+ECJdkAtA/c6MpmMd+XaEKj7km9M4F5TEfBzSKovDLKG1cHobw+b6EDa3WOksYBPAhevBUJMxl8GJTRhFyMLBKSJFn5ls9nvmogS0DfaHOzb3h8AcUuNNBLQNiWa0gRv4MwMMyBwCqxAfCIH82JdYSJKQN+ocjA5NHD2I/e1aj/23iPyhbG6A+bAgXsZoUEII/UAkkQORu71JqIE7o22HBw4VaelpWU74mPPDc/39d1trO5Qb4vJ8QXxbwat06WofcTInMCzeToAtN4VXUn/l1AXDkan9tDSfmL6C81BZooHxDkN9CMveLFZFFAWWZtDwVta3G0sJcAbe3bmYEiniShBXabcL+wflQDD5mD0yKlvk0b/Tk33AG5F7idG+/ibRe54oEl1nLG6A+ZYe1jyAIuG/u2LB3MazxwAfL5vJFGJinxQUwcju6c/n3+FNPm5JhJyy2k/sQTp5nm+2HBJCGi1X1WpwzuBoQXAN+IcjDz8mdePKi/WhH1uxd7GcCjIVBcWpUYDfZ0VbclEJSr2akMBhVrdX6j+Jx3DpSh7vKB8CIiqKwcrcXGqdr05k3RKbU9ryTQVkUB3aHMrEshw7kGCXiv8xxG0h6Uzent6Fpn6MhA17A6GT/3yTxNO1coJbgWur3JFf1fXNuTes5AZe18xXobFHJKv04JZc3O7CtIcgGL9KW03u3QCfL4D4b292dhrpoYgsYOhEz4kaOuHqXKqiagYiN9QnUlyKgX84JUYsQFP9GKzMFRSe8XJb9upE9Dn62CK/KQT75wdTLz+NXgPNdrDuYzeUd0ByN4Wp07n+EdCRZuTY1/ymZQDwIjQye9pA32xdw6IiUgHc639mN8kzCLRjkxzQRzitUpkZ8LZBP1CILUd55EVvdgsCrzJl5i8mgCja+Zgjst4Pq3DUnMmtSWqyNIuQruRU3+CbO08n+pvBAZAjf1IU5kcGJc0YRMBfVV3MPd2RN4+YbvYukI/3sSpe+LUmbw0ryG/6ts1oSLeYrMw6C0xeaFAGc+Wq3hbfeRk582b55lrzf3UHJwWkD0Wp+6BQ3+BfXEXw6UCdHX4TVB0BoJi9Y1Cp59XbUWN8HW7lRjLli3zbINE+1hNiCRI1cGakIhT99ani/A6z1z1nDoUqNQfbO40kyqDfrCBwMg3E5rsCy+8sFlHR8dEnFzRTq/I8hQ9NFFOtGhXVOxgFeUqfknUK7Ctpjl1ANKJ/vmUkvrdwRZmWjpA4J9MTyja2toKY8TQa/ufxP/Whdd5c5cQJHIwfBsTvkKiaqd6/fRyOHKqavdL0H+V2sxmWvrQCAeKItfmQlNyDG/8SVwnetMHyxmA7lm0K2I7GFrlVBW/V6FPP9GqeU4V0Kt2+O2yhctUN6AJBEWD9ngMnessJxh5AfCoQe+8q+xQOYLuWbQrQh2MXP1XYh8S9DKC2sI1z6kCatW3/RCZ6Vj9fNPMqx2wQVNJQlcNEl/mGG5pv48bi7HxMVSOoHsW7QqPg5GlvnJtk6/B9+HMqYUfaXE6rampqWy4dVhgi8FfLprnBXEex+i/wCSkNiSNDSpUxxt7Ccj2nQQYAwUHc9yE3HEotuifDklnfFYMdGNC/lWCxotDf4PvB/jHZTs71c+f2n+ryqCPPcb5/pKdGrTvbH2MUjH4ByOLBDpON9YSFi5cuI1FOwFbbyTox5T6y+iwFL8CqvWvwVtolWgSv/N4sXbl5ZP3r8hRLT50d56KgYJDCYXVhYOhtqqReKDdZuGJtSQSOk8f67x581SspvH3lpoBe9Vefbg/lzveaXmnAf6tEDMNGRp3LnV3ch29o10lQIf+bOKZc+XnmMGARF2EK4vUwQiSw33n7ZlqDWwcaK9Ob29vd26vwj+OT8m3kKFxdd9tlILSJ1Wo8Y8RZT/YiKOY4le5P3SGZJAc7telg7FroL16Jc/n/a1cBBCxsSblwT8LOfofcCh4AQ4x1uoCXZtgVKnYDXLMUECnPSQD29VBcrhfVw7GHrVXb6WylGg0SvUZcrr+YPYuwWVfaE9ltmpA2Q6EQq2UY+yigzf2oqCH4v4MIysD94fdwdig9uqDnB4T5/d+gwHPGNVFcOopyJiPLOfmGTwa0Ek8qS8RKDKORLFWH95utwbDd94SRqqN/Cv4PDXbTFfXfUZWBvRUPJCRBJiIqfnnccy0Dz74wHkWoypY2D4ZGU8gK+kKjQKQ8RcTW1uQI2fmc7nH7LIMFEW+sw6xdyN4CgvNByNIDjp+ZyRVhzlV7dVLaZc7t1cRoW0w9of/No6ptbuRdZupqC3QPZY33HchMkbJiRPssgyaHkN82XaJXPtOJuN+JRuixQI6Cu1VXiZtJehcFGpeNPyXI6cqPWTIvsxU1R7o912akevre4OHfTHot3fEfRbD3y8+Qu0djO5Ce5UXNGl7dTt4z0RGqnOuhgLZgmcPk2FHrrd3jgwkAVQ58e1ioxjcHeMLPWQcq+5gZKm9+hJHjXo5z4xQBQsxxyDjEfir+nNq5GfQo/nYh6f9e4NUgGEFx3DEzvw1nPrOhSJ+kh6GUBUHw6//Kmls96dJ2qv6FxNF9z8g405kVLVXDfkaiFAd4JIkttYUGFpyDOf91Ch/YVEe8DA/gORpuywDfLNMjBOQt4qEupbTPTX4YeJig+/qrnoxkfMeIdH2UHGBfP0H6kFepElc1rY5lBQYXZbzuO7BWYH7b3V3d/+TX1FEG/JSExEJdOi7qsnrx3DuNM8Zdg2NqnN/BjK0EXlVhxORr56wP6Lv/DT+X1FzYLynaOWe2s1TjCQW4An9t6Jk4hBVdH6YpB9YNXoS+SRk/JaQZHd5J2CnesLuyGaze3KZ2hTemoNcpO+uB3pAQuzvC7SeJSfc0258Wo97aX9PT+TmMEMB73jsO0wJzXnVx4llL7pe5kWaFtSqGHHgu6rpPr5jsdx+hyI59G+hA4C25GDO1V69mbf/77h0+lZpzZX44B+Ye1X1cWKz92pKrYlcjtzc6gfN+ufhApd/ErcwTvuTRNI0m4c4Tg77u6gfbCHdTuQcrRFaRKiFU7Xl1O/RqX9RObevRxR43gmEBYUn9wEJIMeF/jk0yVKTta2tE0jg43kx1OatWifEYKDrHYKGDnfkMrU1xHUPaoh7k8i+030EvoV3c6i4aTCoc/9+9NVkFgh6BmZFaig08he3oxYkwBEkQGCzg7gfG6kzaDvuSyLfgIyqt1cF6SAspoS4iJf3c9xaf3JrGEgUzZcOGgvO4agzjTQUkI9V5z4851MuLhBvUUp1gR7tjXEHL+shXFZnduNIBomi6T73FVLLByQePu4N3CxMbVxyzfeQUTYZrdpA3yvoPVf/1jdTGggC6aXx0ieLSecFcWoj72vkhU4IcswU7gVORksb6FHnufbouJ4Xbv+gf1g0EADav9uSeO9YenpA3IfURFVZ0gqEms1rRg0qCzM4TuYy1T061jt0dXXpX0xJ96FMDXIqQXtJ3tSfze6OaY0KU1ogfTUgUJMK0lBIL06dS/F/LJeRe0k2kAAk7BgSWN2GVW/aCOjRuPCbBHVGBG6J3ECKIN3VlfjroguqA+RrMsFvCNqisf5mRox2qPlB4s8vuiMdIE/fVjVvLlRnhKlqYLig7QIpOiva40PAqR2E22neJFrN10AVgWMOIDgPuMOjmRFa+HVaR0fHliaugXoEOe80nBWrZg2dZkZoYffuaW5u1kCVkadmbT70AGdqJodWOhxHqP2eFg1UDvsLatnSFq41M+KKnp6eXbhsdB2OdGiCeX8+/2ecqgnmk/VXNYtqYLSAnNposzpjgw3+H/belpVa8J7TAAAAAElFTkSuQmCC\";\n            imgBack.style.position = \"absolute\";\n            imgBack.style.left = \"50%\";\n            imgBack.style.top = \"50%\";\n            imgBack.style.marginLeft = \"-60px\";\n            imgBack.style.marginTop = \"-60px\";\n            imgBack.style.animation = \"spin1 2s infinite ease-in-out\";\n            imgBack.style.webkitAnimation = \"spin1 2s infinite ease-in-out\";\n            imgBack.style.transformOrigin = \"50% 50%\";\n            imgBack.style.webkitTransformOrigin = \"50% 50%\";\n            this._loadingDiv.appendChild(imgBack);\n            this._resizeLoadingUI();\n            window.addEventListener(\"resize\", this._resizeLoadingUI);\n            this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;\n            document.body.appendChild(this._loadingDiv);\n            this._loadingDiv.style.opacity = \"1\";\n        };\n        DefaultLoadingScreen.prototype.hideLoadingUI = function () {\n            var _this = this;\n            if (!this._loadingDiv) {\n                return;\n            }\n            var onTransitionEnd = function () {\n                if (!_this._loadingDiv) {\n                    return;\n                }\n                document.body.removeChild(_this._loadingDiv);\n                window.removeEventListener(\"resize\", _this._resizeLoadingUI);\n                _this._loadingDiv = null;\n            };\n            this._loadingDiv.style.opacity = \"0\";\n            this._loadingDiv.addEventListener(\"transitionend\", onTransitionEnd);\n        };\n        Object.defineProperty(DefaultLoadingScreen.prototype, \"loadingUIText\", {\n            set: function (text) {\n                this._loadingText = text;\n                if (this._loadingTextDiv) {\n                    this._loadingTextDiv.innerHTML = this._loadingText;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultLoadingScreen.prototype, \"loadingUIBackgroundColor\", {\n            get: function () {\n                return this._loadingDivBackgroundColor;\n            },\n            set: function (color) {\n                this._loadingDivBackgroundColor = color;\n                if (!this._loadingDiv) {\n                    return;\n                }\n                this._loadingDiv.style.backgroundColor = this._loadingDivBackgroundColor;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return DefaultLoadingScreen;\n    }());\n    BABYLON.DefaultLoadingScreen = DefaultLoadingScreen;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.loadingScreen.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SceneLoader = (function () {\n        function SceneLoader() {\n        }\n        Object.defineProperty(SceneLoader, \"NO_LOGGING\", {\n            get: function () {\n                return 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"MINIMAL_LOGGING\", {\n            get: function () {\n                return 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"SUMMARY_LOGGING\", {\n            get: function () {\n                return 2;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"DETAILED_LOGGING\", {\n            get: function () {\n                return 3;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"ForceFullSceneLoadingForIncremental\", {\n            get: function () {\n                return SceneLoader._ForceFullSceneLoadingForIncremental;\n            },\n            set: function (value) {\n                SceneLoader._ForceFullSceneLoadingForIncremental = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"ShowLoadingScreen\", {\n            get: function () {\n                return SceneLoader._ShowLoadingScreen;\n            },\n            set: function (value) {\n                SceneLoader._ShowLoadingScreen = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SceneLoader, \"loggingLevel\", {\n            get: function () {\n                return SceneLoader._loggingLevel;\n            },\n            set: function (value) {\n                SceneLoader._loggingLevel = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        SceneLoader._getDefaultPlugin = function () {\n            return SceneLoader._registeredPlugins[\".babylon\"];\n        };\n        SceneLoader._getPluginForExtension = function (extension) {\n            var registeredPlugin = SceneLoader._registeredPlugins[extension];\n            if (registeredPlugin) {\n                return registeredPlugin;\n            }\n            return SceneLoader._getDefaultPlugin();\n        };\n        SceneLoader._getPluginForDirectLoad = function (data) {\n            for (var extension in SceneLoader._registeredPlugins) {\n                var plugin = SceneLoader._registeredPlugins[extension].plugin;\n                if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {\n                    return SceneLoader._registeredPlugins[extension];\n                }\n            }\n            return SceneLoader._getDefaultPlugin();\n        };\n        SceneLoader._getPluginForFilename = function (sceneFilename) {\n            if (sceneFilename.name) {\n                sceneFilename = sceneFilename.name;\n            }\n            var dotPosition = sceneFilename.lastIndexOf(\".\");\n            var queryStringPosition = sceneFilename.indexOf(\"?\");\n            if (queryStringPosition === -1) {\n                queryStringPosition = sceneFilename.length;\n            }\n            var extension = sceneFilename.substring(dotPosition, queryStringPosition).toLowerCase();\n            return SceneLoader._getPluginForExtension(extension);\n        };\n        // use babylon file loader directly if sceneFilename is prefixed with \"data:\"\n        SceneLoader._getDirectLoad = function (sceneFilename) {\n            if (sceneFilename.substr && sceneFilename.substr(0, 5) === \"data:\") {\n                return sceneFilename.substr(5);\n            }\n            return null;\n        };\n        // Public functions\n        SceneLoader.GetPluginForExtension = function (extension) {\n            return SceneLoader._getPluginForExtension(extension).plugin;\n        };\n        SceneLoader.RegisterPlugin = function (plugin) {\n            if (typeof plugin.extensions === \"string\") {\n                var extension = plugin.extensions;\n                SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n                    plugin: plugin,\n                    isBinary: false\n                };\n            }\n            else {\n                var extensions = plugin.extensions;\n                Object.keys(extensions).forEach(function (extension) {\n                    SceneLoader._registeredPlugins[extension.toLowerCase()] = {\n                        plugin: plugin,\n                        isBinary: extensions[extension].isBinary\n                    };\n                });\n            }\n        };\n        SceneLoader.ImportMesh = function (meshesNames, rootUrl, sceneFilename, scene, onsuccess, progressCallBack, onerror) {\n            if (sceneFilename.substr && sceneFilename.substr(0, 1) === \"/\") {\n                BABYLON.Tools.Error(\"Wrong sceneFilename parameter\");\n                return;\n            }\n            if (sceneFilename.substr && sceneFilename.substr(0, 1) === \"/\") {\n                BABYLON.Tools.Error(\"Wrong sceneFilename parameter\");\n                return;\n            }\n            var directLoad = SceneLoader._getDirectLoad(sceneFilename);\n            var loadingToken = {};\n            scene._addPendingData(loadingToken);\n            var manifestChecked = function (success) {\n                scene.database = database;\n                var registeredPlugin = directLoad ? SceneLoader._getPluginForDirectLoad(directLoad) : SceneLoader._getPluginForFilename(sceneFilename);\n                var plugin = registeredPlugin.plugin;\n                var useArrayBuffer = registeredPlugin.isBinary;\n                var importMeshFromData = function (data) {\n                    var meshes = [];\n                    var particleSystems = [];\n                    var skeletons = [];\n                    if (scene.isDisposed) {\n                        if (onerror) {\n                            onerror(scene, 'Scene was disposed before being able to load ' + rootUrl + sceneFilename);\n                        }\n                        return;\n                    }\n                    try {\n                        if (plugin.importMesh) {\n                            var syncedPlugin = plugin;\n                            if (!syncedPlugin.importMesh(meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons)) {\n                                if (onerror) {\n                                    onerror(scene, 'Unable to import meshes from ' + rootUrl + sceneFilename);\n                                }\n                                scene._removePendingData(loadingToken);\n                                return;\n                            }\n                            if (onsuccess) {\n                                scene.importedMeshesFiles.push(rootUrl + sceneFilename);\n                                onsuccess(meshes, particleSystems, skeletons);\n                                scene._removePendingData(loadingToken);\n                            }\n                        }\n                        else {\n                            var asyncedPlugin = plugin;\n                            asyncedPlugin.importMeshAsync(meshesNames, scene, data, rootUrl, function (meshes, particleSystems, skeletons) {\n                                if (onsuccess) {\n                                    scene.importedMeshesFiles.push(rootUrl + sceneFilename);\n                                    onsuccess(meshes, particleSystems, skeletons);\n                                    scene._removePendingData(loadingToken);\n                                }\n                            }, function () {\n                                if (onerror) {\n                                    onerror(scene, 'Unable to import meshes from ' + rootUrl + sceneFilename);\n                                }\n                                scene._removePendingData(loadingToken);\n                            });\n                        }\n                    }\n                    catch (e) {\n                        if (onerror) {\n                            onerror(scene, 'Unable to import meshes from ' + rootUrl + sceneFilename, e);\n                        }\n                        scene._removePendingData(loadingToken);\n                    }\n                };\n                if (directLoad) {\n                    importMeshFromData(directLoad);\n                    return;\n                }\n                BABYLON.Tools.LoadFile(rootUrl + sceneFilename, function (data) {\n                    importMeshFromData(data);\n                }, progressCallBack, database, useArrayBuffer, function () {\n                    if (onerror) {\n                        onerror(scene, 'Unable to load file ' + rootUrl + sceneFilename);\n                    }\n                });\n            };\n            if (scene.getEngine().enableOfflineSupport && !directLoad) {\n                // Checking if a manifest file has been set for this scene and if offline mode has been requested\n                var database = new BABYLON.Database(rootUrl + sceneFilename, manifestChecked);\n            }\n            else {\n                // If the scene is a data stream or offline support is not enabled, it's a direct load\n                manifestChecked(true);\n            }\n        };\n        /**\n        * Load a scene\n        * @param rootUrl a string that defines the root url for scene and resources\n        * @param sceneFilename a string that defines the name of the scene file. can start with \"data:\" following by the stringified version of the scene\n        * @param engine is the instance of BABYLON.Engine to use to create the scene\n        */\n        SceneLoader.Load = function (rootUrl, sceneFilename, engine, onsuccess, progressCallBack, onerror) {\n            SceneLoader.Append(rootUrl, sceneFilename, new BABYLON.Scene(engine), onsuccess, progressCallBack, onerror);\n        };\n        /**\n        * Append a scene\n        * @param rootUrl a string that defines the root url for scene and resources\n        * @param sceneFilename a string that defines the name of the scene file. can start with \"data:\" following by the stringified version of the scene\n        * @param scene is the instance of BABYLON.Scene to append to\n        */\n        SceneLoader.Append = function (rootUrl, sceneFilename, scene, onsuccess, progressCallBack, onerror) {\n            if (sceneFilename.substr && sceneFilename.substr(0, 1) === \"/\") {\n                BABYLON.Tools.Error(\"Wrong sceneFilename parameter\");\n                return;\n            }\n            var directLoad = SceneLoader._getDirectLoad(sceneFilename);\n            var registeredPlugin = directLoad ? SceneLoader._getPluginForDirectLoad(sceneFilename) : SceneLoader._getPluginForFilename(sceneFilename);\n            var plugin = registeredPlugin.plugin;\n            var useArrayBuffer = registeredPlugin.isBinary;\n            var database;\n            var loadingToken = {};\n            scene._addPendingData(loadingToken);\n            if (SceneLoader.ShowLoadingScreen) {\n                scene.getEngine().displayLoadingUI();\n            }\n            var loadSceneFromData = function (data) {\n                scene.database = database;\n                if (plugin.load) {\n                    var syncedPlugin = plugin;\n                    if (!syncedPlugin.load(scene, data, rootUrl)) {\n                        if (onerror) {\n                            onerror(scene);\n                        }\n                        scene._removePendingData(loadingToken);\n                        scene.getEngine().hideLoadingUI();\n                        return;\n                    }\n                    if (onsuccess) {\n                        onsuccess(scene);\n                    }\n                    scene._removePendingData(loadingToken);\n                }\n                else {\n                    var asyncedPlugin = plugin;\n                    asyncedPlugin.loadAsync(scene, data, rootUrl, function () {\n                        if (onsuccess) {\n                            onsuccess(scene);\n                        }\n                        scene._removePendingData(loadingToken);\n                    }, function () {\n                        if (onerror) {\n                            onerror(scene);\n                        }\n                        scene._removePendingData(loadingToken);\n                        scene.getEngine().hideLoadingUI();\n                    });\n                }\n                if (SceneLoader.ShowLoadingScreen) {\n                    scene.executeWhenReady(function () {\n                        scene.getEngine().hideLoadingUI();\n                    });\n                }\n            };\n            var manifestChecked = function (success) {\n                BABYLON.Tools.LoadFile(rootUrl + sceneFilename, loadSceneFromData, progressCallBack, database, useArrayBuffer);\n            };\n            if (directLoad) {\n                loadSceneFromData(directLoad);\n                return;\n            }\n            if (rootUrl.indexOf(\"file:\") === -1) {\n                if (scene.getEngine().enableOfflineSupport) {\n                    // Checking if a manifest file has been set for this scene and if offline mode has been requested\n                    database = new BABYLON.Database(rootUrl + sceneFilename, manifestChecked);\n                }\n                else {\n                    manifestChecked(true);\n                }\n            }\n            else {\n                BABYLON.Tools.ReadFile(sceneFilename, loadSceneFromData, progressCallBack, useArrayBuffer);\n            }\n        };\n        return SceneLoader;\n    }());\n    // Flags\n    SceneLoader._ForceFullSceneLoadingForIncremental = false;\n    SceneLoader._ShowLoadingScreen = true;\n    SceneLoader._loggingLevel = SceneLoader.NO_LOGGING;\n    // Members\n    SceneLoader._registeredPlugins = {};\n    BABYLON.SceneLoader = SceneLoader;\n    ;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sceneLoader.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var parseMaterialById = function (id, parsedData, scene, rootUrl) {\n            for (var index = 0, cache = parsedData.materials.length; index < cache; index++) {\n                var parsedMaterial = parsedData.materials[index];\n                if (parsedMaterial.id === id) {\n                    return BABYLON.Material.Parse(parsedMaterial, scene, rootUrl);\n                }\n            }\n            return null;\n        };\n        var isDescendantOf = function (mesh, names, hierarchyIds) {\n            names = (names instanceof Array) ? names : [names];\n            for (var i in names) {\n                if (mesh.name === names[i]) {\n                    hierarchyIds.push(mesh.id);\n                    return true;\n                }\n            }\n            if (mesh.parentId && hierarchyIds.indexOf(mesh.parentId) !== -1) {\n                hierarchyIds.push(mesh.id);\n                return true;\n            }\n            return false;\n        };\n        var logOperation = function (operation, producer) {\n            return operation + \" of \" + (producer ? producer.file + \" from \" + producer.name + \" version: \" + producer.version + \", exporter version: \" + producer.exporter_version : \"unknown\");\n        };\n        BABYLON.SceneLoader.RegisterPlugin({\n            extensions: \".babylon\",\n            canDirectLoad: function (data) {\n                if (data.indexOf(\"babylon\") !== -1) {\n                    return true;\n                }\n                return false;\n            },\n            importMesh: function (meshesNames, scene, data, rootUrl, meshes, particleSystems, skeletons) {\n                // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n                // when SceneLoader.debugLogging = true (default), or exception encountered.\n                // Everything stored in var log instead of writing separate lines to support only writing in exception,\n                // and avoid problems with multiple concurrent .babylon loads.\n                var log = \"importMesh has failed JSON parse\";\n                try {\n                    var parsedData = JSON.parse(data);\n                    log = \"\";\n                    var fullDetails = BABYLON.SceneLoader.loggingLevel === BABYLON.SceneLoader.DETAILED_LOGGING;\n                    var loadedSkeletonsIds = [];\n                    var loadedMaterialsIds = [];\n                    var hierarchyIds = [];\n                    var index;\n                    var cache;\n                    for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n                        var parsedMesh = parsedData.meshes[index];\n                        if (!meshesNames || isDescendantOf(parsedMesh, meshesNames, hierarchyIds)) {\n                            if (meshesNames instanceof Array) {\n                                // Remove found mesh name from list.\n                                delete meshesNames[meshesNames.indexOf(parsedMesh.name)];\n                            }\n                            //Geometry?\n                            if (parsedMesh.geometryId) {\n                                //does the file contain geometries?\n                                if (parsedData.geometries) {\n                                    //find the correct geometry and add it to the scene\n                                    var found = false;\n                                    [\"boxes\", \"spheres\", \"cylinders\", \"toruses\", \"grounds\", \"planes\", \"torusKnots\", \"vertexData\"].forEach(function (geometryType) {\n                                        if (found || !parsedData.geometries[geometryType] || !(parsedData.geometries[geometryType] instanceof Array)) {\n                                            return;\n                                        }\n                                        else {\n                                            parsedData.geometries[geometryType].forEach(function (parsedGeometryData) {\n                                                if (parsedGeometryData.id === parsedMesh.geometryId) {\n                                                    switch (geometryType) {\n                                                        case \"boxes\":\n                                                            BABYLON.Geometry.Primitives.Box.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"spheres\":\n                                                            BABYLON.Geometry.Primitives.Sphere.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"cylinders\":\n                                                            BABYLON.Geometry.Primitives.Cylinder.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"toruses\":\n                                                            BABYLON.Geometry.Primitives.Torus.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"grounds\":\n                                                            BABYLON.Geometry.Primitives.Ground.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"planes\":\n                                                            BABYLON.Geometry.Primitives.Plane.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"torusKnots\":\n                                                            BABYLON.Geometry.Primitives.TorusKnot.Parse(parsedGeometryData, scene);\n                                                            break;\n                                                        case \"vertexData\":\n                                                            BABYLON.Geometry.Parse(parsedGeometryData, scene, rootUrl);\n                                                            break;\n                                                    }\n                                                    found = true;\n                                                }\n                                            });\n                                        }\n                                    });\n                                    if (!found) {\n                                        BABYLON.Tools.Warn(\"Geometry not found for mesh \" + parsedMesh.id);\n                                    }\n                                }\n                            }\n                            // Material ?\n                            if (parsedMesh.materialId) {\n                                var materialFound = (loadedMaterialsIds.indexOf(parsedMesh.materialId) !== -1);\n                                if (!materialFound && parsedData.multiMaterials) {\n                                    for (var multimatIndex = 0, multimatCache = parsedData.multiMaterials.length; multimatIndex < multimatCache; multimatIndex++) {\n                                        var parsedMultiMaterial = parsedData.multiMaterials[multimatIndex];\n                                        if (parsedMultiMaterial.id === parsedMesh.materialId) {\n                                            for (var matIndex = 0, matCache = parsedMultiMaterial.materials.length; matIndex < matCache; matIndex++) {\n                                                var subMatId = parsedMultiMaterial.materials[matIndex];\n                                                loadedMaterialsIds.push(subMatId);\n                                                var mat = parseMaterialById(subMatId, parsedData, scene, rootUrl);\n                                                log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                                            }\n                                            loadedMaterialsIds.push(parsedMultiMaterial.id);\n                                            var mmat = BABYLON.Material.ParseMultiMaterial(parsedMultiMaterial, scene);\n                                            materialFound = true;\n                                            log += \"\\n\\tMulti-Material \" + mmat.toString(fullDetails);\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (!materialFound) {\n                                    loadedMaterialsIds.push(parsedMesh.materialId);\n                                    var mat = parseMaterialById(parsedMesh.materialId, parsedData, scene, rootUrl);\n                                    if (!mat) {\n                                        BABYLON.Tools.Warn(\"Material not found for mesh \" + parsedMesh.id);\n                                    }\n                                    else {\n                                        log += \"\\n\\tMaterial \" + mat.toString(fullDetails);\n                                    }\n                                }\n                            }\n                            // Skeleton ?\n                            if (parsedMesh.skeletonId > -1 && scene.skeletons) {\n                                var skeletonAlreadyLoaded = (loadedSkeletonsIds.indexOf(parsedMesh.skeletonId) > -1);\n                                if (!skeletonAlreadyLoaded) {\n                                    for (var skeletonIndex = 0, skeletonCache = parsedData.skeletons.length; skeletonIndex < skeletonCache; skeletonIndex++) {\n                                        var parsedSkeleton = parsedData.skeletons[skeletonIndex];\n                                        if (parsedSkeleton.id === parsedMesh.skeletonId) {\n                                            var skeleton = BABYLON.Skeleton.Parse(parsedSkeleton, scene);\n                                            skeletons.push(skeleton);\n                                            loadedSkeletonsIds.push(parsedSkeleton.id);\n                                            log += \"\\n\\tSkeleton \" + skeleton.toString(fullDetails);\n                                        }\n                                    }\n                                }\n                            }\n                            var mesh = BABYLON.Mesh.Parse(parsedMesh, scene, rootUrl);\n                            meshes.push(mesh);\n                            log += \"\\n\\tMesh \" + mesh.toString(fullDetails);\n                        }\n                    }\n                    // Connecting parents\n                    var currentMesh;\n                    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n                        currentMesh = scene.meshes[index];\n                        if (currentMesh._waitingParentId) {\n                            currentMesh.parent = scene.getLastEntryByID(currentMesh._waitingParentId);\n                            currentMesh._waitingParentId = undefined;\n                        }\n                    }\n                    // freeze and compute world matrix application\n                    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n                        currentMesh = scene.meshes[index];\n                        if (currentMesh._waitingFreezeWorldMatrix) {\n                            currentMesh.freezeWorldMatrix();\n                            currentMesh._waitingFreezeWorldMatrix = undefined;\n                        }\n                        else {\n                            currentMesh.computeWorldMatrix(true);\n                        }\n                    }\n                    // Particles\n                    if (parsedData.particleSystems) {\n                        for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n                            var parsedParticleSystem = parsedData.particleSystems[index];\n                            if (hierarchyIds.indexOf(parsedParticleSystem.emitterId) !== -1) {\n                                particleSystems.push(BABYLON.ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl));\n                            }\n                        }\n                    }\n                    return true;\n                }\n                catch (err) {\n                    BABYLON.Tools.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + log);\n                    log = null;\n                    throw err;\n                }\n                finally {\n                    if (log !== null && BABYLON.SceneLoader.loggingLevel !== BABYLON.SceneLoader.NO_LOGGING) {\n                        BABYLON.Tools.Log(logOperation(\"importMesh\", parsedData ? parsedData.producer : \"Unknown\") + (BABYLON.SceneLoader.loggingLevel !== BABYLON.SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n                    }\n                }\n            },\n            load: function (scene, data, rootUrl) {\n                // Entire method running in try block, so ALWAYS logs as far as it got, only actually writes details\n                // when SceneLoader.debugLogging = true (default), or exception encountered.\n                // Everything stored in var log instead of writing separate lines to support only writing in exception,\n                // and avoid problems with multiple concurrent .babylon loads.\n                var log = \"importScene has failed JSON parse\";\n                try {\n                    var parsedData = JSON.parse(data);\n                    log = \"\";\n                    var fullDetails = BABYLON.SceneLoader.loggingLevel === BABYLON.SceneLoader.DETAILED_LOGGING;\n                    // Scene\n                    scene.useDelayedTextureLoading = parsedData.useDelayedTextureLoading && !BABYLON.SceneLoader.ForceFullSceneLoadingForIncremental;\n                    scene.autoClear = parsedData.autoClear;\n                    scene.clearColor = BABYLON.Color4.FromArray(parsedData.clearColor);\n                    scene.ambientColor = BABYLON.Color3.FromArray(parsedData.ambientColor);\n                    if (parsedData.gravity) {\n                        scene.gravity = BABYLON.Vector3.FromArray(parsedData.gravity);\n                    }\n                    // Fog\n                    if (parsedData.fogMode && parsedData.fogMode !== 0) {\n                        scene.fogMode = parsedData.fogMode;\n                        scene.fogColor = BABYLON.Color3.FromArray(parsedData.fogColor);\n                        scene.fogStart = parsedData.fogStart;\n                        scene.fogEnd = parsedData.fogEnd;\n                        scene.fogDensity = parsedData.fogDensity;\n                        log += \"\\tFog mode for scene:  \";\n                        switch (scene.fogMode) {\n                            // getters not compiling, so using hardcoded\n                            case 1:\n                                log += \"exp\\n\";\n                                break;\n                            case 2:\n                                log += \"exp2\\n\";\n                                break;\n                            case 3:\n                                log += \"linear\\n\";\n                                break;\n                        }\n                    }\n                    //Physics\n                    if (parsedData.physicsEnabled) {\n                        var physicsPlugin;\n                        if (parsedData.physicsEngine === \"cannon\") {\n                            physicsPlugin = new BABYLON.CannonJSPlugin();\n                        }\n                        else if (parsedData.physicsEngine === \"oimo\") {\n                            physicsPlugin = new BABYLON.OimoJSPlugin();\n                        }\n                        log = \"\\tPhysics engine \" + (parsedData.physicsEngine ? parsedData.physicsEngine : \"oimo\") + \" enabled\\n\";\n                        //else - default engine, which is currently oimo\n                        var physicsGravity = parsedData.physicsGravity ? BABYLON.Vector3.FromArray(parsedData.physicsGravity) : null;\n                        scene.enablePhysics(physicsGravity, physicsPlugin);\n                    }\n                    // Metadata\n                    if (parsedData.metadata !== undefined) {\n                        scene.metadata = parsedData.metadata;\n                    }\n                    //collisions, if defined. otherwise, default is true\n                    if (parsedData.collisionsEnabled != undefined) {\n                        scene.collisionsEnabled = parsedData.collisionsEnabled;\n                    }\n                    scene.workerCollisions = !!parsedData.workerCollisions;\n                    var index;\n                    var cache;\n                    // Lights\n                    for (index = 0, cache = parsedData.lights.length; index < cache; index++) {\n                        var parsedLight = parsedData.lights[index];\n                        var light = BABYLON.Light.Parse(parsedLight, scene);\n                        log += (index === 0 ? \"\\n\\tLights:\" : \"\");\n                        log += \"\\n\\t\\t\" + light.toString(fullDetails);\n                    }\n                    // Animations\n                    if (parsedData.animations) {\n                        for (index = 0, cache = parsedData.animations.length; index < cache; index++) {\n                            var parsedAnimation = parsedData.animations[index];\n                            var animation = BABYLON.Animation.Parse(parsedAnimation);\n                            scene.animations.push(animation);\n                            log += (index === 0 ? \"\\n\\tAnimations:\" : \"\");\n                            log += \"\\n\\t\\t\" + animation.toString(fullDetails);\n                        }\n                    }\n                    if (parsedData.autoAnimate) {\n                        scene.beginAnimation(scene, parsedData.autoAnimateFrom, parsedData.autoAnimateTo, parsedData.autoAnimateLoop, parsedData.autoAnimateSpeed || 1.0);\n                    }\n                    // Materials\n                    if (parsedData.materials) {\n                        for (index = 0, cache = parsedData.materials.length; index < cache; index++) {\n                            var parsedMaterial = parsedData.materials[index];\n                            var mat = BABYLON.Material.Parse(parsedMaterial, scene, rootUrl);\n                            log += (index === 0 ? \"\\n\\tMaterials:\" : \"\");\n                            log += \"\\n\\t\\t\" + mat.toString(fullDetails);\n                        }\n                    }\n                    if (parsedData.multiMaterials) {\n                        for (index = 0, cache = parsedData.multiMaterials.length; index < cache; index++) {\n                            var parsedMultiMaterial = parsedData.multiMaterials[index];\n                            var mmat = BABYLON.Material.ParseMultiMaterial(parsedMultiMaterial, scene);\n                            log += (index === 0 ? \"\\n\\tMultiMaterials:\" : \"\");\n                            log += \"\\n\\t\\t\" + mmat.toString(fullDetails);\n                        }\n                    }\n                    // Morph targets\n                    if (parsedData.morphTargetManagers) {\n                        for (var _i = 0, _a = parsedData.morphTargetManagers; _i < _a.length; _i++) {\n                            var managerData = _a[_i];\n                            var parsedManager = BABYLON.MorphTargetManager.Parse(managerData, scene);\n                        }\n                    }\n                    // Skeletons\n                    if (parsedData.skeletons) {\n                        for (index = 0, cache = parsedData.skeletons.length; index < cache; index++) {\n                            var parsedSkeleton = parsedData.skeletons[index];\n                            var skeleton = BABYLON.Skeleton.Parse(parsedSkeleton, scene);\n                            log += (index === 0 ? \"\\n\\tSkeletons:\" : \"\");\n                            log += \"\\n\\t\\t\" + skeleton.toString(fullDetails);\n                        }\n                    }\n                    // Geometries\n                    var geometries = parsedData.geometries;\n                    if (geometries) {\n                        // Boxes\n                        var boxes = geometries.boxes;\n                        if (boxes) {\n                            for (index = 0, cache = boxes.length; index < cache; index++) {\n                                var parsedBox = boxes[index];\n                                BABYLON.Geometry.Primitives.Box.Parse(parsedBox, scene);\n                            }\n                        }\n                        // Spheres\n                        var spheres = geometries.spheres;\n                        if (spheres) {\n                            for (index = 0, cache = spheres.length; index < cache; index++) {\n                                var parsedSphere = spheres[index];\n                                BABYLON.Geometry.Primitives.Sphere.Parse(parsedSphere, scene);\n                            }\n                        }\n                        // Cylinders\n                        var cylinders = geometries.cylinders;\n                        if (cylinders) {\n                            for (index = 0, cache = cylinders.length; index < cache; index++) {\n                                var parsedCylinder = cylinders[index];\n                                BABYLON.Geometry.Primitives.Cylinder.Parse(parsedCylinder, scene);\n                            }\n                        }\n                        // Toruses\n                        var toruses = geometries.toruses;\n                        if (toruses) {\n                            for (index = 0, cache = toruses.length; index < cache; index++) {\n                                var parsedTorus = toruses[index];\n                                BABYLON.Geometry.Primitives.Torus.Parse(parsedTorus, scene);\n                            }\n                        }\n                        // Grounds\n                        var grounds = geometries.grounds;\n                        if (grounds) {\n                            for (index = 0, cache = grounds.length; index < cache; index++) {\n                                var parsedGround = grounds[index];\n                                BABYLON.Geometry.Primitives.Ground.Parse(parsedGround, scene);\n                            }\n                        }\n                        // Planes\n                        var planes = geometries.planes;\n                        if (planes) {\n                            for (index = 0, cache = planes.length; index < cache; index++) {\n                                var parsedPlane = planes[index];\n                                BABYLON.Geometry.Primitives.Plane.Parse(parsedPlane, scene);\n                            }\n                        }\n                        // TorusKnots\n                        var torusKnots = geometries.torusKnots;\n                        if (torusKnots) {\n                            for (index = 0, cache = torusKnots.length; index < cache; index++) {\n                                var parsedTorusKnot = torusKnots[index];\n                                BABYLON.Geometry.Primitives.TorusKnot.Parse(parsedTorusKnot, scene);\n                            }\n                        }\n                        // VertexData\n                        var vertexData = geometries.vertexData;\n                        if (vertexData) {\n                            for (index = 0, cache = vertexData.length; index < cache; index++) {\n                                var parsedVertexData = vertexData[index];\n                                BABYLON.Geometry.Parse(parsedVertexData, scene, rootUrl);\n                            }\n                        }\n                    }\n                    // Meshes\n                    for (index = 0, cache = parsedData.meshes.length; index < cache; index++) {\n                        var parsedMesh = parsedData.meshes[index];\n                        var mesh = BABYLON.Mesh.Parse(parsedMesh, scene, rootUrl);\n                        log += (index === 0 ? \"\\n\\tMeshes:\" : \"\");\n                        log += \"\\n\\t\\t\" + mesh.toString(fullDetails);\n                    }\n                    // Cameras\n                    for (index = 0, cache = parsedData.cameras.length; index < cache; index++) {\n                        var parsedCamera = parsedData.cameras[index];\n                        var camera = BABYLON.Camera.Parse(parsedCamera, scene);\n                        log += (index === 0 ? \"\\n\\tCameras:\" : \"\");\n                        log += \"\\n\\t\\t\" + camera.toString(fullDetails);\n                    }\n                    if (parsedData.activeCameraID) {\n                        scene.setActiveCameraByID(parsedData.activeCameraID);\n                    }\n                    // Browsing all the graph to connect the dots\n                    for (index = 0, cache = scene.cameras.length; index < cache; index++) {\n                        var camera = scene.cameras[index];\n                        if (camera._waitingParentId) {\n                            camera.parent = scene.getLastEntryByID(camera._waitingParentId);\n                            camera._waitingParentId = undefined;\n                        }\n                    }\n                    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n                        var light = scene.lights[index];\n                        if (light._waitingParentId) {\n                            light.parent = scene.getLastEntryByID(light._waitingParentId);\n                            light._waitingParentId = undefined;\n                        }\n                    }\n                    // Sounds\n                    var loadedSounds = [];\n                    var loadedSound;\n                    if (BABYLON.AudioEngine && parsedData.sounds) {\n                        for (index = 0, cache = parsedData.sounds.length; index < cache; index++) {\n                            var parsedSound = parsedData.sounds[index];\n                            if (BABYLON.Engine.audioEngine.canUseWebAudio) {\n                                if (!parsedSound.url)\n                                    parsedSound.url = parsedSound.name;\n                                if (!loadedSounds[parsedSound.url]) {\n                                    loadedSound = BABYLON.Sound.Parse(parsedSound, scene, rootUrl);\n                                    loadedSounds[parsedSound.url] = loadedSound;\n                                }\n                                else {\n                                    BABYLON.Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]);\n                                }\n                            }\n                            else {\n                                var emptySound = new BABYLON.Sound(parsedSound.name, null, scene);\n                            }\n                        }\n                    }\n                    loadedSounds = [];\n                    // Connect parents & children and parse actions\n                    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n                        var mesh = scene.meshes[index];\n                        if (mesh._waitingParentId) {\n                            mesh.parent = scene.getLastEntryByID(mesh._waitingParentId);\n                            mesh._waitingParentId = undefined;\n                        }\n                        if (mesh._waitingActions) {\n                            BABYLON.ActionManager.Parse(mesh._waitingActions, mesh, scene);\n                            mesh._waitingActions = undefined;\n                        }\n                    }\n                    // freeze world matrix application\n                    for (index = 0, cache = scene.meshes.length; index < cache; index++) {\n                        var currentMesh = scene.meshes[index];\n                        if (currentMesh._waitingFreezeWorldMatrix) {\n                            currentMesh.freezeWorldMatrix();\n                            currentMesh._waitingFreezeWorldMatrix = undefined;\n                        }\n                        else {\n                            currentMesh.computeWorldMatrix(true);\n                        }\n                    }\n                    // Particles Systems\n                    if (parsedData.particleSystems) {\n                        for (index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {\n                            var parsedParticleSystem = parsedData.particleSystems[index];\n                            BABYLON.ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);\n                        }\n                    }\n                    // Lens flares\n                    if (parsedData.lensFlareSystems) {\n                        for (index = 0, cache = parsedData.lensFlareSystems.length; index < cache; index++) {\n                            var parsedLensFlareSystem = parsedData.lensFlareSystems[index];\n                            BABYLON.LensFlareSystem.Parse(parsedLensFlareSystem, scene, rootUrl);\n                        }\n                    }\n                    // Shadows\n                    if (parsedData.shadowGenerators) {\n                        for (index = 0, cache = parsedData.shadowGenerators.length; index < cache; index++) {\n                            var parsedShadowGenerator = parsedData.shadowGenerators[index];\n                            BABYLON.ShadowGenerator.Parse(parsedShadowGenerator, scene);\n                        }\n                    }\n                    // Lights exclusions / inclusions\n                    for (index = 0, cache = scene.lights.length; index < cache; index++) {\n                        var light = scene.lights[index];\n                        // Excluded check\n                        if (light._excludedMeshesIds.length > 0) {\n                            for (var excludedIndex = 0; excludedIndex < light._excludedMeshesIds.length; excludedIndex++) {\n                                var excludedMesh = scene.getMeshByID(light._excludedMeshesIds[excludedIndex]);\n                                if (excludedMesh) {\n                                    light.excludedMeshes.push(excludedMesh);\n                                }\n                            }\n                            light._excludedMeshesIds = [];\n                        }\n                        // Included check\n                        if (light._includedOnlyMeshesIds.length > 0) {\n                            for (var includedOnlyIndex = 0; includedOnlyIndex < light._includedOnlyMeshesIds.length; includedOnlyIndex++) {\n                                var includedOnlyMesh = scene.getMeshByID(light._includedOnlyMeshesIds[includedOnlyIndex]);\n                                if (includedOnlyMesh) {\n                                    light.includedOnlyMeshes.push(includedOnlyMesh);\n                                }\n                            }\n                            light._includedOnlyMeshesIds = [];\n                        }\n                    }\n                    // Actions (scene)\n                    if (parsedData.actions) {\n                        BABYLON.ActionManager.Parse(parsedData.actions, null, scene);\n                    }\n                    // Finish\n                    return true;\n                }\n                catch (err) {\n                    BABYLON.Tools.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + log);\n                    log = null;\n                    throw err;\n                }\n                finally {\n                    if (log !== null && BABYLON.SceneLoader.loggingLevel !== BABYLON.SceneLoader.NO_LOGGING) {\n                        BABYLON.Tools.Log(logOperation(\"importScene\", parsedData ? parsedData.producer : \"Unknown\") + (BABYLON.SceneLoader.loggingLevel !== BABYLON.SceneLoader.MINIMAL_LOGGING ? log : \"\"));\n                    }\n                }\n            }\n        });\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.babylonFileLoader.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var FilesInput = (function () {\n        /// Register to core BabylonJS object: engine, scene, rendering canvas, callback function when the scene will be loaded,\n        /// loading progress callback and optionnal addionnal logic to call in the rendering loop\n        function FilesInput(p_engine, p_scene, p_canvas, p_sceneLoadedCallback, p_progressCallback, p_additionnalRenderLoopLogicCallback, p_textureLoadingCallback, p_startingProcessingFilesCallback) {\n            this._engine = p_engine;\n            this._canvas = p_canvas;\n            this._currentScene = p_scene;\n            this._sceneLoadedCallback = p_sceneLoadedCallback;\n            this._progressCallback = p_progressCallback;\n            this._additionnalRenderLoopLogicCallback = p_additionnalRenderLoopLogicCallback;\n            this._textureLoadingCallback = p_textureLoadingCallback;\n            this._startingProcessingFilesCallback = p_startingProcessingFilesCallback;\n        }\n        FilesInput.prototype.monitorElementForDragNDrop = function (p_elementToMonitor) {\n            var _this = this;\n            if (p_elementToMonitor) {\n                this._elementToMonitor = p_elementToMonitor;\n                this._elementToMonitor.addEventListener(\"dragenter\", function (e) { _this.drag(e); }, false);\n                this._elementToMonitor.addEventListener(\"dragover\", function (e) { _this.drag(e); }, false);\n                this._elementToMonitor.addEventListener(\"drop\", function (e) { _this.drop(e); }, false);\n            }\n        };\n        FilesInput.prototype.renderFunction = function () {\n            if (this._additionnalRenderLoopLogicCallback) {\n                this._additionnalRenderLoopLogicCallback();\n            }\n            if (this._currentScene) {\n                if (this._textureLoadingCallback) {\n                    var remaining = this._currentScene.getWaitingItemsCount();\n                    if (remaining > 0) {\n                        this._textureLoadingCallback(remaining);\n                    }\n                }\n                this._currentScene.render();\n            }\n        };\n        FilesInput.prototype.drag = function (e) {\n            e.stopPropagation();\n            e.preventDefault();\n        };\n        FilesInput.prototype.drop = function (eventDrop) {\n            eventDrop.stopPropagation();\n            eventDrop.preventDefault();\n            this.loadFiles(eventDrop);\n        };\n        FilesInput.prototype.loadFiles = function (event) {\n            if (this._startingProcessingFilesCallback)\n                this._startingProcessingFilesCallback();\n            // Handling data transfer via drag'n'drop\n            if (event && event.dataTransfer && event.dataTransfer.files) {\n                this._filesToLoad = event.dataTransfer.files;\n            }\n            // Handling files from input files\n            if (event && event.target && event.target.files) {\n                this._filesToLoad = event.target.files;\n            }\n            if (this._filesToLoad && this._filesToLoad.length > 0) {\n                for (var i = 0; i < this._filesToLoad.length; i++) {\n                    var name_1 = this._filesToLoad[i].name.toLowerCase();\n                    var extension = name_1.split('.').pop();\n                    var type = this._filesToLoad[i].type;\n                    if ((extension === \"babylon\" || extension === \"stl\" || extension === \"obj\" || extension === \"gltf\" || extension === \"glb\")\n                        && name_1.indexOf(\".binary.babylon\") === -1 && name_1.indexOf(\".incremental.babylon\") === -1) {\n                        this._sceneFileToLoad = this._filesToLoad[i];\n                    }\n                    else {\n                        FilesInput.FilesToLoad[name_1] = this._filesToLoad[i];\n                    }\n                }\n                this.reload();\n            }\n        };\n        FilesInput.prototype.reload = function () {\n            var _this = this;\n            var that = this;\n            // If a \".babylon\" file has been provided\n            if (this._sceneFileToLoad) {\n                if (this._currentScene) {\n                    if (BABYLON.Tools.errorsCount > 0) {\n                        BABYLON.Tools.ClearLogCache();\n                        BABYLON.Tools.Log(\"Babylon.js engine (v\" + BABYLON.Engine.Version + \") launched\");\n                    }\n                    this._engine.stopRenderLoop();\n                    this._currentScene.dispose();\n                }\n                BABYLON.SceneLoader.Load(\"file:\", this._sceneFileToLoad, this._engine, function (newScene) {\n                    that._currentScene = newScene;\n                    // Wait for textures and shaders to be ready\n                    that._currentScene.executeWhenReady(function () {\n                        if (that._sceneLoadedCallback) {\n                            that._sceneLoadedCallback(_this._sceneFileToLoad, that._currentScene);\n                        }\n                        that._engine.runRenderLoop(function () { that.renderFunction(); });\n                    });\n                }, function (progress) {\n                    if (_this._progressCallback) {\n                        _this._progressCallback(progress);\n                    }\n                });\n            }\n            else {\n                BABYLON.Tools.Error(\"Please provide a valid .babylon file.\");\n            }\n        };\n        return FilesInput;\n    }());\n    FilesInput.FilesToLoad = new Array();\n    BABYLON.FilesInput = FilesInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.filesInput.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This class implement a typical dictionary using a string as key and the generic type T as value.\n     * The underlying implementation relies on an associative array to ensure the best performances.\n     * The value can be anything including 'null' but except 'undefined'\n     */\n    var StringDictionary = (function () {\n        function StringDictionary() {\n            this._count = 0;\n            this._data = {};\n        }\n        /**\n         * This will clear this dictionary and copy the content from the 'source' one.\n         * If the T value is a custom object, it won't be copied/cloned, the same object will be used\n         * @param source the dictionary to take the content from and copy to this dictionary\n         */\n        StringDictionary.prototype.copyFrom = function (source) {\n            var _this = this;\n            this.clear();\n            source.forEach(function (t, v) { return _this.add(t, v); });\n        };\n        /**\n         * Get a value based from its key\n         * @param key the given key to get the matching value from\n         * @return the value if found, otherwise undefined is returned\n         */\n        StringDictionary.prototype.get = function (key) {\n            var val = this._data[key];\n            if (val !== undefined) {\n                return val;\n            }\n            return undefined;\n        };\n        /**\n         * Get a value from its key or add it if it doesn't exist.\n         * This method will ensure you that a given key/data will be present in the dictionary.\n         * @param key the given key to get the matching value from\n         * @param factory the factory that will create the value if the key is not present in the dictionary.\n         * The factory will only be invoked if there's no data for the given key.\n         * @return the value corresponding to the key.\n         */\n        StringDictionary.prototype.getOrAddWithFactory = function (key, factory) {\n            var val = this.get(key);\n            if (val !== undefined) {\n                return val;\n            }\n            val = factory(key);\n            if (val) {\n                this.add(key, val);\n            }\n            return val;\n        };\n        /**\n         * Get a value from its key if present in the dictionary otherwise add it\n         * @param key the key to get the value from\n         * @param val if there's no such key/value pair in the dictionary add it with this value\n         * @return the value corresponding to the key\n         */\n        StringDictionary.prototype.getOrAdd = function (key, val) {\n            var curVal = this.get(key);\n            if (curVal !== undefined) {\n                return curVal;\n            }\n            this.add(key, val);\n            return val;\n        };\n        /**\n         * Check if there's a given key in the dictionary\n         * @param key the key to check for\n         * @return true if the key is present, false otherwise\n         */\n        StringDictionary.prototype.contains = function (key) {\n            return this._data[key] !== undefined;\n        };\n        /**\n         * Add a new key and its corresponding value\n         * @param key the key to add\n         * @param value the value corresponding to the key\n         * @return true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary\n         */\n        StringDictionary.prototype.add = function (key, value) {\n            if (this._data[key] !== undefined) {\n                return false;\n            }\n            this._data[key] = value;\n            ++this._count;\n            return true;\n        };\n        StringDictionary.prototype.set = function (key, value) {\n            if (this._data[key] === undefined) {\n                return false;\n            }\n            this._data[key] = value;\n            return true;\n        };\n        /**\n         * Get the element of the given key and remove it from the dictionary\n         * @param key\n         */\n        StringDictionary.prototype.getAndRemove = function (key) {\n            var val = this.get(key);\n            if (val !== undefined) {\n                delete this._data[key];\n                --this._count;\n                return val;\n            }\n            return null;\n        };\n        /**\n         * Remove a key/value from the dictionary.\n         * @param key the key to remove\n         * @return true if the item was successfully deleted, false if no item with such key exist in the dictionary\n         */\n        StringDictionary.prototype.remove = function (key) {\n            if (this.contains(key)) {\n                delete this._data[key];\n                --this._count;\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Clear the whole content of the dictionary\n         */\n        StringDictionary.prototype.clear = function () {\n            this._data = {};\n            this._count = 0;\n        };\n        Object.defineProperty(StringDictionary.prototype, \"count\", {\n            get: function () {\n                return this._count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Execute a callback on each key/val of the dictionary.\n         * Note that you can remove any element in this dictionary in the callback implementation\n         * @param callback the callback to execute on a given key/value pair\n         */\n        StringDictionary.prototype.forEach = function (callback) {\n            for (var cur in this._data) {\n                var val = this._data[cur];\n                callback(cur, val);\n            }\n        };\n        /**\n         * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.\n         * If the callback returns null or undefined the method will iterate to the next key/value pair\n         * Note that you can remove any element in this dictionary in the callback implementation\n         * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned\n         */\n        StringDictionary.prototype.first = function (callback) {\n            for (var cur in this._data) {\n                var val = this._data[cur];\n                var res = callback(cur, val);\n                if (res) {\n                    return res;\n                }\n            }\n            return null;\n        };\n        return StringDictionary;\n    }());\n    BABYLON.StringDictionary = StringDictionary;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.stringDictionary.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Tags = (function () {\n        function Tags() {\n        }\n        Tags.EnableFor = function (obj) {\n            obj._tags = obj._tags || {};\n            obj.hasTags = function () {\n                return Tags.HasTags(obj);\n            };\n            obj.addTags = function (tagsString) {\n                return Tags.AddTagsTo(obj, tagsString);\n            };\n            obj.removeTags = function (tagsString) {\n                return Tags.RemoveTagsFrom(obj, tagsString);\n            };\n            obj.matchesTagsQuery = function (tagsQuery) {\n                return Tags.MatchesQuery(obj, tagsQuery);\n            };\n        };\n        Tags.DisableFor = function (obj) {\n            delete obj._tags;\n            delete obj.hasTags;\n            delete obj.addTags;\n            delete obj.removeTags;\n            delete obj.matchesTagsQuery;\n        };\n        Tags.HasTags = function (obj) {\n            if (!obj._tags) {\n                return false;\n            }\n            return !BABYLON.Tools.IsEmpty(obj._tags);\n        };\n        Tags.GetTags = function (obj, asString) {\n            if (asString === void 0) { asString = true; }\n            if (!obj._tags) {\n                return null;\n            }\n            if (asString) {\n                var tagsArray = [];\n                for (var tag in obj._tags) {\n                    if (obj._tags.hasOwnProperty(tag) && obj._tags[tag] === true) {\n                        tagsArray.push(tag);\n                    }\n                }\n                return tagsArray.join(\" \");\n            }\n            else {\n                return obj._tags;\n            }\n        };\n        // the tags 'true' and 'false' are reserved and cannot be used as tags\n        // a tag cannot start with '||', '&&', and '!'\n        // it cannot contain whitespaces\n        Tags.AddTagsTo = function (obj, tagsString) {\n            if (!tagsString) {\n                return;\n            }\n            if (typeof tagsString !== \"string\") {\n                return;\n            }\n            var tags = tagsString.split(\" \");\n            tags.forEach(function (tag, index, array) {\n                Tags._AddTagTo(obj, tag);\n            });\n        };\n        Tags._AddTagTo = function (obj, tag) {\n            tag = tag.trim();\n            if (tag === \"\" || tag === \"true\" || tag === \"false\") {\n                return;\n            }\n            if (tag.match(/[\\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {\n                return;\n            }\n            Tags.EnableFor(obj);\n            obj._tags[tag] = true;\n        };\n        Tags.RemoveTagsFrom = function (obj, tagsString) {\n            if (!Tags.HasTags(obj)) {\n                return;\n            }\n            var tags = tagsString.split(\" \");\n            for (var t in tags) {\n                Tags._RemoveTagFrom(obj, tags[t]);\n            }\n        };\n        Tags._RemoveTagFrom = function (obj, tag) {\n            delete obj._tags[tag];\n        };\n        Tags.MatchesQuery = function (obj, tagsQuery) {\n            if (tagsQuery === undefined) {\n                return true;\n            }\n            if (tagsQuery === \"\") {\n                return Tags.HasTags(obj);\n            }\n            return BABYLON.Internals.AndOrNotEvaluator.Eval(tagsQuery, function (r) { return Tags.HasTags(obj) && obj._tags[r]; });\n        };\n        return Tags;\n    }());\n    BABYLON.Tags = Tags;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.tags.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var AndOrNotEvaluator = (function () {\n            function AndOrNotEvaluator() {\n            }\n            AndOrNotEvaluator.Eval = function (query, evaluateCallback) {\n                if (!query.match(/\\([^\\(\\)]*\\)/g)) {\n                    query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);\n                }\n                else {\n                    query = query.replace(/\\([^\\(\\)]*\\)/g, function (r) {\n                        // remove parenthesis\n                        r = r.slice(1, r.length - 1);\n                        return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);\n                    });\n                }\n                if (query === \"true\") {\n                    return true;\n                }\n                if (query === \"false\") {\n                    return false;\n                }\n                return AndOrNotEvaluator.Eval(query, evaluateCallback);\n            };\n            AndOrNotEvaluator._HandleParenthesisContent = function (parenthesisContent, evaluateCallback) {\n                evaluateCallback = evaluateCallback || (function (r) {\n                    return r === \"true\" ? true : false;\n                });\n                var result;\n                var or = parenthesisContent.split(\"||\");\n                for (var i in or) {\n                    if (or.hasOwnProperty(i)) {\n                        var ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());\n                        var and = ori.split(\"&&\");\n                        if (and.length > 1) {\n                            for (var j = 0; j < and.length; ++j) {\n                                var andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());\n                                if (andj !== \"true\" && andj !== \"false\") {\n                                    if (andj[0] === \"!\") {\n                                        result = !evaluateCallback(andj.substring(1));\n                                    }\n                                    else {\n                                        result = evaluateCallback(andj);\n                                    }\n                                }\n                                else {\n                                    result = andj === \"true\" ? true : false;\n                                }\n                                if (!result) {\n                                    ori = \"false\";\n                                    break;\n                                }\n                            }\n                        }\n                        if (result || ori === \"true\") {\n                            result = true;\n                            break;\n                        }\n                        // result equals false (or undefined)\n                        if (ori !== \"true\" && ori !== \"false\") {\n                            if (ori[0] === \"!\") {\n                                result = !evaluateCallback(ori.substring(1));\n                            }\n                            else {\n                                result = evaluateCallback(ori);\n                            }\n                        }\n                        else {\n                            result = ori === \"true\" ? true : false;\n                        }\n                    }\n                }\n                // the whole parenthesis scope is replaced by 'true' or 'false'\n                return result ? \"true\" : \"false\";\n            };\n            AndOrNotEvaluator._SimplifyNegation = function (booleanString) {\n                booleanString = booleanString.replace(/^[\\s!]+/, function (r) {\n                    // remove whitespaces\n                    r = r.replace(/[\\s]/g, function () { return \"\"; });\n                    return r.length % 2 ? \"!\" : \"\";\n                });\n                booleanString = booleanString.trim();\n                if (booleanString === \"!true\") {\n                    booleanString = \"false\";\n                }\n                else if (booleanString === \"!false\") {\n                    booleanString = \"true\";\n                }\n                return booleanString;\n            };\n            return AndOrNotEvaluator;\n        }());\n        Internals.AndOrNotEvaluator = AndOrNotEvaluator;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.andOrNotEvaluator.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Database = (function () {\n        function Database(urlToScene, callbackManifestChecked) {\n            // Handling various flavors of prefixed version of IndexedDB\n            this.idbFactory = (window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB);\n            this.callbackManifestChecked = callbackManifestChecked;\n            this.currentSceneUrl = Database.ReturnFullUrlLocation(urlToScene);\n            this.db = null;\n            this.enableSceneOffline = false;\n            this.enableTexturesOffline = false;\n            this.manifestVersionFound = 0;\n            this.mustUpdateRessources = false;\n            this.hasReachedQuota = false;\n            if (!Database.IDBStorageEnabled) {\n                this.callbackManifestChecked(true);\n            }\n            else {\n                this.checkManifestFile();\n            }\n        }\n        Database.prototype.checkManifestFile = function () {\n            var _this = this;\n            function noManifestFile() {\n                that.enableSceneOffline = false;\n                that.enableTexturesOffline = false;\n                that.callbackManifestChecked(false);\n            }\n            var that = this;\n            var timeStampUsed = false;\n            var manifestURL = this.currentSceneUrl + \".manifest\";\n            var xhr = new XMLHttpRequest();\n            if (navigator.onLine) {\n                // Adding a timestamp to by-pass browsers' cache\n                timeStampUsed = true;\n                manifestURL = manifestURL + (manifestURL.match(/\\?/) == null ? \"?\" : \"&\") + (new Date()).getTime();\n            }\n            xhr.open(\"GET\", manifestURL, true);\n            xhr.addEventListener(\"load\", function () {\n                if (xhr.status === 200 || BABYLON.Tools.ValidateXHRData(xhr, 1)) {\n                    try {\n                        var manifestFile = JSON.parse(xhr.response);\n                        _this.enableSceneOffline = manifestFile.enableSceneOffline;\n                        _this.enableTexturesOffline = manifestFile.enableTexturesOffline;\n                        if (manifestFile.version && !isNaN(parseInt(manifestFile.version))) {\n                            _this.manifestVersionFound = manifestFile.version;\n                        }\n                        if (_this.callbackManifestChecked) {\n                            _this.callbackManifestChecked(true);\n                        }\n                    }\n                    catch (ex) {\n                        noManifestFile();\n                    }\n                }\n                else {\n                    noManifestFile();\n                }\n            }, false);\n            xhr.addEventListener(\"error\", function (event) {\n                if (timeStampUsed) {\n                    timeStampUsed = false;\n                    // Let's retry without the timeStamp\n                    // It could fail when coupled with HTML5 Offline API\n                    var retryManifestURL = _this.currentSceneUrl + \".manifest\";\n                    xhr.open(\"GET\", retryManifestURL, true);\n                    xhr.send();\n                }\n                else {\n                    noManifestFile();\n                }\n            }, false);\n            try {\n                xhr.send();\n            }\n            catch (ex) {\n                BABYLON.Tools.Error(\"Error on XHR send request.\");\n                that.callbackManifestChecked(false);\n            }\n        };\n        Database.prototype.openAsync = function (successCallback, errorCallback) {\n            var _this = this;\n            function handleError() {\n                that.isSupported = false;\n                if (errorCallback)\n                    errorCallback();\n            }\n            var that = this;\n            if (!this.idbFactory || !(this.enableSceneOffline || this.enableTexturesOffline)) {\n                // Your browser doesn't support IndexedDB\n                this.isSupported = false;\n                if (errorCallback)\n                    errorCallback();\n            }\n            else {\n                // If the DB hasn't been opened or created yet\n                if (!this.db) {\n                    this.hasReachedQuota = false;\n                    this.isSupported = true;\n                    var request = this.idbFactory.open(\"babylonjs\", 1);\n                    // Could occur if user is blocking the quota for the DB and/or doesn't grant access to IndexedDB\n                    request.onerror = function (event) {\n                        handleError();\n                    };\n                    // executes when a version change transaction cannot complete due to other active transactions\n                    request.onblocked = function (event) {\n                        BABYLON.Tools.Error(\"IDB request blocked. Please reload the page.\");\n                        handleError();\n                    };\n                    // DB has been opened successfully\n                    request.onsuccess = function (event) {\n                        _this.db = request.result;\n                        successCallback();\n                    };\n                    // Initialization of the DB. Creating Scenes & Textures stores\n                    request.onupgradeneeded = function (event) {\n                        _this.db = (event.target).result;\n                        try {\n                            var scenesStore = _this.db.createObjectStore(\"scenes\", { keyPath: \"sceneUrl\" });\n                            var versionsStore = _this.db.createObjectStore(\"versions\", { keyPath: \"sceneUrl\" });\n                            var texturesStore = _this.db.createObjectStore(\"textures\", { keyPath: \"textureUrl\" });\n                        }\n                        catch (ex) {\n                            BABYLON.Tools.Error(\"Error while creating object stores. Exception: \" + ex.message);\n                            handleError();\n                        }\n                    };\n                }\n                else {\n                    if (successCallback)\n                        successCallback();\n                }\n            }\n        };\n        Database.prototype.loadImageFromDB = function (url, image) {\n            var _this = this;\n            var completeURL = Database.ReturnFullUrlLocation(url);\n            var saveAndLoadImage = function () {\n                if (!_this.hasReachedQuota && _this.db !== null) {\n                    // the texture is not yet in the DB, let's try to save it\n                    _this._saveImageIntoDBAsync(completeURL, image);\n                }\n                else {\n                    image.src = url;\n                }\n            };\n            if (!this.mustUpdateRessources) {\n                this._loadImageFromDBAsync(completeURL, image, saveAndLoadImage);\n            }\n            else {\n                saveAndLoadImage();\n            }\n        };\n        Database.prototype._loadImageFromDBAsync = function (url, image, notInDBCallback) {\n            if (this.isSupported && this.db !== null) {\n                var texture;\n                var transaction = this.db.transaction([\"textures\"]);\n                transaction.onabort = function (event) {\n                    image.src = url;\n                };\n                transaction.oncomplete = function (event) {\n                    var blobTextureURL;\n                    if (texture) {\n                        var URL = window.URL || window.webkitURL;\n                        blobTextureURL = URL.createObjectURL(texture.data, { oneTimeOnly: true });\n                        image.onerror = function () {\n                            BABYLON.Tools.Error(\"Error loading image from blob URL: \" + blobTextureURL + \" switching back to web url: \" + url);\n                            image.src = url;\n                        };\n                        image.src = blobTextureURL;\n                    }\n                    else {\n                        notInDBCallback();\n                    }\n                };\n                var getRequest = transaction.objectStore(\"textures\").get(url);\n                getRequest.onsuccess = function (event) {\n                    texture = (event.target).result;\n                };\n                getRequest.onerror = function (event) {\n                    BABYLON.Tools.Error(\"Error loading texture \" + url + \" from DB.\");\n                    image.src = url;\n                };\n            }\n            else {\n                BABYLON.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n                image.src = url;\n            }\n        };\n        Database.prototype._saveImageIntoDBAsync = function (url, image) {\n            var _this = this;\n            if (this.isSupported) {\n                // In case of error (type not supported or quota exceeded), we're at least sending back XHR data to allow texture loading later on\n                var generateBlobUrl = function () {\n                    var blobTextureURL;\n                    if (blob) {\n                        var URL = window.URL || window.webkitURL;\n                        try {\n                            blobTextureURL = URL.createObjectURL(blob, { oneTimeOnly: true });\n                        }\n                        // Chrome is raising a type error if we're setting the oneTimeOnly parameter\n                        catch (ex) {\n                            blobTextureURL = URL.createObjectURL(blob);\n                        }\n                    }\n                    image.src = blobTextureURL;\n                };\n                if (Database.IsUASupportingBlobStorage) {\n                    var xhr = new XMLHttpRequest(), blob;\n                    xhr.open(\"GET\", url, true);\n                    xhr.responseType = \"blob\";\n                    xhr.addEventListener(\"load\", function () {\n                        if (xhr.status === 200) {\n                            // Blob as response (XHR2)\n                            blob = xhr.response;\n                            var transaction = _this.db.transaction([\"textures\"], \"readwrite\");\n                            // the transaction could abort because of a QuotaExceededError error\n                            transaction.onabort = function (event) {\n                                try {\n                                    //backwards compatibility with ts 1.0, srcElement doesn't have an \"error\" according to ts 1.3\n                                    if (event.srcElement['error'] && event.srcElement['error'].name === \"QuotaExceededError\") {\n                                        _this.hasReachedQuota = true;\n                                    }\n                                }\n                                catch (ex) { }\n                                generateBlobUrl();\n                            };\n                            transaction.oncomplete = function (event) {\n                                generateBlobUrl();\n                            };\n                            var newTexture = { textureUrl: url, data: blob };\n                            try {\n                                // Put the blob into the dabase\n                                var addRequest = transaction.objectStore(\"textures\").put(newTexture);\n                                addRequest.onsuccess = function (event) {\n                                };\n                                addRequest.onerror = function (event) {\n                                    generateBlobUrl();\n                                };\n                            }\n                            catch (ex) {\n                                // \"DataCloneError\" generated by Chrome when you try to inject blob into IndexedDB\n                                if (ex.code === 25) {\n                                    Database.IsUASupportingBlobStorage = false;\n                                }\n                                image.src = url;\n                            }\n                        }\n                        else {\n                            image.src = url;\n                        }\n                    }, false);\n                    xhr.addEventListener(\"error\", function (event) {\n                        BABYLON.Tools.Error(\"Error in XHR request in BABYLON.Database.\");\n                        image.src = url;\n                    }, false);\n                    xhr.send();\n                }\n                else {\n                    image.src = url;\n                }\n            }\n            else {\n                BABYLON.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n                image.src = url;\n            }\n        };\n        Database.prototype._checkVersionFromDB = function (url, versionLoaded) {\n            var _this = this;\n            var updateVersion = function (event) {\n                // the version is not yet in the DB or we need to update it\n                _this._saveVersionIntoDBAsync(url, versionLoaded);\n            };\n            this._loadVersionFromDBAsync(url, versionLoaded, updateVersion);\n        };\n        Database.prototype._loadVersionFromDBAsync = function (url, callback, updateInDBCallback) {\n            var _this = this;\n            if (this.isSupported) {\n                var version;\n                try {\n                    var transaction = this.db.transaction([\"versions\"]);\n                    transaction.oncomplete = function (event) {\n                        if (version) {\n                            // If the version in the JSON file is > than the version in DB\n                            if (_this.manifestVersionFound > version.data) {\n                                _this.mustUpdateRessources = true;\n                                updateInDBCallback();\n                            }\n                            else {\n                                callback(version.data);\n                            }\n                        }\n                        else {\n                            _this.mustUpdateRessources = true;\n                            updateInDBCallback();\n                        }\n                    };\n                    transaction.onabort = function (event) {\n                        callback(-1);\n                    };\n                    var getRequest = transaction.objectStore(\"versions\").get(url);\n                    getRequest.onsuccess = function (event) {\n                        version = (event.target).result;\n                    };\n                    getRequest.onerror = function (event) {\n                        BABYLON.Tools.Error(\"Error loading version for scene \" + url + \" from DB.\");\n                        callback(-1);\n                    };\n                }\n                catch (ex) {\n                    BABYLON.Tools.Error(\"Error while accessing 'versions' object store (READ OP). Exception: \" + ex.message);\n                    callback(-1);\n                }\n            }\n            else {\n                BABYLON.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n                callback(-1);\n            }\n        };\n        Database.prototype._saveVersionIntoDBAsync = function (url, callback) {\n            var _this = this;\n            if (this.isSupported && !this.hasReachedQuota) {\n                try {\n                    // Open a transaction to the database\n                    var transaction = this.db.transaction([\"versions\"], \"readwrite\");\n                    // the transaction could abort because of a QuotaExceededError error\n                    transaction.onabort = function (event) {\n                        try {\n                            if (event.srcElement['error'] && event.srcElement['error'].name === \"QuotaExceededError\") {\n                                _this.hasReachedQuota = true;\n                            }\n                        }\n                        catch (ex) { }\n                        callback(-1);\n                    };\n                    transaction.oncomplete = function (event) {\n                        callback(_this.manifestVersionFound);\n                    };\n                    var newVersion = { sceneUrl: url, data: this.manifestVersionFound };\n                    // Put the scene into the database\n                    var addRequest = transaction.objectStore(\"versions\").put(newVersion);\n                    addRequest.onsuccess = function (event) {\n                    };\n                    addRequest.onerror = function (event) {\n                        BABYLON.Tools.Error(\"Error in DB add version request in BABYLON.Database.\");\n                    };\n                }\n                catch (ex) {\n                    BABYLON.Tools.Error(\"Error while accessing 'versions' object store (WRITE OP). Exception: \" + ex.message);\n                    callback(-1);\n                }\n            }\n            else {\n                callback(-1);\n            }\n        };\n        Database.prototype.loadFileFromDB = function (url, sceneLoaded, progressCallBack, errorCallback, useArrayBuffer) {\n            var _this = this;\n            var completeUrl = Database.ReturnFullUrlLocation(url);\n            var saveAndLoadFile = function (event) {\n                // the scene is not yet in the DB, let's try to save it\n                _this._saveFileIntoDBAsync(completeUrl, sceneLoaded, progressCallBack);\n            };\n            this._checkVersionFromDB(completeUrl, function (version) {\n                if (version !== -1) {\n                    if (!_this.mustUpdateRessources) {\n                        _this._loadFileFromDBAsync(completeUrl, sceneLoaded, saveAndLoadFile, useArrayBuffer);\n                    }\n                    else {\n                        _this._saveFileIntoDBAsync(completeUrl, sceneLoaded, progressCallBack, useArrayBuffer);\n                    }\n                }\n                else {\n                    errorCallback();\n                }\n            });\n        };\n        Database.prototype._loadFileFromDBAsync = function (url, callback, notInDBCallback, useArrayBuffer) {\n            if (this.isSupported) {\n                var targetStore;\n                if (url.indexOf(\".babylon\") !== -1) {\n                    targetStore = \"scenes\";\n                }\n                else {\n                    targetStore = \"textures\";\n                }\n                var file;\n                var transaction = this.db.transaction([targetStore]);\n                transaction.oncomplete = function (event) {\n                    if (file) {\n                        callback(file.data);\n                    }\n                    else {\n                        notInDBCallback();\n                    }\n                };\n                transaction.onabort = function (event) {\n                    notInDBCallback();\n                };\n                var getRequest = transaction.objectStore(targetStore).get(url);\n                getRequest.onsuccess = function (event) {\n                    file = (event.target).result;\n                };\n                getRequest.onerror = function (event) {\n                    BABYLON.Tools.Error(\"Error loading file \" + url + \" from DB.\");\n                    notInDBCallback();\n                };\n            }\n            else {\n                BABYLON.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n                callback();\n            }\n        };\n        Database.prototype._saveFileIntoDBAsync = function (url, callback, progressCallback, useArrayBuffer) {\n            var _this = this;\n            if (this.isSupported) {\n                var targetStore;\n                if (url.indexOf(\".babylon\") !== -1) {\n                    targetStore = \"scenes\";\n                }\n                else {\n                    targetStore = \"textures\";\n                }\n                // Create XHR\n                var xhr = new XMLHttpRequest(), fileData;\n                xhr.open(\"GET\", url, true);\n                if (useArrayBuffer) {\n                    xhr.responseType = \"arraybuffer\";\n                }\n                xhr.onprogress = progressCallback;\n                xhr.addEventListener(\"load\", function () {\n                    if (xhr.status === 200 || BABYLON.Tools.ValidateXHRData(xhr, !useArrayBuffer ? 1 : 6)) {\n                        // Blob as response (XHR2)\n                        //fileData = xhr.responseText;\n                        fileData = !useArrayBuffer ? xhr.responseText : xhr.response;\n                        if (!_this.hasReachedQuota) {\n                            // Open a transaction to the database\n                            var transaction = _this.db.transaction([targetStore], \"readwrite\");\n                            // the transaction could abort because of a QuotaExceededError error\n                            transaction.onabort = function (event) {\n                                try {\n                                    //backwards compatibility with ts 1.0, srcElement doesn't have an \"error\" according to ts 1.3\n                                    if (event.srcElement['error'] && event.srcElement['error'].name === \"QuotaExceededError\") {\n                                        _this.hasReachedQuota = true;\n                                    }\n                                }\n                                catch (ex) { }\n                                callback(fileData);\n                            };\n                            transaction.oncomplete = function (event) {\n                                callback(fileData);\n                            };\n                            var newFile;\n                            if (targetStore === \"scenes\") {\n                                newFile = { sceneUrl: url, data: fileData, version: _this.manifestVersionFound };\n                            }\n                            else {\n                                newFile = { textureUrl: url, data: fileData };\n                            }\n                            try {\n                                // Put the scene into the database\n                                var addRequest = transaction.objectStore(targetStore).put(newFile);\n                                addRequest.onsuccess = function (event) {\n                                };\n                                addRequest.onerror = function (event) {\n                                    BABYLON.Tools.Error(\"Error in DB add file request in BABYLON.Database.\");\n                                };\n                            }\n                            catch (ex) {\n                                callback(fileData);\n                            }\n                        }\n                        else {\n                            callback(fileData);\n                        }\n                    }\n                    else {\n                        callback();\n                    }\n                }, false);\n                xhr.addEventListener(\"error\", function (event) {\n                    BABYLON.Tools.Error(\"error on XHR request.\");\n                    callback();\n                }, false);\n                xhr.send();\n            }\n            else {\n                BABYLON.Tools.Error(\"Error: IndexedDB not supported by your browser or BabylonJS Database is not open.\");\n                callback();\n            }\n        };\n        return Database;\n    }());\n    Database.IsUASupportingBlobStorage = true;\n    Database.IDBStorageEnabled = true;\n    Database.parseURL = function (url) {\n        var a = document.createElement('a');\n        a.href = url;\n        var urlWithoutHash = url.substring(0, url.lastIndexOf(\"#\"));\n        var fileName = url.substring(urlWithoutHash.lastIndexOf(\"/\") + 1, url.length);\n        var absLocation = url.substring(0, url.indexOf(fileName, 0));\n        return absLocation;\n    };\n    Database.ReturnFullUrlLocation = function (url) {\n        if (url.indexOf(\"http:/\") === -1 && url.indexOf(\"https:/\") === -1) {\n            return (Database.parseURL(window.location.href) + url);\n        }\n        else {\n            return url;\n        }\n    };\n    BABYLON.Database = Database;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.database.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var FresnelParameters = (function () {\n        function FresnelParameters() {\n            this._isEnabled = true;\n            this.leftColor = BABYLON.Color3.White();\n            this.rightColor = BABYLON.Color3.Black();\n            this.bias = 0;\n            this.power = 1;\n        }\n        Object.defineProperty(FresnelParameters.prototype, \"isEnabled\", {\n            get: function () {\n                return this._isEnabled;\n            },\n            set: function (value) {\n                if (this._isEnabled === value) {\n                    return;\n                }\n                this._isEnabled = value;\n                BABYLON.Engine.MarkAllMaterialsAsDirty(BABYLON.Material.FresnelDirtyFlag);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        FresnelParameters.prototype.clone = function () {\n            var newFresnelParameters = new FresnelParameters();\n            BABYLON.Tools.DeepCopy(this, newFresnelParameters);\n            return newFresnelParameters;\n        };\n        FresnelParameters.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.isEnabled = this.isEnabled;\n            serializationObject.leftColor = this.leftColor;\n            serializationObject.rightColor = this.rightColor;\n            serializationObject.bias = this.bias;\n            serializationObject.power = this.power;\n            return serializationObject;\n        };\n        FresnelParameters.Parse = function (parsedFresnelParameters) {\n            var fresnelParameters = new FresnelParameters();\n            fresnelParameters.isEnabled = parsedFresnelParameters.isEnabled;\n            fresnelParameters.leftColor = BABYLON.Color3.FromArray(parsedFresnelParameters.leftColor);\n            fresnelParameters.rightColor = BABYLON.Color3.FromArray(parsedFresnelParameters.rightColor);\n            fresnelParameters.bias = parsedFresnelParameters.bias;\n            fresnelParameters.power = parsedFresnelParameters.power || 1.0;\n            return fresnelParameters;\n        };\n        return FresnelParameters;\n    }());\n    BABYLON.FresnelParameters = FresnelParameters;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.fresnelParameters.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var MultiMaterial = (function (_super) {\n        __extends(MultiMaterial, _super);\n        function MultiMaterial(name, scene) {\n            var _this = _super.call(this, name, scene, true) || this;\n            scene.multiMaterials.push(_this);\n            _this.subMaterials = new Array();\n            return _this;\n        }\n        Object.defineProperty(MultiMaterial.prototype, \"subMaterials\", {\n            get: function () {\n                return this._subMaterials;\n            },\n            set: function (value) {\n                this._subMaterials = value;\n                this._hookArray(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MultiMaterial.prototype._hookArray = function (array) {\n            var _this = this;\n            var oldPush = array.push;\n            array.push = function () {\n                var items = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    items[_i] = arguments[_i];\n                }\n                var result = oldPush.apply(array, items);\n                _this._markAllSubMeshesAsTexturesDirty();\n                return result;\n            };\n            var oldSplice = array.splice;\n            array.splice = function (index, deleteCount) {\n                var deleted = oldSplice.apply(array, [index, deleteCount]);\n                _this._markAllSubMeshesAsTexturesDirty();\n                return deleted;\n            };\n        };\n        // Properties\n        MultiMaterial.prototype.getSubMaterial = function (index) {\n            if (index < 0 || index >= this.subMaterials.length) {\n                return this.getScene().defaultMaterial;\n            }\n            return this.subMaterials[index];\n        };\n        MultiMaterial.prototype.getActiveTextures = function () {\n            return (_a = _super.prototype.getActiveTextures.call(this)).concat.apply(_a, this.subMaterials.map(function (subMaterial) { return subMaterial.getActiveTextures(); }));\n            var _a;\n        };\n        // Methods\n        MultiMaterial.prototype.getClassName = function () {\n            return \"MultiMaterial\";\n        };\n        MultiMaterial.prototype.isReady = function (mesh) {\n            for (var index = 0; index < this.subMaterials.length; index++) {\n                var subMaterial = this.subMaterials[index];\n                if (subMaterial) {\n                    if (!this.subMaterials[index].isReady(mesh)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        MultiMaterial.prototype.clone = function (name, cloneChildren) {\n            var newMultiMaterial = new MultiMaterial(name, this.getScene());\n            for (var index = 0; index < this.subMaterials.length; index++) {\n                var subMaterial = null;\n                if (cloneChildren) {\n                    subMaterial = this.subMaterials[index].clone(name + \"-\" + this.subMaterials[index].name);\n                }\n                else {\n                    subMaterial = this.subMaterials[index];\n                }\n                newMultiMaterial.subMaterials.push(subMaterial);\n            }\n            return newMultiMaterial;\n        };\n        MultiMaterial.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.id = this.id;\n            serializationObject.tags = BABYLON.Tags.GetTags(this);\n            serializationObject.materials = [];\n            for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {\n                var subMat = this.subMaterials[matIndex];\n                if (subMat) {\n                    serializationObject.materials.push(subMat.id);\n                }\n                else {\n                    serializationObject.materials.push(null);\n                }\n            }\n            return serializationObject;\n        };\n        return MultiMaterial;\n    }(BABYLON.Material));\n    BABYLON.MultiMaterial = MultiMaterial;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.multiMaterial.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraTouchInput = (function () {\n        function FreeCameraTouchInput() {\n            this._offsetX = null;\n            this._offsetY = null;\n            this._pointerCount = 0;\n            this._pointerPressed = [];\n            this.touchAngularSensibility = 200000.0;\n            this.touchMoveSensibility = 250.0;\n        }\n        FreeCameraTouchInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            var previousPosition;\n            if (this._pointerInput === undefined) {\n                this._onLostFocus = function (evt) {\n                    _this._offsetX = null;\n                    _this._offsetY = null;\n                };\n                this._pointerInput = function (p, s) {\n                    var evt = p.event;\n                    if (evt.pointerType === \"mouse\") {\n                        return;\n                    }\n                    if (p.type === BABYLON.PointerEventTypes.POINTERDOWN) {\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                        _this._pointerPressed.push(evt.pointerId);\n                        if (_this._pointerPressed.length !== 1) {\n                            return;\n                        }\n                        previousPosition = {\n                            x: evt.clientX,\n                            y: evt.clientY\n                        };\n                    }\n                    else if (p.type === BABYLON.PointerEventTypes.POINTERUP) {\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                        var index = _this._pointerPressed.indexOf(evt.pointerId);\n                        if (index === -1) {\n                            return;\n                        }\n                        _this._pointerPressed.splice(index, 1);\n                        if (index != 0) {\n                            return;\n                        }\n                        previousPosition = null;\n                        _this._offsetX = null;\n                        _this._offsetY = null;\n                    }\n                    else if (p.type === BABYLON.PointerEventTypes.POINTERMOVE) {\n                        if (!noPreventDefault) {\n                            evt.preventDefault();\n                        }\n                        if (!previousPosition) {\n                            return;\n                        }\n                        var index = _this._pointerPressed.indexOf(evt.pointerId);\n                        if (index != 0) {\n                            return;\n                        }\n                        _this._offsetX = evt.clientX - previousPosition.x;\n                        _this._offsetY = -(evt.clientY - previousPosition.y);\n                    }\n                };\n            }\n            this._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, BABYLON.PointerEventTypes.POINTERDOWN | BABYLON.PointerEventTypes.POINTERUP | BABYLON.PointerEventTypes.POINTERMOVE);\n            element.addEventListener(\"blur\", this._onLostFocus);\n        };\n        FreeCameraTouchInput.prototype.detachControl = function (element) {\n            if (this._pointerInput && element) {\n                this.camera.getScene().onPointerObservable.remove(this._observer);\n                this._observer = null;\n                element.removeEventListener(\"blur\", this._onLostFocus);\n                this._onLostFocus = null;\n                this._pointerPressed = [];\n                this._offsetX = null;\n                this._offsetY = null;\n                this._pointerCount = 0;\n            }\n        };\n        FreeCameraTouchInput.prototype.checkInputs = function () {\n            if (this._offsetX) {\n                var camera = this.camera;\n                camera.cameraRotation.y += this._offsetX / this.touchAngularSensibility;\n                if (this._pointerPressed.length > 1) {\n                    camera.cameraRotation.x += -this._offsetY / this.touchAngularSensibility;\n                }\n                else {\n                    var speed = camera._computeLocalCameraSpeed();\n                    var direction = new BABYLON.Vector3(0, 0, speed * this._offsetY / this.touchMoveSensibility);\n                    BABYLON.Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n                    camera.cameraDirection.addInPlace(BABYLON.Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n                }\n            }\n        };\n        FreeCameraTouchInput.prototype.getTypeName = function () {\n            return \"FreeCameraTouchInput\";\n        };\n        FreeCameraTouchInput.prototype.getSimpleName = function () {\n            return \"touch\";\n        };\n        return FreeCameraTouchInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraTouchInput.prototype, \"touchAngularSensibility\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraTouchInput.prototype, \"touchMoveSensibility\", void 0);\n    BABYLON.FreeCameraTouchInput = FreeCameraTouchInput;\n    BABYLON.CameraInputTypes[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraTouchInput.js.map\n\n/// <reference path=\"babylon.freeCamera.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    // We're mainly based on the logic defined into the FreeCamera code\n    var TouchCamera = (function (_super) {\n        __extends(TouchCamera, _super);\n        //-- end properties for backward compatibility for inputs\n        function TouchCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.inputs.addTouch();\n            _this._setupInputs();\n            return _this;\n        }\n        Object.defineProperty(TouchCamera.prototype, \"touchAngularSensibility\", {\n            //-- Begin properties for backward compatibility for inputs\n            get: function () {\n                var touch = this.inputs.attached[\"touch\"];\n                if (touch)\n                    return touch.touchAngularSensibility;\n            },\n            set: function (value) {\n                var touch = this.inputs.attached[\"touch\"];\n                if (touch)\n                    touch.touchAngularSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TouchCamera.prototype, \"touchMoveSensibility\", {\n            get: function () {\n                var touch = this.inputs.attached[\"touch\"];\n                if (touch)\n                    return touch.touchMoveSensibility;\n            },\n            set: function (value) {\n                var touch = this.inputs.attached[\"touch\"];\n                if (touch)\n                    touch.touchMoveSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        TouchCamera.prototype.getClassName = function () {\n            return \"TouchCamera\";\n        };\n        TouchCamera.prototype._setupInputs = function () {\n            var mouse = this.inputs.attached[\"mouse\"];\n            if (mouse) {\n                mouse.touchEnabled = false;\n            }\n        };\n        return TouchCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.TouchCamera = TouchCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.touchCamera.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ProceduralTexture = (function (_super) {\n        __extends(ProceduralTexture, _super);\n        function ProceduralTexture(name, size, fragment, scene, fallbackTexture, generateMipMaps, isCube) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            if (isCube === void 0) { isCube = false; }\n            var _this = _super.call(this, null, scene, !generateMipMaps) || this;\n            _this.isCube = isCube;\n            _this.isEnabled = true;\n            _this._currentRefreshId = -1;\n            _this._refreshRate = 1;\n            _this._vertexBuffers = {};\n            _this._uniforms = new Array();\n            _this._samplers = new Array();\n            _this._textures = new Array();\n            _this._floats = new Array();\n            _this._floatsArrays = {};\n            _this._colors3 = new Array();\n            _this._colors4 = new Array();\n            _this._vectors2 = new Array();\n            _this._vectors3 = new Array();\n            _this._matrices = new Array();\n            _this._fallbackTextureUsed = false;\n            scene._proceduralTextures.push(_this);\n            _this.name = name;\n            _this.isRenderTarget = true;\n            _this._size = size;\n            _this._generateMipMaps = generateMipMaps;\n            _this.setFragment(fragment);\n            _this._fallbackTexture = fallbackTexture;\n            var engine = scene.getEngine();\n            if (isCube) {\n                _this._texture = engine.createRenderTargetCubeTexture(size, { generateMipMaps: generateMipMaps });\n                _this.setFloat(\"face\", 0);\n            }\n            else {\n                _this._texture = engine.createRenderTargetTexture(size, generateMipMaps);\n            }\n            // VBO\n            var vertices = [];\n            vertices.push(1, 1);\n            vertices.push(-1, 1);\n            vertices.push(-1, -1);\n            vertices.push(1, -1);\n            _this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = new BABYLON.VertexBuffer(engine, vertices, BABYLON.VertexBuffer.PositionKind, false, false, 2);\n            // Indices\n            var indices = [];\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            _this._indexBuffer = engine.createIndexBuffer(indices);\n            return _this;\n        }\n        ProceduralTexture.prototype.reset = function () {\n            if (this._effect === undefined) {\n                return;\n            }\n            var engine = this.getScene().getEngine();\n            engine._releaseEffect(this._effect);\n        };\n        ProceduralTexture.prototype.isReady = function () {\n            var _this = this;\n            var engine = this.getScene().getEngine();\n            var shaders;\n            if (!this._fragment) {\n                return false;\n            }\n            if (this._fallbackTextureUsed) {\n                return true;\n            }\n            if (this._fragment.fragmentElement !== undefined) {\n                shaders = { vertex: \"procedural\", fragmentElement: this._fragment.fragmentElement };\n            }\n            else {\n                shaders = { vertex: \"procedural\", fragment: this._fragment };\n            }\n            this._effect = engine.createEffect(shaders, [BABYLON.VertexBuffer.PositionKind], this._uniforms, this._samplers, \"\", null, null, function () {\n                _this.releaseInternalTexture();\n                if (_this._fallbackTexture) {\n                    _this._texture = _this._fallbackTexture._texture;\n                    _this._texture.references++;\n                }\n                _this._fallbackTextureUsed = true;\n            });\n            return this._effect.isReady();\n        };\n        ProceduralTexture.prototype.resetRefreshCounter = function () {\n            this._currentRefreshId = -1;\n        };\n        ProceduralTexture.prototype.setFragment = function (fragment) {\n            this._fragment = fragment;\n        };\n        Object.defineProperty(ProceduralTexture.prototype, \"refreshRate\", {\n            get: function () {\n                return this._refreshRate;\n            },\n            // Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\n            set: function (value) {\n                this._refreshRate = value;\n                this.resetRefreshCounter();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ProceduralTexture.prototype._shouldRender = function () {\n            if (!this.isEnabled || !this.isReady() || !this._texture) {\n                return false;\n            }\n            if (this._fallbackTextureUsed) {\n                return false;\n            }\n            if (this._currentRefreshId === -1) {\n                this._currentRefreshId = 1;\n                return true;\n            }\n            if (this.refreshRate === this._currentRefreshId) {\n                this._currentRefreshId = 1;\n                return true;\n            }\n            this._currentRefreshId++;\n            return false;\n        };\n        ProceduralTexture.prototype.getRenderSize = function () {\n            return this._size;\n        };\n        ProceduralTexture.prototype.resize = function (size, generateMipMaps) {\n            if (this._fallbackTextureUsed) {\n                return;\n            }\n            this.releaseInternalTexture();\n            this._texture = this.getScene().getEngine().createRenderTargetTexture(size, generateMipMaps);\n        };\n        ProceduralTexture.prototype._checkUniform = function (uniformName) {\n            if (this._uniforms.indexOf(uniformName) === -1) {\n                this._uniforms.push(uniformName);\n            }\n        };\n        ProceduralTexture.prototype.setTexture = function (name, texture) {\n            if (this._samplers.indexOf(name) === -1) {\n                this._samplers.push(name);\n            }\n            this._textures[name] = texture;\n            return this;\n        };\n        ProceduralTexture.prototype.setFloat = function (name, value) {\n            this._checkUniform(name);\n            this._floats[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setFloats = function (name, value) {\n            this._checkUniform(name);\n            this._floatsArrays[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setColor3 = function (name, value) {\n            this._checkUniform(name);\n            this._colors3[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setColor4 = function (name, value) {\n            this._checkUniform(name);\n            this._colors4[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setVector2 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors2[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setVector3 = function (name, value) {\n            this._checkUniform(name);\n            this._vectors3[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.setMatrix = function (name, value) {\n            this._checkUniform(name);\n            this._matrices[name] = value;\n            return this;\n        };\n        ProceduralTexture.prototype.render = function (useCameraPostProcess) {\n            var scene = this.getScene();\n            var engine = scene.getEngine();\n            // Render\n            engine.enableEffect(this._effect);\n            engine.setState(false);\n            // Texture\n            for (var name in this._textures) {\n                this._effect.setTexture(name, this._textures[name]);\n            }\n            // Float    \n            for (name in this._floats) {\n                this._effect.setFloat(name, this._floats[name]);\n            }\n            // Floats   \n            for (name in this._floatsArrays) {\n                this._effect.setArray(name, this._floatsArrays[name]);\n            }\n            // Color3        \n            for (name in this._colors3) {\n                this._effect.setColor3(name, this._colors3[name]);\n            }\n            // Color4      \n            for (name in this._colors4) {\n                var color = this._colors4[name];\n                this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\n            }\n            // Vector2        \n            for (name in this._vectors2) {\n                this._effect.setVector2(name, this._vectors2[name]);\n            }\n            // Vector3        \n            for (name in this._vectors3) {\n                this._effect.setVector3(name, this._vectors3[name]);\n            }\n            // Matrix      \n            for (name in this._matrices) {\n                this._effect.setMatrix(name, this._matrices[name]);\n            }\n            if (this.isCube) {\n                for (var face = 0; face < 6; face++) {\n                    engine.bindFramebuffer(this._texture, face);\n                    // VBOs\n                    engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n                    this._effect.setFloat(\"face\", face);\n                    // Clear\n                    engine.clear(scene.clearColor, true, true, true);\n                    // Draw order\n                    engine.draw(true, 0, 6);\n                    // Mipmaps\n                    if (face === 5) {\n                        engine.generateMipMapsForCubemap(this._texture);\n                    }\n                }\n            }\n            else {\n                engine.bindFramebuffer(this._texture);\n                // VBOs\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n                // Clear\n                engine.clear(scene.clearColor, true, true, true);\n                // Draw order\n                engine.draw(true, 0, 6);\n            }\n            // Unbind\n            engine.unBindFramebuffer(this._texture, this.isCube);\n            if (this.onGenerated) {\n                this.onGenerated();\n            }\n        };\n        ProceduralTexture.prototype.clone = function () {\n            var textureSize = this.getSize();\n            var newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);\n            // Base texture\n            newTexture.hasAlpha = this.hasAlpha;\n            newTexture.level = this.level;\n            // RenderTarget Texture\n            newTexture.coordinatesMode = this.coordinatesMode;\n            return newTexture;\n        };\n        ProceduralTexture.prototype.dispose = function () {\n            var index = this.getScene()._proceduralTextures.indexOf(this);\n            if (index >= 0) {\n                this.getScene()._proceduralTextures.splice(index, 1);\n            }\n            var vertexBuffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (vertexBuffer) {\n                vertexBuffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            if (this._indexBuffer && this.getScene().getEngine()._releaseBuffer(this._indexBuffer)) {\n                this._indexBuffer = null;\n            }\n            _super.prototype.dispose.call(this);\n        };\n        return ProceduralTexture;\n    }(BABYLON.Texture));\n    BABYLON.ProceduralTexture = ProceduralTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.proceduralTexture.js.map\n\n/// <reference path=\"babylon.proceduralTexture.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var CustomProceduralTexture = (function (_super) {\n        __extends(CustomProceduralTexture, _super);\n        function CustomProceduralTexture(name, texturePath, size, scene, fallbackTexture, generateMipMaps) {\n            var _this = _super.call(this, name, size, null, scene, fallbackTexture, generateMipMaps) || this;\n            _this._animate = true;\n            _this._time = 0;\n            _this._texturePath = texturePath;\n            //Try to load json\n            _this.loadJson(texturePath);\n            _this.refreshRate = 1;\n            return _this;\n        }\n        CustomProceduralTexture.prototype.loadJson = function (jsonUrl) {\n            var _this = this;\n            var that = this;\n            function noConfigFile() {\n                BABYLON.Tools.Log(\"No config file found in \" + jsonUrl + \" trying to use ShadersStore or DOM element\");\n                try {\n                    that.setFragment(that._texturePath);\n                }\n                catch (ex) {\n                    BABYLON.Tools.Error(\"No json or ShaderStore or DOM element found for CustomProceduralTexture\");\n                }\n            }\n            var configFileUrl = jsonUrl + \"/config.json\";\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"GET\", configFileUrl, true);\n            xhr.addEventListener(\"load\", function () {\n                if (xhr.status === 200 || BABYLON.Tools.ValidateXHRData(xhr, 1)) {\n                    try {\n                        _this._config = JSON.parse(xhr.response);\n                        _this.updateShaderUniforms();\n                        _this.updateTextures();\n                        _this.setFragment(_this._texturePath + \"/custom\");\n                        _this._animate = _this._config.animate;\n                        _this.refreshRate = _this._config.refreshrate;\n                    }\n                    catch (ex) {\n                        noConfigFile();\n                    }\n                }\n                else {\n                    noConfigFile();\n                }\n            }, false);\n            xhr.addEventListener(\"error\", function () {\n                noConfigFile();\n            }, false);\n            try {\n                xhr.send();\n            }\n            catch (ex) {\n                BABYLON.Tools.Error(\"CustomProceduralTexture: Error on XHR send request.\");\n            }\n        };\n        CustomProceduralTexture.prototype.isReady = function () {\n            if (!_super.prototype.isReady.call(this)) {\n                return false;\n            }\n            for (var name in this._textures) {\n                var texture = this._textures[name];\n                if (!texture.isReady()) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        CustomProceduralTexture.prototype.render = function (useCameraPostProcess) {\n            if (this._animate) {\n                this._time += this.getScene().getAnimationRatio() * 0.03;\n                this.updateShaderUniforms();\n            }\n            _super.prototype.render.call(this, useCameraPostProcess);\n        };\n        CustomProceduralTexture.prototype.updateTextures = function () {\n            for (var i = 0; i < this._config.sampler2Ds.length; i++) {\n                this.setTexture(this._config.sampler2Ds[i].sample2Dname, new BABYLON.Texture(this._texturePath + \"/\" + this._config.sampler2Ds[i].textureRelativeUrl, this.getScene()));\n            }\n        };\n        CustomProceduralTexture.prototype.updateShaderUniforms = function () {\n            if (this._config) {\n                for (var j = 0; j < this._config.uniforms.length; j++) {\n                    var uniform = this._config.uniforms[j];\n                    switch (uniform.type) {\n                        case \"float\":\n                            this.setFloat(uniform.name, uniform.value);\n                            break;\n                        case \"color3\":\n                            this.setColor3(uniform.name, new BABYLON.Color3(uniform.r, uniform.g, uniform.b));\n                            break;\n                        case \"color4\":\n                            this.setColor4(uniform.name, new BABYLON.Color4(uniform.r, uniform.g, uniform.b, uniform.a));\n                            break;\n                        case \"vector2\":\n                            this.setVector2(uniform.name, new BABYLON.Vector2(uniform.x, uniform.y));\n                            break;\n                        case \"vector3\":\n                            this.setVector3(uniform.name, new BABYLON.Vector3(uniform.x, uniform.y, uniform.z));\n                            break;\n                    }\n                }\n            }\n            this.setFloat(\"time\", this._time);\n        };\n        Object.defineProperty(CustomProceduralTexture.prototype, \"animate\", {\n            get: function () {\n                return this._animate;\n            },\n            set: function (value) {\n                this._animate = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return CustomProceduralTexture;\n    }(BABYLON.ProceduralTexture));\n    BABYLON.CustomProceduralTexture = CustomProceduralTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.customProceduralTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraGamepadInput = (function () {\n        function FreeCameraGamepadInput() {\n            this.gamepadAngularSensibility = 200;\n            this.gamepadMoveSensibility = 40;\n            // private members\n            this._cameraTransform = BABYLON.Matrix.Identity();\n            this._deltaTransform = BABYLON.Vector3.Zero();\n            this._vector3 = BABYLON.Vector3.Zero();\n            this._vector2 = BABYLON.Vector2.Zero();\n        }\n        FreeCameraGamepadInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            this._gamepads = new BABYLON.Gamepads(function (gamepad) { _this._onNewGameConnected(gamepad); });\n        };\n        FreeCameraGamepadInput.prototype.detachControl = function (element) {\n            if (this._gamepads) {\n                this._gamepads.dispose();\n            }\n            this.gamepad = null;\n        };\n        FreeCameraGamepadInput.prototype.checkInputs = function () {\n            if (this.gamepad && this.gamepad.leftStick) {\n                var camera = this.camera;\n                var LSValues = this.gamepad.leftStick;\n                var normalizedLX = LSValues.x / this.gamepadMoveSensibility;\n                var normalizedLY = LSValues.y / this.gamepadMoveSensibility;\n                LSValues.x = Math.abs(normalizedLX) > 0.005 ? 0 + normalizedLX : 0;\n                LSValues.y = Math.abs(normalizedLY) > 0.005 ? 0 + normalizedLY : 0;\n                var RSValues = this.gamepad.rightStick;\n                if (RSValues) {\n                    var normalizedRX = RSValues.x / this.gamepadAngularSensibility;\n                    var normalizedRY = RSValues.y / this.gamepadAngularSensibility;\n                    RSValues.x = Math.abs(normalizedRX) > 0.001 ? 0 + normalizedRX : 0;\n                    RSValues.y = Math.abs(normalizedRY) > 0.001 ? 0 + normalizedRY : 0;\n                }\n                else {\n                    RSValues = { x: 0, y: 0 };\n                }\n                if (!camera.rotationQuaternion) {\n                    BABYLON.Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, this._cameraTransform);\n                }\n                else {\n                    camera.rotationQuaternion.toRotationMatrix(this._cameraTransform);\n                }\n                var speed = camera._computeLocalCameraSpeed() * 50.0;\n                this._vector3.copyFromFloats(LSValues.x * speed, 0, -LSValues.y * speed);\n                BABYLON.Vector3.TransformCoordinatesToRef(this._vector3, this._cameraTransform, this._deltaTransform);\n                camera.cameraDirection.addInPlace(this._deltaTransform);\n                this._vector2.copyFromFloats(RSValues.y, RSValues.x);\n                camera.cameraRotation.addInPlace(this._vector2);\n            }\n        };\n        FreeCameraGamepadInput.prototype._onNewGameConnected = function (gamepad) {\n            // Only the first gamepad found can control the camera\n            if (gamepad.type !== BABYLON.Gamepad.POSE_ENABLED) {\n                // prioritize XBOX gamepads.\n                if (!this.gamepad || gamepad.type === BABYLON.Gamepad.XBOX) {\n                    this.gamepad = gamepad;\n                }\n            }\n        };\n        FreeCameraGamepadInput.prototype.getTypeName = function () {\n            return \"FreeCameraGamepadInput\";\n        };\n        FreeCameraGamepadInput.prototype.getSimpleName = function () {\n            return \"gamepad\";\n        };\n        return FreeCameraGamepadInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraGamepadInput.prototype, \"gamepadAngularSensibility\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FreeCameraGamepadInput.prototype, \"gamepadMoveSensibility\", void 0);\n    BABYLON.FreeCameraGamepadInput = FreeCameraGamepadInput;\n    BABYLON.CameraInputTypes[\"FreeCameraGamepadInput\"] = FreeCameraGamepadInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraGamepadInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCameraGamepadInput = (function () {\n        function ArcRotateCameraGamepadInput() {\n            this.gamepadRotationSensibility = 80;\n            this.gamepadMoveSensibility = 40;\n        }\n        ArcRotateCameraGamepadInput.prototype.attachControl = function (element, noPreventDefault) {\n            var _this = this;\n            this._gamepads = new BABYLON.Gamepads(function (gamepad) { _this._onNewGameConnected(gamepad); });\n        };\n        ArcRotateCameraGamepadInput.prototype.detachControl = function (element) {\n            if (this._gamepads) {\n                this._gamepads.dispose();\n            }\n            this.gamepad = null;\n        };\n        ArcRotateCameraGamepadInput.prototype.checkInputs = function () {\n            if (this.gamepad) {\n                var camera = this.camera;\n                var RSValues = this.gamepad.rightStick;\n                if (RSValues) {\n                    if (RSValues.x != 0) {\n                        var normalizedRX = RSValues.x / this.gamepadRotationSensibility;\n                        if (normalizedRX != 0 && Math.abs(normalizedRX) > 0.005) {\n                            camera.inertialAlphaOffset += normalizedRX;\n                        }\n                    }\n                    if (RSValues.y != 0) {\n                        var normalizedRY = RSValues.y / this.gamepadRotationSensibility;\n                        if (normalizedRY != 0 && Math.abs(normalizedRY) > 0.005) {\n                            camera.inertialBetaOffset += normalizedRY;\n                        }\n                    }\n                }\n                var LSValues = this.gamepad.leftStick;\n                if (LSValues && LSValues.y != 0) {\n                    var normalizedLY = LSValues.y / this.gamepadMoveSensibility;\n                    if (normalizedLY != 0 && Math.abs(normalizedLY) > 0.005) {\n                        this.camera.inertialRadiusOffset -= normalizedLY;\n                    }\n                }\n            }\n        };\n        ArcRotateCameraGamepadInput.prototype._onNewGameConnected = function (gamepad) {\n            if (gamepad.type !== BABYLON.Gamepad.POSE_ENABLED) {\n                // prioritize XBOX gamepads.\n                if (!this.gamepad || gamepad.type === BABYLON.Gamepad.XBOX) {\n                    this.gamepad = gamepad;\n                }\n            }\n        };\n        ArcRotateCameraGamepadInput.prototype.getTypeName = function () {\n            return \"ArcRotateCameraGamepadInput\";\n        };\n        ArcRotateCameraGamepadInput.prototype.getSimpleName = function () {\n            return \"gamepad\";\n        };\n        return ArcRotateCameraGamepadInput;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraGamepadInput.prototype, \"gamepadRotationSensibility\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ArcRotateCameraGamepadInput.prototype, \"gamepadMoveSensibility\", void 0);\n    BABYLON.ArcRotateCameraGamepadInput = ArcRotateCameraGamepadInput;\n    BABYLON.CameraInputTypes[\"ArcRotateCameraGamepadInput\"] = ArcRotateCameraGamepadInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraGamepadInput.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Gamepads = (function () {\n        function Gamepads(ongamedpadconnected, ongamedpaddisconnected) {\n            var _this = this;\n            this.babylonGamepads = [];\n            this.oneGamepadConnected = false;\n            this.isMonitoring = false;\n            this.gamepadEventSupported = 'GamepadEvent' in window;\n            this.gamepadSupport = (navigator.getGamepads ||\n                navigator.webkitGetGamepads || navigator.msGetGamepads || navigator.webkitGamepads);\n            this._callbackGamepadConnected = ongamedpadconnected;\n            this._callbackGamepadDisconnected = ongamedpaddisconnected;\n            if (this.gamepadSupport) {\n                //first add already-connected gamepads\n                this._updateGamepadObjects();\n                if (this.babylonGamepads.length) {\n                    this._startMonitoringGamepads();\n                }\n                // Checking if the gamepad connected event is supported (like in Firefox)\n                if (this.gamepadEventSupported) {\n                    this._onGamepadConnectedEvent = function (evt) {\n                        _this._onGamepadConnected(evt.gamepad);\n                    };\n                    this._onGamepadDisonnectedEvent = function (evt) {\n                        _this._onGamepadDisconnected(evt.gamepad);\n                    };\n                    window.addEventListener('gamepadconnected', this._onGamepadConnectedEvent, false);\n                    window.addEventListener('gamepaddisconnected', this._onGamepadDisonnectedEvent, false);\n                }\n                else {\n                    this._startMonitoringGamepads();\n                }\n            }\n        }\n        Gamepads.prototype.dispose = function () {\n            if (this._onGamepadConnectedEvent) {\n                window.removeEventListener('gamepadconnected', this._onGamepadConnectedEvent, false);\n                window.removeEventListener('gamepaddisconnected', this._onGamepadDisonnectedEvent, false);\n                this._onGamepadConnectedEvent = null;\n                this._onGamepadDisonnectedEvent = null;\n            }\n            this.oneGamepadConnected = false;\n            this._stopMonitoringGamepads();\n            this.babylonGamepads = [];\n        };\n        Gamepads.prototype._onGamepadConnected = function (gamepad) {\n            // Protection code for Chrome which has a very buggy gamepad implementation...\n            // And raises a connected event on disconnection for instance\n            if (gamepad.index in this.babylonGamepads) {\n                return;\n            }\n            var newGamepad = this._addNewGamepad(gamepad);\n            if (this._callbackGamepadConnected)\n                this._callbackGamepadConnected(newGamepad);\n            this._startMonitoringGamepads();\n        };\n        Gamepads.prototype._addNewGamepad = function (gamepad) {\n            if (!this.oneGamepadConnected) {\n                this.oneGamepadConnected = true;\n            }\n            var newGamepad;\n            var xboxOne = (gamepad.id.search(\"Xbox One\") !== -1);\n            if (xboxOne || gamepad.id.search(\"Xbox 360\") !== -1 || gamepad.id.search(\"xinput\") !== -1) {\n                newGamepad = new Xbox360Pad(gamepad.id, gamepad.index, gamepad, xboxOne);\n            }\n            else if (gamepad.pose) {\n                newGamepad = BABYLON.PoseEnabledControllerHelper.InitiateController(gamepad);\n            }\n            else {\n                newGamepad = new GenericPad(gamepad.id, gamepad.index, gamepad);\n            }\n            this.babylonGamepads.push(newGamepad);\n            return newGamepad;\n        };\n        Gamepads.prototype._onGamepadDisconnected = function (gamepad) {\n            // Remove the gamepad from the list of gamepads to monitor.\n            for (var i in this.babylonGamepads) {\n                if (this.babylonGamepads[i].index == gamepad.index) {\n                    this.babylonGamepads.splice(+i, 1);\n                    break;\n                }\n            }\n            // If no gamepads are left, stop the polling loop.\n            if (this.babylonGamepads.length == 0) {\n                this._stopMonitoringGamepads();\n                this.oneGamepadConnected = false;\n            }\n            if (this._callbackGamepadDisconnected)\n                this._callbackGamepadDisconnected(gamepad);\n        };\n        Gamepads.prototype._startMonitoringGamepads = function () {\n            if (!this.isMonitoring) {\n                this.isMonitoring = true;\n                this._checkGamepadsStatus();\n            }\n        };\n        Gamepads.prototype._stopMonitoringGamepads = function () {\n            this.isMonitoring = false;\n        };\n        Gamepads.prototype._checkGamepadsStatus = function () {\n            var _this = this;\n            // Hack to be compatible Chrome\n            this._updateGamepadObjects();\n            for (var i in this.babylonGamepads) {\n                this.babylonGamepads[i].update();\n            }\n            if (this.isMonitoring) {\n                if (window.requestAnimationFrame) {\n                    window.requestAnimationFrame(function () { _this._checkGamepadsStatus(); });\n                }\n                else if (window.mozRequestAnimationFrame) {\n                    window.mozRequestAnimationFrame(function () { _this._checkGamepadsStatus(); });\n                }\n                else if (window.webkitRequestAnimationFrame) {\n                    window.webkitRequestAnimationFrame(function () { _this._checkGamepadsStatus(); });\n                }\n            }\n        };\n        // This function is called only on Chrome, which does not properly support\n        // connection/disconnection events and forces you to recopy again the gamepad object\n        Gamepads.prototype._updateGamepadObjects = function () {\n            var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);\n            for (var i = 0; i < gamepads.length; i++) {\n                if (gamepads[i]) {\n                    if (!(gamepads[i].index in this.babylonGamepads)) {\n                        var newGamepad = this._addNewGamepad(gamepads[i]);\n                        if (this._callbackGamepadConnected) {\n                            this._callbackGamepadConnected(newGamepad);\n                        }\n                    }\n                    else {\n                        // Forced to copy again this object for Chrome for unknown reason\n                        this.babylonGamepads[i].browserGamepad = gamepads[i];\n                    }\n                }\n            }\n        };\n        return Gamepads;\n    }());\n    BABYLON.Gamepads = Gamepads;\n    var StickValues = (function () {\n        function StickValues(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        return StickValues;\n    }());\n    BABYLON.StickValues = StickValues;\n    var Gamepad = (function () {\n        function Gamepad(id, index, browserGamepad, leftStickX, leftStickY, rightStickX, rightStickY) {\n            if (leftStickX === void 0) { leftStickX = 0; }\n            if (leftStickY === void 0) { leftStickY = 1; }\n            if (rightStickX === void 0) { rightStickX = 2; }\n            if (rightStickY === void 0) { rightStickY = 3; }\n            this.id = id;\n            this.index = index;\n            this.browserGamepad = browserGamepad;\n            this.type = Gamepad.GAMEPAD;\n            this._leftStickAxisX = leftStickX;\n            this._leftStickAxisY = leftStickY;\n            this._rightStickAxisX = rightStickX;\n            this._rightStickAxisY = rightStickY;\n            if (this.browserGamepad.axes.length >= 2) {\n                this._leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\n            }\n            if (this.browserGamepad.axes.length >= 4) {\n                this._rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\n            }\n        }\n        Gamepad.prototype.onleftstickchanged = function (callback) {\n            this._onleftstickchanged = callback;\n        };\n        Gamepad.prototype.onrightstickchanged = function (callback) {\n            this._onrightstickchanged = callback;\n        };\n        Object.defineProperty(Gamepad.prototype, \"leftStick\", {\n            get: function () {\n                return this._leftStick;\n            },\n            set: function (newValues) {\n                if (this._onleftstickchanged && (this._leftStick.x !== newValues.x || this._leftStick.y !== newValues.y)) {\n                    this._onleftstickchanged(newValues);\n                }\n                this._leftStick = newValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Gamepad.prototype, \"rightStick\", {\n            get: function () {\n                return this._rightStick;\n            },\n            set: function (newValues) {\n                if (this._onrightstickchanged && (this._rightStick.x !== newValues.x || this._rightStick.y !== newValues.y)) {\n                    this._onrightstickchanged(newValues);\n                }\n                this._rightStick = newValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Gamepad.prototype.update = function () {\n            if (this._leftStick) {\n                this.leftStick = { x: this.browserGamepad.axes[this._leftStickAxisX], y: this.browserGamepad.axes[this._leftStickAxisY] };\n            }\n            if (this._rightStick) {\n                this.rightStick = { x: this.browserGamepad.axes[this._rightStickAxisX], y: this.browserGamepad.axes[this._rightStickAxisY] };\n            }\n        };\n        return Gamepad;\n    }());\n    Gamepad.GAMEPAD = 0;\n    Gamepad.GENERIC = 1;\n    Gamepad.XBOX = 2;\n    Gamepad.POSE_ENABLED = 3;\n    BABYLON.Gamepad = Gamepad;\n    var GenericPad = (function (_super) {\n        __extends(GenericPad, _super);\n        function GenericPad(id, index, browserGamepad) {\n            var _this = _super.call(this, id, index, browserGamepad) || this;\n            _this.type = Gamepad.GENERIC;\n            _this._buttons = new Array(browserGamepad.buttons.length);\n            return _this;\n        }\n        GenericPad.prototype.onbuttondown = function (callback) {\n            this._onbuttondown = callback;\n        };\n        GenericPad.prototype.onbuttonup = function (callback) {\n            this._onbuttonup = callback;\n        };\n        GenericPad.prototype._setButtonValue = function (newValue, currentValue, buttonIndex) {\n            if (newValue !== currentValue) {\n                if (this._onbuttondown && newValue === 1) {\n                    this._onbuttondown(buttonIndex);\n                }\n                if (this._onbuttonup && newValue === 0) {\n                    this._onbuttonup(buttonIndex);\n                }\n            }\n            return newValue;\n        };\n        GenericPad.prototype.update = function () {\n            _super.prototype.update.call(this);\n            for (var index = 0; index < this._buttons.length; index++) {\n                this._buttons[index] = this._setButtonValue(this.browserGamepad.buttons[index].value, this._buttons[index], index);\n            }\n        };\n        return GenericPad;\n    }(Gamepad));\n    BABYLON.GenericPad = GenericPad;\n    var Xbox360Button;\n    (function (Xbox360Button) {\n        Xbox360Button[Xbox360Button[\"A\"] = 0] = \"A\";\n        Xbox360Button[Xbox360Button[\"B\"] = 1] = \"B\";\n        Xbox360Button[Xbox360Button[\"X\"] = 2] = \"X\";\n        Xbox360Button[Xbox360Button[\"Y\"] = 3] = \"Y\";\n        Xbox360Button[Xbox360Button[\"Start\"] = 4] = \"Start\";\n        Xbox360Button[Xbox360Button[\"Back\"] = 5] = \"Back\";\n        Xbox360Button[Xbox360Button[\"LB\"] = 6] = \"LB\";\n        Xbox360Button[Xbox360Button[\"RB\"] = 7] = \"RB\";\n        Xbox360Button[Xbox360Button[\"LeftStick\"] = 8] = \"LeftStick\";\n        Xbox360Button[Xbox360Button[\"RightStick\"] = 9] = \"RightStick\";\n    })(Xbox360Button = BABYLON.Xbox360Button || (BABYLON.Xbox360Button = {}));\n    var Xbox360Dpad;\n    (function (Xbox360Dpad) {\n        Xbox360Dpad[Xbox360Dpad[\"Up\"] = 0] = \"Up\";\n        Xbox360Dpad[Xbox360Dpad[\"Down\"] = 1] = \"Down\";\n        Xbox360Dpad[Xbox360Dpad[\"Left\"] = 2] = \"Left\";\n        Xbox360Dpad[Xbox360Dpad[\"Right\"] = 3] = \"Right\";\n    })(Xbox360Dpad = BABYLON.Xbox360Dpad || (BABYLON.Xbox360Dpad = {}));\n    var Xbox360Pad = (function (_super) {\n        __extends(Xbox360Pad, _super);\n        function Xbox360Pad(id, index, gamepad, xboxOne) {\n            if (xboxOne === void 0) { xboxOne = false; }\n            var _this = _super.call(this, id, index, gamepad, 0, 1, (xboxOne ? 3 : 2), (xboxOne ? 4 : 3)) || this;\n            _this._leftTrigger = 0;\n            _this._rightTrigger = 0;\n            _this._buttonA = 0;\n            _this._buttonB = 0;\n            _this._buttonX = 0;\n            _this._buttonY = 0;\n            _this._buttonBack = 0;\n            _this._buttonStart = 0;\n            _this._buttonLB = 0;\n            _this._buttonRB = 0;\n            _this._buttonLeftStick = 0;\n            _this._buttonRightStick = 0;\n            _this._dPadUp = 0;\n            _this._dPadDown = 0;\n            _this._dPadLeft = 0;\n            _this._dPadRight = 0;\n            _this._isXboxOnePad = false;\n            _this.type = Gamepad.XBOX;\n            _this._isXboxOnePad = xboxOne;\n            return _this;\n        }\n        Xbox360Pad.prototype.onlefttriggerchanged = function (callback) {\n            this._onlefttriggerchanged = callback;\n        };\n        Xbox360Pad.prototype.onrighttriggerchanged = function (callback) {\n            this._onrighttriggerchanged = callback;\n        };\n        Object.defineProperty(Xbox360Pad.prototype, \"leftTrigger\", {\n            get: function () {\n                return this._leftTrigger;\n            },\n            set: function (newValue) {\n                if (this._onlefttriggerchanged && this._leftTrigger !== newValue) {\n                    this._onlefttriggerchanged(newValue);\n                }\n                this._leftTrigger = newValue;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"rightTrigger\", {\n            get: function () {\n                return this._rightTrigger;\n            },\n            set: function (newValue) {\n                if (this._onrighttriggerchanged && this._rightTrigger !== newValue) {\n                    this._onrighttriggerchanged(newValue);\n                }\n                this._rightTrigger = newValue;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Xbox360Pad.prototype.onbuttondown = function (callback) {\n            this._onbuttondown = callback;\n        };\n        Xbox360Pad.prototype.onbuttonup = function (callback) {\n            this._onbuttonup = callback;\n        };\n        Xbox360Pad.prototype.ondpaddown = function (callback) {\n            this._ondpaddown = callback;\n        };\n        Xbox360Pad.prototype.ondpadup = function (callback) {\n            this._ondpadup = callback;\n        };\n        Xbox360Pad.prototype._setButtonValue = function (newValue, currentValue, buttonType) {\n            if (newValue !== currentValue) {\n                if (this._onbuttondown && newValue === 1) {\n                    this._onbuttondown(buttonType);\n                }\n                if (this._onbuttonup && newValue === 0) {\n                    this._onbuttonup(buttonType);\n                }\n            }\n            return newValue;\n        };\n        Xbox360Pad.prototype._setDPadValue = function (newValue, currentValue, buttonType) {\n            if (newValue !== currentValue) {\n                if (this._ondpaddown && newValue === 1) {\n                    this._ondpaddown(buttonType);\n                }\n                if (this._ondpadup && newValue === 0) {\n                    this._ondpadup(buttonType);\n                }\n            }\n            return newValue;\n        };\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonA\", {\n            get: function () {\n                return this._buttonA;\n            },\n            set: function (value) {\n                this._buttonA = this._setButtonValue(value, this._buttonA, Xbox360Button.A);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonB\", {\n            get: function () {\n                return this._buttonB;\n            },\n            set: function (value) {\n                this._buttonB = this._setButtonValue(value, this._buttonB, Xbox360Button.B);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonX\", {\n            get: function () {\n                return this._buttonX;\n            },\n            set: function (value) {\n                this._buttonX = this._setButtonValue(value, this._buttonX, Xbox360Button.X);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonY\", {\n            get: function () {\n                return this._buttonY;\n            },\n            set: function (value) {\n                this._buttonY = this._setButtonValue(value, this._buttonY, Xbox360Button.Y);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonStart\", {\n            get: function () {\n                return this._buttonStart;\n            },\n            set: function (value) {\n                this._buttonStart = this._setButtonValue(value, this._buttonStart, Xbox360Button.Start);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonBack\", {\n            get: function () {\n                return this._buttonBack;\n            },\n            set: function (value) {\n                this._buttonBack = this._setButtonValue(value, this._buttonBack, Xbox360Button.Back);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonLB\", {\n            get: function () {\n                return this._buttonLB;\n            },\n            set: function (value) {\n                this._buttonLB = this._setButtonValue(value, this._buttonLB, Xbox360Button.LB);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonRB\", {\n            get: function () {\n                return this._buttonRB;\n            },\n            set: function (value) {\n                this._buttonRB = this._setButtonValue(value, this._buttonRB, Xbox360Button.RB);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonLeftStick\", {\n            get: function () {\n                return this._buttonLeftStick;\n            },\n            set: function (value) {\n                this._buttonLeftStick = this._setButtonValue(value, this._buttonLeftStick, Xbox360Button.LeftStick);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"buttonRightStick\", {\n            get: function () {\n                return this._buttonRightStick;\n            },\n            set: function (value) {\n                this._buttonRightStick = this._setButtonValue(value, this._buttonRightStick, Xbox360Button.RightStick);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"dPadUp\", {\n            get: function () {\n                return this._dPadUp;\n            },\n            set: function (value) {\n                this._dPadUp = this._setDPadValue(value, this._dPadUp, Xbox360Dpad.Up);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"dPadDown\", {\n            get: function () {\n                return this._dPadDown;\n            },\n            set: function (value) {\n                this._dPadDown = this._setDPadValue(value, this._dPadDown, Xbox360Dpad.Down);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"dPadLeft\", {\n            get: function () {\n                return this._dPadLeft;\n            },\n            set: function (value) {\n                this._dPadLeft = this._setDPadValue(value, this._dPadLeft, Xbox360Dpad.Left);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Xbox360Pad.prototype, \"dPadRight\", {\n            get: function () {\n                return this._dPadRight;\n            },\n            set: function (value) {\n                this._dPadRight = this._setDPadValue(value, this._dPadRight, Xbox360Dpad.Right);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Xbox360Pad.prototype.update = function () {\n            _super.prototype.update.call(this);\n            if (this._isXboxOnePad) {\n                this.buttonA = this.browserGamepad.buttons[0].value;\n                this.buttonB = this.browserGamepad.buttons[1].value;\n                this.buttonX = this.browserGamepad.buttons[2].value;\n                this.buttonY = this.browserGamepad.buttons[3].value;\n                this.buttonLB = this.browserGamepad.buttons[4].value;\n                this.buttonRB = this.browserGamepad.buttons[5].value;\n                this.leftTrigger = this.browserGamepad.axes[2];\n                this.rightTrigger = this.browserGamepad.axes[5];\n                this.buttonBack = this.browserGamepad.buttons[9].value;\n                this.buttonStart = this.browserGamepad.buttons[8].value;\n                this.buttonLeftStick = this.browserGamepad.buttons[6].value;\n                this.buttonRightStick = this.browserGamepad.buttons[7].value;\n                this.dPadUp = this.browserGamepad.buttons[11].value;\n                this.dPadDown = this.browserGamepad.buttons[12].value;\n                this.dPadLeft = this.browserGamepad.buttons[13].value;\n                this.dPadRight = this.browserGamepad.buttons[14].value;\n            }\n            else {\n                this.buttonA = this.browserGamepad.buttons[0].value;\n                this.buttonB = this.browserGamepad.buttons[1].value;\n                this.buttonX = this.browserGamepad.buttons[2].value;\n                this.buttonY = this.browserGamepad.buttons[3].value;\n                this.buttonLB = this.browserGamepad.buttons[4].value;\n                this.buttonRB = this.browserGamepad.buttons[5].value;\n                this.leftTrigger = this.browserGamepad.buttons[6].value;\n                this.rightTrigger = this.browserGamepad.buttons[7].value;\n                this.buttonBack = this.browserGamepad.buttons[8].value;\n                this.buttonStart = this.browserGamepad.buttons[9].value;\n                this.buttonLeftStick = this.browserGamepad.buttons[10].value;\n                this.buttonRightStick = this.browserGamepad.buttons[11].value;\n                this.dPadUp = this.browserGamepad.buttons[12].value;\n                this.dPadDown = this.browserGamepad.buttons[13].value;\n                this.dPadLeft = this.browserGamepad.buttons[14].value;\n                this.dPadRight = this.browserGamepad.buttons[15].value;\n            }\n        };\n        return Xbox360Pad;\n    }(Gamepad));\n    BABYLON.Xbox360Pad = Xbox360Pad;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.gamepads.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PoseEnabledControllerType;\n    (function (PoseEnabledControllerType) {\n        PoseEnabledControllerType[PoseEnabledControllerType[\"VIVE\"] = 0] = \"VIVE\";\n        PoseEnabledControllerType[PoseEnabledControllerType[\"OCULUS\"] = 1] = \"OCULUS\";\n        PoseEnabledControllerType[PoseEnabledControllerType[\"GENERIC\"] = 2] = \"GENERIC\";\n    })(PoseEnabledControllerType = BABYLON.PoseEnabledControllerType || (BABYLON.PoseEnabledControllerType = {}));\n    var PoseEnabledControllerHelper = (function () {\n        function PoseEnabledControllerHelper() {\n        }\n        PoseEnabledControllerHelper.InitiateController = function (vrGamepad) {\n            // for now, only Oculus and Vive are supported\n            if (vrGamepad.id.indexOf('Oculus Touch') !== -1) {\n                return new OculusTouchController(vrGamepad);\n            }\n            else {\n                return new ViveController(vrGamepad);\n            }\n        };\n        return PoseEnabledControllerHelper;\n    }());\n    BABYLON.PoseEnabledControllerHelper = PoseEnabledControllerHelper;\n    var PoseEnabledController = (function (_super) {\n        __extends(PoseEnabledController, _super);\n        function PoseEnabledController(vrGamepad) {\n            var _this = _super.call(this, vrGamepad.id, vrGamepad.index, vrGamepad) || this;\n            _this.vrGamepad = vrGamepad;\n            _this.deviceScaleFactor = 1;\n            _this._leftHandSystemQuaternion = new BABYLON.Quaternion();\n            _this.type = BABYLON.Gamepad.POSE_ENABLED;\n            _this.controllerType = PoseEnabledControllerType.GENERIC;\n            _this.position = BABYLON.Vector3.Zero();\n            _this.rotationQuaternion = new BABYLON.Quaternion();\n            _this.devicePosition = BABYLON.Vector3.Zero();\n            _this.deviceRotationQuaternion = new BABYLON.Quaternion();\n            _this._calculatedPosition = BABYLON.Vector3.Zero();\n            _this._calculatedRotation = new BABYLON.Quaternion();\n            BABYLON.Quaternion.RotationYawPitchRollToRef(Math.PI, 0, 0, _this._leftHandSystemQuaternion);\n            return _this;\n        }\n        PoseEnabledController.prototype.update = function () {\n            _super.prototype.update.call(this);\n            var pose = this.vrGamepad.pose;\n            this.updateFromDevice(pose);\n            if (this._mesh) {\n                this._mesh.position.copyFrom(this._calculatedPosition);\n                this._mesh.rotationQuaternion.copyFrom(this._calculatedRotation);\n            }\n        };\n        PoseEnabledController.prototype.updateFromDevice = function (poseData) {\n            if (poseData) {\n                this.rawPose = poseData;\n                if (poseData.position) {\n                    this.devicePosition.copyFromFloats(poseData.position[0], poseData.position[1], -poseData.position[2]);\n                    if (this._mesh && this._mesh.getScene().useRightHandedSystem) {\n                        this.devicePosition.z *= -1;\n                    }\n                    this.devicePosition.scaleToRef(this.deviceScaleFactor, this._calculatedPosition);\n                    this._calculatedPosition.addInPlace(this.position);\n                }\n                if (poseData.orientation) {\n                    this.deviceRotationQuaternion.copyFromFloats(this.rawPose.orientation[0], this.rawPose.orientation[1], -this.rawPose.orientation[2], -this.rawPose.orientation[3]);\n                    if (this._mesh) {\n                        if (this._mesh.getScene().useRightHandedSystem) {\n                            this.deviceRotationQuaternion.z *= -1;\n                            this.deviceRotationQuaternion.w *= -1;\n                        }\n                        else {\n                            this.deviceRotationQuaternion.multiplyToRef(this._leftHandSystemQuaternion, this.deviceRotationQuaternion);\n                        }\n                    }\n                    // if the camera is set, rotate to the camera's rotation\n                    this.deviceRotationQuaternion.multiplyToRef(this.rotationQuaternion, this._calculatedRotation);\n                }\n            }\n        };\n        PoseEnabledController.prototype.attachToMesh = function (mesh) {\n            if (this._mesh) {\n                this._mesh.parent = undefined;\n            }\n            this._mesh = mesh;\n            if (this._poseControlledCamera) {\n                this._mesh.parent = this._poseControlledCamera;\n            }\n            if (!this._mesh.rotationQuaternion) {\n                this._mesh.rotationQuaternion = new BABYLON.Quaternion();\n            }\n        };\n        PoseEnabledController.prototype.attachToPoseControlledCamera = function (camera) {\n            this._poseControlledCamera = camera;\n            if (this._mesh) {\n                this._mesh.parent = this._poseControlledCamera;\n            }\n        };\n        PoseEnabledController.prototype.detachMesh = function () {\n            this._mesh = undefined;\n        };\n        Object.defineProperty(PoseEnabledController.prototype, \"mesh\", {\n            get: function () {\n                return this._mesh;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PoseEnabledController.prototype.getForwardRay = function (length) {\n            if (length === void 0) { length = 100; }\n            if (!this.mesh) {\n                return new BABYLON.Ray(BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, 1), length);\n            }\n            var m = this.mesh.getWorldMatrix();\n            var origin = m.getTranslation();\n            var forward = new BABYLON.Vector3(0, 0, -1);\n            var forwardWorld = BABYLON.Vector3.TransformNormal(forward, m);\n            var direction = BABYLON.Vector3.Normalize(forwardWorld);\n            return new BABYLON.Ray(origin, direction, length);\n        };\n        return PoseEnabledController;\n    }(BABYLON.Gamepad));\n    BABYLON.PoseEnabledController = PoseEnabledController;\n    var WebVRController = (function (_super) {\n        __extends(WebVRController, _super);\n        function WebVRController(vrGamepad) {\n            var _this = _super.call(this, vrGamepad) || this;\n            //public onTriggerStateChangedObservable = new Observable<{ state: ExtendedGamepadButton, changes: GamepadButtonChanges }>();\n            _this.onTriggerStateChangedObservable = new BABYLON.Observable();\n            _this.onMainButtonStateChangedObservable = new BABYLON.Observable();\n            _this.onSecondaryButtonStateChangedObservable = new BABYLON.Observable();\n            _this.onPadStateChangedObservable = new BABYLON.Observable();\n            _this.onPadValuesChangedObservable = new BABYLON.Observable();\n            _this.pad = { x: 0, y: 0 };\n            // avoid GC, store state in a tmp object\n            _this._changes = {\n                pressChanged: false,\n                touchChanged: false,\n                valueChanged: false,\n                changed: false\n            };\n            _this._buttons = new Array(vrGamepad.buttons.length);\n            _this.hand = vrGamepad.hand;\n            return _this;\n        }\n        WebVRController.prototype.onButtonStateChange = function (callback) {\n            this._onButtonStateChange = callback;\n        };\n        WebVRController.prototype.update = function () {\n            _super.prototype.update.call(this);\n            for (var index = 0; index < this._buttons.length; index++) {\n                this._setButtonValue(this.vrGamepad.buttons[index], this._buttons[index], index);\n            }\n            ;\n            if (this.leftStick.x !== this.pad.x || this.leftStick.y !== this.pad.y) {\n                this.pad.x = this.leftStick.x;\n                this.pad.y = this.leftStick.y;\n                this.onPadValuesChangedObservable.notifyObservers(this.pad);\n            }\n        };\n        WebVRController.prototype._setButtonValue = function (newState, currentState, buttonIndex) {\n            if (!currentState) {\n                this._buttons[buttonIndex] = {\n                    pressed: newState.pressed,\n                    touched: newState.touched,\n                    value: newState.value\n                };\n                return;\n            }\n            this._checkChanges(newState, currentState);\n            if (this._changes.changed) {\n                this._onButtonStateChange && this._onButtonStateChange(this.index, buttonIndex, newState);\n                this.handleButtonChange(buttonIndex, newState, this._changes);\n            }\n            this._buttons[buttonIndex].pressed = newState.pressed;\n            this._buttons[buttonIndex].touched = newState.touched;\n            // oculus triggers are never 0, thou not touched.\n            this._buttons[buttonIndex].value = newState.value < 0.00000001 ? 0 : newState.value;\n        };\n        WebVRController.prototype._checkChanges = function (newState, currentState) {\n            this._changes.pressChanged = newState.pressed !== currentState.pressed;\n            this._changes.touchChanged = newState.touched !== currentState.touched;\n            this._changes.valueChanged = newState.value !== currentState.value;\n            this._changes.changed = this._changes.pressChanged || this._changes.touchChanged || this._changes.valueChanged;\n            return this._changes;\n        };\n        return WebVRController;\n    }(PoseEnabledController));\n    BABYLON.WebVRController = WebVRController;\n    var OculusTouchController = (function (_super) {\n        __extends(OculusTouchController, _super);\n        function OculusTouchController(vrGamepad) {\n            var _this = _super.call(this, vrGamepad) || this;\n            _this.onSecondaryTriggerStateChangedObservable = new BABYLON.Observable();\n            _this.onThumbRestChangedObservable = new BABYLON.Observable();\n            _this.controllerType = PoseEnabledControllerType.OCULUS;\n            return _this;\n        }\n        OculusTouchController.prototype.initControllerMesh = function (scene, meshLoaded) {\n            var _this = this;\n            var meshName = this.hand === 'right' ? 'RightTouch.babylon' : 'LeftTouch.babylon';\n            BABYLON.SceneLoader.ImportMesh(\"\", \"http://yoda.blob.core.windows.net/models/\", meshName, scene, function (newMeshes) {\n                /*\n                Parent Mesh name: oculus_touch_left\n                - body\n                - trigger\n                - thumbstick\n                - grip\n                - button_y\n                - button_x\n                - button_enter\n                */\n                _this._defaultModel = newMeshes[1];\n                if (meshLoaded) {\n                    meshLoaded(_this._defaultModel);\n                }\n                _this.attachToMesh(_this._defaultModel);\n            });\n        };\n        Object.defineProperty(OculusTouchController.prototype, \"onAButtonStateChangedObservable\", {\n            // helper getters for left and right hand.\n            get: function () {\n                if (this.hand === 'right') {\n                    return this.onMainButtonStateChangedObservable;\n                }\n                else {\n                    throw new Error('No A button on left hand');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OculusTouchController.prototype, \"onBButtonStateChangedObservable\", {\n            get: function () {\n                if (this.hand === 'right') {\n                    return this.onSecondaryButtonStateChangedObservable;\n                }\n                else {\n                    throw new Error('No B button on left hand');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OculusTouchController.prototype, \"onXButtonStateChangedObservable\", {\n            get: function () {\n                if (this.hand === 'left') {\n                    return this.onMainButtonStateChangedObservable;\n                }\n                else {\n                    throw new Error('No X button on right hand');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OculusTouchController.prototype, \"onYButtonStateChangedObservable\", {\n            get: function () {\n                if (this.hand === 'left') {\n                    return this.onSecondaryButtonStateChangedObservable;\n                }\n                else {\n                    throw new Error('No Y button on right hand');\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /*\n         0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick\n         1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)\n         2) secondary trigger (same)\n         3) A (right) X (left), touch, pressed = value\n         4) B / Y\n         5) thumb rest\n        */\n        OculusTouchController.prototype.handleButtonChange = function (buttonIdx, state, changes) {\n            var notifyObject = state; //{ state: state, changes: changes };\n            var triggerDirection = this.hand === 'right' ? -1 : 1;\n            switch (buttonIdx) {\n                case 0:\n                    this.onPadStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 1:\n                    if (this._defaultModel) {\n                        (this._defaultModel.getChildren()[3]).rotation.x = -notifyObject.value * 0.20;\n                        (this._defaultModel.getChildren()[3]).position.y = -notifyObject.value * 0.005;\n                        (this._defaultModel.getChildren()[3]).position.z = -notifyObject.value * 0.005;\n                    }\n                    this.onTriggerStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 2:\n                    if (this._defaultModel) {\n                        (this._defaultModel.getChildren()[4]).position.x = triggerDirection * notifyObject.value * 0.0035;\n                    }\n                    this.onSecondaryTriggerStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 3:\n                    if (this._defaultModel) {\n                        if (notifyObject.pressed) {\n                            (this._defaultModel.getChildren()[1]).position.y = -0.001;\n                        }\n                        else {\n                            (this._defaultModel.getChildren()[1]).position.y = 0;\n                        }\n                    }\n                    this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 4:\n                    if (this._defaultModel) {\n                        if (notifyObject.pressed) {\n                            (this._defaultModel.getChildren()[2]).position.y = -0.001;\n                        }\n                        else {\n                            (this._defaultModel.getChildren()[2]).position.y = 0;\n                        }\n                    }\n                    this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 5:\n                    this.onThumbRestChangedObservable.notifyObservers(notifyObject);\n                    return;\n            }\n        };\n        return OculusTouchController;\n    }(WebVRController));\n    BABYLON.OculusTouchController = OculusTouchController;\n    var ViveController = (function (_super) {\n        __extends(ViveController, _super);\n        function ViveController(vrGamepad) {\n            var _this = _super.call(this, vrGamepad) || this;\n            _this.controllerType = PoseEnabledControllerType.VIVE;\n            return _this;\n        }\n        ViveController.prototype.initControllerMesh = function (scene, meshLoaded) {\n            var _this = this;\n            BABYLON.SceneLoader.ImportMesh(\"\", \"http://yoda.blob.core.windows.net/models/\", \"ViveWand.babylon\", scene, function (newMeshes) {\n                /*\n                Parent Mesh name: ViveWand\n                - body\n                - r_gripper\n                - l_gripper\n                - menu_button\n                - system_button\n                - trackpad\n                - trigger\n                - LED\n                */\n                _this._defaultModel = newMeshes[1];\n                if (meshLoaded) {\n                    meshLoaded(_this._defaultModel);\n                }\n                _this.attachToMesh(_this._defaultModel);\n            });\n        };\n        Object.defineProperty(ViveController.prototype, \"onLeftButtonStateChangedObservable\", {\n            get: function () {\n                return this.onMainButtonStateChangedObservable;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViveController.prototype, \"onRightButtonStateChangedObservable\", {\n            get: function () {\n                return this.onMainButtonStateChangedObservable;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ViveController.prototype, \"onMenuButtonStateChangedObservable\", {\n            get: function () {\n                return this.onSecondaryButtonStateChangedObservable;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Vive mapping:\n         * 0: touchpad\n         * 1: trigger\n         * 2: left AND right buttons\n         * 3: menu button\n         */\n        ViveController.prototype.handleButtonChange = function (buttonIdx, state, changes) {\n            var notifyObject = state; //{ state: state, changes: changes };\n            switch (buttonIdx) {\n                case 0:\n                    this.onPadStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 1:\n                    if (this._defaultModel) {\n                        (this._defaultModel.getChildren()[6]).rotation.x = -notifyObject.value * 0.15;\n                    }\n                    this.onTriggerStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 2:\n                    this.onMainButtonStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n                case 3:\n                    if (this._defaultModel) {\n                        if (notifyObject.pressed) {\n                            (this._defaultModel.getChildren()[2]).position.y = -0.001;\n                        }\n                        else {\n                            (this._defaultModel.getChildren()[2]).position.y = 0;\n                        }\n                    }\n                    this.onSecondaryButtonStateChangedObservable.notifyObservers(notifyObject);\n                    return;\n            }\n        };\n        return ViveController;\n    }(WebVRController));\n    BABYLON.ViveController = ViveController;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.extendedGamepad.js.map\n\n/// <reference path=\"babylon.targetCamera.ts\" />\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FollowCamera = (function (_super) {\n        __extends(FollowCamera, _super);\n        function FollowCamera(name, position, scene, lockedTarget) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.radius = 12;\n            _this.rotationOffset = 0;\n            _this.heightOffset = 4;\n            _this.cameraAcceleration = 0.05;\n            _this.maxCameraSpeed = 20;\n            _this.lockedTarget = lockedTarget;\n            return _this;\n        }\n        FollowCamera.prototype.getRadians = function (degrees) {\n            return degrees * Math.PI / 180;\n        };\n        FollowCamera.prototype.follow = function (cameraTarget) {\n            if (!cameraTarget)\n                return;\n            var yRotation;\n            if (cameraTarget.rotationQuaternion) {\n                var rotMatrix = new BABYLON.Matrix();\n                cameraTarget.rotationQuaternion.toRotationMatrix(rotMatrix);\n                yRotation = Math.atan2(rotMatrix.m[8], rotMatrix.m[10]);\n            }\n            else {\n                yRotation = cameraTarget.rotation.y;\n            }\n            var radians = this.getRadians(this.rotationOffset) + yRotation;\n            var targetPosition = cameraTarget.getAbsolutePosition();\n            var targetX = targetPosition.x + Math.sin(radians) * this.radius;\n            var targetZ = targetPosition.z + Math.cos(radians) * this.radius;\n            var dx = targetX - this.position.x;\n            var dy = (targetPosition.y + this.heightOffset) - this.position.y;\n            var dz = (targetZ) - this.position.z;\n            var vx = dx * this.cameraAcceleration * 2; //this is set to .05\n            var vy = dy * this.cameraAcceleration;\n            var vz = dz * this.cameraAcceleration * 2;\n            if (vx > this.maxCameraSpeed || vx < -this.maxCameraSpeed) {\n                vx = vx < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n            }\n            if (vy > this.maxCameraSpeed || vy < -this.maxCameraSpeed) {\n                vy = vy < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n            }\n            if (vz > this.maxCameraSpeed || vz < -this.maxCameraSpeed) {\n                vz = vz < 1 ? -this.maxCameraSpeed : this.maxCameraSpeed;\n            }\n            this.position = new BABYLON.Vector3(this.position.x + vx, this.position.y + vy, this.position.z + vz);\n            this.setTarget(targetPosition);\n        };\n        FollowCamera.prototype._checkInputs = function () {\n            _super.prototype._checkInputs.call(this);\n            this.follow(this.lockedTarget);\n        };\n        FollowCamera.prototype.getClassName = function () {\n            return \"FollowCamera\";\n        };\n        return FollowCamera;\n    }(BABYLON.TargetCamera));\n    __decorate([\n        BABYLON.serialize()\n    ], FollowCamera.prototype, \"radius\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FollowCamera.prototype, \"rotationOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FollowCamera.prototype, \"heightOffset\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FollowCamera.prototype, \"cameraAcceleration\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], FollowCamera.prototype, \"maxCameraSpeed\", void 0);\n    __decorate([\n        BABYLON.serializeAsMeshReference(\"lockedTargetId\")\n    ], FollowCamera.prototype, \"lockedTarget\", void 0);\n    BABYLON.FollowCamera = FollowCamera;\n    var ArcFollowCamera = (function (_super) {\n        __extends(ArcFollowCamera, _super);\n        function ArcFollowCamera(name, alpha, beta, radius, target, scene) {\n            var _this = _super.call(this, name, BABYLON.Vector3.Zero(), scene) || this;\n            _this.alpha = alpha;\n            _this.beta = beta;\n            _this.radius = radius;\n            _this.target = target;\n            _this._cartesianCoordinates = BABYLON.Vector3.Zero();\n            _this.follow();\n            return _this;\n        }\n        ArcFollowCamera.prototype.follow = function () {\n            this._cartesianCoordinates.x = this.radius * Math.cos(this.alpha) * Math.cos(this.beta);\n            this._cartesianCoordinates.y = this.radius * Math.sin(this.beta);\n            this._cartesianCoordinates.z = this.radius * Math.sin(this.alpha) * Math.cos(this.beta);\n            var targetPosition = this.target.getAbsolutePosition();\n            this.position = targetPosition.add(this._cartesianCoordinates);\n            this.setTarget(targetPosition);\n        };\n        ArcFollowCamera.prototype._checkInputs = function () {\n            _super.prototype._checkInputs.call(this);\n            this.follow();\n        };\n        ArcFollowCamera.prototype.getClassName = function () {\n            return \"ArcFollowCamera\";\n        };\n        return ArcFollowCamera;\n    }(BABYLON.TargetCamera));\n    BABYLON.ArcFollowCamera = ArcFollowCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.followCamera.js.map\n\n/// <reference path=\"babylon.touchCamera.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    // We're mainly based on the logic defined into the FreeCamera code\n    var UniversalCamera = (function (_super) {\n        __extends(UniversalCamera, _super);\n        //-- end properties for backward compatibility for inputs\n        function UniversalCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.inputs.addGamepad();\n            return _this;\n        }\n        Object.defineProperty(UniversalCamera.prototype, \"gamepadAngularSensibility\", {\n            //-- Begin properties for backward compatibility for inputs\n            get: function () {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    return gamepad.gamepadAngularSensibility;\n            },\n            set: function (value) {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    gamepad.gamepadAngularSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(UniversalCamera.prototype, \"gamepadMoveSensibility\", {\n            get: function () {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    return gamepad.gamepadMoveSensibility;\n            },\n            set: function (value) {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    gamepad.gamepadMoveSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        UniversalCamera.prototype.getClassName = function () {\n            return \"UniversalCamera\";\n        };\n        return UniversalCamera;\n    }(BABYLON.TouchCamera));\n    BABYLON.UniversalCamera = UniversalCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.universalCamera.js.map\n\n/// <reference path=\"babylon.universalCamera.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    // We're mainly based on the logic defined into the FreeCamera code\n    var GamepadCamera = (function (_super) {\n        __extends(GamepadCamera, _super);\n        //-- end properties for backward compatibility for inputs\n        function GamepadCamera(name, position, scene) {\n            return _super.call(this, name, position, scene) || this;\n        }\n        Object.defineProperty(GamepadCamera.prototype, \"gamepadAngularSensibility\", {\n            //-- Begin properties for backward compatibility for inputs\n            get: function () {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    return gamepad.gamepadAngularSensibility;\n            },\n            set: function (value) {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    gamepad.gamepadAngularSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GamepadCamera.prototype, \"gamepadMoveSensibility\", {\n            get: function () {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    return gamepad.gamepadMoveSensibility;\n            },\n            set: function (value) {\n                var gamepad = this.inputs.attached[\"gamepad\"];\n                if (gamepad)\n                    gamepad.gamepadMoveSensibility = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        GamepadCamera.prototype.getClassName = function () {\n            return \"GamepadCamera\";\n        };\n        return GamepadCamera;\n    }(BABYLON.UniversalCamera));\n    BABYLON.GamepadCamera = GamepadCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.gamepadCamera.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcessRenderPipelineManager = (function () {\n        function PostProcessRenderPipelineManager() {\n            this._renderPipelines = {};\n        }\n        PostProcessRenderPipelineManager.prototype.addPipeline = function (renderPipeline) {\n            this._renderPipelines[renderPipeline._name] = renderPipeline;\n        };\n        PostProcessRenderPipelineManager.prototype.attachCamerasToRenderPipeline = function (renderPipelineName, cameras, unique) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._attachCameras(cameras, unique);\n        };\n        PostProcessRenderPipelineManager.prototype.detachCamerasFromRenderPipeline = function (renderPipelineName, cameras) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._detachCameras(cameras);\n        };\n        PostProcessRenderPipelineManager.prototype.enableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._enableEffect(renderEffectName, cameras);\n        };\n        PostProcessRenderPipelineManager.prototype.disableEffectInPipeline = function (renderPipelineName, renderEffectName, cameras) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._disableEffect(renderEffectName, cameras);\n        };\n        PostProcessRenderPipelineManager.prototype.enableDisplayOnlyPassInPipeline = function (renderPipelineName, passName, cameras) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._enableDisplayOnlyPass(passName, cameras);\n        };\n        PostProcessRenderPipelineManager.prototype.disableDisplayOnlyPassInPipeline = function (renderPipelineName, cameras) {\n            var renderPipeline = this._renderPipelines[renderPipelineName];\n            if (!renderPipeline) {\n                return;\n            }\n            renderPipeline._disableDisplayOnlyPass(cameras);\n        };\n        PostProcessRenderPipelineManager.prototype.update = function () {\n            for (var renderPipelineName in this._renderPipelines) {\n                var pipeline = this._renderPipelines[renderPipelineName];\n                if (!pipeline.isSupported) {\n                    pipeline.dispose();\n                    delete this._renderPipelines[renderPipelineName];\n                }\n                else {\n                    pipeline._update();\n                }\n            }\n        };\n        return PostProcessRenderPipelineManager;\n    }());\n    BABYLON.PostProcessRenderPipelineManager = PostProcessRenderPipelineManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcessRenderPipelineManager.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcessRenderPass = (function () {\n        function PostProcessRenderPass(scene, name, size, renderList, beforeRender, afterRender) {\n            this._enabled = true;\n            this._refCount = 0;\n            this._name = name;\n            this._renderTexture = new BABYLON.RenderTargetTexture(name, size, scene);\n            this.setRenderList(renderList);\n            this._renderTexture.onBeforeRenderObservable.add(beforeRender);\n            this._renderTexture.onAfterRenderObservable.add(afterRender);\n            this._scene = scene;\n            this._renderList = renderList;\n        }\n        // private\n        PostProcessRenderPass.prototype._incRefCount = function () {\n            if (this._refCount === 0) {\n                this._scene.customRenderTargets.push(this._renderTexture);\n            }\n            return ++this._refCount;\n        };\n        PostProcessRenderPass.prototype._decRefCount = function () {\n            this._refCount--;\n            if (this._refCount <= 0) {\n                this._scene.customRenderTargets.splice(this._scene.customRenderTargets.indexOf(this._renderTexture), 1);\n            }\n            return this._refCount;\n        };\n        PostProcessRenderPass.prototype._update = function () {\n            this.setRenderList(this._renderList);\n        };\n        // public\n        PostProcessRenderPass.prototype.setRenderList = function (renderList) {\n            this._renderTexture.renderList = renderList;\n        };\n        PostProcessRenderPass.prototype.getRenderTexture = function () {\n            return this._renderTexture;\n        };\n        return PostProcessRenderPass;\n    }());\n    BABYLON.PostProcessRenderPass = PostProcessRenderPass;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcessRenderPass.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcessRenderEffect = (function () {\n        function PostProcessRenderEffect(engine, name, getPostProcess, singleInstance) {\n            this._engine = engine;\n            this._name = name;\n            this._singleInstance = singleInstance || true;\n            this._getPostProcess = getPostProcess;\n            this._cameras = [];\n            this._indicesForCamera = [];\n            this._postProcesses = {};\n            this._renderPasses = {};\n            this._renderEffectAsPasses = {};\n        }\n        Object.defineProperty(PostProcessRenderEffect.prototype, \"isSupported\", {\n            get: function () {\n                for (var index in this._postProcesses) {\n                    if (!this._postProcesses[index].isSupported) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PostProcessRenderEffect.prototype._update = function () {\n            for (var renderPassName in this._renderPasses) {\n                this._renderPasses[renderPassName]._update();\n            }\n        };\n        PostProcessRenderEffect.prototype.addPass = function (renderPass) {\n            this._renderPasses[renderPass._name] = renderPass;\n            this._linkParameters();\n        };\n        PostProcessRenderEffect.prototype.removePass = function (renderPass) {\n            delete this._renderPasses[renderPass._name];\n            this._linkParameters();\n        };\n        PostProcessRenderEffect.prototype.addRenderEffectAsPass = function (renderEffect) {\n            this._renderEffectAsPasses[renderEffect._name] = renderEffect;\n            this._linkParameters();\n        };\n        PostProcessRenderEffect.prototype.getPass = function (passName) {\n            for (var renderPassName in this._renderPasses) {\n                if (renderPassName === passName) {\n                    return this._renderPasses[passName];\n                }\n            }\n        };\n        PostProcessRenderEffect.prototype.emptyPasses = function () {\n            this._renderPasses = {};\n            this._linkParameters();\n        };\n        PostProcessRenderEffect.prototype._attachCameras = function (cameras) {\n            var cameraKey;\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                if (this._singleInstance) {\n                    cameraKey = 0;\n                }\n                else {\n                    cameraKey = cameraName;\n                }\n                this._postProcesses[cameraKey] = this._postProcesses[cameraKey] || this._getPostProcess();\n                var index = camera.attachPostProcess(this._postProcesses[cameraKey]);\n                if (!this._indicesForCamera[cameraName]) {\n                    this._indicesForCamera[cameraName] = [];\n                }\n                this._indicesForCamera[cameraName].push(index);\n                if (this._cameras.indexOf(camera) === -1) {\n                    this._cameras[cameraName] = camera;\n                }\n                for (var passName in this._renderPasses) {\n                    this._renderPasses[passName]._incRefCount();\n                }\n            }\n            this._linkParameters();\n        };\n        PostProcessRenderEffect.prototype._detachCameras = function (cameras) {\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                camera.detachPostProcess(this._postProcesses[this._singleInstance ? 0 : cameraName], this._indicesForCamera[cameraName]);\n                var index = this._cameras.indexOf(cameraName);\n                this._indicesForCamera.splice(index, 1);\n                this._cameras.splice(index, 1);\n                for (var passName in this._renderPasses) {\n                    this._renderPasses[passName]._decRefCount();\n                }\n            }\n        };\n        PostProcessRenderEffect.prototype._enable = function (cameras) {\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                for (var j = 0; j < this._indicesForCamera[cameraName].length; j++) {\n                    if (camera._postProcesses[this._indicesForCamera[cameraName][j]] === undefined) {\n                        cameras[i].attachPostProcess(this._postProcesses[this._singleInstance ? 0 : cameraName], this._indicesForCamera[cameraName][j]);\n                    }\n                }\n                for (var passName in this._renderPasses) {\n                    this._renderPasses[passName]._incRefCount();\n                }\n            }\n        };\n        PostProcessRenderEffect.prototype._disable = function (cameras) {\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.Name;\n                camera.detachPostProcess(this._postProcesses[this._singleInstance ? 0 : cameraName], this._indicesForCamera[cameraName]);\n                for (var passName in this._renderPasses) {\n                    this._renderPasses[passName]._decRefCount();\n                }\n            }\n        };\n        PostProcessRenderEffect.prototype.getPostProcess = function (camera) {\n            if (this._singleInstance) {\n                return this._postProcesses[0];\n            }\n            else {\n                return this._postProcesses[camera.name];\n            }\n        };\n        PostProcessRenderEffect.prototype._linkParameters = function () {\n            var _this = this;\n            for (var index in this._postProcesses) {\n                if (this.applyParameters) {\n                    this.applyParameters(this._postProcesses[index]);\n                }\n                this._postProcesses[index].onBeforeRenderObservable.add(function (effect) {\n                    _this._linkTextures(effect);\n                });\n            }\n        };\n        PostProcessRenderEffect.prototype._linkTextures = function (effect) {\n            for (var renderPassName in this._renderPasses) {\n                effect.setTexture(renderPassName, this._renderPasses[renderPassName].getRenderTexture());\n            }\n            for (var renderEffectName in this._renderEffectAsPasses) {\n                effect.setTextureFromPostProcess(renderEffectName + \"Sampler\", this._renderEffectAsPasses[renderEffectName].getPostProcess());\n            }\n        };\n        return PostProcessRenderEffect;\n    }());\n    BABYLON.PostProcessRenderEffect = PostProcessRenderEffect;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcessRenderEffect.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var PostProcessRenderPipeline = (function () {\n        function PostProcessRenderPipeline(engine, name) {\n            this._engine = engine;\n            this._name = name;\n            this._renderEffects = new Array();\n            this._renderEffectsForIsolatedPass = new Array();\n            this._cameras = [];\n        }\n        Object.defineProperty(PostProcessRenderPipeline.prototype, \"isSupported\", {\n            get: function () {\n                for (var renderEffectName in this._renderEffects) {\n                    if (!this._renderEffects[renderEffectName].isSupported) {\n                        return false;\n                    }\n                }\n                return true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PostProcessRenderPipeline.prototype.addEffect = function (renderEffect) {\n            this._renderEffects[renderEffect._name] = renderEffect;\n        };\n        PostProcessRenderPipeline.prototype._enableEffect = function (renderEffectName, cameras) {\n            var renderEffects = this._renderEffects[renderEffectName];\n            if (!renderEffects) {\n                return;\n            }\n            renderEffects._enable(BABYLON.Tools.MakeArray(cameras || this._cameras));\n        };\n        PostProcessRenderPipeline.prototype._disableEffect = function (renderEffectName, cameras) {\n            var renderEffects = this._renderEffects[renderEffectName];\n            if (!renderEffects) {\n                return;\n            }\n            renderEffects._disable(BABYLON.Tools.MakeArray(cameras || this._cameras));\n        };\n        PostProcessRenderPipeline.prototype._attachCameras = function (cameras, unique) {\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            var indicesToDelete = [];\n            var i;\n            for (i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                if (this._cameras.indexOf(camera) === -1) {\n                    this._cameras[cameraName] = camera;\n                }\n                else if (unique) {\n                    indicesToDelete.push(i);\n                }\n            }\n            for (i = 0; i < indicesToDelete.length; i++) {\n                cameras.splice(indicesToDelete[i], 1);\n            }\n            for (var renderEffectName in this._renderEffects) {\n                this._renderEffects[renderEffectName]._attachCameras(_cam);\n            }\n        };\n        PostProcessRenderPipeline.prototype._detachCameras = function (cameras) {\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var renderEffectName in this._renderEffects) {\n                this._renderEffects[renderEffectName]._detachCameras(_cam);\n            }\n            for (var i = 0; i < _cam.length; i++) {\n                this._cameras.splice(this._cameras.indexOf(_cam[i]), 1);\n            }\n        };\n        PostProcessRenderPipeline.prototype._enableDisplayOnlyPass = function (passName, cameras) {\n            var _this = this;\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            var pass = null;\n            var renderEffectName;\n            for (renderEffectName in this._renderEffects) {\n                pass = this._renderEffects[renderEffectName].getPass(passName);\n                if (pass != null) {\n                    break;\n                }\n            }\n            if (pass === null) {\n                return;\n            }\n            for (renderEffectName in this._renderEffects) {\n                this._renderEffects[renderEffectName]._disable(_cam);\n            }\n            pass._name = PostProcessRenderPipeline.PASS_SAMPLER_NAME;\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                this._renderEffectsForIsolatedPass[cameraName] = this._renderEffectsForIsolatedPass[cameraName] || new BABYLON.PostProcessRenderEffect(this._engine, PostProcessRenderPipeline.PASS_EFFECT_NAME, function () { return new BABYLON.DisplayPassPostProcess(PostProcessRenderPipeline.PASS_EFFECT_NAME, 1.0, null, null, _this._engine, true); });\n                this._renderEffectsForIsolatedPass[cameraName].emptyPasses();\n                this._renderEffectsForIsolatedPass[cameraName].addPass(pass);\n                this._renderEffectsForIsolatedPass[cameraName]._attachCameras(camera);\n            }\n        };\n        PostProcessRenderPipeline.prototype._disableDisplayOnlyPass = function (cameras) {\n            var _this = this;\n            var _cam = BABYLON.Tools.MakeArray(cameras || this._cameras);\n            for (var i = 0; i < _cam.length; i++) {\n                var camera = _cam[i];\n                var cameraName = camera.name;\n                this._renderEffectsForIsolatedPass[cameraName] = this._renderEffectsForIsolatedPass[cameraName] || new BABYLON.PostProcessRenderEffect(this._engine, PostProcessRenderPipeline.PASS_EFFECT_NAME, function () { return new BABYLON.DisplayPassPostProcess(PostProcessRenderPipeline.PASS_EFFECT_NAME, 1.0, null, null, _this._engine, true); });\n                this._renderEffectsForIsolatedPass[cameraName]._disable(camera);\n            }\n            for (var renderEffectName in this._renderEffects) {\n                this._renderEffects[renderEffectName]._enable(_cam);\n            }\n        };\n        PostProcessRenderPipeline.prototype._update = function () {\n            for (var renderEffectName in this._renderEffects) {\n                this._renderEffects[renderEffectName]._update();\n            }\n            for (var i = 0; i < this._cameras.length; i++) {\n                var cameraName = this._cameras[i].name;\n                if (this._renderEffectsForIsolatedPass[cameraName]) {\n                    this._renderEffectsForIsolatedPass[cameraName]._update();\n                }\n            }\n        };\n        PostProcessRenderPipeline.prototype._reset = function () {\n            this._renderEffects = new Array();\n            this._renderEffectsForIsolatedPass = new Array();\n        };\n        PostProcessRenderPipeline.prototype.dispose = function () {\n            // Must be implemented by children \n        };\n        return PostProcessRenderPipeline;\n    }());\n    PostProcessRenderPipeline.PASS_EFFECT_NAME = \"passEffect\";\n    PostProcessRenderPipeline.PASS_SAMPLER_NAME = \"passSampler\";\n    __decorate([\n        BABYLON.serialize()\n    ], PostProcessRenderPipeline.prototype, \"_name\", void 0);\n    BABYLON.PostProcessRenderPipeline = PostProcessRenderPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.postProcessRenderPipeline.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var DepthRenderer = (function () {\n        function DepthRenderer(scene, type) {\n            if (type === void 0) { type = BABYLON.Engine.TEXTURETYPE_FLOAT; }\n            var _this = this;\n            this._viewMatrix = BABYLON.Matrix.Zero();\n            this._projectionMatrix = BABYLON.Matrix.Zero();\n            this._transformMatrix = BABYLON.Matrix.Zero();\n            this._worldViewProjection = BABYLON.Matrix.Zero();\n            this._scene = scene;\n            var engine = scene.getEngine();\n            // Render target\n            this._depthMap = new BABYLON.RenderTargetTexture(\"depthMap\", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type);\n            this._depthMap.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._depthMap.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._depthMap.refreshRate = 1;\n            this._depthMap.renderParticles = false;\n            this._depthMap.renderList = null;\n            // set default depth value to 1.0 (far away)\n            this._depthMap.onClearObservable.add(function (engine) {\n                engine.clear(new BABYLON.Color4(1.0, 1.0, 1.0, 1.0), true, true, true);\n            });\n            // Custom render function\n            var renderSubMesh = function (subMesh) {\n                var mesh = subMesh.getRenderingMesh();\n                var scene = _this._scene;\n                var engine = scene.getEngine();\n                // Culling\n                engine.setState(subMesh.getMaterial().backFaceCulling);\n                // Managing instances\n                var batch = mesh._getInstancesRenderList(subMesh._id);\n                if (batch.mustReturn) {\n                    return;\n                }\n                var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);\n                if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n                    engine.enableEffect(_this._effect);\n                    mesh._bind(subMesh, _this._effect, BABYLON.Material.TriangleFillMode);\n                    var material = subMesh.getMaterial();\n                    _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    _this._effect.setFloat2(\"depthValues\", scene.activeCamera.minZ, scene.activeCamera.minZ + scene.activeCamera.maxZ);\n                    // Alpha test\n                    if (material && material.needAlphaTesting()) {\n                        var alphaTexture = material.getAlphaTestTexture();\n                        _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                    // Bones\n                    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                        _this._effect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n                    }\n                    // Draw\n                    mesh._processRendering(subMesh, _this._effect, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix(\"world\", world); });\n                }\n            };\n            this._depthMap.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes) {\n                var index;\n                for (index = 0; index < opaqueSubMeshes.length; index++) {\n                    renderSubMesh(opaqueSubMeshes.data[index]);\n                }\n                for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                    renderSubMesh(alphaTestSubMeshes.data[index]);\n                }\n            };\n        }\n        DepthRenderer.prototype.isReady = function (subMesh, useInstances) {\n            var material = subMesh.getMaterial();\n            if (material.disableDepthWrite) {\n                return false;\n            }\n            var defines = [];\n            var attribs = [BABYLON.VertexBuffer.PositionKind];\n            var mesh = subMesh.getMesh();\n            var scene = mesh.getScene();\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                defines.push(\"#define ALPHATEST\");\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect      \n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._effect = this._scene.getEngine().createEffect(\"depth\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"depthValues\"], [\"diffuseSampler\"], join);\n            }\n            return this._effect.isReady();\n        };\n        DepthRenderer.prototype.getDepthMap = function () {\n            return this._depthMap;\n        };\n        // Methods\n        DepthRenderer.prototype.dispose = function () {\n            this._depthMap.dispose();\n        };\n        return DepthRenderer;\n    }());\n    BABYLON.DepthRenderer = DepthRenderer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.depthRenderer.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var SSAORenderingPipeline = (function (_super) {\n        __extends(SSAORenderingPipeline, _super);\n        /**\n         * @constructor\n         * @param {string} name - The rendering pipeline name\n         * @param {BABYLON.Scene} scene - The scene linked to this pipeline\n         * @param {any} ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }\n         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to\n         */\n        function SSAORenderingPipeline(name, scene, ratio, cameras) {\n            var _this = _super.call(this, scene.getEngine(), name) || this;\n            // Members\n            /**\n            * The PassPostProcess id in the pipeline that contains the original scene color\n            * @type {string}\n            */\n            _this.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\";\n            /**\n            * The SSAO PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAORenderEffect = \"SSAORenderEffect\";\n            /**\n            * The horizontal blur PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\";\n            /**\n            * The vertical blur PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\";\n            /**\n            * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)\n            * @type {string}\n            */\n            _this.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\";\n            /**\n            * The output strength of the SSAO post-process. Default value is 1.0.\n            * @type {number}\n            */\n            _this.totalStrength = 1.0;\n            /**\n            * The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006\n            * @type {number}\n            */\n            _this.radius = 0.0001;\n            /**\n            * Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel\n            * Must not be equal to fallOff and superior to fallOff.\n            * Default value is 0.975\n            * @type {number}\n            */\n            _this.area = 0.0075;\n            /**\n            * Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel\n            * Must not be equal to area and inferior to area.\n            * Default value is 0.0\n            * @type {number}\n            */\n            _this.fallOff = 0.000001;\n            /**\n            * The base color of the SSAO post-process\n            * The final result is \"base + ssao\" between [0, 1]\n            * @type {number}\n            */\n            _this.base = 0.5;\n            _this._firstUpdate = true;\n            _this._scene = scene;\n            // Set up assets\n            _this._createRandomTexture();\n            _this._depthTexture = scene.enableDepthRenderer().getDepthMap(); // Force depth renderer \"on\"\n            var ssaoRatio = ratio.ssaoRatio || ratio;\n            var combineRatio = ratio.combineRatio || ratio;\n            _this._ratio = {\n                ssaoRatio: ssaoRatio,\n                combineRatio: combineRatio\n            };\n            _this._originalColorPostProcess = new BABYLON.PassPostProcess(\"SSAOOriginalSceneColor\", combineRatio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n            _this._createSSAOPostProcess(ssaoRatio);\n            _this._createBlurPostProcess(ssaoRatio);\n            _this._createSSAOCombinePostProcess(combineRatio);\n            // Set up pipeline\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function () { return _this._originalColorPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function () { return _this._ssaoPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function () { return _this._blurHPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function () { return _this._blurVPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function () { return _this._ssaoCombinePostProcess; }, true));\n            // Finish\n            scene.postProcessRenderPipelineManager.addPipeline(_this);\n            if (cameras)\n                scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n            return _this;\n        }\n        // Public Methods\n        /**\n         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras\n         */\n        SSAORenderingPipeline.prototype.dispose = function (disableDepthRender) {\n            if (disableDepthRender === void 0) { disableDepthRender = false; }\n            for (var i = 0; i < this._scene.cameras.length; i++) {\n                var camera = this._scene.cameras[i];\n                this._originalColorPostProcess.dispose(camera);\n                this._ssaoPostProcess.dispose(camera);\n                this._blurHPostProcess.dispose(camera);\n                this._blurVPostProcess.dispose(camera);\n                this._ssaoCombinePostProcess.dispose(camera);\n            }\n            this._randomTexture.dispose();\n            if (disableDepthRender)\n                this._scene.disableDepthRenderer();\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n            _super.prototype.dispose.call(this);\n        };\n        // Private Methods\n        SSAORenderingPipeline.prototype._createBlurPostProcess = function (ratio) {\n            var _this = this;\n            /*\n            var samplerOffsets = [\n                -8.0, -6.0, -4.0, -2.0,\n                0.0,\n                2.0, 4.0, 6.0, 8.0\n            ];\n            */\n            var samples = 16;\n            var samplerOffsets = [];\n            for (var i = -8; i < 8; i++) {\n                samplerOffsets.push(i * 2);\n            }\n            this._blurHPostProcess = new BABYLON.PostProcess(\"BlurH\", \"ssao\", [\"outSize\", \"samplerOffsets\"], [\"depthSampler\"], ratio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\");\n            this._blurHPostProcess.onApply = function (effect) {\n                effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.width);\n                effect.setTexture(\"depthSampler\", _this._depthTexture);\n                if (_this._firstUpdate) {\n                    effect.setArray(\"samplerOffsets\", samplerOffsets);\n                }\n            };\n            this._blurVPostProcess = new BABYLON.PostProcess(\"BlurV\", \"ssao\", [\"outSize\", \"samplerOffsets\"], [\"depthSampler\"], ratio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define SAMPLES 16\");\n            this._blurVPostProcess.onApply = function (effect) {\n                effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.height);\n                effect.setTexture(\"depthSampler\", _this._depthTexture);\n                if (_this._firstUpdate) {\n                    effect.setArray(\"samplerOffsets\", samplerOffsets);\n                    _this._firstUpdate = false;\n                }\n            };\n        };\n        SSAORenderingPipeline.prototype._createSSAOPostProcess = function (ratio) {\n            var _this = this;\n            var numSamples = 16;\n            var sampleSphere = [\n                0.5381, 0.1856, -0.4319,\n                0.1379, 0.2486, 0.4430,\n                0.3371, 0.5679, -0.0057,\n                -0.6999, -0.0451, -0.0019,\n                0.0689, -0.1598, -0.8547,\n                0.0560, 0.0069, -0.1843,\n                -0.0146, 0.1402, 0.0762,\n                0.0100, -0.1924, -0.0344,\n                -0.3577, -0.5301, -0.4358,\n                -0.3169, 0.1063, 0.0158,\n                0.0103, -0.5869, 0.0046,\n                -0.0897, -0.4940, 0.3287,\n                0.7119, -0.0154, -0.0918,\n                -0.0533, 0.0596, -0.5411,\n                0.0352, -0.0631, 0.5460,\n                -0.4776, 0.2847, -0.0271\n            ];\n            var samplesFactor = 1.0 / numSamples;\n            this._ssaoPostProcess = new BABYLON.PostProcess(\"ssao\", \"ssao\", [\n                \"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\",\n                \"area\", \"fallOff\", \"base\", \"range\", \"viewport\"\n            ], [\"randomSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define SAMPLES \" + numSamples + \"\\n#define SSAO\");\n            var viewport = new BABYLON.Vector2(0, 0);\n            this._ssaoPostProcess.onApply = function (effect) {\n                if (_this._firstUpdate) {\n                    effect.setArray3(\"sampleSphere\", sampleSphere);\n                    effect.setFloat(\"samplesFactor\", samplesFactor);\n                    effect.setFloat(\"randTextureTiles\", 4.0);\n                }\n                effect.setFloat(\"totalStrength\", _this.totalStrength);\n                effect.setFloat(\"radius\", _this.radius);\n                effect.setFloat(\"area\", _this.area);\n                effect.setFloat(\"fallOff\", _this.fallOff);\n                effect.setFloat(\"base\", _this.base);\n                effect.setTexture(\"textureSampler\", _this._depthTexture);\n                effect.setTexture(\"randomSampler\", _this._randomTexture);\n            };\n        };\n        SSAORenderingPipeline.prototype._createSSAOCombinePostProcess = function (ratio) {\n            var _this = this;\n            this._ssaoCombinePostProcess = new BABYLON.PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n            this._ssaoCombinePostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"originalColor\", _this._originalColorPostProcess);\n            };\n        };\n        SSAORenderingPipeline.prototype._createRandomTexture = function () {\n            var size = 512;\n            this._randomTexture = new BABYLON.DynamicTexture(\"SSAORandomTexture\", size, this._scene, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);\n            this._randomTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;\n            this._randomTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;\n            var context = this._randomTexture.getContext();\n            var rand = function (min, max) {\n                return Math.random() * (max - min) + min;\n            };\n            var randVector = BABYLON.Vector3.Zero();\n            for (var x = 0; x < size; x++) {\n                for (var y = 0; y < size; y++) {\n                    randVector.x = Math.floor(rand(-1.0, 1.0) * 255);\n                    randVector.y = Math.floor(rand(-1.0, 1.0) * 255);\n                    randVector.z = Math.floor(rand(-1.0, 1.0) * 255);\n                    context.fillStyle = 'rgb(' + randVector.x + ', ' + randVector.y + ', ' + randVector.z + ')';\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n            this._randomTexture.update(false);\n        };\n        return SSAORenderingPipeline;\n    }(BABYLON.PostProcessRenderPipeline));\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"totalStrength\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"radius\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"area\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"fallOff\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"base\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAORenderingPipeline.prototype, \"_ratio\", void 0);\n    BABYLON.SSAORenderingPipeline = SSAORenderingPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.ssaoRenderingPipeline.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var SSAO2RenderingPipeline = (function (_super) {\n        __extends(SSAO2RenderingPipeline, _super);\n        /**\n         * @constructor\n         * @param {string} name - The rendering pipeline name\n         * @param {BABYLON.Scene} scene - The scene linked to this pipeline\n         * @param {any} ratio - The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }\n         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to\n         */\n        function SSAO2RenderingPipeline(name, scene, ratio, cameras) {\n            var _this = _super.call(this, scene.getEngine(), name) || this;\n            // Members\n            /**\n            * The PassPostProcess id in the pipeline that contains the original scene color\n            * @type {string}\n            */\n            _this.SSAOOriginalSceneColorEffect = \"SSAOOriginalSceneColorEffect\";\n            /**\n            * The SSAO PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAORenderEffect = \"SSAORenderEffect\";\n            /**\n            * The horizontal blur PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAOBlurHRenderEffect = \"SSAOBlurHRenderEffect\";\n            /**\n            * The vertical blur PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.SSAOBlurVRenderEffect = \"SSAOBlurVRenderEffect\";\n            /**\n            * The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)\n            * @type {string}\n            */\n            _this.SSAOCombineRenderEffect = \"SSAOCombineRenderEffect\";\n            /**\n            * The output strength of the SSAO post-process. Default value is 1.0.\n            * @type {number}\n            */\n            _this.totalStrength = 1.0;\n            /**\n            * Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.\n            * @type {number}\n            */\n            _this.maxZ = 100.0;\n            /**\n            * In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much\n            * @type {number}\n            */\n            _this.minZAspect = 0.2;\n            /**\n            * Number of samples used for the SSAO calculations. Default value is 8\n            * @type {number}\n            */\n            _this._samples = 8;\n            /**\n            * Are we using bilateral blur ?\n            * @type {boolean}\n            */\n            _this._expensiveBlur = true;\n            /**\n            * The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0\n            * @type {number}\n            */\n            _this.radius = 2.0;\n            /**\n            * The base color of the SSAO post-process\n            * The final result is \"base + ssao\" between [0, 1]\n            * @type {number}\n            */\n            _this.base = 0.1;\n            _this._firstUpdate = true;\n            _this._scene = scene;\n            if (!_this.isSupported) {\n                BABYLON.Tools.Error(\"SSAO 2 needs WebGL 2 support.\");\n                return _this;\n            }\n            var ssaoRatio = ratio.ssaoRatio || ratio;\n            var blurRatio = ratio.blurRatio || ratio;\n            _this._ratio = {\n                ssaoRatio: ssaoRatio,\n                blurRatio: blurRatio\n            };\n            // Set up assets\n            _this._createRandomTexture();\n            _this._depthTexture = scene.enableGeometryBufferRenderer().getGBuffer().textures[0];\n            _this._normalTexture = scene.enableGeometryBufferRenderer().getGBuffer().textures[1];\n            _this._originalColorPostProcess = new BABYLON.PassPostProcess(\"SSAOOriginalSceneColor\", 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false);\n            _this._createSSAOPostProcess(1.0);\n            _this._createBlurPostProcess(ssaoRatio, blurRatio);\n            _this._createSSAOCombinePostProcess(blurRatio);\n            // Set up pipeline\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOOriginalSceneColorEffect, function () { return _this._originalColorPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAORenderEffect, function () { return _this._ssaoPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurHRenderEffect, function () { return _this._blurHPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOBlurVRenderEffect, function () { return _this._blurVPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.SSAOCombineRenderEffect, function () { return _this._ssaoCombinePostProcess; }, true));\n            // Finish\n            scene.postProcessRenderPipelineManager.addPipeline(_this);\n            if (cameras)\n                scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n            return _this;\n        }\n        Object.defineProperty(SSAO2RenderingPipeline.prototype, \"samples\", {\n            get: function () {\n                return this._samples;\n            },\n            set: function (n) {\n                this._ssaoPostProcess.updateEffect(\"#define SAMPLES \" + n + \"\\n#define SSAO\");\n                this._samples = n;\n                this._sampleSphere = this._generateHemisphere();\n                this._firstUpdate = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SSAO2RenderingPipeline.prototype, \"expensiveBlur\", {\n            get: function () {\n                return this._expensiveBlur;\n            },\n            set: function (b) {\n                this._blurHPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (b ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthSampler\"]);\n                this._blurVPostProcess.updateEffect(\"#define BILATERAL_BLUR\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (b ? \"1\" : \"0\") + \"\\n\", null, [\"textureSampler\", \"depthSampler\"]);\n                this._expensiveBlur = b;\n                this._firstUpdate = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(SSAO2RenderingPipeline, \"IsSupported\", {\n            /**\n            *  Support test.\n            * @type {boolean}\n            */\n            get: function () {\n                var engine = BABYLON.Engine.LastCreatedEngine;\n                return engine.webGLVersion > 1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Public Methods\n        /**\n         * Removes the internal pipeline assets and detatches the pipeline from the scene cameras\n         */\n        SSAO2RenderingPipeline.prototype.dispose = function (disableGeometryBufferRenderer) {\n            if (disableGeometryBufferRenderer === void 0) { disableGeometryBufferRenderer = false; }\n            for (var i = 0; i < this._scene.cameras.length; i++) {\n                var camera = this._scene.cameras[i];\n                this._originalColorPostProcess.dispose(camera);\n                this._ssaoPostProcess.dispose(camera);\n                this._blurHPostProcess.dispose(camera);\n                this._blurVPostProcess.dispose(camera);\n                this._ssaoCombinePostProcess.dispose(camera);\n            }\n            this._randomTexture.dispose();\n            if (disableGeometryBufferRenderer)\n                this._scene.disableGeometryBufferRenderer();\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n            _super.prototype.dispose.call(this);\n        };\n        // Private Methods\n        SSAO2RenderingPipeline.prototype._createBlurPostProcess = function (ssaoRatio, blurRatio) {\n            var _this = this;\n            var samples = 16;\n            this._samplerOffsets = [];\n            var expensive = this.expensiveBlur;\n            for (var i = -8; i < 8; i++) {\n                this._samplerOffsets.push(i * 2 + 0.5);\n            }\n            this._blurHPostProcess = new BABYLON.PostProcess(\"BlurH\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthSampler\"], ssaoRatio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_H\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (expensive ? \"1\" : \"0\") + \"\\n\");\n            this._blurHPostProcess.onApply = function (effect) {\n                effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.width);\n                effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n                effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n                effect.setFloat(\"radius\", _this.radius);\n                effect.setTexture(\"depthSampler\", _this._depthTexture);\n                if (_this._firstUpdate) {\n                    effect.setArray(\"samplerOffsets\", _this._samplerOffsets);\n                }\n            };\n            this._blurVPostProcess = new BABYLON.PostProcess(\"BlurV\", \"ssao2\", [\"outSize\", \"samplerOffsets\", \"near\", \"far\", \"radius\"], [\"depthSampler\"], blurRatio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define BILATERAL_BLUR\\n#define BILATERAL_BLUR_V\\n#define SAMPLES 16\\n#define EXPENSIVE \" + (expensive ? \"1\" : \"0\") + \"\\n\");\n            this._blurVPostProcess.onApply = function (effect) {\n                effect.setFloat(\"outSize\", _this._ssaoCombinePostProcess.height);\n                effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n                effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n                effect.setFloat(\"radius\", _this.radius);\n                effect.setTexture(\"depthSampler\", _this._depthTexture);\n                if (_this._firstUpdate) {\n                    effect.setArray(\"samplerOffsets\", _this._samplerOffsets);\n                    _this._firstUpdate = false;\n                }\n            };\n        };\n        SSAO2RenderingPipeline.prototype._generateHemisphere = function () {\n            var numSamples = this.samples;\n            var result = [];\n            var vector, scale;\n            var rand = function (min, max) {\n                return Math.random() * (max - min) + min;\n            };\n            var lerp = function (start, end, percent) {\n                return (start + percent * (end - start));\n            };\n            var i = 0;\n            var normal = new BABYLON.Vector3(0, 0, 1);\n            while (i < numSamples) {\n                vector = new BABYLON.Vector3(rand(-1.0, 1.0), rand(-1.0, 1.0), rand(0.30, 1.0));\n                vector.normalize();\n                scale = i / numSamples;\n                scale = lerp(0.1, 1.0, scale * scale);\n                vector.scaleInPlace(scale);\n                result.push(vector.x, vector.y, vector.z);\n                i++;\n            }\n            return result;\n        };\n        SSAO2RenderingPipeline.prototype._createSSAOPostProcess = function (ratio) {\n            var _this = this;\n            var numSamples = this.samples;\n            this._sampleSphere = this._generateHemisphere();\n            this._ssaoPostProcess = new BABYLON.PostProcess(\"ssao2\", \"ssao2\", [\n                \"sampleSphere\", \"samplesFactor\", \"randTextureTiles\", \"totalStrength\", \"radius\",\n                \"base\", \"range\", \"projection\", \"near\", \"far\", \"texelSize\",\n                \"xViewport\", \"yViewport\", \"maxZ\", \"minZAspect\"\n            ], [\"randomSampler\", \"normalSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, \"#define SAMPLES \" + numSamples + \"\\n#define SSAO\");\n            this._ssaoPostProcess.onApply = function (effect) {\n                if (_this._firstUpdate) {\n                    effect.setArray3(\"sampleSphere\", _this._sampleSphere);\n                    effect.setFloat(\"randTextureTiles\", 4.0);\n                }\n                effect.setFloat(\"samplesFactor\", 1 / _this.samples);\n                effect.setFloat(\"totalStrength\", _this.totalStrength);\n                effect.setFloat2(\"texelSize\", 1 / _this._ssaoPostProcess.width, 1 / _this._ssaoPostProcess.height);\n                effect.setFloat(\"radius\", _this.radius);\n                effect.setFloat(\"maxZ\", _this.maxZ);\n                effect.setFloat(\"minZAspect\", _this.minZAspect);\n                effect.setFloat(\"base\", _this.base);\n                effect.setFloat(\"near\", _this._scene.activeCamera.minZ);\n                effect.setFloat(\"far\", _this._scene.activeCamera.maxZ);\n                effect.setFloat(\"xViewport\", Math.tan(_this._scene.activeCamera.fov / 2) * _this._scene.getEngine().getAspectRatio(_this._scene.activeCamera, true));\n                effect.setFloat(\"yViewport\", Math.tan(_this._scene.activeCamera.fov / 2));\n                effect.setMatrix(\"projection\", _this._scene.getProjectionMatrix());\n                effect.setTexture(\"textureSampler\", _this._depthTexture);\n                effect.setTexture(\"normalSampler\", _this._normalTexture);\n                effect.setTexture(\"randomSampler\", _this._randomTexture);\n            };\n        };\n        SSAO2RenderingPipeline.prototype._createSSAOCombinePostProcess = function (ratio) {\n            var _this = this;\n            this._ssaoCombinePostProcess = new BABYLON.PostProcess(\"ssaoCombine\", \"ssaoCombine\", [], [\"originalColor\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n            this._ssaoCombinePostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"originalColor\", _this._originalColorPostProcess);\n            };\n        };\n        SSAO2RenderingPipeline.prototype._createRandomTexture = function () {\n            var size = 512;\n            this._randomTexture = new BABYLON.DynamicTexture(\"SSAORandomTexture\", size, this._scene, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);\n            this._randomTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;\n            this._randomTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;\n            var context = this._randomTexture.getContext();\n            var rand = function (min, max) {\n                return Math.random() * (max - min) + min;\n            };\n            var randVector = BABYLON.Vector3.Zero();\n            for (var x = 0; x < size; x++) {\n                for (var y = 0; y < size; y++) {\n                    randVector.x = rand(0.0, 1.0);\n                    randVector.y = rand(0.0, 1.0);\n                    randVector.z = 0.0;\n                    randVector.normalize();\n                    randVector.scaleInPlace(255);\n                    randVector.x = Math.floor(randVector.x);\n                    randVector.y = Math.floor(randVector.y);\n                    context.fillStyle = 'rgb(' + randVector.x + ', ' + randVector.y + ', ' + randVector.z + ')';\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n            this._randomTexture.update(false);\n        };\n        return SSAO2RenderingPipeline;\n    }(BABYLON.PostProcessRenderPipeline));\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"totalStrength\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"maxZ\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"minZAspect\", void 0);\n    __decorate([\n        BABYLON.serialize(\"samples\")\n    ], SSAO2RenderingPipeline.prototype, \"_samples\", void 0);\n    __decorate([\n        BABYLON.serialize(\"expensiveBlur\")\n    ], SSAO2RenderingPipeline.prototype, \"_expensiveBlur\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"radius\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"base\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], SSAO2RenderingPipeline.prototype, \"_ratio\", void 0);\n    BABYLON.SSAO2RenderingPipeline = SSAO2RenderingPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.ssao2RenderingPipeline.js.map\n\n// BABYLON.JS Chromatic Aberration GLSL Shader\n// Author: Olivier Guyot\n// Separates very slightly R, G and B colors on the edges of the screen\n// Inspired by Francois Tarlier & Martins Upitis\n\nvar BABYLON;\n(function (BABYLON) {\n    var LensRenderingPipeline = (function (_super) {\n        __extends(LensRenderingPipeline, _super);\n        /**\n         * @constructor\n         *\n         * Effect parameters are as follow:\n         * {\n         *      chromatic_aberration: number;       // from 0 to x (1 for realism)\n         *      edge_blur: number;                  // from 0 to x (1 for realism)\n         *      distortion: number;                 // from 0 to x (1 for realism)\n         *      grain_amount: number;               // from 0 to 1\n         *      grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise\n         *      dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)\n         *      dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)\n         *      dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)\n         *      dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like \"bokeh\" effect\n         *      dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)\n         *      dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)\n         *      blur_noise: boolean;                // add a little bit of noise to the blur (default: true)\n         * }\n         * Note: if an effect parameter is unset, effect is disabled\n         *\n         * @param {string} name - The rendering pipeline name\n         * @param {object} parameters - An object containing all parameters (see above)\n         * @param {BABYLON.Scene} scene - The scene linked to this pipeline\n         * @param {number} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to\n         */\n        function LensRenderingPipeline(name, parameters, scene, ratio, cameras) {\n            if (ratio === void 0) { ratio = 1.0; }\n            var _this = _super.call(this, scene.getEngine(), name) || this;\n            // Lens effects can be of the following:\n            // - chromatic aberration (slight shift of RGB colors)\n            // - blur on the edge of the lens\n            // - lens distortion\n            // - depth-of-field blur & highlights enhancing\n            // - depth-of-field 'bokeh' effect (shapes appearing in blurred areas)\n            // - grain effect (noise or custom texture)\n            // Two additional texture samplers are needed:\n            // - depth map (for depth-of-field)\n            // - grain texture\n            /**\n            * The chromatic aberration PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.LensChromaticAberrationEffect = \"LensChromaticAberrationEffect\";\n            /**\n            * The highlights enhancing PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.HighlightsEnhancingEffect = \"HighlightsEnhancingEffect\";\n            /**\n            * The depth-of-field PostProcess id in the pipeline\n            * @type {string}\n            */\n            _this.LensDepthOfFieldEffect = \"LensDepthOfFieldEffect\";\n            _this._scene = scene;\n            // Fetch texture samplers\n            _this._depthTexture = scene.enableDepthRenderer().getDepthMap(); // Force depth renderer \"on\"\n            if (parameters.grain_texture) {\n                _this._grainTexture = parameters.grain_texture;\n            }\n            else {\n                _this._createGrainTexture();\n            }\n            // save parameters\n            _this._edgeBlur = parameters.edge_blur ? parameters.edge_blur : 0;\n            _this._grainAmount = parameters.grain_amount ? parameters.grain_amount : 0;\n            _this._chromaticAberration = parameters.chromatic_aberration ? parameters.chromatic_aberration : 0;\n            _this._distortion = parameters.distortion ? parameters.distortion : 0;\n            _this._highlightsGain = parameters.dof_gain !== undefined ? parameters.dof_gain : -1;\n            _this._highlightsThreshold = parameters.dof_threshold ? parameters.dof_threshold : 1;\n            _this._dofDistance = parameters.dof_focus_distance !== undefined ? parameters.dof_focus_distance : -1;\n            _this._dofAperture = parameters.dof_aperture ? parameters.dof_aperture : 1;\n            _this._dofDarken = parameters.dof_darken ? parameters.dof_darken : 0;\n            _this._dofPentagon = parameters.dof_pentagon !== undefined ? parameters.dof_pentagon : true;\n            _this._blurNoise = parameters.blur_noise !== undefined ? parameters.blur_noise : true;\n            // Create effects\n            _this._createChromaticAberrationPostProcess(ratio);\n            _this._createHighlightsPostProcess(ratio);\n            _this._createDepthOfFieldPostProcess(ratio / 4);\n            // Set up pipeline\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.LensChromaticAberrationEffect, function () { return _this._chromaticAberrationPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.HighlightsEnhancingEffect, function () { return _this._highlightsPostProcess; }, true));\n            _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), _this.LensDepthOfFieldEffect, function () { return _this._depthOfFieldPostProcess; }, true));\n            if (_this._highlightsGain === -1) {\n                _this._disableEffect(_this.HighlightsEnhancingEffect, null);\n            }\n            // Finish\n            scene.postProcessRenderPipelineManager.addPipeline(_this);\n            if (cameras) {\n                scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(name, cameras);\n            }\n            return _this;\n        }\n        // public methods (self explanatory)\n        LensRenderingPipeline.prototype.setEdgeBlur = function (amount) { this._edgeBlur = amount; };\n        LensRenderingPipeline.prototype.disableEdgeBlur = function () { this._edgeBlur = 0; };\n        LensRenderingPipeline.prototype.setGrainAmount = function (amount) { this._grainAmount = amount; };\n        LensRenderingPipeline.prototype.disableGrain = function () { this._grainAmount = 0; };\n        LensRenderingPipeline.prototype.setChromaticAberration = function (amount) { this._chromaticAberration = amount; };\n        LensRenderingPipeline.prototype.disableChromaticAberration = function () { this._chromaticAberration = 0; };\n        LensRenderingPipeline.prototype.setEdgeDistortion = function (amount) { this._distortion = amount; };\n        LensRenderingPipeline.prototype.disableEdgeDistortion = function () { this._distortion = 0; };\n        LensRenderingPipeline.prototype.setFocusDistance = function (amount) { this._dofDistance = amount; };\n        LensRenderingPipeline.prototype.disableDepthOfField = function () { this._dofDistance = -1; };\n        LensRenderingPipeline.prototype.setAperture = function (amount) { this._dofAperture = amount; };\n        LensRenderingPipeline.prototype.setDarkenOutOfFocus = function (amount) { this._dofDarken = amount; };\n        LensRenderingPipeline.prototype.enablePentagonBokeh = function () {\n            this._highlightsPostProcess.updateEffect(\"#define PENTAGON\\n\");\n        };\n        LensRenderingPipeline.prototype.disablePentagonBokeh = function () {\n            this._highlightsPostProcess.updateEffect();\n        };\n        LensRenderingPipeline.prototype.enableNoiseBlur = function () { this._blurNoise = true; };\n        LensRenderingPipeline.prototype.disableNoiseBlur = function () { this._blurNoise = false; };\n        LensRenderingPipeline.prototype.setHighlightsGain = function (amount) {\n            this._highlightsGain = amount;\n        };\n        LensRenderingPipeline.prototype.setHighlightsThreshold = function (amount) {\n            if (this._highlightsGain === -1) {\n                this._highlightsGain = 1.0;\n            }\n            this._highlightsThreshold = amount;\n        };\n        LensRenderingPipeline.prototype.disableHighlights = function () {\n            this._highlightsGain = -1;\n        };\n        /**\n         * Removes the internal pipeline assets and detaches the pipeline from the scene cameras\n         */\n        LensRenderingPipeline.prototype.dispose = function (disableDepthRender) {\n            if (disableDepthRender === void 0) { disableDepthRender = false; }\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._scene.cameras);\n            this._chromaticAberrationPostProcess = undefined;\n            this._highlightsPostProcess = undefined;\n            this._depthOfFieldPostProcess = undefined;\n            this._grainTexture.dispose();\n            if (disableDepthRender)\n                this._scene.disableDepthRenderer();\n        };\n        // colors shifting and distortion\n        LensRenderingPipeline.prototype._createChromaticAberrationPostProcess = function (ratio) {\n            var _this = this;\n            this._chromaticAberrationPostProcess = new BABYLON.PostProcess(\"LensChromaticAberration\", \"chromaticAberration\", [\"chromatic_aberration\", \"screen_width\", \"screen_height\"], // uniforms\n            [], // samplers\n            ratio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n            this._chromaticAberrationPostProcess.onApply = function (effect) {\n                effect.setFloat('chromatic_aberration', _this._chromaticAberration);\n                effect.setFloat('screen_width', _this._scene.getEngine().getRenderingCanvas().width);\n                effect.setFloat('screen_height', _this._scene.getEngine().getRenderingCanvas().height);\n            };\n        };\n        // highlights enhancing\n        LensRenderingPipeline.prototype._createHighlightsPostProcess = function (ratio) {\n            var _this = this;\n            this._highlightsPostProcess = new BABYLON.PostProcess(\"LensHighlights\", \"lensHighlights\", [\"gain\", \"threshold\", \"screen_width\", \"screen_height\"], // uniforms\n            [], // samplers\n            ratio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false, this._dofPentagon ? \"#define PENTAGON\\n\" : \"\");\n            this._highlightsPostProcess.onApply = function (effect) {\n                effect.setFloat('gain', _this._highlightsGain);\n                effect.setFloat('threshold', _this._highlightsThreshold);\n                effect.setTextureFromPostProcess(\"textureSampler\", _this._chromaticAberrationPostProcess);\n                effect.setFloat('screen_width', _this._scene.getEngine().getRenderingCanvas().width);\n                effect.setFloat('screen_height', _this._scene.getEngine().getRenderingCanvas().height);\n            };\n        };\n        // colors shifting and distortion\n        LensRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (ratio) {\n            var _this = this;\n            this._depthOfFieldPostProcess = new BABYLON.PostProcess(\"LensDepthOfField\", \"depthOfField\", [\n                \"grain_amount\", \"blur_noise\", \"screen_width\", \"screen_height\", \"distortion\", \"dof_enabled\",\n                \"screen_distance\", \"aperture\", \"darken\", \"edge_blur\", \"highlights\", \"near\", \"far\"\n            ], [\"depthSampler\", \"grainSampler\", \"highlightsSampler\"], ratio, null, BABYLON.Texture.TRILINEAR_SAMPLINGMODE, this._scene.getEngine(), false);\n            this._depthOfFieldPostProcess.onApply = function (effect) {\n                effect.setTexture(\"depthSampler\", _this._depthTexture);\n                effect.setTexture(\"grainSampler\", _this._grainTexture);\n                effect.setTextureFromPostProcess(\"textureSampler\", _this._highlightsPostProcess);\n                effect.setTextureFromPostProcess(\"highlightsSampler\", _this._depthOfFieldPostProcess);\n                effect.setFloat('grain_amount', _this._grainAmount);\n                effect.setBool('blur_noise', _this._blurNoise);\n                effect.setFloat('screen_width', _this._scene.getEngine().getRenderingCanvas().width);\n                effect.setFloat('screen_height', _this._scene.getEngine().getRenderingCanvas().height);\n                effect.setFloat('distortion', _this._distortion);\n                effect.setBool('dof_enabled', (_this._dofDistance !== -1));\n                effect.setFloat('screen_distance', 1.0 / (0.1 - 1.0 / _this._dofDistance));\n                effect.setFloat('aperture', _this._dofAperture);\n                effect.setFloat('darken', _this._dofDarken);\n                effect.setFloat('edge_blur', _this._edgeBlur);\n                effect.setBool('highlights', (_this._highlightsGain !== -1));\n                effect.setFloat('near', _this._scene.activeCamera.minZ);\n                effect.setFloat('far', _this._scene.activeCamera.maxZ);\n            };\n        };\n        // creates a black and white random noise texture, 512x512\n        LensRenderingPipeline.prototype._createGrainTexture = function () {\n            var size = 512;\n            this._grainTexture = new BABYLON.DynamicTexture(\"LensNoiseTexture\", size, this._scene, false, BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            this._grainTexture.wrapU = BABYLON.Texture.WRAP_ADDRESSMODE;\n            this._grainTexture.wrapV = BABYLON.Texture.WRAP_ADDRESSMODE;\n            var context = this._grainTexture.getContext();\n            var rand = function (min, max) {\n                return Math.random() * (max - min) + min;\n            };\n            var value;\n            for (var x = 0; x < size; x++) {\n                for (var y = 0; y < size; y++) {\n                    value = Math.floor(rand(0.42, 0.58) * 255);\n                    context.fillStyle = 'rgb(' + value + ', ' + value + ', ' + value + ')';\n                    context.fillRect(x, y, 1, 1);\n                }\n            }\n            this._grainTexture.update(false);\n        };\n        return LensRenderingPipeline;\n    }(BABYLON.PostProcessRenderPipeline));\n    BABYLON.LensRenderingPipeline = LensRenderingPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.lensRenderingPipeline.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var StandardRenderingPipeline = (function (_super) {\n        __extends(StandardRenderingPipeline, _super);\n        /**\n         * @constructor\n         * @param {string} name - The rendering pipeline name\n         * @param {BABYLON.Scene} scene - The scene linked to this pipeline\n         * @param {any} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n         * @param {BABYLON.PostProcess} originalPostProcess - the custom original color post-process. Must be \"reusable\". Can be null.\n         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to\n         */\n        function StandardRenderingPipeline(name, scene, ratio, originalPostProcess, cameras) {\n            if (originalPostProcess === void 0) { originalPostProcess = null; }\n            var _this = _super.call(this, scene.getEngine(), name) || this;\n            _this.downSampleX4PostProcess = null;\n            _this.brightPassPostProcess = null;\n            _this.blurHPostProcesses = [];\n            _this.blurVPostProcesses = [];\n            _this.textureAdderPostProcess = null;\n            _this.volumetricLightPostProcess = null;\n            _this.volumetricLightSmoothXPostProcess = null;\n            _this.volumetricLightSmoothYPostProcess = null;\n            _this.volumetricLightMergePostProces = null;\n            _this.volumetricLightFinalPostProcess = null;\n            _this.luminancePostProcess = null;\n            _this.luminanceDownSamplePostProcesses = [];\n            _this.hdrPostProcess = null;\n            _this.textureAdderFinalPostProcess = null;\n            _this.lensFlareFinalPostProcess = null;\n            _this.hdrFinalPostProcess = null;\n            _this.lensFlarePostProcess = null;\n            _this.lensFlareComposePostProcess = null;\n            _this.motionBlurPostProcess = null;\n            _this.depthOfFieldPostProcess = null;\n            // Values\n            _this.brightThreshold = 1.0;\n            _this.blurWidth = 512.0;\n            _this.horizontalBlur = false;\n            _this.exposure = 1.0;\n            _this.lensTexture = null;\n            _this.volumetricLightCoefficient = 0.2;\n            _this.volumetricLightPower = 4.0;\n            _this.volumetricLightBlurScale = 64.0;\n            _this.sourceLight = null;\n            _this.hdrMinimumLuminance = 1.0;\n            _this.hdrDecreaseRate = 0.5;\n            _this.hdrIncreaseRate = 0.5;\n            _this.lensColorTexture = null;\n            _this.lensFlareStrength = 20.0;\n            _this.lensFlareGhostDispersal = 1.4;\n            _this.lensFlareHaloWidth = 0.7;\n            _this.lensFlareDistortionStrength = 16.0;\n            _this.lensStarTexture = null;\n            _this.lensFlareDirtTexture = null;\n            _this.depthOfFieldDistance = 10.0;\n            _this.depthOfFieldBlurWidth = 64.0;\n            _this.motionStrength = 1.0;\n            // IAnimatable\n            _this.animations = [];\n            _this._currentDepthOfFieldSource = null;\n            _this._hdrCurrentLuminance = 1.0;\n            // Getters and setters\n            _this._bloomEnabled = true;\n            _this._depthOfFieldEnabled = false;\n            _this._vlsEnabled = false;\n            _this._lensFlareEnabled = false;\n            _this._hdrEnabled = false;\n            _this._motionBlurEnabled = false;\n            _this._motionBlurSamples = 64.0;\n            _this._volumetricLightStepsCount = 50.0;\n            _this._cameras = cameras || [];\n            // Initialize\n            _this._scene = scene;\n            _this._basePostProcess = originalPostProcess;\n            _this._ratio = ratio;\n            // Misc\n            _this._floatTextureType = scene.getEngine().getCaps().textureFloatRender ? BABYLON.Engine.TEXTURETYPE_FLOAT : BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n            // Finish\n            scene.postProcessRenderPipelineManager.addPipeline(_this);\n            _this._buildPipeline();\n            return _this;\n        }\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"BloomEnabled\", {\n            get: function () {\n                return this._bloomEnabled;\n            },\n            set: function (enabled) {\n                if (this._bloomEnabled === enabled) {\n                    return;\n                }\n                this._bloomEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", {\n            get: function () {\n                return this._depthOfFieldEnabled;\n            },\n            set: function (enabled) {\n                if (this._depthOfFieldEnabled === enabled) {\n                    return;\n                }\n                this._depthOfFieldEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"LensFlareEnabled\", {\n            get: function () {\n                return this._lensFlareEnabled;\n            },\n            set: function (enabled) {\n                if (this._lensFlareEnabled === enabled) {\n                    return;\n                }\n                this._lensFlareEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"HDREnabled\", {\n            get: function () {\n                return this._hdrEnabled;\n            },\n            set: function (enabled) {\n                if (this._hdrEnabled === enabled) {\n                    return;\n                }\n                this._hdrEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"VLSEnabled\", {\n            get: function () {\n                return this._vlsEnabled;\n            },\n            set: function (enabled) {\n                if (this._vlsEnabled === enabled) {\n                    return;\n                }\n                if (enabled) {\n                    var geometry = this._scene.enableGeometryBufferRenderer();\n                    if (!geometry) {\n                        BABYLON.Tools.Warn(\"Geometry renderer is not supported, cannot create volumetric lights in Standard Rendering Pipeline\");\n                        return;\n                    }\n                }\n                this._vlsEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", {\n            get: function () {\n                return this._motionBlurEnabled;\n            },\n            set: function (enabled) {\n                if (this._motionBlurEnabled === enabled) {\n                    return;\n                }\n                this._motionBlurEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", {\n            get: function () {\n                return this._volumetricLightStepsCount;\n            },\n            set: function (count) {\n                if (this.volumetricLightPostProcess) {\n                    this.volumetricLightPostProcess.updateEffect(\"#define VLS\\n#define NB_STEPS \" + count.toFixed(1));\n                }\n                this._volumetricLightStepsCount = count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(StandardRenderingPipeline.prototype, \"motionBlurSamples\", {\n            get: function () {\n                return this._motionBlurSamples;\n            },\n            set: function (samples) {\n                if (this.motionBlurPostProcess) {\n                    this.motionBlurPostProcess.updateEffect(\"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + samples.toFixed(1));\n                }\n                this._motionBlurSamples = samples;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        StandardRenderingPipeline.prototype._buildPipeline = function () {\n            var _this = this;\n            var ratio = this._ratio;\n            var scene = this._scene;\n            this._disposePostProcesses();\n            this._reset();\n            // Create pass post-process\n            if (!this._basePostProcess) {\n                this.originalPostProcess = new BABYLON.PostProcess(\"HDRPass\", \"standard\", [], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", this._floatTextureType);\n                this.originalPostProcess.onApply = function (effect) {\n                    _this._currentDepthOfFieldSource = _this.originalPostProcess;\n                };\n            }\n            else {\n                this.originalPostProcess = this._basePostProcess;\n            }\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRPassPostProcess\", function () { return _this.originalPostProcess; }, true));\n            this._currentDepthOfFieldSource = this.originalPostProcess;\n            if (this._vlsEnabled) {\n                // Create volumetric light\n                this._createVolumetricLightPostProcess(scene, ratio);\n                // Create volumetric light final post-process\n                this.volumetricLightFinalPostProcess = new BABYLON.PostProcess(\"HDRVLSFinal\", \"standard\", [], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRVLSFinal\", function () { return _this.volumetricLightFinalPostProcess; }, true));\n            }\n            if (this._bloomEnabled) {\n                // Create down sample X4 post-process\n                this._createDownSampleX4PostProcess(scene, ratio / 2);\n                // Create bright pass post-process\n                this._createBrightPassPostProcess(scene, ratio / 2);\n                // Create gaussian blur post-processes (down sampling blurs)\n                this._createBlurPostProcesses(scene, ratio / 4, 1);\n                // Create texture adder post-process\n                this._createTextureAdderPostProcess(scene, ratio);\n                // Create depth-of-field source post-process\n                this.textureAdderFinalPostProcess = new BABYLON.PostProcess(\"HDRDepthOfFieldSource\", \"standard\", [], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRBaseDepthOfFieldSource\", function () { return _this.textureAdderFinalPostProcess; }, true));\n            }\n            if (this._lensFlareEnabled) {\n                // Create lens flare post-process\n                this._createLensFlarePostProcess(scene, ratio);\n                // Create depth-of-field source post-process post lens-flare and disable it now\n                this.lensFlareFinalPostProcess = new BABYLON.PostProcess(\"HDRPostLensFlareDepthOfFieldSource\", \"standard\", [], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRPostLensFlareDepthOfFieldSource\", function () { return _this.lensFlareFinalPostProcess; }, true));\n            }\n            if (this._hdrEnabled) {\n                // Create luminance\n                this._createLuminancePostProcesses(scene, this._floatTextureType);\n                // Create HDR\n                this._createHdrPostProcess(scene, ratio);\n                // Create depth-of-field source post-process post hdr and disable it now\n                this.hdrFinalPostProcess = new BABYLON.PostProcess(\"HDRPostHDReDepthOfFieldSource\", \"standard\", [], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define PASS_POST_PROCESS\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRPostHDReDepthOfFieldSource\", function () { return _this.hdrFinalPostProcess; }, true));\n            }\n            if (this._depthOfFieldEnabled) {\n                // Create gaussian blur used by depth-of-field\n                this._createBlurPostProcesses(scene, ratio / 2, 3, \"depthOfFieldBlurWidth\");\n                // Create depth-of-field post-process\n                this._createDepthOfFieldPostProcess(scene, ratio);\n            }\n            if (this._motionBlurEnabled) {\n                // Create motion blur post-process\n                this._createMotionBlurPostProcess(scene, ratio);\n            }\n            if (this._cameras !== null) {\n                this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n            }\n        };\n        // Down Sample X4 Post-Processs\n        StandardRenderingPipeline.prototype._createDownSampleX4PostProcess = function (scene, ratio) {\n            var _this = this;\n            var downSampleX4Offsets = new Array(32);\n            this.downSampleX4PostProcess = new BABYLON.PostProcess(\"HDRDownSampleX4\", \"standard\", [\"dsOffsets\"], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DOWN_SAMPLE_X4\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.downSampleX4PostProcess.onApply = function (effect) {\n                var id = 0;\n                for (var i = -2; i < 2; i++) {\n                    for (var j = -2; j < 2; j++) {\n                        downSampleX4Offsets[id] = (i + 0.5) * (1.0 / _this.downSampleX4PostProcess.width);\n                        downSampleX4Offsets[id + 1] = (j + 0.5) * (1.0 / _this.downSampleX4PostProcess.height);\n                        id += 2;\n                    }\n                }\n                effect.setArray2(\"dsOffsets\", downSampleX4Offsets);\n            };\n            // Add to pipeline\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRDownSampleX4\", function () { return _this.downSampleX4PostProcess; }, true));\n        };\n        // Brightpass Post-Process\n        StandardRenderingPipeline.prototype._createBrightPassPostProcess = function (scene, ratio) {\n            var _this = this;\n            var brightOffsets = new Array(8);\n            this.brightPassPostProcess = new BABYLON.PostProcess(\"HDRBrightPass\", \"standard\", [\"dsOffsets\", \"brightThreshold\"], [], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define BRIGHT_PASS\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.brightPassPostProcess.onApply = function (effect) {\n                var sU = (1.0 / _this.brightPassPostProcess.width);\n                var sV = (1.0 / _this.brightPassPostProcess.height);\n                brightOffsets[0] = -0.5 * sU;\n                brightOffsets[1] = 0.5 * sV;\n                brightOffsets[2] = 0.5 * sU;\n                brightOffsets[3] = 0.5 * sV;\n                brightOffsets[4] = -0.5 * sU;\n                brightOffsets[5] = -0.5 * sV;\n                brightOffsets[6] = 0.5 * sU;\n                brightOffsets[7] = -0.5 * sV;\n                effect.setArray2(\"dsOffsets\", brightOffsets);\n                effect.setFloat(\"brightThreshold\", _this.brightThreshold);\n            };\n            // Add to pipeline\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRBrightPass\", function () { return _this.brightPassPostProcess; }, true));\n        };\n        // Create blur H&V post-processes\n        StandardRenderingPipeline.prototype._createBlurPostProcesses = function (scene, ratio, indice, blurWidthKey) {\n            var _this = this;\n            if (blurWidthKey === void 0) { blurWidthKey = \"blurWidth\"; }\n            var engine = scene.getEngine();\n            var blurX = new BABYLON.BlurPostProcess(\"HDRBlurH\" + \"_\" + indice, new BABYLON.Vector2(1, 0), this[blurWidthKey], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            var blurY = new BABYLON.BlurPostProcess(\"HDRBlurV\" + \"_\" + indice, new BABYLON.Vector2(0, 1), this[blurWidthKey], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            blurX.onActivateObservable.add(function () {\n                var dw = blurX.width / engine.getRenderingCanvas().width;\n                blurX.kernel = _this[blurWidthKey] * dw;\n            });\n            blurY.onActivateObservable.add(function () {\n                var dw = blurY.height / engine.getRenderingCanvas().height;\n                blurY.kernel = _this.horizontalBlur ? 64 * dw : _this[blurWidthKey] * dw;\n            });\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRBlurH\" + indice, function () { return blurX; }, true));\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRBlurV\" + indice, function () { return blurY; }, true));\n            this.blurHPostProcesses.push(blurX);\n            this.blurVPostProcesses.push(blurY);\n        };\n        // Create texture adder post-process\n        StandardRenderingPipeline.prototype._createTextureAdderPostProcess = function (scene, ratio) {\n            var _this = this;\n            this.textureAdderPostProcess = new BABYLON.PostProcess(\"HDRTextureAdder\", \"standard\", [\"exposure\"], [\"otherSampler\", \"lensSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define TEXTURE_ADDER\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.textureAdderPostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"otherSampler\", _this._vlsEnabled ? _this._currentDepthOfFieldSource : _this.originalPostProcess);\n                effect.setTexture(\"lensSampler\", _this.lensTexture);\n                effect.setFloat(\"exposure\", _this.exposure);\n                _this._currentDepthOfFieldSource = _this.textureAdderFinalPostProcess;\n            };\n            // Add to pipeline\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRTextureAdder\", function () { return _this.textureAdderPostProcess; }, true));\n        };\n        StandardRenderingPipeline.prototype._createVolumetricLightPostProcess = function (scene, ratio) {\n            var _this = this;\n            var geometryRenderer = scene.enableGeometryBufferRenderer();\n            geometryRenderer.enablePosition = true;\n            var geometry = geometryRenderer.getGBuffer();\n            // Base post-process\n            this.volumetricLightPostProcess = new BABYLON.PostProcess(\"HDRVLS\", \"standard\", [\"shadowViewProjection\", \"cameraPosition\", \"sunDirection\", \"sunColor\", \"scatteringCoefficient\", \"scatteringPower\", \"depthValues\"], [\"shadowMapSampler\", \"positionSampler\"], ratio / 8, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLS\\n#define NB_STEPS \" + this._volumetricLightStepsCount.toFixed(1));\n            var depthValues = BABYLON.Vector2.Zero();\n            this.volumetricLightPostProcess.onApply = function (effect) {\n                if (_this.sourceLight && _this.sourceLight.getShadowGenerator()) {\n                    var generator = _this.sourceLight.getShadowGenerator();\n                    effect.setTexture(\"shadowMapSampler\", generator.getShadowMap());\n                    effect.setTexture(\"positionSampler\", geometry.textures[2]);\n                    effect.setColor3(\"sunColor\", _this.sourceLight.diffuse);\n                    effect.setVector3(\"sunDirection\", _this.sourceLight.getShadowDirection());\n                    effect.setVector3(\"cameraPosition\", scene.activeCamera.globalPosition);\n                    effect.setMatrix(\"shadowViewProjection\", generator.getTransformMatrix());\n                    effect.setFloat(\"scatteringCoefficient\", _this.volumetricLightCoefficient);\n                    effect.setFloat(\"scatteringPower\", _this.volumetricLightPower);\n                    depthValues.x = generator.getLight().getDepthMinZ(_this._scene.activeCamera);\n                    depthValues.y = generator.getLight().getDepthMaxZ(_this._scene.activeCamera);\n                    effect.setVector2(\"depthValues\", depthValues);\n                }\n            };\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRVLS\", function () { return _this.volumetricLightPostProcess; }, true));\n            // Smooth\n            this._createBlurPostProcesses(scene, ratio / 4, 0, \"volumetricLightBlurScale\");\n            // Merge\n            this.volumetricLightMergePostProces = new BABYLON.PostProcess(\"HDRVLSMerge\", \"standard\", [], [\"originalSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define VLSMERGE\");\n            this.volumetricLightMergePostProces.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"originalSampler\", _this.originalPostProcess);\n                _this._currentDepthOfFieldSource = _this.volumetricLightFinalPostProcess;\n            };\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRVLSMerge\", function () { return _this.volumetricLightMergePostProces; }, true));\n        };\n        // Create luminance\n        StandardRenderingPipeline.prototype._createLuminancePostProcesses = function (scene, textureType) {\n            var _this = this;\n            // Create luminance\n            var size = Math.pow(3, StandardRenderingPipeline.LuminanceSteps);\n            this.luminancePostProcess = new BABYLON.PostProcess(\"HDRLuminance\", \"standard\", [\"lumOffsets\"], [], { width: size, height: size }, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LUMINANCE\", textureType);\n            var offsets = [];\n            this.luminancePostProcess.onApply = function (effect) {\n                var sU = (1.0 / _this.luminancePostProcess.width);\n                var sV = (1.0 / _this.luminancePostProcess.height);\n                offsets[0] = -0.5 * sU;\n                offsets[1] = 0.5 * sV;\n                offsets[2] = 0.5 * sU;\n                offsets[3] = 0.5 * sV;\n                offsets[4] = -0.5 * sU;\n                offsets[5] = -0.5 * sV;\n                offsets[6] = 0.5 * sU;\n                offsets[7] = -0.5 * sV;\n                effect.setArray2(\"lumOffsets\", offsets);\n            };\n            // Add to pipeline\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRLuminance\", function () { return _this.luminancePostProcess; }, true));\n            // Create down sample luminance\n            for (var i = StandardRenderingPipeline.LuminanceSteps - 1; i >= 0; i--) {\n                var size = Math.pow(3, i);\n                var defines = \"#define LUMINANCE_DOWN_SAMPLE\\n\";\n                if (i === 0) {\n                    defines += \"#define FINAL_DOWN_SAMPLER\";\n                }\n                var postProcess = new BABYLON.PostProcess(\"HDRLuminanceDownSample\" + i, \"standard\", [\"dsOffsets\", \"halfDestPixelSize\"], [], { width: size, height: size }, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, defines, textureType);\n                this.luminanceDownSamplePostProcesses.push(postProcess);\n            }\n            // Create callbacks and add effects\n            var lastLuminance = this.luminancePostProcess;\n            this.luminanceDownSamplePostProcesses.forEach(function (pp, index) {\n                var downSampleOffsets = new Array(18);\n                pp.onApply = function (effect) {\n                    var id = 0;\n                    for (var x = -1; x < 2; x++) {\n                        for (var y = -1; y < 2; y++) {\n                            downSampleOffsets[id] = x / lastLuminance.width;\n                            downSampleOffsets[id + 1] = y / lastLuminance.height;\n                            id += 2;\n                        }\n                    }\n                    effect.setArray2(\"dsOffsets\", downSampleOffsets);\n                    effect.setFloat(\"halfDestPixelSize\", 0.5 / lastLuminance.width);\n                    if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n                        lastLuminance = _this.luminancePostProcess;\n                    }\n                    else {\n                        lastLuminance = pp;\n                    }\n                };\n                if (index === _this.luminanceDownSamplePostProcesses.length - 1) {\n                    pp.onAfterRender = function (effect) {\n                        var pixel = scene.getEngine().readPixels(0, 0, 1, 1);\n                        var bit_shift = new BABYLON.Vector4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n                        _this._hdrCurrentLuminance = (pixel[0] * bit_shift.x + pixel[1] * bit_shift.y + pixel[2] * bit_shift.z + pixel[3] * bit_shift.w) / 100.0;\n                    };\n                }\n                _this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRLuminanceDownSample\" + index, function () { return pp; }, true));\n            });\n        };\n        // Create HDR post-process\n        StandardRenderingPipeline.prototype._createHdrPostProcess = function (scene, ratio) {\n            var _this = this;\n            this.hdrPostProcess = new BABYLON.PostProcess(\"HDR\", \"standard\", [\"averageLuminance\"], [\"textureAdderSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define HDR\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            var outputLiminance = 1;\n            var time = 0;\n            var lastTime = 0;\n            this.hdrPostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"textureAdderSampler\", _this._currentDepthOfFieldSource);\n                time += scene.getEngine().getDeltaTime();\n                if (outputLiminance < 0) {\n                    outputLiminance = _this._hdrCurrentLuminance;\n                }\n                else {\n                    var dt = (lastTime - time) / 1000.0;\n                    if (_this._hdrCurrentLuminance < outputLiminance + _this.hdrDecreaseRate * dt) {\n                        outputLiminance += _this.hdrDecreaseRate * dt;\n                    }\n                    else if (_this._hdrCurrentLuminance > outputLiminance - _this.hdrIncreaseRate * dt) {\n                        outputLiminance -= _this.hdrIncreaseRate * dt;\n                    }\n                    else {\n                        outputLiminance = _this._hdrCurrentLuminance;\n                    }\n                }\n                outputLiminance = BABYLON.MathTools.Clamp(outputLiminance, _this.hdrMinimumLuminance, 1e20);\n                effect.setFloat(\"averageLuminance\", outputLiminance);\n                lastTime = time;\n                _this._currentDepthOfFieldSource = _this.hdrFinalPostProcess;\n            };\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDR\", function () { return _this.hdrPostProcess; }, true));\n        };\n        // Create lens flare post-process\n        StandardRenderingPipeline.prototype._createLensFlarePostProcess = function (scene, ratio) {\n            var _this = this;\n            this.lensFlarePostProcess = new BABYLON.PostProcess(\"HDRLensFlare\", \"standard\", [\"strength\", \"ghostDispersal\", \"haloWidth\", \"resolution\", \"distortionStrength\"], [\"lensColorSampler\"], ratio / 2, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlare\", function () { return _this.lensFlarePostProcess; }, true));\n            this._createBlurPostProcesses(scene, ratio / 4, 2);\n            this.lensFlareComposePostProcess = new BABYLON.PostProcess(\"HDRLensFlareCompose\", \"standard\", [\"lensStarMatrix\"], [\"otherSampler\", \"lensDirtSampler\", \"lensStarSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define LENS_FLARE_COMPOSE\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRLensFlareCompose\", function () { return _this.lensFlareComposePostProcess; }, true));\n            var resolution = new BABYLON.Vector2(0, 0);\n            // Lens flare\n            this.lensFlarePostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"textureSampler\", _this._bloomEnabled ? _this.blurHPostProcesses[0] : _this.originalPostProcess);\n                effect.setTexture(\"lensColorSampler\", _this.lensColorTexture);\n                effect.setFloat(\"strength\", _this.lensFlareStrength);\n                effect.setFloat(\"ghostDispersal\", _this.lensFlareGhostDispersal);\n                effect.setFloat(\"haloWidth\", _this.lensFlareHaloWidth);\n                // Shift\n                resolution.x = _this.lensFlarePostProcess.width;\n                resolution.y = _this.lensFlarePostProcess.height;\n                effect.setVector2(\"resolution\", resolution);\n                effect.setFloat(\"distortionStrength\", _this.lensFlareDistortionStrength);\n            };\n            // Compose\n            var scaleBias1 = BABYLON.Matrix.FromValues(2.0, 0.0, -1.0, 0.0, 0.0, 2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n            var scaleBias2 = BABYLON.Matrix.FromValues(0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n            this.lensFlareComposePostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"otherSampler\", _this._currentDepthOfFieldSource);\n                effect.setTexture(\"lensDirtSampler\", _this.lensFlareDirtTexture);\n                effect.setTexture(\"lensStarSampler\", _this.lensStarTexture);\n                // Lens start rotation matrix\n                var camerax = _this._scene.activeCamera.getViewMatrix().getRow(0);\n                var cameraz = _this._scene.activeCamera.getViewMatrix().getRow(2);\n                var camRot = BABYLON.Vector3.Dot(camerax.toVector3(), new BABYLON.Vector3(1.0, 0.0, 0.0)) + BABYLON.Vector3.Dot(cameraz.toVector3(), new BABYLON.Vector3(0.0, 0.0, 1.0));\n                camRot *= 4.0;\n                var starRotation = BABYLON.Matrix.FromValues(Math.cos(camRot) * 0.5, -Math.sin(camRot), 0.0, 0.0, Math.sin(camRot), Math.cos(camRot) * 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n                var lensStarMatrix = scaleBias2.multiply(starRotation).multiply(scaleBias1);\n                effect.setMatrix(\"lensStarMatrix\", lensStarMatrix);\n                _this._currentDepthOfFieldSource = _this.lensFlareFinalPostProcess;\n            };\n        };\n        // Create depth-of-field post-process\n        StandardRenderingPipeline.prototype._createDepthOfFieldPostProcess = function (scene, ratio) {\n            var _this = this;\n            this.depthOfFieldPostProcess = new BABYLON.PostProcess(\"HDRDepthOfField\", \"standard\", [\"distance\"], [\"otherSampler\", \"depthSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define DEPTH_OF_FIELD\", BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this.depthOfFieldPostProcess.onApply = function (effect) {\n                effect.setTextureFromPostProcess(\"otherSampler\", _this._currentDepthOfFieldSource);\n                effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n                effect.setFloat(\"distance\", _this.depthOfFieldDistance);\n            };\n            // Add to pipeline\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRDepthOfField\", function () { return _this.depthOfFieldPostProcess; }, true));\n        };\n        // Create motion blur post-process\n        StandardRenderingPipeline.prototype._createMotionBlurPostProcess = function (scene, ratio) {\n            var _this = this;\n            this.motionBlurPostProcess = new BABYLON.PostProcess(\"HDRMotionBlur\", \"standard\", [\"inverseViewProjection\", \"prevViewProjection\", \"screenSize\", \"motionScale\", \"motionStrength\"], [\"depthSampler\"], ratio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, scene.getEngine(), false, \"#define MOTION_BLUR\\n#define MAX_MOTION_SAMPLES \" + this.motionBlurSamples.toFixed(1), BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            var motionScale = 0;\n            var prevViewProjection = BABYLON.Matrix.Identity();\n            var invViewProjection = BABYLON.Matrix.Identity();\n            var viewProjection = BABYLON.Matrix.Identity();\n            var screenSize = BABYLON.Vector2.Zero();\n            this.motionBlurPostProcess.onApply = function (effect) {\n                viewProjection = scene.getProjectionMatrix().multiply(scene.getViewMatrix());\n                viewProjection.invertToRef(invViewProjection);\n                effect.setMatrix(\"inverseViewProjection\", invViewProjection);\n                effect.setMatrix(\"prevViewProjection\", prevViewProjection);\n                prevViewProjection = viewProjection;\n                screenSize.x = _this.motionBlurPostProcess.width;\n                screenSize.y = _this.motionBlurPostProcess.height;\n                effect.setVector2(\"screenSize\", screenSize);\n                motionScale = scene.getEngine().getFps() / 60.0;\n                effect.setFloat(\"motionScale\", motionScale);\n                effect.setFloat(\"motionStrength\", _this.motionStrength);\n                effect.setTexture(\"depthSampler\", _this._getDepthTexture());\n            };\n            this.addEffect(new BABYLON.PostProcessRenderEffect(scene.getEngine(), \"HDRMotionBlur\", function () { return _this.motionBlurPostProcess; }, true));\n        };\n        StandardRenderingPipeline.prototype._getDepthTexture = function () {\n            var geometry = this._scene.enableGeometryBufferRenderer();\n            if (geometry) {\n                return geometry.getGBuffer().textures[0];\n            }\n            return this._scene.enableDepthRenderer().getDepthMap();\n        };\n        StandardRenderingPipeline.prototype._disposePostProcesses = function () {\n            for (var i = 0; i < this._cameras.length; i++) {\n                var camera = this._cameras[i];\n                if (this.originalPostProcess) {\n                    this.originalPostProcess.dispose(camera);\n                }\n                if (this.downSampleX4PostProcess) {\n                    this.downSampleX4PostProcess.dispose(camera);\n                }\n                if (this.brightPassPostProcess) {\n                    this.brightPassPostProcess.dispose(camera);\n                }\n                if (this.textureAdderPostProcess) {\n                    this.textureAdderPostProcess.dispose(camera);\n                }\n                if (this.textureAdderFinalPostProcess) {\n                    this.textureAdderFinalPostProcess.dispose(camera);\n                }\n                if (this.volumetricLightPostProcess) {\n                    this.volumetricLightPostProcess.dispose(camera);\n                }\n                if (this.volumetricLightSmoothXPostProcess) {\n                    this.volumetricLightSmoothXPostProcess.dispose(camera);\n                }\n                if (this.volumetricLightSmoothYPostProcess) {\n                    this.volumetricLightSmoothYPostProcess.dispose(camera);\n                }\n                if (this.volumetricLightMergePostProces) {\n                    this.volumetricLightMergePostProces.dispose(camera);\n                }\n                if (this.volumetricLightFinalPostProcess) {\n                    this.volumetricLightFinalPostProcess.dispose(camera);\n                }\n                if (this.lensFlarePostProcess) {\n                    this.lensFlarePostProcess.dispose(camera);\n                }\n                if (this.lensFlareComposePostProcess) {\n                    this.lensFlareComposePostProcess.dispose(camera);\n                }\n                for (var j = 0; j < this.luminanceDownSamplePostProcesses.length; j++) {\n                    this.luminanceDownSamplePostProcesses[j].dispose(camera);\n                }\n                if (this.luminancePostProcess) {\n                    this.luminancePostProcess.dispose(camera);\n                }\n                if (this.hdrPostProcess) {\n                    this.hdrPostProcess.dispose(camera);\n                }\n                if (this.hdrFinalPostProcess) {\n                    this.hdrFinalPostProcess.dispose(camera);\n                }\n                if (this.depthOfFieldPostProcess) {\n                    this.depthOfFieldPostProcess.dispose(camera);\n                }\n                if (this.motionBlurPostProcess) {\n                    this.motionBlurPostProcess.dispose(camera);\n                }\n                for (var j = 0; j < this.blurHPostProcesses.length; j++) {\n                    this.blurHPostProcesses[j].dispose(camera);\n                }\n                for (var j = 0; j < this.blurVPostProcesses.length; j++) {\n                    this.blurVPostProcesses[j].dispose(camera);\n                }\n            }\n            this.originalPostProcess = null;\n            this.downSampleX4PostProcess = null;\n            this.brightPassPostProcess = null;\n            this.textureAdderPostProcess = null;\n            this.textureAdderFinalPostProcess = null;\n            this.volumetricLightPostProcess = null;\n            this.volumetricLightSmoothXPostProcess = null;\n            this.volumetricLightSmoothYPostProcess = null;\n            this.volumetricLightMergePostProces = null;\n            this.volumetricLightFinalPostProcess = null;\n            this.lensFlarePostProcess = null;\n            this.lensFlareComposePostProcess = null;\n            this.luminancePostProcess = null;\n            this.hdrPostProcess = null;\n            this.hdrFinalPostProcess = null;\n            this.depthOfFieldPostProcess = null;\n            this.motionBlurPostProcess = null;\n            this.luminanceDownSamplePostProcesses = [];\n            this.blurHPostProcesses = [];\n            this.blurVPostProcesses = [];\n        };\n        // Dispose\n        StandardRenderingPipeline.prototype.dispose = function () {\n            this._disposePostProcesses();\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n            _super.prototype.dispose.call(this);\n        };\n        // Serialize rendering pipeline\n        StandardRenderingPipeline.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"StandardRenderingPipeline\";\n            return serializationObject;\n        };\n        /**\n         * Static members\n         */\n        // Parse serialized pipeline\n        StandardRenderingPipeline.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new StandardRenderingPipeline(source._name, scene, source._ratio); }, source, scene, rootUrl);\n        };\n        return StandardRenderingPipeline;\n    }(BABYLON.PostProcessRenderPipeline));\n    // Luminance steps\n    StandardRenderingPipeline.LuminanceSteps = 6;\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"brightThreshold\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"blurWidth\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"horizontalBlur\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"exposure\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"lensTexture\")\n    ], StandardRenderingPipeline.prototype, \"lensTexture\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"volumetricLightCoefficient\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"volumetricLightPower\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"volumetricLightBlurScale\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"hdrMinimumLuminance\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"hdrDecreaseRate\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"hdrIncreaseRate\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"lensColorTexture\")\n    ], StandardRenderingPipeline.prototype, \"lensColorTexture\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"lensFlareStrength\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"lensFlareGhostDispersal\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"lensFlareHaloWidth\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"lensFlareDistortionStrength\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"lensStarTexture\")\n    ], StandardRenderingPipeline.prototype, \"lensStarTexture\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture(\"lensFlareDirtTexture\")\n    ], StandardRenderingPipeline.prototype, \"lensFlareDirtTexture\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"depthOfFieldDistance\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"depthOfFieldBlurWidth\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"motionStrength\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"BloomEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"DepthOfFieldEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"LensFlareEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"HDREnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"VLSEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"MotionBlurEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"volumetricLightStepsCount\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], StandardRenderingPipeline.prototype, \"motionBlurSamples\", null);\n    BABYLON.StandardRenderingPipeline = StandardRenderingPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.standardRenderingPipeline.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FxaaPostProcess = (function (_super) {\n        __extends(FxaaPostProcess, _super);\n        function FxaaPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            var _this = _super.call(this, name, \"fxaa\", [\"texelSize\"], null, options, camera, samplingMode || BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, reusable, null, textureType, \"fxaa\") || this;\n            _this.onApplyObservable.add(function (effect) {\n                var texelSize = _this.texelSize;\n                effect.setFloat2(\"texelSize\", texelSize.x, texelSize.y);\n            });\n            return _this;\n        }\n        return FxaaPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.FxaaPostProcess = FxaaPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.fxaaPostProcess.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var DefaultRenderingPipeline = (function (_super) {\n        __extends(DefaultRenderingPipeline, _super);\n        /**\n         * @constructor\n         * @param {string} name - The rendering pipeline name\n         * @param {BABYLON.Scene} scene - The scene linked to this pipeline\n         * @param {any} ratio - The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n         * @param {BABYLON.Camera[]} cameras - The array of cameras that the rendering pipeline will be attached to\n         */\n        function DefaultRenderingPipeline(name, hdr, scene, cameras) {\n            var _this = _super.call(this, scene.getEngine(), name) || this;\n            _this.PassPostProcessId = \"PassPostProcessEffect\";\n            _this.HighLightsPostProcessId = \"HighLightsPostProcessEffect\";\n            _this.BlurXPostProcessId = \"BlurXPostProcessEffect\";\n            _this.BlurYPostProcessId = \"BlurYPostProcessEffect\";\n            _this.CopyBackPostProcessId = \"CopyBackPostProcessEffect\";\n            _this.ImageProcessingPostProcessId = \"ImageProcessingPostProcessEffect\";\n            _this.FxaaPostProcessId = \"FxaaPostProcessEffect\";\n            _this.FinalMergePostProcessId = \"FinalMergePostProcessEffect\";\n            // IAnimatable\n            _this.animations = [];\n            // Values       \n            _this._bloomEnabled = false;\n            _this._fxaaEnabled = false;\n            _this._imageProcessingEnabled = true;\n            _this._bloomScale = 0.6;\n            /**\n             * Specifies the size of the bloom blur kernel, relative to the final output size\n             */\n            _this.bloomKernel = 64;\n            /**\n             * Specifies the weight of the bloom in the final rendering\n             */\n            _this._bloomWeight = 0.15;\n            _this._cameras = cameras || [];\n            // Initialize\n            _this._scene = scene;\n            var caps = _this._scene.getEngine().getCaps();\n            _this._hdr = hdr && (caps.textureHalfFloatRender || caps.textureFloatRender);\n            // Misc\n            if (_this._hdr) {\n                if (caps.textureHalfFloatRender) {\n                    _this._defaultPipelineTextureType = BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                }\n                else if (caps.textureFloatRender) {\n                    _this._defaultPipelineTextureType = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                }\n            }\n            else {\n                _this._defaultPipelineTextureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n            }\n            // Attach\n            scene.postProcessRenderPipelineManager.addPipeline(_this);\n            _this._buildPipeline();\n            return _this;\n        }\n        Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomWeight\", {\n            get: function () {\n                return this._bloomWeight;\n            },\n            set: function (value) {\n                if (this._bloomWeight === value) {\n                    return;\n                }\n                this._bloomWeight = value;\n                if (this._hdr && this.copyBack) {\n                    this.copyBack.alphaConstants = new BABYLON.Color4(value, value, value, value);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomScale\", {\n            get: function () {\n                return this._bloomScale;\n            },\n            set: function (value) {\n                if (this._bloomScale === value) {\n                    return;\n                }\n                this._bloomScale = value;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultRenderingPipeline.prototype, \"bloomEnabled\", {\n            get: function () {\n                return this._bloomEnabled;\n            },\n            set: function (enabled) {\n                if (this._bloomEnabled === enabled) {\n                    return;\n                }\n                this._bloomEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultRenderingPipeline.prototype, \"fxaaEnabled\", {\n            get: function () {\n                return this._fxaaEnabled;\n            },\n            set: function (enabled) {\n                if (this._fxaaEnabled === enabled) {\n                    return;\n                }\n                this._fxaaEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", {\n            get: function () {\n                return this._imageProcessingEnabled;\n            },\n            set: function (enabled) {\n                if (this._imageProcessingEnabled === enabled) {\n                    return;\n                }\n                this._imageProcessingEnabled = enabled;\n                this._buildPipeline();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DefaultRenderingPipeline.prototype._buildPipeline = function () {\n            var _this = this;\n            var engine = this._scene.getEngine();\n            this._disposePostProcesses();\n            this._reset();\n            if (this.bloomEnabled) {\n                this.pass = new BABYLON.PassPostProcess(\"sceneRenderTarget\", 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.PassPostProcessId, function () { return _this.pass; }, true));\n                if (!this._hdr) {\n                    this.highlights = new BABYLON.HighlightsPostProcess(\"highlights\", this.bloomScale, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                    this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.HighLightsPostProcessId, function () { return _this.highlights; }, true));\n                    this.highlights.autoClear = false;\n                    this.highlights.alwaysForcePOT = true;\n                }\n                this.blurX = new BABYLON.BlurPostProcess(\"horizontal blur\", new BABYLON.Vector2(1.0, 0), 10.0, this.bloomScale, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.BlurXPostProcessId, function () { return _this.blurX; }, true));\n                this.blurX.alwaysForcePOT = true;\n                this.blurX.autoClear = false;\n                this.blurX.onActivateObservable.add(function () {\n                    var dw = _this.blurX.width / engine.getRenderingCanvas().width;\n                    _this.blurX.kernel = _this.bloomKernel * dw;\n                });\n                this.blurY = new BABYLON.BlurPostProcess(\"vertical blur\", new BABYLON.Vector2(0, 1.0), 10.0, this.bloomScale, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.BlurYPostProcessId, function () { return _this.blurY; }, true));\n                this.blurY.alwaysForcePOT = true;\n                this.blurY.autoClear = false;\n                this.blurY.onActivateObservable.add(function () {\n                    var dh = _this.blurY.height / engine.getRenderingCanvas().height;\n                    _this.blurY.kernel = _this.bloomKernel * dh;\n                });\n                this.copyBack = new BABYLON.PassPostProcess(\"bloomBlendBlit\", this.bloomScale, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.CopyBackPostProcessId, function () { return _this.copyBack; }, true));\n                this.copyBack.alwaysForcePOT = true;\n                if (this._hdr) {\n                    this.copyBack.alphaMode = BABYLON.Engine.ALPHA_INTERPOLATE;\n                    var w = this.bloomWeight;\n                    this.copyBack.alphaConstants = new BABYLON.Color4(w, w, w, w);\n                }\n                else {\n                    this.copyBack.alphaMode = BABYLON.Engine.ALPHA_SCREENMODE;\n                }\n                this.copyBack.autoClear = false;\n            }\n            if (this._imageProcessingEnabled) {\n                this.imageProcessing = new BABYLON.ImageProcessingPostProcess(\"imageProcessing\", 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                if (this._hdr) {\n                    this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.ImageProcessingPostProcessId, function () { return _this.imageProcessing; }, true));\n                }\n            }\n            if (this.fxaaEnabled) {\n                this.fxaa = new BABYLON.FxaaPostProcess(\"fxaa\", 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.FxaaPostProcessId, function () { return _this.fxaa; }, true));\n                this.fxaa.autoClear = !this.bloomEnabled && (!this._hdr || !this.imageProcessing);\n            }\n            else {\n                this.finalMerge = new BABYLON.PassPostProcess(\"finalMerge\", 1.0, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, engine, false, this._defaultPipelineTextureType);\n                this.addEffect(new BABYLON.PostProcessRenderEffect(engine, this.FinalMergePostProcessId, function () { return _this.finalMerge; }, true));\n                this.finalMerge.autoClear = !this.bloomEnabled && (!this._hdr || !this.imageProcessing);\n            }\n            if (this.bloomEnabled) {\n                if (this._hdr) {\n                    this.copyBack.shareOutputWith(this.blurX);\n                    if (this.imageProcessing) {\n                        this.imageProcessing.shareOutputWith(this.pass);\n                        this.imageProcessing.autoClear = false;\n                    }\n                    else if (this.fxaa) {\n                        this.fxaa.shareOutputWith(this.pass);\n                    }\n                    else {\n                        this.finalMerge.shareOutputWith(this.pass);\n                    }\n                }\n                else {\n                    if (this.fxaa) {\n                        this.fxaa.shareOutputWith(this.pass);\n                    }\n                    else {\n                        this.finalMerge.shareOutputWith(this.pass);\n                    }\n                }\n            }\n            if (this._cameras !== null) {\n                this._scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this._name, this._cameras);\n            }\n        };\n        DefaultRenderingPipeline.prototype._disposePostProcesses = function () {\n            for (var i = 0; i < this._cameras.length; i++) {\n                var camera = this._cameras[i];\n                if (this.pass) {\n                    this.pass.dispose(camera);\n                }\n                if (this.highlights) {\n                    this.highlights.dispose(camera);\n                }\n                if (this.blurX) {\n                    this.blurX.dispose(camera);\n                }\n                if (this.blurY) {\n                    this.blurY.dispose(camera);\n                }\n                if (this.copyBack) {\n                    this.copyBack.dispose(camera);\n                }\n                if (this.imageProcessing) {\n                    this.imageProcessing.dispose(camera);\n                }\n                if (this.fxaa) {\n                    this.fxaa.dispose(camera);\n                }\n                if (this.finalMerge) {\n                    this.finalMerge.dispose(camera);\n                }\n            }\n            this.pass = null;\n            this.highlights = null;\n            this.blurX = null;\n            this.blurY = null;\n            this.copyBack = null;\n            this.imageProcessing = null;\n            this.fxaa = null;\n            this.finalMerge = null;\n        };\n        // Dispose\n        DefaultRenderingPipeline.prototype.dispose = function () {\n            this._disposePostProcesses();\n            this._scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this._name, this._cameras);\n            _super.prototype.dispose.call(this);\n        };\n        // Serialize rendering pipeline\n        DefaultRenderingPipeline.prototype.serialize = function () {\n            var serializationObject = BABYLON.SerializationHelper.Serialize(this);\n            serializationObject.customType = \"DefaultRenderingPipeline\";\n            return serializationObject;\n        };\n        // Parse serialized pipeline\n        DefaultRenderingPipeline.Parse = function (source, scene, rootUrl) {\n            return BABYLON.SerializationHelper.Parse(function () { return new DefaultRenderingPipeline(source._name, source._name._hdr, scene); }, source, scene, rootUrl);\n        };\n        return DefaultRenderingPipeline;\n    }(BABYLON.PostProcessRenderPipeline));\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"bloomKernel\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"_bloomWeight\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"_hdr\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"bloomWeight\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"bloomScale\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"bloomEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"fxaaEnabled\", null);\n    __decorate([\n        BABYLON.serialize()\n    ], DefaultRenderingPipeline.prototype, \"imageProcessingEnabled\", null);\n    BABYLON.DefaultRenderingPipeline = DefaultRenderingPipeline;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.defaultRenderingPipeline.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var GeometryBufferRenderer = (function () {\n        function GeometryBufferRenderer(scene, ratio) {\n            if (ratio === void 0) { ratio = 1; }\n            this._viewMatrix = BABYLON.Matrix.Zero();\n            this._projectionMatrix = BABYLON.Matrix.Zero();\n            this._transformMatrix = BABYLON.Matrix.Zero();\n            this._worldViewProjection = BABYLON.Matrix.Zero();\n            this._enablePosition = false;\n            this._scene = scene;\n            this._ratio = ratio;\n            // Render target\n            this._createRenderTargets();\n        }\n        Object.defineProperty(GeometryBufferRenderer.prototype, \"renderList\", {\n            set: function (meshes) {\n                this._multiRenderTarget.renderList = meshes;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeometryBufferRenderer.prototype, \"isSupported\", {\n            get: function () {\n                return this._multiRenderTarget.isSupported;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeometryBufferRenderer.prototype, \"enablePosition\", {\n            get: function () {\n                return this._enablePosition;\n            },\n            set: function (enable) {\n                this._enablePosition = enable;\n                this.dispose();\n                this._createRenderTargets();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        GeometryBufferRenderer.prototype.isReady = function (subMesh, useInstances) {\n            var material = subMesh.getMaterial();\n            if (material && material.disableDepthWrite) {\n                return false;\n            }\n            var defines = [];\n            var attribs = [BABYLON.VertexBuffer.PositionKind, BABYLON.VertexBuffer.NormalKind];\n            var mesh = subMesh.getMesh();\n            var scene = mesh.getScene();\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                defines.push(\"#define ALPHATEST\");\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n            // Buffers\n            if (this._enablePosition) {\n                defines.push(\"#define POSITION\");\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect      \n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._effect = this._scene.getEngine().createEffect(\"geometry\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"view\"], [\"diffuseSampler\"], join);\n            }\n            return this._effect.isReady();\n        };\n        GeometryBufferRenderer.prototype.getGBuffer = function () {\n            return this._multiRenderTarget;\n        };\n        // Methods\n        GeometryBufferRenderer.prototype.dispose = function () {\n            this.getGBuffer().dispose();\n        };\n        GeometryBufferRenderer.prototype._createRenderTargets = function () {\n            var _this = this;\n            var engine = this._scene.getEngine();\n            var count = this._enablePosition ? 3 : 2;\n            this._multiRenderTarget = new BABYLON.MultiRenderTarget(\"gBuffer\", { width: engine.getRenderWidth() * this._ratio, height: engine.getRenderHeight() * this._ratio }, count, this._scene, { generateMipMaps: false, generateDepthTexture: true });\n            if (!this.isSupported) {\n                return null;\n            }\n            this._multiRenderTarget.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._multiRenderTarget.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._multiRenderTarget.refreshRate = 1;\n            this._multiRenderTarget.renderParticles = false;\n            this._multiRenderTarget.renderList = null;\n            // set default depth value to 1.0 (far away)\n            this._multiRenderTarget.onClearObservable.add(function (engine) {\n                engine.clear(new BABYLON.Color4(0.0, 0.0, 0.0, 1.0), true, true, true);\n            });\n            // Custom render function\n            var renderSubMesh = function (subMesh) {\n                var mesh = subMesh.getRenderingMesh();\n                var scene = _this._scene;\n                var engine = scene.getEngine();\n                // Culling\n                engine.setState(subMesh.getMaterial().backFaceCulling);\n                // Managing instances\n                var batch = mesh._getInstancesRenderList(subMesh._id);\n                if (batch.mustReturn) {\n                    return;\n                }\n                var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);\n                if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n                    engine.enableEffect(_this._effect);\n                    mesh._bind(subMesh, _this._effect, BABYLON.Material.TriangleFillMode);\n                    var material = subMesh.getMaterial();\n                    _this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    _this._effect.setMatrix(\"view\", scene.getViewMatrix());\n                    // Alpha test\n                    if (material && material.needAlphaTesting()) {\n                        var alphaTexture = material.getAlphaTestTexture();\n                        _this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        _this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                    // Bones\n                    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                        _this._effect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n                    }\n                    // Draw\n                    mesh._processRendering(subMesh, _this._effect, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._effect.setMatrix(\"world\", world); });\n                }\n            };\n            this._multiRenderTarget.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes) {\n                var index;\n                for (index = 0; index < opaqueSubMeshes.length; index++) {\n                    renderSubMesh(opaqueSubMeshes.data[index]);\n                }\n                for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                    renderSubMesh(alphaTestSubMeshes.data[index]);\n                }\n            };\n        };\n        return GeometryBufferRenderer;\n    }());\n    BABYLON.GeometryBufferRenderer = GeometryBufferRenderer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.geometryBufferRenderer.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var RefractionPostProcess = (function (_super) {\n        __extends(RefractionPostProcess, _super);\n        function RefractionPostProcess(name, refractionTextureUrl, color, depth, colorLevel, options, camera, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"refraction\", [\"baseColor\", \"depth\", \"colorLevel\"], [\"refractionSampler\"], options, camera, samplingMode, engine, reusable) || this;\n            _this.color = color;\n            _this.depth = depth;\n            _this.colorLevel = colorLevel;\n            _this.onActivateObservable.add(function (cam) {\n                _this._refRexture = _this._refRexture || new BABYLON.Texture(refractionTextureUrl, cam.getScene());\n            });\n            _this.onApplyObservable.add(function (effect) {\n                effect.setColor3(\"baseColor\", _this.color);\n                effect.setFloat(\"depth\", _this.depth);\n                effect.setFloat(\"colorLevel\", _this.colorLevel);\n                effect.setTexture(\"refractionSampler\", _this._refRexture);\n            });\n            return _this;\n        }\n        // Methods\n        RefractionPostProcess.prototype.dispose = function (camera) {\n            if (this._refRexture) {\n                this._refRexture.dispose();\n            }\n            _super.prototype.dispose.call(this, camera);\n        };\n        return RefractionPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.RefractionPostProcess = RefractionPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.refractionPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var BlackAndWhitePostProcess = (function (_super) {\n        __extends(BlackAndWhitePostProcess, _super);\n        function BlackAndWhitePostProcess(name, options, camera, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"blackAndWhite\", [\"degree\"], null, options, camera, samplingMode, engine, reusable) || this;\n            _this.degree = 1;\n            _this.onApplyObservable.add(function (effect) {\n                effect.setFloat(\"degree\", _this.degree);\n            });\n            return _this;\n        }\n        return BlackAndWhitePostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.BlackAndWhitePostProcess = BlackAndWhitePostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.blackAndWhitePostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ConvolutionPostProcess = (function (_super) {\n        __extends(ConvolutionPostProcess, _super);\n        function ConvolutionPostProcess(name, kernel, options, camera, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"convolution\", [\"kernel\", \"screenSize\"], null, options, camera, samplingMode, engine, reusable) || this;\n            _this.kernel = kernel;\n            _this.onApply = function (effect) {\n                effect.setFloat2(\"screenSize\", _this.width, _this.height);\n                effect.setArray(\"kernel\", _this.kernel);\n            };\n            return _this;\n        }\n        return ConvolutionPostProcess;\n    }(BABYLON.PostProcess));\n    // Statics\n    // Based on http://en.wikipedia.org/wiki/Kernel_(image_processing)\n    ConvolutionPostProcess.EdgeDetect0Kernel = [1, 0, -1, 0, 0, 0, -1, 0, 1];\n    ConvolutionPostProcess.EdgeDetect1Kernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];\n    ConvolutionPostProcess.EdgeDetect2Kernel = [-1, -1, -1, -1, 8, -1, -1, -1, -1];\n    ConvolutionPostProcess.SharpenKernel = [0, -1, 0, -1, 5, -1, 0, -1, 0];\n    ConvolutionPostProcess.EmbossKernel = [-2, -1, 0, -1, 1, 1, 0, 1, 2];\n    ConvolutionPostProcess.GaussianKernel = [0, 1, 0, 1, 1, 1, 0, 1, 0];\n    BABYLON.ConvolutionPostProcess = ConvolutionPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.convolutionPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var FilterPostProcess = (function (_super) {\n        __extends(FilterPostProcess, _super);\n        function FilterPostProcess(name, kernelMatrix, options, camera, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"filter\", [\"kernelMatrix\"], null, options, camera, samplingMode, engine, reusable) || this;\n            _this.kernelMatrix = kernelMatrix;\n            _this.onApply = function (effect) {\n                effect.setMatrix(\"kernelMatrix\", _this.kernelMatrix);\n            };\n            return _this;\n        }\n        return FilterPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.FilterPostProcess = FilterPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.filterPostProcess.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    // Inspired by http://http.developer.nvidia.com/GPUGems3/gpugems3_ch13.html\n    var VolumetricLightScatteringPostProcess = (function (_super) {\n        __extends(VolumetricLightScatteringPostProcess, _super);\n        /**\n         * @constructor\n         * @param {string} name - The post-process name\n         * @param {any} ratio - The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)\n         * @param {BABYLON.Camera} camera - The camera that the post-process will be attached to\n         * @param {BABYLON.Mesh} mesh - The mesh used to create the light scattering\n         * @param {number} samples - The post-process quality, default 100\n         * @param {number} samplingMode - The post-process filtering mode\n         * @param {BABYLON.Engine} engine - The babylon engine\n         * @param {boolean} reusable - If the post-process is reusable\n         * @param {BABYLON.Scene} scene - The constructor needs a scene reference to initialize internal components. If \"camera\" is null (RenderPipeline, \"scene\" must be provided\n         */\n        function VolumetricLightScatteringPostProcess(name, ratio, camera, mesh, samples, samplingMode, engine, reusable, scene) {\n            if (samples === void 0) { samples = 100; }\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.BILINEAR_SAMPLINGMODE; }\n            var _this = _super.call(this, name, \"volumetricLightScattering\", [\"decay\", \"exposure\", \"weight\", \"meshPositionOnScreen\", \"density\"], [\"lightScatteringSampler\"], ratio.postProcessRatio || ratio, camera, samplingMode, engine, reusable, \"#define NUM_SAMPLES \" + samples) || this;\n            _this._screenCoordinates = BABYLON.Vector2.Zero();\n            /**\n            * Custom position of the mesh. Used if \"useCustomMeshPosition\" is set to \"true\"\n            * @type {Vector3}\n            */\n            _this.customMeshPosition = BABYLON.Vector3.Zero();\n            /**\n            * Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)\n            * @type {boolean}\n            */\n            _this.useCustomMeshPosition = false;\n            /**\n            * If the post-process should inverse the light scattering direction\n            * @type {boolean}\n            */\n            _this.invert = true;\n            /**\n            * Array containing the excluded meshes not rendered in the internal pass\n            */\n            _this.excludedMeshes = new Array();\n            /**\n            * Controls the overall intensity of the post-process\n            * @type {number}\n            */\n            _this.exposure = 0.3;\n            /**\n            * Dissipates each sample's contribution in range [0, 1]\n            * @type {number}\n            */\n            _this.decay = 0.96815;\n            /**\n            * Controls the overall intensity of each sample\n            * @type {number}\n            */\n            _this.weight = 0.58767;\n            /**\n            * Controls the density of each sample\n            * @type {number}\n            */\n            _this.density = 0.926;\n            scene = (camera === null) ? scene : camera.getScene(); // parameter \"scene\" can be null.\n            var engine = scene.getEngine();\n            _this._viewPort = new BABYLON.Viewport(0, 0, 1, 1).toGlobal(engine.getRenderWidth(), engine.getRenderHeight());\n            // Configure mesh\n            _this.mesh = (mesh !== null) ? mesh : VolumetricLightScatteringPostProcess.CreateDefaultMesh(\"VolumetricLightScatteringMesh\", scene);\n            // Configure\n            _this._createPass(scene, ratio.passRatio || ratio);\n            _this.onActivate = function (camera) {\n                if (!_this.isSupported) {\n                    _this.dispose(camera);\n                }\n                _this.onActivate = null;\n            };\n            _this.onApplyObservable.add(function (effect) {\n                _this._updateMeshScreenCoordinates(scene);\n                effect.setTexture(\"lightScatteringSampler\", _this._volumetricLightScatteringRTT);\n                effect.setFloat(\"exposure\", _this.exposure);\n                effect.setFloat(\"decay\", _this.decay);\n                effect.setFloat(\"weight\", _this.weight);\n                effect.setFloat(\"density\", _this.density);\n                effect.setVector2(\"meshPositionOnScreen\", _this._screenCoordinates);\n            });\n            return _this;\n        }\n        Object.defineProperty(VolumetricLightScatteringPostProcess.prototype, \"useDiffuseColor\", {\n            get: function () {\n                BABYLON.Tools.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n                return false;\n            },\n            set: function (useDiffuseColor) {\n                BABYLON.Tools.Warn(\"VolumetricLightScatteringPostProcess.useDiffuseColor is no longer used, use the mesh material directly instead\");\n            },\n            enumerable: true,\n            configurable: true\n        });\n        VolumetricLightScatteringPostProcess.prototype.isReady = function (subMesh, useInstances) {\n            var mesh = subMesh.getMesh();\n            // Render this.mesh as default\n            if (mesh === this.mesh) {\n                return mesh.material.isReady(mesh);\n            }\n            var defines = [];\n            var attribs = [BABYLON.VertexBuffer.PositionKind];\n            var material = subMesh.getMaterial();\n            var needUV = false;\n            // Alpha test\n            if (material) {\n                if (material.needAlphaTesting()) {\n                    defines.push(\"#define ALPHATEST\");\n                }\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect      \n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._volumetricLightScatteringPass = mesh.getScene().getEngine().createEffect({ vertexElement: \"depth\", fragmentElement: \"volumetricLightScatteringPass\" }, attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\"], [\"diffuseSampler\"], join);\n            }\n            return this._volumetricLightScatteringPass.isReady();\n        };\n        /**\n         * Sets the new light position for light scattering effect\n         * @param {BABYLON.Vector3} The new custom light position\n         */\n        VolumetricLightScatteringPostProcess.prototype.setCustomMeshPosition = function (position) {\n            this.customMeshPosition = position;\n        };\n        /**\n         * Returns the light position for light scattering effect\n         * @return {BABYLON.Vector3} The custom light position\n         */\n        VolumetricLightScatteringPostProcess.prototype.getCustomMeshPosition = function () {\n            return this.customMeshPosition;\n        };\n        /**\n         * Disposes the internal assets and detaches the post-process from the camera\n         */\n        VolumetricLightScatteringPostProcess.prototype.dispose = function (camera) {\n            var rttIndex = camera.getScene().customRenderTargets.indexOf(this._volumetricLightScatteringRTT);\n            if (rttIndex !== -1) {\n                camera.getScene().customRenderTargets.splice(rttIndex, 1);\n            }\n            this._volumetricLightScatteringRTT.dispose();\n            _super.prototype.dispose.call(this, camera);\n        };\n        /**\n         * Returns the render target texture used by the post-process\n         * @return {BABYLON.RenderTargetTexture} The render target texture used by the post-process\n         */\n        VolumetricLightScatteringPostProcess.prototype.getPass = function () {\n            return this._volumetricLightScatteringRTT;\n        };\n        // Private methods\n        VolumetricLightScatteringPostProcess.prototype._meshExcluded = function (mesh) {\n            if (this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\n                return true;\n            }\n            return false;\n        };\n        VolumetricLightScatteringPostProcess.prototype._createPass = function (scene, ratio) {\n            var _this = this;\n            var engine = scene.getEngine();\n            this._volumetricLightScatteringRTT = new BABYLON.RenderTargetTexture(\"volumetricLightScatteringMap\", { width: engine.getRenderWidth() * ratio, height: engine.getRenderHeight() * ratio }, scene, false, true, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this._volumetricLightScatteringRTT.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._volumetricLightScatteringRTT.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._volumetricLightScatteringRTT.renderList = null;\n            this._volumetricLightScatteringRTT.renderParticles = false;\n            scene.customRenderTargets.push(this._volumetricLightScatteringRTT);\n            // Custom render function for submeshes\n            var renderSubMesh = function (subMesh) {\n                var mesh = subMesh.getRenderingMesh();\n                if (_this._meshExcluded(mesh)) {\n                    return;\n                }\n                var scene = mesh.getScene();\n                var engine = scene.getEngine();\n                // Culling\n                engine.setState(subMesh.getMaterial().backFaceCulling);\n                // Managing instances\n                var batch = mesh._getInstancesRenderList(subMesh._id);\n                if (batch.mustReturn) {\n                    return;\n                }\n                var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null);\n                if (_this.isReady(subMesh, hardwareInstancedRendering)) {\n                    var effect = _this._volumetricLightScatteringPass;\n                    if (mesh === _this.mesh) {\n                        if (subMesh.effect) {\n                            effect = subMesh.effect;\n                        }\n                        else {\n                            effect = subMesh.getMaterial().getEffect();\n                        }\n                    }\n                    engine.enableEffect(effect);\n                    mesh._bind(subMesh, effect, BABYLON.Material.TriangleFillMode);\n                    if (mesh === _this.mesh) {\n                        subMesh.getMaterial().bind(mesh.getWorldMatrix(), mesh);\n                    }\n                    else {\n                        var material = subMesh.getMaterial();\n                        _this._volumetricLightScatteringPass.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                        // Alpha test\n                        if (material && material.needAlphaTesting()) {\n                            var alphaTexture = material.getAlphaTestTexture();\n                            _this._volumetricLightScatteringPass.setTexture(\"diffuseSampler\", alphaTexture);\n                            if (alphaTexture) {\n                                _this._volumetricLightScatteringPass.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                            }\n                        }\n                        // Bones\n                        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                            _this._volumetricLightScatteringPass.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n                        }\n                    }\n                    // Draw\n                    mesh._processRendering(subMesh, _this._volumetricLightScatteringPass, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return effect.setMatrix(\"world\", world); });\n                }\n            };\n            // Render target texture callbacks\n            var savedSceneClearColor;\n            var sceneClearColor = new BABYLON.Color4(0.0, 0.0, 0.0, 1.0);\n            this._volumetricLightScatteringRTT.onBeforeRenderObservable.add(function () {\n                savedSceneClearColor = scene.clearColor;\n                scene.clearColor = sceneClearColor;\n            });\n            this._volumetricLightScatteringRTT.onAfterRenderObservable.add(function () {\n                scene.clearColor = savedSceneClearColor;\n            });\n            this._volumetricLightScatteringRTT.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes) {\n                var engine = scene.getEngine();\n                var index;\n                for (index = 0; index < opaqueSubMeshes.length; index++) {\n                    renderSubMesh(opaqueSubMeshes.data[index]);\n                }\n                engine.setAlphaTesting(true);\n                for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                    renderSubMesh(alphaTestSubMeshes.data[index]);\n                }\n                engine.setAlphaTesting(false);\n                if (transparentSubMeshes.length) {\n                    // Sort sub meshes\n                    for (index = 0; index < transparentSubMeshes.length; index++) {\n                        var submesh = transparentSubMeshes.data[index];\n                        submesh._alphaIndex = submesh.getMesh().alphaIndex;\n                        submesh._distanceToCamera = submesh.getBoundingInfo().boundingSphere.centerWorld.subtract(scene.activeCamera.position).length();\n                    }\n                    var sortedArray = transparentSubMeshes.data.slice(0, transparentSubMeshes.length);\n                    sortedArray.sort(function (a, b) {\n                        // Alpha index first\n                        if (a._alphaIndex > b._alphaIndex) {\n                            return 1;\n                        }\n                        if (a._alphaIndex < b._alphaIndex) {\n                            return -1;\n                        }\n                        // Then distance to camera\n                        if (a._distanceToCamera < b._distanceToCamera) {\n                            return 1;\n                        }\n                        if (a._distanceToCamera > b._distanceToCamera) {\n                            return -1;\n                        }\n                        return 0;\n                    });\n                    // Render sub meshes\n                    engine.setAlphaMode(BABYLON.Engine.ALPHA_COMBINE);\n                    for (index = 0; index < sortedArray.length; index++) {\n                        renderSubMesh(sortedArray[index]);\n                    }\n                    engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n                }\n            };\n        };\n        VolumetricLightScatteringPostProcess.prototype._updateMeshScreenCoordinates = function (scene) {\n            var transform = scene.getTransformMatrix();\n            var meshPosition;\n            if (this.useCustomMeshPosition) {\n                meshPosition = this.customMeshPosition;\n            }\n            else if (this.attachedNode) {\n                meshPosition = this.attachedNode.position;\n            }\n            else {\n                meshPosition = this.mesh.parent ? this.mesh.getAbsolutePosition() : this.mesh.position;\n            }\n            var pos = BABYLON.Vector3.Project(meshPosition, BABYLON.Matrix.Identity(), transform, this._viewPort);\n            this._screenCoordinates.x = pos.x / this._viewPort.width;\n            this._screenCoordinates.y = pos.y / this._viewPort.height;\n            if (this.invert)\n                this._screenCoordinates.y = 1.0 - this._screenCoordinates.y;\n        };\n        // Static methods\n        /**\n        * Creates a default mesh for the Volumeric Light Scattering post-process\n        * @param {string} The mesh name\n        * @param {BABYLON.Scene} The scene where to create the mesh\n        * @return {BABYLON.Mesh} the default mesh\n        */\n        VolumetricLightScatteringPostProcess.CreateDefaultMesh = function (name, scene) {\n            var mesh = BABYLON.Mesh.CreatePlane(name, 1, scene);\n            mesh.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_ALL;\n            var material = new BABYLON.StandardMaterial(name + \"Material\", scene);\n            material.emissiveColor = new BABYLON.Color3(1, 1, 1);\n            mesh.material = material;\n            return mesh;\n        };\n        return VolumetricLightScatteringPostProcess;\n    }(BABYLON.PostProcess));\n    __decorate([\n        BABYLON.serializeAsVector3()\n    ], VolumetricLightScatteringPostProcess.prototype, \"customMeshPosition\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"useCustomMeshPosition\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"invert\", void 0);\n    __decorate([\n        BABYLON.serializeAsMeshReference()\n    ], VolumetricLightScatteringPostProcess.prototype, \"mesh\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"excludedMeshes\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"exposure\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"decay\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"weight\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], VolumetricLightScatteringPostProcess.prototype, \"density\", void 0);\n    BABYLON.VolumetricLightScatteringPostProcess = VolumetricLightScatteringPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.volumetricLightScatteringPostProcess.js.map\n\n//\n//  This post-process allows the modification of rendered colors by using\n//  a 'look-up table' (LUT). This effect is also called Color Grading.\n// \n//  The object needs to be provided an url to a texture containing the color\n//  look-up table: the texture must be 256 pixels wide and 16 pixels high.\n//  Use an image editing software to tweak the LUT to match your needs.\n// \n//  For an example of a color LUT, see here:\n//      http://udn.epicgames.com/Three/rsrc/Three/ColorGrading/RGBTable16x1.png\n//  For explanations on color grading, see here:\n//      http://udn.epicgames.com/Three/ColorGrading.html\n//\n\nvar BABYLON;\n(function (BABYLON) {\n    var ColorCorrectionPostProcess = (function (_super) {\n        __extends(ColorCorrectionPostProcess, _super);\n        function ColorCorrectionPostProcess(name, colorTableUrl, options, camera, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, 'colorCorrection', null, ['colorTable'], options, camera, samplingMode, engine, reusable) || this;\n            _this._colorTableTexture = new BABYLON.Texture(colorTableUrl, camera.getScene(), true, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE);\n            _this._colorTableTexture.anisotropicFilteringLevel = 1;\n            _this._colorTableTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this._colorTableTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.onApply = function (effect) {\n                effect.setTexture(\"colorTable\", _this._colorTableTexture);\n            };\n            return _this;\n        }\n        return ColorCorrectionPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.ColorCorrectionPostProcess = ColorCorrectionPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.colorCorrectionPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var TonemappingOperator;\n    (function (TonemappingOperator) {\n        TonemappingOperator[TonemappingOperator[\"Hable\"] = 0] = \"Hable\";\n        TonemappingOperator[TonemappingOperator[\"Reinhard\"] = 1] = \"Reinhard\";\n        TonemappingOperator[TonemappingOperator[\"HejiDawson\"] = 2] = \"HejiDawson\";\n        TonemappingOperator[TonemappingOperator[\"Photographic\"] = 3] = \"Photographic\";\n    })(TonemappingOperator = BABYLON.TonemappingOperator || (BABYLON.TonemappingOperator = {}));\n    ;\n    var TonemapPostProcess = (function (_super) {\n        __extends(TonemapPostProcess, _super);\n        function TonemapPostProcess(name, _operator, exposureAdjustment, camera, samplingMode, engine, textureFormat) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.BILINEAR_SAMPLINGMODE; }\n            if (textureFormat === void 0) { textureFormat = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            var _this = _super.call(this, name, \"tonemap\", [\"_ExposureAdjustment\"], null, 1.0, camera, samplingMode, engine, true, defines, textureFormat) || this;\n            _this._operator = _operator;\n            _this.exposureAdjustment = exposureAdjustment;\n            var defines = \"#define \";\n            if (_this._operator === TonemappingOperator.Hable)\n                defines += \"HABLE_TONEMAPPING\";\n            else if (_this._operator === TonemappingOperator.Reinhard)\n                defines += \"REINHARD_TONEMAPPING\";\n            else if (_this._operator === TonemappingOperator.HejiDawson)\n                defines += \"OPTIMIZED_HEJIDAWSON_TONEMAPPING\";\n            else if (_this._operator === TonemappingOperator.Photographic)\n                defines += \"PHOTOGRAPHIC_TONEMAPPING\";\n            //sadly a second call to create the effect.\n            _this.updateEffect(defines);\n            _this.onApply = function (effect) {\n                effect.setFloat(\"_ExposureAdjustment\", _this.exposureAdjustment);\n            };\n            return _this;\n        }\n        return TonemapPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.TonemapPostProcess = TonemapPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.tonemapPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var DisplayPassPostProcess = (function (_super) {\n        __extends(DisplayPassPostProcess, _super);\n        function DisplayPassPostProcess(name, options, camera, samplingMode, engine, reusable) {\n            return _super.call(this, name, \"displayPass\", [\"passSampler\"], [\"passSampler\"], options, camera, samplingMode, engine, reusable) || this;\n        }\n        return DisplayPassPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.DisplayPassPostProcess = DisplayPassPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.displayPassPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var HighlightsPostProcess = (function (_super) {\n        __extends(HighlightsPostProcess, _super);\n        function HighlightsPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            return _super.call(this, name, \"highlights\", null, null, options, camera, samplingMode, engine, reusable, null, textureType) || this;\n        }\n        return HighlightsPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.HighlightsPostProcess = HighlightsPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.highlightsPostProcess.js.map\n\n\n\n\n\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var ImageProcessingPostProcess = (function (_super) {\n        __extends(ImageProcessingPostProcess, _super);\n        function ImageProcessingPostProcess(name, options, camera, samplingMode, engine, reusable, textureType) {\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            var _this = _super.call(this, name, \"imageProcessing\", [], [], options, camera, samplingMode, engine, reusable, null, textureType, \"postprocess\", null, true) || this;\n            _this._fromLinearSpace = true;\n            /**\n             * Defines cache preventing GC.\n             */\n            _this._defines = {\n                IMAGEPROCESSING: false,\n                VIGNETTE: false,\n                VIGNETTEBLENDMODEMULTIPLY: false,\n                VIGNETTEBLENDMODEOPAQUE: false,\n                TONEMAPPING: false,\n                CONTRAST: false,\n                COLORCURVES: false,\n                COLORGRADING: false,\n                FROMLINEARSPACE: false,\n                SAMPLER3DGREENDEPTH: false,\n                SAMPLER3DBGRMAP: false,\n                IMAGEPROCESSINGPOSTPROCESS: false,\n                EXPOSURE: false,\n            };\n            // Setup the default processing configuration to the scene.\n            _this._attachImageProcessingConfiguration(null);\n            _this.imageProcessingConfiguration.applyByPostProcess = true;\n            _this._updateParameters();\n            _this.onApply = function (effect) {\n                _this.imageProcessingConfiguration.bind(effect, _this.aspectRatio);\n            };\n            return _this;\n        }\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"imageProcessingConfiguration\", {\n            /**\n             * Gets the image processing configuration used either in this material.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration;\n            },\n            /**\n             * Sets the Default image processing configuration used either in the this material.\n             *\n             * If sets to null, the scene one is in use.\n             */\n            set: function (value) {\n                this._attachImageProcessingConfiguration(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Attaches a new image processing configuration to the PBR Material.\n         * @param configuration\n         */\n        ImageProcessingPostProcess.prototype._attachImageProcessingConfiguration = function (configuration) {\n            var _this = this;\n            if (configuration === this._imageProcessingConfiguration) {\n                return;\n            }\n            // Detaches observer.\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            // Pick the scene configuration if needed.\n            if (!configuration) {\n                var camera = this.getCamera();\n                var scene = camera ? camera.getScene() : BABYLON.Engine.LastCreatedScene;\n                this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\n            }\n            else {\n                this._imageProcessingConfiguration = configuration;\n            }\n            // Attaches observer.\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(function (conf) {\n                _this._updateParameters();\n            });\n            // Ensure the effect will be rebuilt.\n            this._updateParameters();\n        };\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorCurves\", {\n            /**\n             * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorCurves;\n            },\n            /**\n             * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorCurves = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorCurvesEnabled\", {\n            /**\n             * Gets wether the color curves effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorCurvesEnabled;\n            },\n            /**\n             * Sets wether the color curves effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorCurvesEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorGradingTexture\", {\n            /**\n             * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorGradingTexture;\n            },\n            /**\n             * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorGradingTexture = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"colorGradingEnabled\", {\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.colorGradingEnabled;\n            },\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.colorGradingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"exposure\", {\n            /**\n             * Gets exposure used in the effect.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.exposure;\n            },\n            /**\n             * Sets exposure used in the effect.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.exposure = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"toneMappingEnabled\", {\n            /**\n             * Gets wether tonemapping is enabled or not.\n             */\n            get: function () {\n                return this._imageProcessingConfiguration.toneMappingEnabled;\n            },\n            /**\n             * Sets wether tonemapping is enabled or not\n             */\n            set: function (value) {\n                this._imageProcessingConfiguration.toneMappingEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        ;\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"contrast\", {\n            /**\n             * Gets contrast used in the effect.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.contrast;\n            },\n            /**\n             * Sets contrast used in the effect.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.contrast = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteStretch\", {\n            /**\n             * Gets Vignette stretch size.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteStretch;\n            },\n            /**\n             * Sets Vignette stretch size.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteStretch = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCentreX\", {\n            /**\n             * Gets Vignette centre X Offset.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteCentreX;\n            },\n            /**\n             * Sets Vignette centre X Offset.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteCentreX = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCentreY\", {\n            /**\n             * Gets Vignette centre Y Offset.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteCentreY;\n            },\n            /**\n             * Sets Vignette centre Y Offset.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteCentreY = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteWeight\", {\n            /**\n             * Gets Vignette weight or intensity of the vignette effect.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteWeight;\n            },\n            /**\n             * Sets Vignette weight or intensity of the vignette effect.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteWeight = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteColor\", {\n            /**\n             * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n             * if vignetteEnabled is set to true.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteColor;\n            },\n            /**\n             * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n             * if vignetteEnabled is set to true.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteColor = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteCameraFov\", {\n            /**\n             * Gets Camera field of view used by the Vignette effect.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteCameraFov;\n            },\n            /**\n             * Sets Camera field of view used by the Vignette effect.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteCameraFov = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteBlendMode\", {\n            /**\n             * Gets the vignette blend mode allowing different kind of effect.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteBlendMode;\n            },\n            /**\n             * Sets the vignette blend mode allowing different kind of effect.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteBlendMode = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"vignetteEnabled\", {\n            /**\n             * Gets wether the vignette effect is enabled.\n             */\n            get: function () {\n                return this.imageProcessingConfiguration.vignetteEnabled;\n            },\n            /**\n             * Sets wether the vignette effect is enabled.\n             */\n            set: function (value) {\n                this.imageProcessingConfiguration.vignetteEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingPostProcess.prototype, \"fromLinearSpace\", {\n            /**\n             * Gets wether the input of the processing is in Gamma or Linear Space.\n             */\n            get: function () {\n                return this._fromLinearSpace;\n            },\n            /**\n             * Sets wether the input of the processing is in Gamma or Linear Space.\n             */\n            set: function (value) {\n                if (this._fromLinearSpace === value) {\n                    return;\n                }\n                this._fromLinearSpace = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ImageProcessingPostProcess.prototype._updateParameters = function () {\n            this._defines.FROMLINEARSPACE = this._fromLinearSpace;\n            this.imageProcessingConfiguration.prepareDefines(this._defines);\n            var defines = \"\";\n            for (var define in this._defines) {\n                if (this._defines[define]) {\n                    defines += \"#define \" + define + \";\\r\\n\";\n                }\n            }\n            var samplers = [\"textureSampler\"];\n            BABYLON.ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\n            var uniforms = [\"scale\"];\n            BABYLON.ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\n            this.updateEffect(defines, uniforms, samplers);\n        };\n        ImageProcessingPostProcess.prototype.dispose = function (camera) {\n            _super.prototype.dispose.call(this, camera);\n            if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n                this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n            }\n            this.imageProcessingConfiguration.applyByPostProcess = false;\n        };\n        return ImageProcessingPostProcess;\n    }(BABYLON.PostProcess));\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingPostProcess.prototype, \"_fromLinearSpace\", void 0);\n    BABYLON.ImageProcessingPostProcess = ImageProcessingPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.imageProcessingPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var BlurPostProcess = (function (_super) {\n        __extends(BlurPostProcess, _super);\n        function BlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable, textureType) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.BILINEAR_SAMPLINGMODE; }\n            if (textureType === void 0) { textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT; }\n            var _this = _super.call(this, name, \"kernelBlur\", [\"delta\", \"direction\"], null, options, camera, samplingMode, engine, reusable, null, textureType, \"kernelBlur\", { varyingCount: 0, depCount: 0 }, true) || this;\n            _this.direction = direction;\n            _this._packedFloat = false;\n            _this.onApplyObservable.add(function (effect) {\n                effect.setFloat2('delta', (1 / _this.width) * _this.direction.x, (1 / _this.height) * _this.direction.y);\n            });\n            _this.kernel = kernel;\n            return _this;\n        }\n        Object.defineProperty(BlurPostProcess.prototype, \"kernel\", {\n            /**\n             * Gets the length in pixels of the blur sample region\n             */\n            get: function () {\n                return this._idealKernel;\n            },\n            /**\n             * Sets the length in pixels of the blur sample region\n             */\n            set: function (v) {\n                if (this._idealKernel === v) {\n                    return;\n                }\n                v = Math.max(v, 1);\n                this._idealKernel = v;\n                this._kernel = this._nearestBestKernel(v);\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BlurPostProcess.prototype, \"packedFloat\", {\n            /**\n             * Gets wether or not the blur is unpacking/repacking floats\n             */\n            get: function () {\n                return this._packedFloat;\n            },\n            /**\n             * Sets wether or not the blur needs to unpack/repack floats\n             */\n            set: function (v) {\n                if (this._packedFloat === v) {\n                    return;\n                }\n                this._packedFloat = v;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BlurPostProcess.prototype._updateParameters = function () {\n            // Generate sampling offsets and weights\n            var N = this._kernel;\n            var centerIndex = (N - 1) / 2;\n            // Generate Gaussian sampling weights over kernel\n            var offsets = [];\n            var weights = [];\n            var totalWeight = 0;\n            for (var i = 0; i < N; i++) {\n                var u = i / (N - 1);\n                var w = this._gaussianWeight(u * 2.0 - 1);\n                offsets[i] = (i - centerIndex);\n                weights[i] = w;\n                totalWeight += w;\n            }\n            // Normalize weights\n            for (var i = 0; i < weights.length; i++) {\n                weights[i] /= totalWeight;\n            }\n            // Optimize: combine samples to take advantage of hardware linear sampling\n            // Walk from left to center, combining pairs (symmetrically)\n            var linearSamplingWeights = [];\n            var linearSamplingOffsets = [];\n            var linearSamplingMap = [];\n            for (var i = 0; i <= centerIndex; i += 2) {\n                var j = Math.min(i + 1, Math.floor(centerIndex));\n                var singleCenterSample = i === j;\n                if (singleCenterSample) {\n                    linearSamplingMap.push({ o: offsets[i], w: weights[i] });\n                }\n                else {\n                    var sharedCell = j === centerIndex;\n                    var weightLinear = (weights[i] + weights[j] * (sharedCell ? .5 : 1.));\n                    var offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);\n                    if (offsetLinear === 0) {\n                        linearSamplingMap.push({ o: offsets[i], w: weights[i] });\n                        linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });\n                    }\n                    else {\n                        linearSamplingMap.push({ o: offsetLinear, w: weightLinear });\n                        linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });\n                    }\n                }\n            }\n            for (var i = 0; i < linearSamplingMap.length; i++) {\n                linearSamplingOffsets[i] = linearSamplingMap[i].o;\n                linearSamplingWeights[i] = linearSamplingMap[i].w;\n            }\n            // Replace with optimized\n            offsets = linearSamplingOffsets;\n            weights = linearSamplingWeights;\n            // Generate shaders\n            var maxVaryingRows = this.getEngine().getCaps().maxVaryingVectors;\n            var freeVaryingVec2 = Math.max(maxVaryingRows, 0.) - 1; // Because of sampleCenter\n            var varyingCount = Math.min(offsets.length, freeVaryingVec2);\n            var defines = \"\";\n            for (var i = 0; i < varyingCount; i++) {\n                defines += \"#define KERNEL_OFFSET\" + i + \" \" + this._glslFloat(offsets[i]) + \"\\r\\n\";\n                defines += \"#define KERNEL_WEIGHT\" + i + \" \" + this._glslFloat(weights[i]) + \"\\r\\n\";\n            }\n            var depCount = 0;\n            for (var i = freeVaryingVec2; i < offsets.length; i++) {\n                defines += \"#define KERNEL_DEP_OFFSET\" + depCount + \" \" + this._glslFloat(offsets[i]) + \"\\r\\n\";\n                defines += \"#define KERNEL_DEP_WEIGHT\" + depCount + \" \" + this._glslFloat(weights[i]) + \"\\r\\n\";\n                depCount++;\n            }\n            if (this.packedFloat) {\n                defines += \"#define PACKEDFLOAT 1\";\n            }\n            this.updateEffect(defines, null, null, {\n                varyingCount: varyingCount,\n                depCount: depCount\n            });\n        };\n        /**\n         * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.\n         * Other odd kernels optimize correctly but require proportionally more samples, even kernels are\n         * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we\n         * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.\n         * The gaps between physical kernels are compensated for in the weighting of the samples\n         * @param idealKernel Ideal blur kernel.\n         * @return Nearest best kernel.\n         */\n        BlurPostProcess.prototype._nearestBestKernel = function (idealKernel) {\n            var v = Math.round(idealKernel);\n            for (var _i = 0, _a = [v, v - 1, v + 1, v - 2, v + 2]; _i < _a.length; _i++) {\n                var k = _a[_i];\n                if (((k % 2) !== 0) && ((Math.floor(k / 2) % 2) === 0) && k > 0) {\n                    return Math.max(k, 3);\n                }\n            }\n            return Math.max(v, 3);\n        };\n        /**\n         * Calculates the value of a Gaussian distribution with sigma 3 at a given point.\n         * @param x The point on the Gaussian distribution to sample.\n         * @return the value of the Gaussian function at x.\n         */\n        BlurPostProcess.prototype._gaussianWeight = function (x) {\n            //reference: Engine/ImageProcessingBlur.cpp #dcc760\n            // We are evaluating the Gaussian (normal) distribution over a kernel parameter space of [-1,1],\n            // so we truncate at three standard deviations by setting stddev (sigma) to 1/3.\n            // The choice of 3-sigma truncation is common but arbitrary, and means that the signal is\n            // truncated at around 1.3% of peak strength.\n            //the distribution is scaled to account for the difference between the actual kernel size and the requested kernel size\n            var sigma = (1 / 3);\n            var denominator = Math.sqrt(2.0 * Math.PI) * sigma;\n            var exponent = -((x * x) / (2.0 * sigma * sigma));\n            var weight = (1.0 / denominator) * Math.exp(exponent);\n            return weight;\n        };\n        /**\n          * Generates a string that can be used as a floating point number in GLSL.\n          * @param x Value to print.\n          * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).\n          * @return GLSL float string.\n          */\n        BlurPostProcess.prototype._glslFloat = function (x, decimalFigures) {\n            if (decimalFigures === void 0) { decimalFigures = 8; }\n            return x.toFixed(decimalFigures).replace(/0+$/, '');\n        };\n        return BlurPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.BlurPostProcess = BlurPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.blurPostProcess.js.map\n\n/// <reference path=\"..\\babylon.node.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var Bone = (function (_super) {\n        __extends(Bone, _super);\n        function Bone(name, skeleton, parentBone, matrix, restPose) {\n            if (parentBone === void 0) { parentBone = null; }\n            var _this = _super.call(this, name, skeleton.getScene()) || this;\n            _this.name = name;\n            _this.children = new Array();\n            _this.animations = new Array();\n            _this._worldTransform = new BABYLON.Matrix();\n            _this._absoluteTransform = new BABYLON.Matrix();\n            _this._invertedAbsoluteTransform = new BABYLON.Matrix();\n            _this._scaleMatrix = BABYLON.Matrix.Identity();\n            _this._scaleVector = BABYLON.Vector3.One();\n            _this._negateScaleChildren = BABYLON.Vector3.One();\n            _this._scalingDeterminant = 1;\n            _this._skeleton = skeleton;\n            _this._localMatrix = matrix ? matrix : BABYLON.Matrix.Identity();\n            _this._baseMatrix = _this._localMatrix.clone();\n            _this._restPose = restPose ? restPose : _this._localMatrix.clone();\n            skeleton.bones.push(_this);\n            _this.setParent(parentBone, false);\n            _this._updateDifferenceMatrix();\n            return _this;\n        }\n        Object.defineProperty(Bone.prototype, \"_matrix\", {\n            get: function () {\n                return this._localMatrix;\n            },\n            set: function (val) {\n                if (this._localMatrix) {\n                    this._localMatrix.copyFrom(val);\n                }\n                else {\n                    this._localMatrix = val;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Members\n        Bone.prototype.getSkeleton = function () {\n            return this._skeleton;\n        };\n        Bone.prototype.getParent = function () {\n            return this._parent;\n        };\n        Bone.prototype.setParent = function (parent, updateDifferenceMatrix) {\n            if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\n            if (this._parent === parent) {\n                return;\n            }\n            if (this._parent) {\n                var index = this._parent.children.indexOf(this);\n                if (index !== -1) {\n                    this._parent.children.splice(index);\n                }\n            }\n            this._parent = parent;\n            if (this._parent) {\n                this._parent.children.push(this);\n            }\n            if (updateDifferenceMatrix) {\n                this._updateDifferenceMatrix();\n            }\n        };\n        Bone.prototype.getLocalMatrix = function () {\n            return this._localMatrix;\n        };\n        Bone.prototype.getBaseMatrix = function () {\n            return this._baseMatrix;\n        };\n        Bone.prototype.getRestPose = function () {\n            return this._restPose;\n        };\n        Bone.prototype.returnToRest = function () {\n            this.updateMatrix(this._restPose.clone());\n        };\n        Bone.prototype.getWorldMatrix = function () {\n            return this._worldTransform;\n        };\n        Bone.prototype.getInvertedAbsoluteTransform = function () {\n            return this._invertedAbsoluteTransform;\n        };\n        Bone.prototype.getAbsoluteTransform = function () {\n            return this._absoluteTransform;\n        };\n        Object.defineProperty(Bone.prototype, \"position\", {\n            // Properties (matches AbstractMesh properties)\n            get: function () {\n                return this.getPosition();\n            },\n            set: function (newPosition) {\n                this.setPosition(newPosition);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Bone.prototype, \"rotation\", {\n            get: function () {\n                return this.getRotation();\n            },\n            set: function (newRotation) {\n                this.setRotation(newRotation);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Bone.prototype, \"rotationQuaternion\", {\n            get: function () {\n                return this.getRotationQuaternion();\n            },\n            set: function (newRotation) {\n                this.setRotationQuaternion(newRotation);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Bone.prototype, \"scaling\", {\n            get: function () {\n                return this.getScale();\n            },\n            set: function (newScaling) {\n                this.setScale(newScaling.x, newScaling.y, newScaling.z);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        Bone.prototype.updateMatrix = function (matrix, updateDifferenceMatrix) {\n            if (updateDifferenceMatrix === void 0) { updateDifferenceMatrix = true; }\n            this._baseMatrix = matrix.clone();\n            this._localMatrix = matrix.clone();\n            this._skeleton._markAsDirty();\n            if (updateDifferenceMatrix) {\n                this._updateDifferenceMatrix();\n            }\n        };\n        Bone.prototype._updateDifferenceMatrix = function (rootMatrix) {\n            if (!rootMatrix) {\n                rootMatrix = this._baseMatrix;\n            }\n            if (this._parent) {\n                rootMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n            }\n            else {\n                this._absoluteTransform.copyFrom(rootMatrix);\n            }\n            this._absoluteTransform.invertToRef(this._invertedAbsoluteTransform);\n            for (var index = 0; index < this.children.length; index++) {\n                this.children[index]._updateDifferenceMatrix();\n            }\n            this._scalingDeterminant = (this._absoluteTransform.determinant() < 0 ? -1 : 1);\n        };\n        Bone.prototype.markAsDirty = function () {\n            this._currentRenderId++;\n            this._skeleton._markAsDirty();\n        };\n        Bone.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired, skelDimensionsRatio) {\n            if (rescaleAsRequired === void 0) { rescaleAsRequired = false; }\n            if (skelDimensionsRatio === void 0) { skelDimensionsRatio = null; }\n            // all animation may be coming from a library skeleton, so may need to create animation\n            if (this.animations.length === 0) {\n                this.animations.push(new BABYLON.Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, BABYLON.Animation.ANIMATIONTYPE_MATRIX, 0));\n                this.animations[0].setKeys([]);\n            }\n            // get animation info / verify there is such a range from the source bone\n            var sourceRange = source.animations[0].getRange(rangeName);\n            if (!sourceRange) {\n                return false;\n            }\n            var from = sourceRange.from;\n            var to = sourceRange.to;\n            var sourceKeys = source.animations[0].getKeys();\n            // rescaling prep\n            var sourceBoneLength = source.length;\n            var sourceParent = source.getParent();\n            var parent = this.getParent();\n            var parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n            var parentRatio = parentScalingReqd ? parent.length / sourceParent.length : null;\n            var dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n            var destKeys = this.animations[0].getKeys();\n            // loop vars declaration\n            var orig;\n            var origTranslation;\n            var mat;\n            for (var key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n                orig = sourceKeys[key];\n                if (orig.frame >= from && orig.frame <= to) {\n                    if (rescaleAsRequired) {\n                        mat = orig.value.clone();\n                        // scale based on parent ratio, when bone has parent\n                        if (parentScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\n                        }\n                        else if (dimensionsScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n                            // use original when root bone, and no data for skelDimensionsRatio\n                        }\n                        else {\n                            mat = orig.value;\n                        }\n                    }\n                    else {\n                        mat = orig.value;\n                    }\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\n                }\n            }\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n            return true;\n        };\n        /**\n         * Translate the bone in local or world space.\n         * @param vec The amount to translate the bone.\n         * @param space The space that the translation is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.translate = function (vec, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var lm = this.getLocalMatrix();\n            if (space == BABYLON.Space.LOCAL) {\n                lm.m[12] += vec.x;\n                lm.m[13] += vec.y;\n                lm.m[14] += vec.z;\n            }\n            else {\n                var wm;\n                //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n                if (mesh) {\n                    wm = mesh.getWorldMatrix();\n                }\n                this._skeleton.computeAbsoluteTransforms();\n                var tmat = Bone._tmpMats[0];\n                var tvec = Bone._tmpVecs[0];\n                if (mesh) {\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\n                    tmat.multiplyToRef(wm, tmat);\n                }\n                else {\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\n                }\n                tmat.m[12] = 0;\n                tmat.m[13] = 0;\n                tmat.m[14] = 0;\n                tmat.invert();\n                BABYLON.Vector3.TransformCoordinatesToRef(vec, tmat, tvec);\n                lm.m[12] += tvec.x;\n                lm.m[13] += tvec.y;\n                lm.m[14] += tvec.z;\n            }\n            this.markAsDirty();\n        };\n        /**\n         * Set the postion of the bone in local or world space.\n         * @param position The position to set the bone.\n         * @param space The space that the position is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setPosition = function (position, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var lm = this.getLocalMatrix();\n            if (space == BABYLON.Space.LOCAL) {\n                lm.m[12] = position.x;\n                lm.m[13] = position.y;\n                lm.m[14] = position.z;\n            }\n            else {\n                var wm;\n                //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n                if (mesh) {\n                    wm = mesh.getWorldMatrix();\n                }\n                this._skeleton.computeAbsoluteTransforms();\n                var tmat = Bone._tmpMats[0];\n                var vec = Bone._tmpVecs[0];\n                if (mesh) {\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\n                    tmat.multiplyToRef(wm, tmat);\n                }\n                else {\n                    tmat.copyFrom(this._parent.getAbsoluteTransform());\n                }\n                tmat.invert();\n                BABYLON.Vector3.TransformCoordinatesToRef(position, tmat, vec);\n                lm.m[12] = vec.x;\n                lm.m[13] = vec.y;\n                lm.m[14] = vec.z;\n            }\n            this.markAsDirty();\n        };\n        /**\n         * Set the absolute postion of the bone (world space).\n         * @param position The position to set the bone.\n         * @param mesh The mesh that this bone is attached to.\n         */\n        Bone.prototype.setAbsolutePosition = function (position, mesh) {\n            this.setPosition(position, BABYLON.Space.WORLD, mesh);\n        };\n        /**\n         * Set the scale of the bone on the x, y and z axes.\n         * @param x The scale of the bone on the x axis.\n         * @param x The scale of the bone on the y axis.\n         * @param z The scale of the bone on the z axis.\n         * @param scaleChildren Set this to true if children of the bone should be scaled.\n         */\n        Bone.prototype.setScale = function (x, y, z, scaleChildren) {\n            if (scaleChildren === void 0) { scaleChildren = false; }\n            if (this.animations[0] && !this.animations[0].isStopped()) {\n                if (!scaleChildren) {\n                    this._negateScaleChildren.x = 1 / x;\n                    this._negateScaleChildren.y = 1 / y;\n                    this._negateScaleChildren.z = 1 / z;\n                }\n                this._syncScaleVector();\n            }\n            this.scale(x / this._scaleVector.x, y / this._scaleVector.y, z / this._scaleVector.z, scaleChildren);\n        };\n        /**\n         * Scale the bone on the x, y and z axes.\n         * @param x The amount to scale the bone on the x axis.\n         * @param x The amount to scale the bone on the y axis.\n         * @param z The amount to scale the bone on the z axis.\n         * @param scaleChildren Set this to true if children of the bone should be scaled.\n         */\n        Bone.prototype.scale = function (x, y, z, scaleChildren) {\n            if (scaleChildren === void 0) { scaleChildren = false; }\n            var locMat = this.getLocalMatrix();\n            var origLocMat = Bone._tmpMats[0];\n            origLocMat.copyFrom(locMat);\n            var origLocMatInv = Bone._tmpMats[1];\n            origLocMatInv.copyFrom(origLocMat);\n            origLocMatInv.invert();\n            var scaleMat = Bone._tmpMats[2];\n            BABYLON.Matrix.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, scaleMat);\n            this._scaleMatrix.multiplyToRef(scaleMat, this._scaleMatrix);\n            this._scaleVector.x *= x;\n            this._scaleVector.y *= y;\n            this._scaleVector.z *= z;\n            locMat.multiplyToRef(origLocMatInv, locMat);\n            locMat.multiplyToRef(scaleMat, locMat);\n            locMat.multiplyToRef(origLocMat, locMat);\n            var parent = this.getParent();\n            if (parent) {\n                locMat.multiplyToRef(parent.getAbsoluteTransform(), this.getAbsoluteTransform());\n            }\n            else {\n                this.getAbsoluteTransform().copyFrom(locMat);\n            }\n            var len = this.children.length;\n            scaleMat.invert();\n            for (var i = 0; i < len; i++) {\n                var child = this.children[i];\n                var cm = child.getLocalMatrix();\n                cm.multiplyToRef(scaleMat, cm);\n                var lm = child.getLocalMatrix();\n                lm.m[12] *= x;\n                lm.m[13] *= y;\n                lm.m[14] *= z;\n            }\n            this.computeAbsoluteTransforms();\n            if (scaleChildren) {\n                for (var i = 0; i < len; i++) {\n                    this.children[i].scale(x, y, z, scaleChildren);\n                }\n            }\n            this.markAsDirty();\n        };\n        /**\n         * Set the yaw, pitch, and roll of the bone in local or world space.\n         * @param yaw The rotation of the bone on the y axis.\n         * @param pitch The rotation of the bone on the x axis.\n         * @param roll The rotation of the bone on the z axis.\n         * @param space The space that the axes of rotation are in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setYawPitchRoll = function (yaw, pitch, roll, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var rotMat = Bone._tmpMats[0];\n            BABYLON.Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);\n            var rotMatInv = Bone._tmpMats[1];\n            this._getNegativeRotationToRef(rotMatInv, space, mesh);\n            rotMatInv.multiplyToRef(rotMat, rotMat);\n            this._rotateWithMatrix(rotMat, space, mesh);\n        };\n        /**\n         * Rotate the bone on an axis in local or world space.\n         * @param axis The axis to rotate the bone on.\n         * @param amount The amount to rotate the bone.\n         * @param space The space that the axis is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.rotate = function (axis, amount, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var rmat = Bone._tmpMats[0];\n            rmat.m[12] = 0;\n            rmat.m[13] = 0;\n            rmat.m[14] = 0;\n            BABYLON.Matrix.RotationAxisToRef(axis, amount, rmat);\n            this._rotateWithMatrix(rmat, space, mesh);\n        };\n        /**\n         * Set the rotation of the bone to a particular axis angle in local or world space.\n         * @param axis The axis to rotate the bone on.\n         * @param angle The angle that the bone should be rotated to.\n         * @param space The space that the axis is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setAxisAngle = function (axis, angle, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var rotMat = Bone._tmpMats[0];\n            BABYLON.Matrix.RotationAxisToRef(axis, angle, rotMat);\n            var rotMatInv = Bone._tmpMats[1];\n            this._getNegativeRotationToRef(rotMatInv, space, mesh);\n            rotMatInv.multiplyToRef(rotMat, rotMat);\n            this._rotateWithMatrix(rotMat, space, mesh);\n        };\n        /**\n         * Set the euler rotation of the bone in local of world space.\n         * @param rotation The euler rotation that the bone should be set to.\n         * @param space The space that the rotation is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setRotation = function (rotation, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, mesh);\n        };\n        /**\n         * Set the quaternion rotation of the bone in local of world space.\n         * @param quat The quaternion rotation that the bone should be set to.\n         * @param space The space that the rotation is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setRotationQuaternion = function (quat, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var rotMatInv = Bone._tmpMats[0];\n            this._getNegativeRotationToRef(rotMatInv, space, mesh);\n            var rotMat = Bone._tmpMats[1];\n            BABYLON.Matrix.FromQuaternionToRef(quat, rotMat);\n            rotMatInv.multiplyToRef(rotMat, rotMat);\n            this._rotateWithMatrix(rotMat, space, mesh);\n        };\n        /**\n         * Set the rotation matrix of the bone in local of world space.\n         * @param rotMat The rotation matrix that the bone should be set to.\n         * @param space The space that the rotation is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         */\n        Bone.prototype.setRotationMatrix = function (rotMat, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var rotMatInv = Bone._tmpMats[0];\n            this._getNegativeRotationToRef(rotMatInv, space, mesh);\n            var rotMat2 = Bone._tmpMats[1];\n            rotMat2.copyFrom(rotMat);\n            rotMatInv.multiplyToRef(rotMat, rotMat2);\n            this._rotateWithMatrix(rotMat2, space, mesh);\n        };\n        Bone.prototype._rotateWithMatrix = function (rmat, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var lmat = this.getLocalMatrix();\n            var lx = lmat.m[12];\n            var ly = lmat.m[13];\n            var lz = lmat.m[14];\n            var parent = this.getParent();\n            var parentScale = Bone._tmpMats[3];\n            var parentScaleInv = Bone._tmpMats[4];\n            if (parent) {\n                if (space == BABYLON.Space.WORLD) {\n                    if (mesh) {\n                        parentScale.copyFrom(mesh.getWorldMatrix());\n                        parent.getAbsoluteTransform().multiplyToRef(parentScale, parentScale);\n                    }\n                    else {\n                        parentScale.copyFrom(parent.getAbsoluteTransform());\n                    }\n                }\n                else {\n                    parentScale = parent._scaleMatrix;\n                }\n                parentScaleInv.copyFrom(parentScale);\n                parentScaleInv.invert();\n                lmat.multiplyToRef(parentScale, lmat);\n                lmat.multiplyToRef(rmat, lmat);\n                lmat.multiplyToRef(parentScaleInv, lmat);\n            }\n            else {\n                if (space == BABYLON.Space.WORLD && mesh) {\n                    parentScale.copyFrom(mesh.getWorldMatrix());\n                    parentScaleInv.copyFrom(parentScale);\n                    parentScaleInv.invert();\n                    lmat.multiplyToRef(parentScale, lmat);\n                    lmat.multiplyToRef(rmat, lmat);\n                    lmat.multiplyToRef(parentScaleInv, lmat);\n                }\n                else {\n                    lmat.multiplyToRef(rmat, lmat);\n                }\n            }\n            lmat.m[12] = lx;\n            lmat.m[13] = ly;\n            lmat.m[14] = lz;\n            this.computeAbsoluteTransforms();\n            this.markAsDirty();\n        };\n        Bone.prototype._getNegativeRotationToRef = function (rotMatInv, space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            if (space == BABYLON.Space.WORLD) {\n                var scaleMatrix = Bone._tmpMats[2];\n                scaleMatrix.copyFrom(this._scaleMatrix);\n                rotMatInv.copyFrom(this.getAbsoluteTransform());\n                if (mesh) {\n                    rotMatInv.multiplyToRef(mesh.getWorldMatrix(), rotMatInv);\n                    var meshScale = Bone._tmpMats[3];\n                    BABYLON.Matrix.ScalingToRef(mesh.scaling.x, mesh.scaling.y, mesh.scaling.z, meshScale);\n                    scaleMatrix.multiplyToRef(meshScale, scaleMatrix);\n                }\n                rotMatInv.invert();\n                scaleMatrix.m[0] *= this._scalingDeterminant;\n                rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n            }\n            else {\n                rotMatInv.copyFrom(this.getLocalMatrix());\n                rotMatInv.invert();\n                var scaleMatrix = Bone._tmpMats[2];\n                scaleMatrix.copyFrom(this._scaleMatrix);\n                if (this._parent) {\n                    var pscaleMatrix = Bone._tmpMats[3];\n                    pscaleMatrix.copyFrom(this._parent._scaleMatrix);\n                    pscaleMatrix.invert();\n                    pscaleMatrix.multiplyToRef(rotMatInv, rotMatInv);\n                }\n                else {\n                    scaleMatrix.m[0] *= this._scalingDeterminant;\n                }\n                rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);\n            }\n        };\n        /**\n         * Get the scale of the bone\n         * @returns the scale of the bone\n         */\n        Bone.prototype.getScale = function () {\n            return this._scaleVector.clone();\n        };\n        /**\n         * Copy the scale of the bone to a vector3.\n         * @param result The vector3 to copy the scale to\n         */\n        Bone.prototype.getScaleToRef = function (result) {\n            result.copyFrom(this._scaleVector);\n        };\n        /**\n         * Get the position of the bone in local or world space.\n         * @param space The space that the returned position is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @returns The position of the bone\n         */\n        Bone.prototype.getPosition = function (space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var pos = BABYLON.Vector3.Zero();\n            this.getPositionToRef(space, mesh, pos);\n            return pos;\n        };\n        /**\n         * Copy the position of the bone to a vector3 in local or world space.\n         * @param space The space that the returned position is in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @param result The vector3 to copy the position to.\n         */\n        Bone.prototype.getPositionToRef = function (space, mesh, result) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            if (space == BABYLON.Space.LOCAL) {\n                var lm = this.getLocalMatrix();\n                result.x = lm.m[12];\n                result.y = lm.m[13];\n                result.z = lm.m[14];\n            }\n            else {\n                var wm;\n                //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n                if (mesh) {\n                    wm = mesh.getWorldMatrix();\n                }\n                this._skeleton.computeAbsoluteTransforms();\n                var tmat = Bone._tmpMats[0];\n                if (mesh) {\n                    tmat.copyFrom(this.getAbsoluteTransform());\n                    tmat.multiplyToRef(wm, tmat);\n                }\n                else {\n                    tmat = this.getAbsoluteTransform();\n                }\n                result.x = tmat.m[12];\n                result.y = tmat.m[13];\n                result.z = tmat.m[14];\n            }\n        };\n        /**\n         * Get the absolute position of the bone (world space).\n         * @param mesh The mesh that this bone is attached to.\n         * @returns The absolute position of the bone\n         */\n        Bone.prototype.getAbsolutePosition = function (mesh) {\n            var pos = BABYLON.Vector3.Zero();\n            this.getPositionToRef(BABYLON.Space.WORLD, mesh, pos);\n            return pos;\n        };\n        /**\n         * Copy the absolute position of the bone (world space) to the result param.\n         * @param mesh The mesh that this bone is attached to.\n         * @param result The vector3 to copy the absolute position to.\n         */\n        Bone.prototype.getAbsolutePositionToRef = function (mesh, result) {\n            this.getPositionToRef(BABYLON.Space.WORLD, mesh, result);\n        };\n        /**\n         * Compute the absolute transforms of this bone and its children.\n         */\n        Bone.prototype.computeAbsoluteTransforms = function () {\n            if (this._parent) {\n                this._localMatrix.multiplyToRef(this._parent._absoluteTransform, this._absoluteTransform);\n            }\n            else {\n                this._absoluteTransform.copyFrom(this._localMatrix);\n                var poseMatrix = this._skeleton.getPoseMatrix();\n                if (poseMatrix) {\n                    this._absoluteTransform.multiplyToRef(poseMatrix, this._absoluteTransform);\n                }\n            }\n            var children = this.children;\n            var len = children.length;\n            for (var i = 0; i < len; i++) {\n                children[i].computeAbsoluteTransforms();\n            }\n        };\n        Bone.prototype._syncScaleVector = function () {\n            var lm = this.getLocalMatrix();\n            var xsq = (lm.m[0] * lm.m[0] + lm.m[1] * lm.m[1] + lm.m[2] * lm.m[2]);\n            var ysq = (lm.m[4] * lm.m[4] + lm.m[5] * lm.m[5] + lm.m[6] * lm.m[6]);\n            var zsq = (lm.m[8] * lm.m[8] + lm.m[9] * lm.m[9] + lm.m[10] * lm.m[10]);\n            var xs = lm.m[0] * lm.m[1] * lm.m[2] * lm.m[3] < 0 ? -1 : 1;\n            var ys = lm.m[4] * lm.m[5] * lm.m[6] * lm.m[7] < 0 ? -1 : 1;\n            var zs = lm.m[8] * lm.m[9] * lm.m[10] * lm.m[11] < 0 ? -1 : 1;\n            this._scaleVector.x = xs * Math.sqrt(xsq);\n            this._scaleVector.y = ys * Math.sqrt(ysq);\n            this._scaleVector.z = zs * Math.sqrt(zsq);\n            if (this._parent) {\n                this._scaleVector.x /= this._parent._negateScaleChildren.x;\n                this._scaleVector.y /= this._parent._negateScaleChildren.y;\n                this._scaleVector.z /= this._parent._negateScaleChildren.z;\n            }\n            BABYLON.Matrix.FromValuesToRef(this._scaleVector.x, 0, 0, 0, 0, this._scaleVector.y, 0, 0, 0, 0, this._scaleVector.z, 0, 0, 0, 0, 1, this._scaleMatrix);\n        };\n        /**\n         * Get the world direction from an axis that is in the local space of the bone.\n         * @param localAxis The local direction that is used to compute the world direction.\n         * @param mesh The mesh that this bone is attached to.\n         * @returns The world direction\n         */\n        Bone.prototype.getDirection = function (localAxis, mesh) {\n            var result = BABYLON.Vector3.Zero();\n            this.getDirectionToRef(localAxis, mesh, result);\n            return result;\n        };\n        /**\n         * Copy the world direction to a vector3 from an axis that is in the local space of the bone.\n         * @param localAxis The local direction that is used to compute the world direction.\n         * @param mesh The mesh that this bone is attached to.\n         * @param result The vector3 that the world direction will be copied to.\n         */\n        Bone.prototype.getDirectionToRef = function (localAxis, mesh, result) {\n            var wm;\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (mesh) {\n                wm = mesh.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            var mat = Bone._tmpMats[0];\n            mat.copyFrom(this.getAbsoluteTransform());\n            if (mesh) {\n                mat.multiplyToRef(wm, mat);\n            }\n            BABYLON.Vector3.TransformNormalToRef(localAxis, mat, result);\n            result.normalize();\n        };\n        /**\n         * Get the euler rotation of the bone in local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @returns The euler rotation\n         */\n        Bone.prototype.getRotation = function (space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var result = BABYLON.Vector3.Zero();\n            this.getRotationToRef(space, mesh, result);\n            return result;\n        };\n        /**\n         * Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @param result The vector3 that the rotation should be copied to.\n         */\n        Bone.prototype.getRotationToRef = function (space, mesh, result) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var quat = Bone._tmpQuat;\n            this.getRotationQuaternionToRef(space, mesh, quat);\n            quat.toEulerAnglesToRef(result);\n        };\n        /**\n         * Get the quaternion rotation of the bone in either local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @returns The quaternion rotation\n         */\n        Bone.prototype.getRotationQuaternion = function (space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var result = BABYLON.Quaternion.Identity();\n            this.getRotationQuaternionToRef(space, mesh, result);\n            return result;\n        };\n        /**\n         * Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @param result The quaternion that the rotation should be copied to.\n         */\n        Bone.prototype.getRotationQuaternionToRef = function (space, mesh, result) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            if (space == BABYLON.Space.LOCAL) {\n                this.getLocalMatrix().decompose(Bone._tmpVecs[0], result, Bone._tmpVecs[1]);\n            }\n            else {\n                var mat = Bone._tmpMats[0];\n                var amat = this.getAbsoluteTransform();\n                if (mesh) {\n                    amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n                }\n                else {\n                    mat.copyFrom(amat);\n                }\n                mat.m[0] *= this._scalingDeterminant;\n                mat.m[1] *= this._scalingDeterminant;\n                mat.m[2] *= this._scalingDeterminant;\n                mat.decompose(Bone._tmpVecs[0], result, Bone._tmpVecs[1]);\n            }\n        };\n        /**\n         * Get the rotation matrix of the bone in local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @returns The rotation matrix\n         */\n        Bone.prototype.getRotationMatrix = function (space, mesh) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            var result = BABYLON.Matrix.Identity();\n            this.getRotationMatrixToRef(space, mesh, result);\n            return result;\n        };\n        /**\n         * Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space.\n         * @param space The space that the rotation should be in.\n         * @param mesh The mesh that this bone is attached to.  This is only used in world space.\n         * @param result The quaternion that the rotation should be copied to.\n         */\n        Bone.prototype.getRotationMatrixToRef = function (space, mesh, result) {\n            if (space === void 0) { space = BABYLON.Space.LOCAL; }\n            if (space == BABYLON.Space.LOCAL) {\n                this.getLocalMatrix().getRotationMatrixToRef(result);\n            }\n            else {\n                var mat = Bone._tmpMats[0];\n                var amat = this.getAbsoluteTransform();\n                if (mesh) {\n                    amat.multiplyToRef(mesh.getWorldMatrix(), mat);\n                }\n                else {\n                    mat.copyFrom(amat);\n                }\n                mat.m[0] *= this._scalingDeterminant;\n                mat.m[1] *= this._scalingDeterminant;\n                mat.m[2] *= this._scalingDeterminant;\n                mat.getRotationMatrixToRef(result);\n            }\n        };\n        /**\n         * Get the world position of a point that is in the local space of the bone.\n         * @param position The local position\n         * @param mesh The mesh that this bone is attached to.\n         * @returns The world position\n         */\n        Bone.prototype.getAbsolutePositionFromLocal = function (position, mesh) {\n            var result = BABYLON.Vector3.Zero();\n            this.getAbsolutePositionFromLocalToRef(position, mesh, result);\n            return result;\n        };\n        /**\n         * Get the world position of a point that is in the local space of the bone and copy it to the result param.\n         * @param position The local position\n         * @param mesh The mesh that this bone is attached to.\n         * @param result The vector3 that the world position should be copied to.\n         */\n        Bone.prototype.getAbsolutePositionFromLocalToRef = function (position, mesh, result) {\n            var wm;\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (mesh) {\n                wm = mesh.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            var tmat = Bone._tmpMats[0];\n            if (mesh) {\n                tmat.copyFrom(this.getAbsoluteTransform());\n                tmat.multiplyToRef(wm, tmat);\n            }\n            else {\n                tmat = this.getAbsoluteTransform();\n            }\n            BABYLON.Vector3.TransformCoordinatesToRef(position, tmat, result);\n        };\n        /**\n         * Get the local position of a point that is in world space.\n         * @param position The world position\n         * @param mesh The mesh that this bone is attached to.\n         * @returns The local position\n         */\n        Bone.prototype.getLocalPositionFromAbsolute = function (position, mesh) {\n            var result = BABYLON.Vector3.Zero();\n            this.getLocalPositionFromAbsoluteToRef(position, mesh, result);\n            return result;\n        };\n        /**\n         * Get the local position of a point that is in world space and copy it to the result param.\n         * @param position The world position\n         * @param mesh The mesh that this bone is attached to.\n         * @param result The vector3 that the local position should be copied to.\n         */\n        Bone.prototype.getLocalPositionFromAbsoluteToRef = function (position, mesh, result) {\n            var wm;\n            //mesh.getWorldMatrix() needs to be called before skeleton.computeAbsoluteTransforms()\n            if (mesh) {\n                wm = mesh.getWorldMatrix();\n            }\n            this._skeleton.computeAbsoluteTransforms();\n            var tmat = Bone._tmpMats[0];\n            tmat.copyFrom(this.getAbsoluteTransform());\n            if (mesh) {\n                tmat.multiplyToRef(wm, tmat);\n            }\n            tmat.invert();\n            BABYLON.Vector3.TransformCoordinatesToRef(position, tmat, result);\n        };\n        return Bone;\n    }(BABYLON.Node));\n    Bone._tmpVecs = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n    Bone._tmpQuat = BABYLON.Quaternion.Identity();\n    Bone._tmpMats = [BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity()];\n    BABYLON.Bone = Bone;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.bone.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var BoneIKController = (function () {\n        function BoneIKController(mesh, bone, options) {\n            this.targetPosition = BABYLON.Vector3.Zero();\n            this.poleTargetPosition = BABYLON.Vector3.Zero();\n            this.poleTargetLocalOffset = BABYLON.Vector3.Zero();\n            this.poleAngle = 0;\n            this.slerpAmount = 1;\n            this._bone1Quat = BABYLON.Quaternion.Identity();\n            this._bone1Mat = BABYLON.Matrix.Identity();\n            this._bone2Ang = Math.PI;\n            this._maxAngle = Math.PI;\n            this._rightHandedSystem = false;\n            this._bendAxis = BABYLON.Vector3.Right();\n            this._slerping = false;\n            this._adjustRoll = 0;\n            this._bone2 = bone;\n            this._bone1 = bone.getParent();\n            this.mesh = mesh;\n            var bonePos = bone.getPosition();\n            if (bone.getAbsoluteTransform().determinant() > 0) {\n                this._rightHandedSystem = true;\n                this._bendAxis.x = 0;\n                this._bendAxis.y = 0;\n                this._bendAxis.z = -1;\n                if (bonePos.x > bonePos.y && bonePos.x > bonePos.z) {\n                    this._adjustRoll = Math.PI * .5;\n                    this._bendAxis.z = 1;\n                }\n            }\n            if (this._bone1.length) {\n                var boneScale1 = this._bone1.getScale();\n                var boneScale2 = this._bone2.getScale();\n                this._bone1Length = this._bone1.length * boneScale1.y * this.mesh.scaling.y;\n                this._bone2Length = this._bone2.length * boneScale2.y * this.mesh.scaling.y;\n            }\n            else if (this._bone1.children[0]) {\n                mesh.computeWorldMatrix(true);\n                var pos1 = this._bone2.children[0].getAbsolutePosition(mesh);\n                var pos2 = this._bone2.getAbsolutePosition(mesh);\n                var pos3 = this._bone1.getAbsolutePosition(mesh);\n                this._bone1Length = BABYLON.Vector3.Distance(pos1, pos2);\n                this._bone2Length = BABYLON.Vector3.Distance(pos2, pos3);\n            }\n            this._bone1.getRotationMatrixToRef(BABYLON.Space.WORLD, mesh, this._bone1Mat);\n            this.maxAngle = Math.PI;\n            if (options) {\n                if (options.targetMesh) {\n                    this.targetMesh = options.targetMesh;\n                    this.targetMesh.computeWorldMatrix(true);\n                }\n                if (options.poleTargetMesh) {\n                    this.poleTargetMesh = options.poleTargetMesh;\n                    this.poleTargetMesh.computeWorldMatrix(true);\n                }\n                else if (options.poleTargetBone) {\n                    this.poleTargetBone = options.poleTargetBone;\n                }\n                else if (this._bone1.getParent()) {\n                    this.poleTargetBone = this._bone1.getParent();\n                }\n                if (options.poleTargetLocalOffset) {\n                    this.poleTargetLocalOffset.copyFrom(options.poleTargetLocalOffset);\n                }\n                if (options.poleAngle) {\n                    this.poleAngle = options.poleAngle;\n                }\n                if (options.bendAxis) {\n                    this._bendAxis.copyFrom(options.bendAxis);\n                }\n                if (options.maxAngle) {\n                    this.maxAngle = options.maxAngle;\n                }\n                if (options.slerpAmount) {\n                    this.slerpAmount = options.slerpAmount;\n                }\n            }\n        }\n        Object.defineProperty(BoneIKController.prototype, \"maxAngle\", {\n            get: function () {\n                return this._maxAngle;\n            },\n            set: function (value) {\n                this._setMaxAngle(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BoneIKController.prototype._setMaxAngle = function (ang) {\n            if (ang < 0) {\n                ang = 0;\n            }\n            if (ang > Math.PI || ang == undefined) {\n                ang = Math.PI;\n            }\n            this._maxAngle = ang;\n            var a = this._bone1Length;\n            var b = this._bone2Length;\n            this._maxReach = Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(ang));\n        };\n        BoneIKController.prototype.update = function () {\n            var bone1 = this._bone1;\n            var target = this.targetPosition;\n            var poleTarget = this.poleTargetPosition;\n            var mat1 = BoneIKController._tmpMats[0];\n            var mat2 = BoneIKController._tmpMats[1];\n            if (this.targetMesh) {\n                target.copyFrom(this.targetMesh.getAbsolutePosition());\n            }\n            if (this.poleTargetBone) {\n                this.poleTargetBone.getAbsolutePositionFromLocalToRef(this.poleTargetLocalOffset, this.mesh, poleTarget);\n            }\n            else if (this.poleTargetMesh) {\n                BABYLON.Vector3.TransformCoordinatesToRef(this.poleTargetLocalOffset, this.poleTargetMesh.getWorldMatrix(), poleTarget);\n            }\n            var bonePos = BoneIKController._tmpVecs[0];\n            var zaxis = BoneIKController._tmpVecs[1];\n            var xaxis = BoneIKController._tmpVecs[2];\n            var yaxis = BoneIKController._tmpVecs[3];\n            var upAxis = BoneIKController._tmpVecs[4];\n            var _tmpQuat = BoneIKController._tmpQuat;\n            bone1.getAbsolutePositionToRef(this.mesh, bonePos);\n            poleTarget.subtractToRef(bonePos, upAxis);\n            if (upAxis.x == 0 && upAxis.y == 0 && upAxis.z == 0) {\n                upAxis.y = 1;\n            }\n            else {\n                upAxis.normalize();\n            }\n            target.subtractToRef(bonePos, yaxis);\n            yaxis.normalize();\n            BABYLON.Vector3.CrossToRef(yaxis, upAxis, zaxis);\n            zaxis.normalize();\n            BABYLON.Vector3.CrossToRef(yaxis, zaxis, xaxis);\n            xaxis.normalize();\n            BABYLON.Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, mat1);\n            var a = this._bone1Length;\n            var b = this._bone2Length;\n            var c = BABYLON.Vector3.Distance(bonePos, target);\n            if (this._maxReach > 0) {\n                c = Math.min(this._maxReach, c);\n            }\n            var acosa = (b * b + c * c - a * a) / (2 * b * c);\n            var acosb = (c * c + a * a - b * b) / (2 * c * a);\n            if (acosa > 1) {\n                acosa = 1;\n            }\n            if (acosb > 1) {\n                acosb = 1;\n            }\n            if (acosa < -1) {\n                acosa = -1;\n            }\n            if (acosb < -1) {\n                acosb = -1;\n            }\n            var angA = Math.acos(acosa);\n            var angB = Math.acos(acosb);\n            var angC = -angA - angB;\n            if (this._rightHandedSystem) {\n                BABYLON.Matrix.RotationYawPitchRollToRef(0, 0, this._adjustRoll, mat2);\n                mat2.multiplyToRef(mat1, mat1);\n                BABYLON.Matrix.RotationAxisToRef(this._bendAxis, angB, mat2);\n                mat2.multiplyToRef(mat1, mat1);\n            }\n            else {\n                var _tmpVec = BoneIKController._tmpVecs[5];\n                _tmpVec.copyFrom(this._bendAxis);\n                _tmpVec.x *= -1;\n                BABYLON.Matrix.RotationAxisToRef(_tmpVec, -angB, mat2);\n                mat2.multiplyToRef(mat1, mat1);\n            }\n            if (this.poleAngle) {\n                BABYLON.Matrix.RotationAxisToRef(yaxis, this.poleAngle, mat2);\n                mat1.multiplyToRef(mat2, mat1);\n            }\n            if (this.slerpAmount < 1) {\n                if (!this._slerping) {\n                    BABYLON.Quaternion.FromRotationMatrixToRef(this._bone1Mat, this._bone1Quat);\n                }\n                BABYLON.Quaternion.FromRotationMatrixToRef(mat1, _tmpQuat);\n                BABYLON.Quaternion.SlerpToRef(this._bone1Quat, _tmpQuat, this.slerpAmount, this._bone1Quat);\n                angC = this._bone2Ang * (1.0 - this.slerpAmount) + angC * this.slerpAmount;\n                this._bone1.setRotationQuaternion(this._bone1Quat, BABYLON.Space.WORLD, this.mesh);\n                this._slerping = true;\n            }\n            else {\n                this._bone1.setRotationMatrix(mat1, BABYLON.Space.WORLD, this.mesh);\n                this._bone1Mat.copyFrom(mat1);\n                this._slerping = false;\n            }\n            this._bone2.setAxisAngle(this._bendAxis, angC, BABYLON.Space.LOCAL);\n            this._bone2Ang = angC;\n        };\n        return BoneIKController;\n    }());\n    BoneIKController._tmpVecs = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n    BoneIKController._tmpQuat = BABYLON.Quaternion.Identity();\n    BoneIKController._tmpMats = [BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity()];\n    BABYLON.BoneIKController = BoneIKController;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boneIKController.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var BoneLookController = (function () {\n        /**\n         * Create a BoneLookController\n         * @param mesh the mesh that the bone belongs to\n         * @param bone the bone that will be looking to the target\n         * @param target the target Vector3 to look at\n         * @param settings optional settings:\n         * - maxYaw: the maximum angle the bone will yaw to\n         * - minYaw: the minimum angle the bone will yaw to\n         * - maxPitch: the maximum angle the bone will pitch to\n         * - minPitch: the minimum angle the bone will yaw to\n         * - slerpAmount: set the between 0 and 1 to make the bone slerp to the target.\n         * - upAxis: the up axis of the coordinate system\n         * - upAxisSpace: the space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD.\n         * - yawAxis: set yawAxis if the bone does not yaw on the y axis\n         * - pitchAxis: set pitchAxis if the bone does not pitch on the x axis\n         * - adjustYaw: used to make an adjustment to the yaw of the bone\n         * - adjustPitch: used to make an adjustment to the pitch of the bone\n         * - adjustRoll: used to make an adjustment to the roll of the bone\n         **/\n        function BoneLookController(mesh, bone, target, options) {\n            /**\n             * The up axis of the coordinate system that is used when the bone is rotated.\n             */\n            this.upAxis = BABYLON.Vector3.Up();\n            /**\n             * The space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD.\n             */\n            this.upAxisSpace = BABYLON.Space.LOCAL;\n            /**\n             * Used to make an adjustment to the yaw of the bone.\n             */\n            this.adjustYaw = 0;\n            /**\n             * Used to make an adjustment to the pitch of the bone.\n             */\n            this.adjustPitch = 0;\n            /**\n             * Used to make an adjustment to the roll of the bone.\n             */\n            this.adjustRoll = 0;\n            /**\n             * The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp).\n             */\n            this.slerpAmount = 1;\n            this._boneQuat = BABYLON.Quaternion.Identity();\n            this._slerping = false;\n            this._firstFrameSkipped = false;\n            this._fowardAxis = BABYLON.Vector3.Forward();\n            this.mesh = mesh;\n            this.bone = bone;\n            this.target = target;\n            if (options) {\n                if (options.adjustYaw) {\n                    this.adjustYaw = options.adjustYaw;\n                }\n                if (options.adjustPitch) {\n                    this.adjustPitch = options.adjustPitch;\n                }\n                if (options.adjustRoll) {\n                    this.adjustRoll = options.adjustRoll;\n                }\n                if (options.maxYaw != null) {\n                    this.maxYaw = options.maxYaw;\n                }\n                else {\n                    this.maxYaw = Math.PI;\n                }\n                if (options.minYaw != null) {\n                    this.minYaw = options.minYaw;\n                }\n                else {\n                    this.minYaw = -Math.PI;\n                }\n                if (options.maxPitch != null) {\n                    this.maxPitch = options.maxPitch;\n                }\n                else {\n                    this.maxPitch = Math.PI;\n                }\n                if (options.minPitch != null) {\n                    this.minPitch = options.minPitch;\n                }\n                else {\n                    this.minPitch = -Math.PI;\n                }\n                if (options.slerpAmount != null) {\n                    this.slerpAmount = options.slerpAmount;\n                }\n                if (options.upAxis != null) {\n                    this.upAxis = options.upAxis;\n                }\n                if (options.upAxisSpace != null) {\n                    this.upAxisSpace = options.upAxisSpace;\n                }\n                if (options.yawAxis != null || options.pitchAxis != null) {\n                    var newYawAxis = BABYLON.Axis.Y;\n                    var newPitchAxis = BABYLON.Axis.X;\n                    if (options.yawAxis != null) {\n                        newYawAxis = options.yawAxis.clone();\n                        newYawAxis.normalize();\n                    }\n                    if (options.pitchAxis != null) {\n                        newPitchAxis = options.pitchAxis.clone();\n                        newPitchAxis.normalize();\n                    }\n                    var newRollAxis = BABYLON.Vector3.Cross(newPitchAxis, newYawAxis);\n                    this._transformYawPitch = BABYLON.Matrix.Identity();\n                    BABYLON.Matrix.FromXYZAxesToRef(newPitchAxis, newYawAxis, newRollAxis, this._transformYawPitch);\n                    this._transformYawPitchInv = this._transformYawPitch.clone();\n                    this._transformYawPitch.invert();\n                }\n            }\n            if (!bone.getParent() && this.upAxisSpace == BABYLON.Space.BONE) {\n                this.upAxisSpace = BABYLON.Space.LOCAL;\n            }\n        }\n        Object.defineProperty(BoneLookController.prototype, \"minYaw\", {\n            /**\n             * Get/set the minimum yaw angle that the bone can look to.\n             */\n            get: function () {\n                return this._minYaw;\n            },\n            set: function (value) {\n                this._minYaw = value;\n                this._minYawSin = Math.sin(value);\n                this._minYawCos = Math.cos(value);\n                if (this._maxYaw != null) {\n                    this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n                    this._yawRange = this._maxYaw - this._minYaw;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BoneLookController.prototype, \"maxYaw\", {\n            /**\n             * Get/set the maximum yaw angle that the bone can look to.\n             */\n            get: function () {\n                return this._maxYaw;\n            },\n            set: function (value) {\n                this._maxYaw = value;\n                this._maxYawSin = Math.sin(value);\n                this._maxYawCos = Math.cos(value);\n                if (this._minYaw != null) {\n                    this._midYawConstraint = this._getAngleDiff(this._minYaw, this._maxYaw) * .5 + this._minYaw;\n                    this._yawRange = this._maxYaw - this._minYaw;\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BoneLookController.prototype, \"minPitch\", {\n            /**\n             * Get/set the minimum pitch angle that the bone can look to.\n             */\n            get: function () {\n                return this._minPitch;\n            },\n            set: function (value) {\n                this._minPitch = value;\n                this._minPitchTan = Math.tan(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(BoneLookController.prototype, \"maxPitch\", {\n            /**\n             * Get/set the maximum pitch angle that the bone can look to.\n             */\n            get: function () {\n                return this._maxPitch;\n            },\n            set: function (value) {\n                this._maxPitch = value;\n                this._maxPitchTan = Math.tan(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender()).\n         */\n        BoneLookController.prototype.update = function () {\n            //skip the first frame when slerping so that the mesh rotation is correct\n            if (this.slerpAmount < 1 && !this._firstFrameSkipped) {\n                this._firstFrameSkipped = true;\n                return;\n            }\n            var bone = this.bone;\n            var bonePos = BoneLookController._tmpVecs[0];\n            bone.getAbsolutePositionToRef(this.mesh, bonePos);\n            var target = this.target;\n            var _tmpMat1 = BoneLookController._tmpMats[0];\n            var _tmpMat2 = BoneLookController._tmpMats[1];\n            var mesh = this.mesh;\n            var parentBone = bone.getParent();\n            var upAxis = BoneLookController._tmpVecs[1];\n            upAxis.copyFrom(this.upAxis);\n            if (this.upAxisSpace == BABYLON.Space.BONE) {\n                if (this._transformYawPitch) {\n                    BABYLON.Vector3.TransformCoordinatesToRef(upAxis, this._transformYawPitchInv, upAxis);\n                }\n                parentBone.getDirectionToRef(upAxis, this.mesh, upAxis);\n            }\n            else if (this.upAxisSpace == BABYLON.Space.LOCAL) {\n                mesh.getDirectionToRef(upAxis, upAxis);\n                if (mesh.scaling.x != 1 || mesh.scaling.y != 1 || mesh.scaling.z != 1) {\n                    upAxis.normalize();\n                }\n            }\n            var checkYaw = false;\n            var checkPitch = false;\n            if (this._maxYaw != Math.PI || this._minYaw != -Math.PI) {\n                checkYaw = true;\n            }\n            if (this._maxPitch != Math.PI || this._minPitch != -Math.PI) {\n                checkPitch = true;\n            }\n            if (checkYaw || checkPitch) {\n                var spaceMat = BoneLookController._tmpMats[2];\n                var spaceMatInv = BoneLookController._tmpMats[3];\n                if (this.upAxisSpace == BABYLON.Space.BONE && upAxis.y == 1) {\n                    parentBone.getRotationMatrixToRef(BABYLON.Space.WORLD, this.mesh, spaceMat);\n                }\n                else if (this.upAxisSpace == BABYLON.Space.LOCAL && upAxis.y == 1 && !parentBone) {\n                    spaceMat.copyFrom(mesh.getWorldMatrix());\n                }\n                else {\n                    var forwardAxis = BoneLookController._tmpVecs[2];\n                    forwardAxis.copyFrom(this._fowardAxis);\n                    if (this._transformYawPitch) {\n                        BABYLON.Vector3.TransformCoordinatesToRef(forwardAxis, this._transformYawPitchInv, forwardAxis);\n                    }\n                    if (parentBone) {\n                        parentBone.getDirectionToRef(forwardAxis, this.mesh, forwardAxis);\n                    }\n                    else {\n                        mesh.getDirectionToRef(forwardAxis, forwardAxis);\n                    }\n                    var rightAxis = BABYLON.Vector3.Cross(upAxis, forwardAxis);\n                    rightAxis.normalize();\n                    var forwardAxis = BABYLON.Vector3.Cross(rightAxis, upAxis);\n                    BABYLON.Matrix.FromXYZAxesToRef(rightAxis, upAxis, forwardAxis, spaceMat);\n                }\n                spaceMat.invertToRef(spaceMatInv);\n                var xzlen;\n                if (checkPitch) {\n                    var localTarget = BoneLookController._tmpVecs[3];\n                    target.subtractToRef(bonePos, localTarget);\n                    BABYLON.Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n                    var xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                    var pitch = Math.atan2(localTarget.y, xzlen);\n                    var newPitch = pitch;\n                    if (pitch > this._maxPitch) {\n                        localTarget.y = this._maxPitchTan * xzlen;\n                        newPitch = this._maxPitch;\n                    }\n                    else if (pitch < this._minPitch) {\n                        localTarget.y = this._minPitchTan * xzlen;\n                        newPitch = this._minPitch;\n                    }\n                    if (pitch != newPitch) {\n                        BABYLON.Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n                        localTarget.addInPlace(bonePos);\n                        target = localTarget;\n                    }\n                }\n                if (checkYaw) {\n                    var localTarget = BoneLookController._tmpVecs[4];\n                    target.subtractToRef(bonePos, localTarget);\n                    BABYLON.Vector3.TransformCoordinatesToRef(localTarget, spaceMatInv, localTarget);\n                    var yaw = Math.atan2(localTarget.x, localTarget.z);\n                    var newYaw = yaw;\n                    if (yaw > this._maxYaw || yaw < this._minYaw) {\n                        if (xzlen == null) {\n                            xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                        }\n                        if (this._yawRange > Math.PI) {\n                            if (this._isAngleBetween(yaw, this._maxYaw, this._midYawConstraint)) {\n                                localTarget.z = this._maxYawCos * xzlen;\n                                localTarget.x = this._maxYawSin * xzlen;\n                                newYaw = this._maxYaw;\n                            }\n                            else if (this._isAngleBetween(yaw, this._midYawConstraint, this._minYaw)) {\n                                localTarget.z = this._minYawCos * xzlen;\n                                localTarget.x = this._minYawSin * xzlen;\n                                newYaw = this._minYaw;\n                            }\n                        }\n                        else {\n                            if (yaw > this._maxYaw) {\n                                localTarget.z = this._maxYawCos * xzlen;\n                                localTarget.x = this._maxYawSin * xzlen;\n                                newYaw = this._maxYaw;\n                            }\n                            else if (yaw < this._minYaw) {\n                                localTarget.z = this._minYawCos * xzlen;\n                                localTarget.x = this._minYawSin * xzlen;\n                                newYaw = this._minYaw;\n                            }\n                        }\n                    }\n                    if (this._slerping && this._yawRange > Math.PI) {\n                        //are we going to be crossing into the min/max region?\n                        var boneFwd = BoneLookController._tmpVecs[8];\n                        boneFwd.copyFrom(BABYLON.Axis.Z);\n                        if (this._transformYawPitch) {\n                            BABYLON.Vector3.TransformCoordinatesToRef(boneFwd, this._transformYawPitchInv, boneFwd);\n                        }\n                        var boneRotMat = BABYLON.BoneLookController._tmpMats[4];\n                        this._boneQuat.toRotationMatrix(boneRotMat);\n                        this.mesh.getWorldMatrix().multiplyToRef(boneRotMat, boneRotMat);\n                        BABYLON.Vector3.TransformCoordinatesToRef(boneFwd, boneRotMat, boneFwd);\n                        BABYLON.Vector3.TransformCoordinatesToRef(boneFwd, spaceMatInv, boneFwd);\n                        var boneYaw = Math.atan2(boneFwd.x, boneFwd.z);\n                        var angBtwTar = this._getAngleBetween(boneYaw, yaw);\n                        var angBtwMidYaw = this._getAngleBetween(boneYaw, this._midYawConstraint);\n                        if (angBtwTar > angBtwMidYaw) {\n                            if (xzlen == null) {\n                                xzlen = Math.sqrt(localTarget.x * localTarget.x + localTarget.z * localTarget.z);\n                            }\n                            var angBtwMax = this._getAngleBetween(boneYaw, this._maxYaw);\n                            var angBtwMin = this._getAngleBetween(boneYaw, this._minYaw);\n                            if (angBtwMin < angBtwMax) {\n                                newYaw = boneYaw + Math.PI * .75;\n                                localTarget.z = Math.cos(newYaw) * xzlen;\n                                localTarget.x = Math.sin(newYaw) * xzlen;\n                            }\n                            else {\n                                newYaw = boneYaw - Math.PI * .75;\n                                localTarget.z = Math.cos(newYaw) * xzlen;\n                                localTarget.x = Math.sin(newYaw) * xzlen;\n                            }\n                        }\n                    }\n                    if (yaw != newYaw) {\n                        BABYLON.Vector3.TransformCoordinatesToRef(localTarget, spaceMat, localTarget);\n                        localTarget.addInPlace(bonePos);\n                        target = localTarget;\n                    }\n                }\n            }\n            var zaxis = BoneLookController._tmpVecs[5];\n            var xaxis = BoneLookController._tmpVecs[6];\n            var yaxis = BoneLookController._tmpVecs[7];\n            var _tmpQuat = BoneLookController._tmpQuat;\n            target.subtractToRef(bonePos, zaxis);\n            zaxis.normalize();\n            BABYLON.Vector3.CrossToRef(upAxis, zaxis, xaxis);\n            xaxis.normalize();\n            BABYLON.Vector3.CrossToRef(zaxis, xaxis, yaxis);\n            yaxis.normalize();\n            BABYLON.Matrix.FromXYZAxesToRef(xaxis, yaxis, zaxis, _tmpMat1);\n            if (xaxis.x === 0 && xaxis.y === 0 && xaxis.z === 0) {\n                return;\n            }\n            if (yaxis.x === 0 && yaxis.y === 0 && yaxis.z === 0) {\n                return;\n            }\n            if (zaxis.x === 0 && zaxis.y === 0 && zaxis.z === 0) {\n                return;\n            }\n            if (this.adjustYaw || this.adjustPitch || this.adjustRoll) {\n                BABYLON.Matrix.RotationYawPitchRollToRef(this.adjustYaw, this.adjustPitch, this.adjustRoll, _tmpMat2);\n                _tmpMat2.multiplyToRef(_tmpMat1, _tmpMat1);\n            }\n            if (this.slerpAmount < 1) {\n                if (!this._slerping) {\n                    this.bone.getRotationQuaternionToRef(BABYLON.Space.WORLD, this.mesh, this._boneQuat);\n                }\n                if (this._transformYawPitch) {\n                    this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n                }\n                BABYLON.Quaternion.FromRotationMatrixToRef(_tmpMat1, _tmpQuat);\n                BABYLON.Quaternion.SlerpToRef(this._boneQuat, _tmpQuat, this.slerpAmount, this._boneQuat);\n                this.bone.setRotationQuaternion(this._boneQuat, BABYLON.Space.WORLD, this.mesh);\n                this._slerping = true;\n            }\n            else {\n                if (this._transformYawPitch) {\n                    this._transformYawPitch.multiplyToRef(_tmpMat1, _tmpMat1);\n                }\n                this.bone.setRotationMatrix(_tmpMat1, BABYLON.Space.WORLD, this.mesh);\n                this._slerping = false;\n            }\n        };\n        BoneLookController.prototype._getAngleDiff = function (ang1, ang2) {\n            var angDiff = ang2 - ang1;\n            angDiff %= Math.PI * 2;\n            if (angDiff > Math.PI) {\n                angDiff -= Math.PI * 2;\n            }\n            else if (angDiff < -Math.PI) {\n                angDiff += Math.PI * 2;\n            }\n            return angDiff;\n        };\n        BoneLookController.prototype._getAngleBetween = function (ang1, ang2) {\n            ang1 %= (2 * Math.PI);\n            ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;\n            ang2 %= (2 * Math.PI);\n            ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;\n            var ab = 0;\n            if (ang1 < ang2) {\n                ab = ang2 - ang1;\n            }\n            else {\n                ab = ang1 - ang2;\n            }\n            if (ab > Math.PI) {\n                ab = Math.PI * 2 - ab;\n            }\n            return ab;\n        };\n        BoneLookController.prototype._isAngleBetween = function (ang, ang1, ang2) {\n            ang %= (2 * Math.PI);\n            ang = (ang < 0) ? ang + (2 * Math.PI) : ang;\n            ang1 %= (2 * Math.PI);\n            ang1 = (ang1 < 0) ? ang1 + (2 * Math.PI) : ang1;\n            ang2 %= (2 * Math.PI);\n            ang2 = (ang2 < 0) ? ang2 + (2 * Math.PI) : ang2;\n            if (ang1 < ang2) {\n                if (ang > ang1 && ang < ang2) {\n                    return true;\n                }\n            }\n            else {\n                if (ang > ang2 && ang < ang1) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        return BoneLookController;\n    }());\n    BoneLookController._tmpVecs = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n    BoneLookController._tmpQuat = BABYLON.Quaternion.Identity();\n    BoneLookController._tmpMats = [BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity(), BABYLON.Matrix.Identity()];\n    BABYLON.BoneLookController = BoneLookController;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boneLookController.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Skeleton = (function () {\n        function Skeleton(name, id, scene) {\n            this.name = name;\n            this.id = id;\n            this.bones = new Array();\n            this.needInitialSkinMatrix = false;\n            this._isDirty = true;\n            this._meshesWithPoseMatrix = new Array();\n            this._identity = BABYLON.Matrix.Identity();\n            this._ranges = {};\n            this._lastAbsoluteTransformsUpdateId = -1;\n            // Events\n            /**\n             * An event triggered before computing the skeleton's matrices\n             * @type {BABYLON.Observable}\n             */\n            this.onBeforeComputeObservable = new BABYLON.Observable();\n            this.bones = [];\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            scene.skeletons.push(this);\n            //make sure it will recalculate the matrix next time prepare is called.\n            this._isDirty = true;\n        }\n        // Members\n        Skeleton.prototype.getTransformMatrices = function (mesh) {\n            if (this.needInitialSkinMatrix && mesh._bonesTransformMatrices) {\n                return mesh._bonesTransformMatrices;\n            }\n            if (!this._transformMatrices) {\n                this.prepare();\n            }\n            return this._transformMatrices;\n        };\n        Skeleton.prototype.getScene = function () {\n            return this._scene;\n        };\n        // Methods\n        /**\n         * @param {boolean} fullDetails - support for multiple levels of logging within scene loading\n         */\n        Skeleton.prototype.toString = function (fullDetails) {\n            var ret = \"Name: \" + this.name + \", nBones: \" + this.bones.length;\n            ret += \", nAnimationRanges: \" + (this._ranges ? Object.keys(this._ranges).length : \"none\");\n            if (fullDetails) {\n                ret += \", Ranges: {\";\n                var first = true;\n                for (var name_1 in this._ranges) {\n                    if (first) {\n                        ret += \", \";\n                        first = false;\n                    }\n                    ret += name_1;\n                }\n                ret += \"}\";\n            }\n            return ret;\n        };\n        /**\n        * Get bone's index searching by name\n        * @param {string} name is bone's name to search for\n        * @return {number} Indice of the bone. Returns -1 if not found\n        */\n        Skeleton.prototype.getBoneIndexByName = function (name) {\n            for (var boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n                if (this.bones[boneIndex].name === name) {\n                    return boneIndex;\n                }\n            }\n            return -1;\n        };\n        Skeleton.prototype.createAnimationRange = function (name, from, to) {\n            // check name not already in use\n            if (!this._ranges[name]) {\n                this._ranges[name] = new BABYLON.AnimationRange(name, from, to);\n                for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n                    if (this.bones[i].animations[0]) {\n                        this.bones[i].animations[0].createRange(name, from, to);\n                    }\n                }\n            }\n        };\n        Skeleton.prototype.deleteAnimationRange = function (name, deleteFrames) {\n            if (deleteFrames === void 0) { deleteFrames = true; }\n            for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].deleteRange(name, deleteFrames);\n                }\n            }\n            this._ranges[name] = undefined; // said much faster than 'delete this._range[name]' \n        };\n        Skeleton.prototype.getAnimationRange = function (name) {\n            return this._ranges[name];\n        };\n        /**\n         *  Returns as an Array, all AnimationRanges defined on this skeleton\n         */\n        Skeleton.prototype.getAnimationRanges = function () {\n            var animationRanges = [];\n            var name;\n            var i = 0;\n            for (name in this._ranges) {\n                animationRanges[i] = this._ranges[name];\n                i++;\n            }\n            return animationRanges;\n        };\n        /**\n         *  note: This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n         */\n        Skeleton.prototype.copyAnimationRange = function (source, name, rescaleAsRequired) {\n            if (rescaleAsRequired === void 0) { rescaleAsRequired = false; }\n            if (this._ranges[name] || !source.getAnimationRange(name)) {\n                return false;\n            }\n            var ret = true;\n            var frameOffset = this._getHighestAnimationFrame() + 1;\n            // make a dictionary of source skeleton's bones, so exact same order or doublely nested loop is not required\n            var boneDict = {};\n            var sourceBones = source.bones;\n            var nBones;\n            var i;\n            for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n                boneDict[sourceBones[i].name] = sourceBones[i];\n            }\n            if (this.bones.length !== sourceBones.length) {\n                BABYLON.Tools.Warn(\"copyAnimationRange: this rig has \" + this.bones.length + \" bones, while source as \" + sourceBones.length);\n                ret = false;\n            }\n            var skelDimensionsRatio = (rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest) ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n            for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n                var boneName = this.bones[i].name;\n                var sourceBone = boneDict[boneName];\n                if (sourceBone) {\n                    ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n                }\n                else {\n                    BABYLON.Tools.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                    ret = false;\n                }\n            }\n            // do not call createAnimationRange(), since it also is done to bones, which was already done\n            var range = source.getAnimationRange(name);\n            this._ranges[name] = new BABYLON.AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n            return ret;\n        };\n        Skeleton.prototype.returnToRest = function () {\n            for (var index = 0; index < this.bones.length; index++) {\n                this.bones[index].returnToRest();\n            }\n        };\n        Skeleton.prototype._getHighestAnimationFrame = function () {\n            var ret = 0;\n            for (var i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    var highest = this.bones[i].animations[0].getHighestFrame();\n                    if (ret < highest) {\n                        ret = highest;\n                    }\n                }\n            }\n            return ret;\n        };\n        Skeleton.prototype.beginAnimation = function (name, loop, speedRatio, onAnimationEnd) {\n            var range = this.getAnimationRange(name);\n            if (!range) {\n                return null;\n            }\n            return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n        };\n        Skeleton.prototype._markAsDirty = function () {\n            this._isDirty = true;\n        };\n        Skeleton.prototype._registerMeshWithPoseMatrix = function (mesh) {\n            this._meshesWithPoseMatrix.push(mesh);\n        };\n        Skeleton.prototype._unregisterMeshWithPoseMatrix = function (mesh) {\n            var index = this._meshesWithPoseMatrix.indexOf(mesh);\n            if (index > -1) {\n                this._meshesWithPoseMatrix.splice(index, 1);\n            }\n        };\n        Skeleton.prototype._computeTransformMatrices = function (targetMatrix, initialSkinMatrix) {\n            this.onBeforeComputeObservable.notifyObservers(this);\n            for (var index = 0; index < this.bones.length; index++) {\n                var bone = this.bones[index];\n                var parentBone = bone.getParent();\n                if (parentBone) {\n                    bone.getLocalMatrix().multiplyToRef(parentBone.getWorldMatrix(), bone.getWorldMatrix());\n                }\n                else {\n                    if (initialSkinMatrix) {\n                        bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getWorldMatrix());\n                    }\n                    else {\n                        bone.getWorldMatrix().copyFrom(bone.getLocalMatrix());\n                    }\n                }\n                bone.getInvertedAbsoluteTransform().multiplyToArray(bone.getWorldMatrix(), targetMatrix, index * 16);\n            }\n            this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n        };\n        Skeleton.prototype.prepare = function () {\n            if (!this._isDirty) {\n                return;\n            }\n            if (this.needInitialSkinMatrix) {\n                for (var index = 0; index < this._meshesWithPoseMatrix.length; index++) {\n                    var mesh = this._meshesWithPoseMatrix[index];\n                    var poseMatrix = mesh.getPoseMatrix();\n                    if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                        mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    }\n                    if (this._synchronizedWithMesh !== mesh) {\n                        this._synchronizedWithMesh = mesh;\n                        // Prepare bones\n                        for (var boneIndex = 0; boneIndex < this.bones.length; boneIndex++) {\n                            var bone = this.bones[boneIndex];\n                            if (!bone.getParent()) {\n                                var matrix = bone.getBaseMatrix();\n                                matrix.multiplyToRef(poseMatrix, BABYLON.Tmp.Matrix[1]);\n                                bone._updateDifferenceMatrix(BABYLON.Tmp.Matrix[1]);\n                            }\n                        }\n                    }\n                    this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                }\n            }\n            else {\n                if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                }\n                this._computeTransformMatrices(this._transformMatrices, null);\n            }\n            this._isDirty = false;\n            this._scene._activeBones.addCount(this.bones.length, false);\n        };\n        Skeleton.prototype.getAnimatables = function () {\n            if (!this._animatables || this._animatables.length !== this.bones.length) {\n                this._animatables = [];\n                for (var index = 0; index < this.bones.length; index++) {\n                    this._animatables.push(this.bones[index]);\n                }\n            }\n            return this._animatables;\n        };\n        Skeleton.prototype.clone = function (name, id) {\n            var result = new Skeleton(name, id || name, this._scene);\n            result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n            for (var index = 0; index < this.bones.length; index++) {\n                var source = this.bones[index];\n                var parentBone = null;\n                if (source.getParent()) {\n                    var parentIndex = this.bones.indexOf(source.getParent());\n                    parentBone = result.bones[parentIndex];\n                }\n                var bone = new BABYLON.Bone(source.name, result, parentBone, source.getBaseMatrix().clone(), source.getRestPose().clone());\n                BABYLON.Tools.DeepCopy(source.animations, bone.animations);\n            }\n            if (this._ranges) {\n                result._ranges = {};\n                for (var rangeName in this._ranges) {\n                    result._ranges[rangeName] = this._ranges[rangeName].clone();\n                }\n            }\n            this._isDirty = true;\n            return result;\n        };\n        Skeleton.prototype.enableBlending = function (blendingSpeed) {\n            if (blendingSpeed === void 0) { blendingSpeed = 0.01; }\n            this.bones.forEach(function (bone) {\n                bone.animations.forEach(function (animation) {\n                    animation.enableBlending = true;\n                    animation.blendingSpeed = blendingSpeed;\n                });\n            });\n        };\n        Skeleton.prototype.dispose = function () {\n            this._meshesWithPoseMatrix = [];\n            // Animations\n            this.getScene().stopAnimation(this);\n            // Remove from scene\n            this.getScene().removeSkeleton(this);\n        };\n        Skeleton.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.id = this.id;\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest;\n            serializationObject.bones = [];\n            serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n            for (var index = 0; index < this.bones.length; index++) {\n                var bone = this.bones[index];\n                var serializedBone = {\n                    parentBoneIndex: bone.getParent() ? this.bones.indexOf(bone.getParent()) : -1,\n                    name: bone.name,\n                    matrix: bone.getBaseMatrix().toArray(),\n                    rest: bone.getRestPose().toArray()\n                };\n                serializationObject.bones.push(serializedBone);\n                if (bone.length) {\n                    serializedBone.length = bone.length;\n                }\n                if (bone.animations && bone.animations.length > 0) {\n                    serializedBone.animation = bone.animations[0].serialize();\n                }\n                serializationObject.ranges = [];\n                for (var name in this._ranges) {\n                    var range = {};\n                    range.name = name;\n                    range.from = this._ranges[name].from;\n                    range.to = this._ranges[name].to;\n                    serializationObject.ranges.push(range);\n                }\n            }\n            return serializationObject;\n        };\n        Skeleton.Parse = function (parsedSkeleton, scene) {\n            var skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n            if (parsedSkeleton.dimensionsAtRest) {\n                skeleton.dimensionsAtRest = BABYLON.Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n            }\n            skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n            var index;\n            for (index = 0; index < parsedSkeleton.bones.length; index++) {\n                var parsedBone = parsedSkeleton.bones[index];\n                var parentBone = null;\n                if (parsedBone.parentBoneIndex > -1) {\n                    parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n                }\n                var rest = parsedBone.rest ? BABYLON.Matrix.FromArray(parsedBone.rest) : null;\n                var bone = new BABYLON.Bone(parsedBone.name, skeleton, parentBone, BABYLON.Matrix.FromArray(parsedBone.matrix), rest);\n                if (parsedBone.length) {\n                    bone.length = parsedBone.length;\n                }\n                if (parsedBone.animation) {\n                    bone.animations.push(BABYLON.Animation.Parse(parsedBone.animation));\n                }\n            }\n            // placed after bones, so createAnimationRange can cascade down\n            if (parsedSkeleton.ranges) {\n                for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                    var data = parsedSkeleton.ranges[index];\n                    skeleton.createAnimationRange(data.name, data.from, data.to);\n                }\n            }\n            return skeleton;\n        };\n        Skeleton.prototype.computeAbsoluteTransforms = function (forceUpdate) {\n            if (forceUpdate === void 0) { forceUpdate = false; }\n            var renderId = this._scene.getRenderId();\n            if (this._lastAbsoluteTransformsUpdateId != renderId || forceUpdate) {\n                this.bones[0].computeAbsoluteTransforms();\n                this._lastAbsoluteTransformsUpdateId = renderId;\n            }\n        };\n        Skeleton.prototype.getPoseMatrix = function () {\n            var poseMatrix;\n            if (this._meshesWithPoseMatrix.length > 0) {\n                poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n            }\n            return poseMatrix;\n        };\n        return Skeleton;\n    }());\n    BABYLON.Skeleton = Skeleton;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.skeleton.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SphericalPolynomial = (function () {\n        function SphericalPolynomial() {\n            this.x = BABYLON.Vector3.Zero();\n            this.y = BABYLON.Vector3.Zero();\n            this.z = BABYLON.Vector3.Zero();\n            this.xx = BABYLON.Vector3.Zero();\n            this.yy = BABYLON.Vector3.Zero();\n            this.zz = BABYLON.Vector3.Zero();\n            this.xy = BABYLON.Vector3.Zero();\n            this.yz = BABYLON.Vector3.Zero();\n            this.zx = BABYLON.Vector3.Zero();\n        }\n        SphericalPolynomial.prototype.addAmbient = function (color) {\n            var colorVector = new BABYLON.Vector3(color.r, color.g, color.b);\n            this.xx = this.xx.add(colorVector);\n            this.yy = this.yy.add(colorVector);\n            this.zz = this.zz.add(colorVector);\n        };\n        SphericalPolynomial.getSphericalPolynomialFromHarmonics = function (harmonics) {\n            var result = new SphericalPolynomial();\n            result.x = harmonics.L11.scale(1.02333);\n            result.y = harmonics.L1_1.scale(1.02333);\n            result.z = harmonics.L10.scale(1.02333);\n            result.xx = harmonics.L00.scale(0.886277).subtract(harmonics.L20.scale(0.247708)).add(harmonics.L22.scale(0.429043));\n            result.yy = harmonics.L00.scale(0.886277).subtract(harmonics.L20.scale(0.247708)).subtract(harmonics.L22.scale(0.429043));\n            result.zz = harmonics.L00.scale(0.886277).add(harmonics.L20.scale(0.495417));\n            result.yz = harmonics.L2_1.scale(0.858086);\n            result.zx = harmonics.L21.scale(0.858086);\n            result.xy = harmonics.L2_2.scale(0.858086);\n            result.scale(1.0 / Math.PI);\n            return result;\n        };\n        SphericalPolynomial.prototype.scale = function (scale) {\n            this.x = this.x.scale(scale);\n            this.y = this.y.scale(scale);\n            this.z = this.z.scale(scale);\n            this.xx = this.xx.scale(scale);\n            this.yy = this.yy.scale(scale);\n            this.zz = this.zz.scale(scale);\n            this.yz = this.yz.scale(scale);\n            this.zx = this.zx.scale(scale);\n            this.xy = this.xy.scale(scale);\n        };\n        return SphericalPolynomial;\n    }());\n    BABYLON.SphericalPolynomial = SphericalPolynomial;\n    var SphericalHarmonics = (function () {\n        function SphericalHarmonics() {\n            this.L00 = BABYLON.Vector3.Zero();\n            this.L1_1 = BABYLON.Vector3.Zero();\n            this.L10 = BABYLON.Vector3.Zero();\n            this.L11 = BABYLON.Vector3.Zero();\n            this.L2_2 = BABYLON.Vector3.Zero();\n            this.L2_1 = BABYLON.Vector3.Zero();\n            this.L20 = BABYLON.Vector3.Zero();\n            this.L21 = BABYLON.Vector3.Zero();\n            this.L22 = BABYLON.Vector3.Zero();\n        }\n        SphericalHarmonics.prototype.addLight = function (direction, color, deltaSolidAngle) {\n            var colorVector = new BABYLON.Vector3(color.r, color.g, color.b);\n            var c = colorVector.scale(deltaSolidAngle);\n            this.L00 = this.L00.add(c.scale(0.282095));\n            this.L1_1 = this.L1_1.add(c.scale(0.488603 * direction.y));\n            this.L10 = this.L10.add(c.scale(0.488603 * direction.z));\n            this.L11 = this.L11.add(c.scale(0.488603 * direction.x));\n            this.L2_2 = this.L2_2.add(c.scale(1.092548 * direction.x * direction.y));\n            this.L2_1 = this.L2_1.add(c.scale(1.092548 * direction.y * direction.z));\n            this.L21 = this.L21.add(c.scale(1.092548 * direction.x * direction.z));\n            this.L20 = this.L20.add(c.scale(0.315392 * (3.0 * direction.z * direction.z - 1.0)));\n            this.L22 = this.L22.add(c.scale(0.546274 * (direction.x * direction.x - direction.y * direction.y)));\n        };\n        SphericalHarmonics.prototype.scale = function (scale) {\n            this.L00 = this.L00.scale(scale);\n            this.L1_1 = this.L1_1.scale(scale);\n            this.L10 = this.L10.scale(scale);\n            this.L11 = this.L11.scale(scale);\n            this.L2_2 = this.L2_2.scale(scale);\n            this.L2_1 = this.L2_1.scale(scale);\n            this.L20 = this.L20.scale(scale);\n            this.L21 = this.L21.scale(scale);\n            this.L22 = this.L22.scale(scale);\n        };\n        SphericalHarmonics.prototype.convertIncidentRadianceToIrradiance = function () {\n            // Convert from incident radiance (Li) to irradiance (E) by applying convolution with the cosine-weighted hemisphere.\n            //\n            //      E_lm = A_l * L_lm\n            // \n            // In spherical harmonics this convolution amounts to scaling factors for each frequency band.\n            // This corresponds to equation 5 in \"An Efficient Representation for Irradiance Environment Maps\", where\n            // the scaling factors are given in equation 9.\n            // Constant (Band 0)\n            this.L00 = this.L00.scale(3.141593);\n            // Linear (Band 1)\n            this.L1_1 = this.L1_1.scale(2.094395);\n            this.L10 = this.L10.scale(2.094395);\n            this.L11 = this.L11.scale(2.094395);\n            // Quadratic (Band 2)\n            this.L2_2 = this.L2_2.scale(0.785398);\n            this.L2_1 = this.L2_1.scale(0.785398);\n            this.L20 = this.L20.scale(0.785398);\n            this.L21 = this.L21.scale(0.785398);\n            this.L22 = this.L22.scale(0.785398);\n        };\n        SphericalHarmonics.prototype.convertIrradianceToLambertianRadiance = function () {\n            // Convert from irradiance to outgoing radiance for Lambertian BDRF, suitable for efficient shader evaluation.\n            //      L = (1/pi) * E * rho\n            // \n            // This is done by an additional scale by 1/pi, so is a fairly trivial operation but important conceptually.\n            this.scale(1.0 / Math.PI);\n            // The resultant SH now represents outgoing radiance, so includes the Lambert 1/pi normalisation factor but without albedo (rho) applied\n            // (The pixel shader must apply albedo after texture fetches, etc).\n        };\n        SphericalHarmonics.getsphericalHarmonicsFromPolynomial = function (polynomial) {\n            var result = new SphericalHarmonics();\n            result.L00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));\n            result.L1_1 = polynomial.y.scale(0.977204);\n            result.L10 = polynomial.z.scale(0.977204);\n            result.L11 = polynomial.x.scale(0.977204);\n            result.L2_2 = polynomial.xy.scale(1.16538);\n            result.L2_1 = polynomial.yz.scale(1.16538);\n            result.L20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));\n            result.L21 = polynomial.zx.scale(1.16538);\n            result.L22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));\n            result.scale(Math.PI);\n            return result;\n        };\n        return SphericalHarmonics;\n    }());\n    BABYLON.SphericalHarmonics = SphericalHarmonics;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sphericalPolynomial.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var FileFaceOrientation = (function () {\n            function FileFaceOrientation(name, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {\n                this.name = name;\n                this.worldAxisForNormal = worldAxisForNormal;\n                this.worldAxisForFileX = worldAxisForFileX;\n                this.worldAxisForFileY = worldAxisForFileY;\n            }\n            return FileFaceOrientation;\n        }());\n        ;\n        /**\n         * Helper class dealing with the extraction of spherical polynomial dataArray\n         * from a cube map.\n         */\n        var CubeMapToSphericalPolynomialTools = (function () {\n            function CubeMapToSphericalPolynomialTools() {\n            }\n            /**\n             * Converts a texture to the according Spherical Polynomial data.\n             * This extracts the first 3 orders only as they are the only one used in the lighting.\n             *\n             * @param texture The texture to extract the information from.\n             * @return The Spherical Polynomial data.\n             */\n            CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial = function (texture) {\n                if (!texture.isCube) {\n                    // Only supports cube Textures currently.\n                    return null;\n                }\n                var size = texture.getSize().width;\n                var right = texture.readPixels(0);\n                var left = texture.readPixels(1);\n                var up = texture.readPixels(2);\n                var down = texture.readPixels(3);\n                var front = texture.readPixels(4);\n                var back = texture.readPixels(5);\n                var gammaSpace = texture.gammaSpace;\n                // Always read as RGBA.\n                var format = BABYLON.Engine.TEXTUREFORMAT_RGBA;\n                var type = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                if (texture.textureType && texture.textureType !== BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT) {\n                    type = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                }\n                var cubeInfo = {\n                    size: size,\n                    right: right,\n                    left: left,\n                    up: up,\n                    down: down,\n                    front: front,\n                    back: back,\n                    format: format,\n                    type: type,\n                    gammaSpace: gammaSpace,\n                };\n                return this.ConvertCubeMapToSphericalPolynomial(cubeInfo);\n            };\n            /**\n             * Converts a cubemap to the according Spherical Polynomial data.\n             * This extracts the first 3 orders only as they are the only one used in the lighting.\n             *\n             * @param cubeInfo The Cube map to extract the information from.\n             * @return The Spherical Polynomial data.\n             */\n            CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial = function (cubeInfo) {\n                var sphericalHarmonics = new BABYLON.SphericalHarmonics();\n                var totalSolidAngle = 0.0;\n                // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\n                var du = 2.0 / cubeInfo.size;\n                var dv = du;\n                // The (u,v) of the first texel is half a texel from the corner (-1,-1).\n                var minUV = du * 0.5 - 1.0;\n                for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n                    var fileFace = this.FileFaces[faceIndex];\n                    var dataArray = cubeInfo[fileFace.name];\n                    var v = minUV;\n                    // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\n                    // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\n                    // Because SP is still linear, so summation is fine in that basis.\n                    var stride = cubeInfo.format === BABYLON.Engine.TEXTUREFORMAT_RGBA ? 4 : 3;\n                    for (var y = 0; y < cubeInfo.size; y++) {\n                        var u = minUV;\n                        for (var x = 0; x < cubeInfo.size; x++) {\n                            // World direction (not normalised)\n                            var worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\n                            worldDirection.normalize();\n                            var deltaSolidAngle = Math.pow(1.0 + u * u + v * v, -3.0 / 2.0);\n                            var r = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 0];\n                            var g = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 1];\n                            var b = dataArray[(y * cubeInfo.size * stride) + (x * stride) + 2];\n                            // Handle Integer types.\n                            if (cubeInfo.type === BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT) {\n                                r /= 255;\n                                g /= 255;\n                                b /= 255;\n                            }\n                            // Handle Gamma space textures.\n                            if (cubeInfo.gammaSpace) {\n                                r = Math.pow(BABYLON.MathTools.Clamp(r), BABYLON.ToLinearSpace);\n                                g = Math.pow(BABYLON.MathTools.Clamp(g), BABYLON.ToLinearSpace);\n                                b = Math.pow(BABYLON.MathTools.Clamp(b), BABYLON.ToLinearSpace);\n                            }\n                            var color = new BABYLON.Color3(r, g, b);\n                            sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\n                            totalSolidAngle += deltaSolidAngle;\n                            u += du;\n                        }\n                        v += dv;\n                    }\n                }\n                // Solid angle for entire sphere is 4*pi\n                var sphereSolidAngle = 4.0 * Math.PI;\n                // Adjust the solid angle to allow for how many faces we processed.\n                var facesProcessed = 6.0;\n                var expectedSolidAngle = sphereSolidAngle * facesProcessed / 6.0;\n                // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle. \n                // This is needed because the numerical integration over the cube uses a \n                // small angle approximation of solid angle for each texel (see deltaSolidAngle),\n                // and also to compensate for accumulative error due to float precision in the summation.\n                var correctionFactor = expectedSolidAngle / totalSolidAngle;\n                sphericalHarmonics.scale(correctionFactor);\n                sphericalHarmonics.convertIncidentRadianceToIrradiance();\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\n                return BABYLON.SphericalPolynomial.getSphericalPolynomialFromHarmonics(sphericalHarmonics);\n            };\n            return CubeMapToSphericalPolynomialTools;\n        }());\n        CubeMapToSphericalPolynomialTools.FileFaces = [\n            new FileFaceOrientation(\"right\", new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(0, 0, -1), new BABYLON.Vector3(0, -1, 0)),\n            new FileFaceOrientation(\"left\", new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(0, 0, 1), new BABYLON.Vector3(0, -1, 0)),\n            new FileFaceOrientation(\"up\", new BABYLON.Vector3(0, 1, 0), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(0, 0, 1)),\n            new FileFaceOrientation(\"down\", new BABYLON.Vector3(0, -1, 0), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(0, 0, -1)),\n            new FileFaceOrientation(\"front\", new BABYLON.Vector3(0, 0, 1), new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(0, -1, 0)),\n            new FileFaceOrientation(\"back\", new BABYLON.Vector3(0, 0, -1), new BABYLON.Vector3(-1, 0, 0), new BABYLON.Vector3(0, -1, 0)) // -Z bottom\n        ];\n        Internals.CubeMapToSphericalPolynomialTools = CubeMapToSphericalPolynomialTools;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.cubemapToSphericalPolynomial.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        /**\n         * Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.\n         */\n        var PanoramaToCubeMapTools = (function () {\n            function PanoramaToCubeMapTools() {\n            }\n            /**\n             * Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).\n             *\n             * @param float32Array The source data.\n             * @param inputWidth The width of the input panorama.\n             * @param inputhHeight The height of the input panorama.\n             * @param size The willing size of the generated cubemap (each faces will be size * size pixels)\n             * @return The cubemap data\n             */\n            PanoramaToCubeMapTools.ConvertPanoramaToCubemap = function (float32Array, inputWidth, inputHeight, size) {\n                if (!float32Array) {\n                    throw \"ConvertPanoramaToCubemap: input cannot be null\";\n                }\n                if (float32Array.length != inputWidth * inputHeight * 3) {\n                    throw \"ConvertPanoramaToCubemap: input size is wrong\";\n                }\n                var textureFront = this.CreateCubemapTexture(size, this.FACE_FRONT, float32Array, inputWidth, inputHeight);\n                var textureBack = this.CreateCubemapTexture(size, this.FACE_BACK, float32Array, inputWidth, inputHeight);\n                var textureLeft = this.CreateCubemapTexture(size, this.FACE_LEFT, float32Array, inputWidth, inputHeight);\n                var textureRight = this.CreateCubemapTexture(size, this.FACE_RIGHT, float32Array, inputWidth, inputHeight);\n                var textureUp = this.CreateCubemapTexture(size, this.FACE_UP, float32Array, inputWidth, inputHeight);\n                var textureDown = this.CreateCubemapTexture(size, this.FACE_DOWN, float32Array, inputWidth, inputHeight);\n                return {\n                    front: textureFront,\n                    back: textureBack,\n                    left: textureLeft,\n                    right: textureRight,\n                    up: textureUp,\n                    down: textureDown,\n                    size: size,\n                    type: BABYLON.Engine.TEXTURETYPE_FLOAT,\n                    format: BABYLON.Engine.TEXTUREFORMAT_RGB,\n                    gammaSpace: false,\n                };\n            };\n            PanoramaToCubeMapTools.CreateCubemapTexture = function (texSize, faceData, float32Array, inputWidth, inputHeight) {\n                var buffer = new ArrayBuffer(texSize * texSize * 4 * 3);\n                var textureArray = new Float32Array(buffer);\n                var rotDX1 = faceData[1].subtract(faceData[0]).scale(1 / texSize);\n                var rotDX2 = faceData[3].subtract(faceData[2]).scale(1 / texSize);\n                var dy = 1 / texSize;\n                var fy = 0;\n                for (var y = 0; y < texSize; y++) {\n                    var xv1 = faceData[0];\n                    var xv2 = faceData[2];\n                    for (var x = 0; x < texSize; x++) {\n                        var v = xv2.subtract(xv1).scale(fy).add(xv1);\n                        v.normalize();\n                        var color = this.CalcProjectionSpherical(v, float32Array, inputWidth, inputHeight);\n                        // 3 channels per pixels\n                        textureArray[y * texSize * 3 + (x * 3) + 0] = color.r;\n                        textureArray[y * texSize * 3 + (x * 3) + 1] = color.g;\n                        textureArray[y * texSize * 3 + (x * 3) + 2] = color.b;\n                        xv1 = xv1.add(rotDX1);\n                        xv2 = xv2.add(rotDX2);\n                    }\n                    fy += dy;\n                }\n                return textureArray;\n            };\n            PanoramaToCubeMapTools.CalcProjectionSpherical = function (vDir, float32Array, inputWidth, inputHeight) {\n                var theta = Math.atan2(vDir.z, vDir.x);\n                var phi = Math.acos(vDir.y);\n                while (theta < -Math.PI)\n                    theta += 2 * Math.PI;\n                while (theta > Math.PI)\n                    theta -= 2 * Math.PI;\n                var dx = theta / Math.PI;\n                var dy = phi / Math.PI;\n                // recenter.\n                dx = dx * 0.5 + 0.5;\n                var px = Math.round(dx * inputWidth);\n                if (px < 0)\n                    px = 0;\n                else if (px >= inputWidth)\n                    px = inputWidth - 1;\n                var py = Math.round(dy * inputHeight);\n                if (py < 0)\n                    py = 0;\n                else if (py >= inputHeight)\n                    py = inputHeight - 1;\n                var inputY = (inputHeight - py - 1);\n                var r = float32Array[inputY * inputWidth * 3 + (px * 3) + 0];\n                var g = float32Array[inputY * inputWidth * 3 + (px * 3) + 1];\n                var b = float32Array[inputY * inputWidth * 3 + (px * 3) + 2];\n                return {\n                    r: r,\n                    g: g,\n                    b: b\n                };\n            };\n            return PanoramaToCubeMapTools;\n        }());\n        PanoramaToCubeMapTools.FACE_FRONT = [\n            new BABYLON.Vector3(-1.0, -1.0, -1.0),\n            new BABYLON.Vector3(1.0, -1.0, -1.0),\n            new BABYLON.Vector3(-1.0, 1.0, -1.0),\n            new BABYLON.Vector3(1.0, 1.0, -1.0)\n        ];\n        PanoramaToCubeMapTools.FACE_BACK = [\n            new BABYLON.Vector3(1.0, -1.0, 1.0),\n            new BABYLON.Vector3(-1.0, -1.0, 1.0),\n            new BABYLON.Vector3(1.0, 1.0, 1.0),\n            new BABYLON.Vector3(-1.0, 1.0, 1.0)\n        ];\n        PanoramaToCubeMapTools.FACE_RIGHT = [\n            new BABYLON.Vector3(1.0, -1.0, -1.0),\n            new BABYLON.Vector3(1.0, -1.0, 1.0),\n            new BABYLON.Vector3(1.0, 1.0, -1.0),\n            new BABYLON.Vector3(1.0, 1.0, 1.0)\n        ];\n        PanoramaToCubeMapTools.FACE_LEFT = [\n            new BABYLON.Vector3(-1.0, -1.0, 1.0),\n            new BABYLON.Vector3(-1.0, -1.0, -1.0),\n            new BABYLON.Vector3(-1.0, 1.0, 1.0),\n            new BABYLON.Vector3(-1.0, 1.0, -1.0)\n        ];\n        PanoramaToCubeMapTools.FACE_DOWN = [\n            new BABYLON.Vector3(-1.0, 1.0, -1.0),\n            new BABYLON.Vector3(1.0, 1.0, -1.0),\n            new BABYLON.Vector3(-1.0, 1.0, 1.0),\n            new BABYLON.Vector3(1.0, 1.0, 1.0)\n        ];\n        PanoramaToCubeMapTools.FACE_UP = [\n            new BABYLON.Vector3(-1.0, -1.0, 1.0),\n            new BABYLON.Vector3(1.0, -1.0, 1.0),\n            new BABYLON.Vector3(-1.0, -1.0, -1.0),\n            new BABYLON.Vector3(1.0, -1.0, -1.0)\n        ];\n        Internals.PanoramaToCubeMapTools = PanoramaToCubeMapTools;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.panoramaToCubemap.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        ;\n        /**\n         * This groups tools to convert HDR texture to native colors array.\n         */\n        var HDRTools = (function () {\n            function HDRTools() {\n            }\n            HDRTools.Ldexp = function (mantissa, exponent) {\n                if (exponent > 1023) {\n                    return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);\n                }\n                if (exponent < -1074) {\n                    return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);\n                }\n                return mantissa * Math.pow(2, exponent);\n            };\n            HDRTools.Rgbe2float = function (float32array, red, green, blue, exponent, index) {\n                if (exponent > 0) {\n                    exponent = this.Ldexp(1.0, exponent - (128 + 8));\n                    float32array[index + 0] = red * exponent;\n                    float32array[index + 1] = green * exponent;\n                    float32array[index + 2] = blue * exponent;\n                }\n                else {\n                    float32array[index + 0] = 0;\n                    float32array[index + 1] = 0;\n                    float32array[index + 2] = 0;\n                }\n            };\n            HDRTools.readStringLine = function (uint8array, startIndex) {\n                var line = \"\";\n                var character = \"\";\n                for (var i = startIndex; i < uint8array.length - startIndex; i++) {\n                    character = String.fromCharCode(uint8array[i]);\n                    if (character == \"\\n\") {\n                        break;\n                    }\n                    line += character;\n                }\n                return line;\n            };\n            /**\n             * Reads header information from an RGBE texture stored in a native array.\n             * More information on this format are available here:\n             * https://en.wikipedia.org/wiki/RGBE_image_format\n             *\n             * @param uint8array The binary file stored in  native array.\n             * @return The header information.\n             */\n            HDRTools.RGBE_ReadHeader = function (uint8array) {\n                var height = 0;\n                var width = 0;\n                var line = this.readStringLine(uint8array, 0);\n                if (line[0] != '#' || line[1] != '?') {\n                    throw \"Bad HDR Format.\";\n                }\n                var endOfHeader = false;\n                var findFormat = false;\n                var lineIndex = 0;\n                do {\n                    lineIndex += (line.length + 1);\n                    line = this.readStringLine(uint8array, lineIndex);\n                    if (line == \"FORMAT=32-bit_rle_rgbe\") {\n                        findFormat = true;\n                    }\n                    else if (line.length == 0) {\n                        endOfHeader = true;\n                    }\n                } while (!endOfHeader);\n                if (!findFormat) {\n                    throw \"HDR Bad header format, unsupported FORMAT\";\n                }\n                lineIndex += (line.length + 1);\n                line = this.readStringLine(uint8array, lineIndex);\n                var sizeRegexp = /^\\-Y (.*) \\+X (.*)$/g;\n                var match = sizeRegexp.exec(line);\n                // TODO. Support +Y and -X if needed.\n                if (match.length < 3) {\n                    throw \"HDR Bad header format, no size\";\n                }\n                width = parseInt(match[2]);\n                height = parseInt(match[1]);\n                if (width < 8 || width > 0x7fff) {\n                    throw \"HDR Bad header format, unsupported size\";\n                }\n                lineIndex += (line.length + 1);\n                return {\n                    height: height,\n                    width: width,\n                    dataPosition: lineIndex\n                };\n            };\n            /**\n             * Returns the cubemap information (each faces texture data) extracted from an RGBE texture.\n             * This RGBE texture needs to store the information as a panorama.\n             *\n             * More information on this format are available here:\n             * https://en.wikipedia.org/wiki/RGBE_image_format\n             *\n             * @param buffer The binary file stored in an array buffer.\n             * @param size The expected size of the extracted cubemap.\n             * @return The Cube Map information.\n             */\n            HDRTools.GetCubeMapTextureData = function (buffer, size) {\n                var uint8array = new Uint8Array(buffer);\n                var hdrInfo = this.RGBE_ReadHeader(uint8array);\n                var data = this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\n                var cubeMapData = Internals.PanoramaToCubeMapTools.ConvertPanoramaToCubemap(data, hdrInfo.width, hdrInfo.height, size);\n                return cubeMapData;\n            };\n            /**\n             * Returns the pixels data extracted from an RGBE texture.\n             * This pixels will be stored left to right up to down in the R G B order in one array.\n             *\n             * More information on this format are available here:\n             * https://en.wikipedia.org/wiki/RGBE_image_format\n             *\n             * @param uint8array The binary file stored in an array buffer.\n             * @param hdrInfo The header information of the file.\n             * @return The pixels data in RGB right to left up to down order.\n             */\n            HDRTools.RGBE_ReadPixels = function (uint8array, hdrInfo) {\n                // Keep for multi format supports.\n                return this.RGBE_ReadPixels_RLE(uint8array, hdrInfo);\n            };\n            HDRTools.RGBE_ReadPixels_RLE = function (uint8array, hdrInfo) {\n                var num_scanlines = hdrInfo.height;\n                var scanline_width = hdrInfo.width;\n                var a, b, c, d, count;\n                var dataIndex = hdrInfo.dataPosition;\n                var index = 0, endIndex = 0, i = 0;\n                var scanLineArrayBuffer = new ArrayBuffer(scanline_width * 4); // four channel R G B E\n                var scanLineArray = new Uint8Array(scanLineArrayBuffer);\n                // 3 channels of 4 bytes per pixel in float.\n                var resultBuffer = new ArrayBuffer(hdrInfo.width * hdrInfo.height * 4 * 3);\n                var resultArray = new Float32Array(resultBuffer);\n                // read in each successive scanline\n                while (num_scanlines > 0) {\n                    a = uint8array[dataIndex++];\n                    b = uint8array[dataIndex++];\n                    c = uint8array[dataIndex++];\n                    d = uint8array[dataIndex++];\n                    if (a != 2 || b != 2 || (c & 0x80)) {\n                        // this file is not run length encoded\n                        throw \"HDR Bad header format, not RLE\";\n                    }\n                    if (((c << 8) | d) != scanline_width) {\n                        throw \"HDR Bad header format, wrong scan line width\";\n                    }\n                    index = 0;\n                    // read each of the four channels for the scanline into the buffer\n                    for (i = 0; i < 4; i++) {\n                        endIndex = (i + 1) * scanline_width;\n                        while (index < endIndex) {\n                            a = uint8array[dataIndex++];\n                            b = uint8array[dataIndex++];\n                            if (a > 128) {\n                                // a run of the same value\n                                count = a - 128;\n                                if ((count == 0) || (count > endIndex - index)) {\n                                    throw \"HDR Bad Format, bad scanline data (run)\";\n                                }\n                                while (count-- > 0) {\n                                    scanLineArray[index++] = b;\n                                }\n                            }\n                            else {\n                                // a non-run\n                                count = a;\n                                if ((count == 0) || (count > endIndex - index)) {\n                                    throw \"HDR Bad Format, bad scanline data (non-run)\";\n                                }\n                                scanLineArray[index++] = b;\n                                if (--count > 0) {\n                                    for (var j = 0; j < count; j++) {\n                                        scanLineArray[index++] = uint8array[dataIndex++];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    // now convert data from buffer into floats\n                    for (i = 0; i < scanline_width; i++) {\n                        a = scanLineArray[i];\n                        b = scanLineArray[i + scanline_width];\n                        c = scanLineArray[i + 2 * scanline_width];\n                        d = scanLineArray[i + 3 * scanline_width];\n                        this.Rgbe2float(resultArray, a, b, c, d, (hdrInfo.height - num_scanlines) * scanline_width * 3 + i * 3);\n                    }\n                    num_scanlines--;\n                }\n                return resultArray;\n            };\n            return HDRTools;\n        }());\n        Internals.HDRTools = HDRTools;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.hdr.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This represents a texture coming from an HDR input.\n     *\n     * The only supported format is currently panorama picture stored in RGBE format.\n     * Example of such files can be found on HDRLib: http://hdrlib.com/\n     */\n    var HDRCubeTexture = (function (_super) {\n        __extends(HDRCubeTexture, _super);\n        /**\n         * Instantiates an HDRTexture from the following parameters.\n         *\n         * @param url The location of the HDR raw data (Panorama stored in RGBE format)\n         * @param scene The scene the texture will be used in\n         * @param size The cubemap desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.\n         * @param noMipmap Forces to not generate the mipmap if true\n         * @param generateHarmonics Specifies wether you want to extract the polynomial harmonics during the generation process\n         * @param useInGammaSpace Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)\n         * @param usePMREMGenerator Specifies wether or not to generate the CubeMap through CubeMapGen to avoid seams issue at run time.\n         */\n        function HDRCubeTexture(url, scene, size, noMipmap, generateHarmonics, useInGammaSpace, usePMREMGenerator, onLoad, onError) {\n            if (noMipmap === void 0) { noMipmap = false; }\n            if (generateHarmonics === void 0) { generateHarmonics = true; }\n            if (useInGammaSpace === void 0) { useInGammaSpace = false; }\n            if (usePMREMGenerator === void 0) { usePMREMGenerator = false; }\n            if (onLoad === void 0) { onLoad = null; }\n            if (onError === void 0) { onError = null; }\n            var _this = _super.call(this, scene) || this;\n            _this._useInGammaSpace = false;\n            _this._generateHarmonics = true;\n            _this._isBABYLONPreprocessed = false;\n            _this._onLoad = null;\n            _this._onError = null;\n            /**\n             * The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.\n             */\n            _this.coordinatesMode = BABYLON.Texture.CUBIC_MODE;\n            /**\n             * Specifies wether the texture has been generated through the PMREMGenerator tool.\n             * This is usefull at run time to apply the good shader.\n             */\n            _this.isPMREM = false;\n            _this._isBlocking = true;\n            if (!url) {\n                return _this;\n            }\n            _this.name = url;\n            _this.url = url;\n            _this.hasAlpha = false;\n            _this.isCube = true;\n            _this._textureMatrix = BABYLON.Matrix.Identity();\n            _this._onLoad = onLoad;\n            _this._onError = onError;\n            _this.gammaSpace = false;\n            if (size) {\n                _this._isBABYLONPreprocessed = false;\n                _this._noMipmap = noMipmap;\n                _this._size = size;\n                _this._useInGammaSpace = useInGammaSpace;\n                _this._usePMREMGenerator = usePMREMGenerator &&\n                    scene.getEngine().getCaps().textureLOD &&\n                    _this.getScene().getEngine().getCaps().textureFloat &&\n                    !_this._useInGammaSpace;\n            }\n            else {\n                _this._isBABYLONPreprocessed = true;\n                _this._noMipmap = false;\n                _this._useInGammaSpace = false;\n                _this._usePMREMGenerator = scene.getEngine().getCaps().textureLOD &&\n                    _this.getScene().getEngine().getCaps().textureFloat &&\n                    !_this._useInGammaSpace;\n            }\n            _this.isPMREM = _this._usePMREMGenerator;\n            _this._texture = _this._getFromCache(url, _this._noMipmap);\n            if (!_this._texture) {\n                if (!scene.useDelayedTextureLoading) {\n                    _this.loadTexture();\n                }\n                else {\n                    _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                }\n            }\n            return _this;\n        }\n        Object.defineProperty(HDRCubeTexture.prototype, \"isBlocking\", {\n            /**\n             * Gets wether or not the texture is blocking during loading.\n             */\n            get: function () {\n                return this._isBlocking;\n            },\n            /**\n             * Sets wether or not the texture is blocking during loading.\n             */\n            set: function (value) {\n                this._isBlocking = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Occurs when the file is a preprocessed .babylon.hdr file.\n         */\n        HDRCubeTexture.prototype.loadBabylonTexture = function () {\n            var _this = this;\n            var mipLevels = 0;\n            var floatArrayView = null;\n            var mipmapGenerator = (!this._useInGammaSpace && this.getScene().getEngine().getCaps().textureFloat) ? function (data) {\n                var mips = [];\n                var startIndex = 30;\n                for (var level = 0; level < mipLevels; level++) {\n                    mips.push([]);\n                    // Fill each pixel of the mip level.\n                    var faceSize = Math.pow(_this._size >> level, 2) * 3;\n                    for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n                        var faceData = floatArrayView.subarray(startIndex, startIndex + faceSize);\n                        mips[level].push(faceData);\n                        startIndex += faceSize;\n                    }\n                }\n                return mips;\n            } : null;\n            var callback = function (buffer) {\n                // Create Native Array Views\n                var intArrayView = new Int32Array(buffer);\n                floatArrayView = new Float32Array(buffer);\n                // Fill header.\n                var version = intArrayView[0]; // Version 1. (MAy be use in case of format changes for backward compaibility)\n                _this._size = intArrayView[1]; // CubeMap max mip face size.\n                // Update Texture Information.\n                _this.getScene().getEngine().updateTextureSize(_this._texture, _this._size, _this._size);\n                // Fill polynomial information.\n                var sphericalPolynomial = new BABYLON.SphericalPolynomial();\n                sphericalPolynomial.x.copyFromFloats(floatArrayView[2], floatArrayView[3], floatArrayView[4]);\n                sphericalPolynomial.y.copyFromFloats(floatArrayView[5], floatArrayView[6], floatArrayView[7]);\n                sphericalPolynomial.z.copyFromFloats(floatArrayView[8], floatArrayView[9], floatArrayView[10]);\n                sphericalPolynomial.xx.copyFromFloats(floatArrayView[11], floatArrayView[12], floatArrayView[13]);\n                sphericalPolynomial.yy.copyFromFloats(floatArrayView[14], floatArrayView[15], floatArrayView[16]);\n                sphericalPolynomial.zz.copyFromFloats(floatArrayView[17], floatArrayView[18], floatArrayView[19]);\n                sphericalPolynomial.xy.copyFromFloats(floatArrayView[20], floatArrayView[21], floatArrayView[22]);\n                sphericalPolynomial.yz.copyFromFloats(floatArrayView[23], floatArrayView[24], floatArrayView[25]);\n                sphericalPolynomial.zx.copyFromFloats(floatArrayView[26], floatArrayView[27], floatArrayView[28]);\n                _this.sphericalPolynomial = sphericalPolynomial;\n                // Fill pixel data.\n                mipLevels = intArrayView[29]; // Number of mip levels.\n                var startIndex = 30;\n                var data = [];\n                var faceSize = Math.pow(_this._size, 2) * 3;\n                for (var faceIndex = 0; faceIndex < 6; faceIndex++) {\n                    data.push(floatArrayView.subarray(startIndex, startIndex + faceSize));\n                    startIndex += faceSize;\n                }\n                var results = [];\n                var byteArray = null;\n                // Push each faces.\n                for (var k = 0; k < 6; k++) {\n                    var dataFace = null;\n                    // To be deprecated.\n                    if (version === 1) {\n                        var j = ([0, 2, 4, 1, 3, 5])[k]; // Transforms +X+Y+Z... to +X-X+Y-Y...\n                        dataFace = data[j];\n                    }\n                    // If special cases.\n                    if (!mipmapGenerator) {\n                        if (!_this.getScene().getEngine().getCaps().textureFloat) {\n                            // 3 channels of 1 bytes per pixel in bytes.\n                            var byteBuffer = new ArrayBuffer(faceSize);\n                            byteArray = new Uint8Array(byteBuffer);\n                        }\n                        for (var i = 0; i < _this._size * _this._size; i++) {\n                            // Put in gamma space if requested.\n                            if (_this._useInGammaSpace) {\n                                dataFace[(i * 3) + 0] = Math.pow(dataFace[(i * 3) + 0], BABYLON.ToGammaSpace);\n                                dataFace[(i * 3) + 1] = Math.pow(dataFace[(i * 3) + 1], BABYLON.ToGammaSpace);\n                                dataFace[(i * 3) + 2] = Math.pow(dataFace[(i * 3) + 2], BABYLON.ToGammaSpace);\n                            }\n                            // Convert to int texture for fallback.\n                            if (byteArray) {\n                                var r = Math.max(dataFace[(i * 3) + 0] * 255, 0);\n                                var g = Math.max(dataFace[(i * 3) + 1] * 255, 0);\n                                var b = Math.max(dataFace[(i * 3) + 2] * 255, 0);\n                                // May use luminance instead if the result is not accurate.\n                                var max = Math.max(Math.max(r, g), b);\n                                if (max > 255) {\n                                    var scale = 255 / max;\n                                    r *= scale;\n                                    g *= scale;\n                                    b *= scale;\n                                }\n                                byteArray[(i * 3) + 0] = r;\n                                byteArray[(i * 3) + 1] = g;\n                                byteArray[(i * 3) + 2] = b;\n                            }\n                        }\n                    }\n                    // Fill the array accordingly.\n                    if (byteArray) {\n                        results.push(byteArray);\n                    }\n                    else {\n                        results.push(dataFace);\n                    }\n                }\n                return results;\n            };\n            this._texture = this.getScene().getEngine().createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, BABYLON.Engine.TEXTUREFORMAT_RGB, this.getScene().getEngine().getCaps().textureFloat ? BABYLON.Engine.TEXTURETYPE_FLOAT : BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, callback, mipmapGenerator, this._onLoad, this._onError);\n        };\n        /**\n         * Occurs when the file is raw .hdr file.\n         */\n        HDRCubeTexture.prototype.loadHDRTexture = function () {\n            var _this = this;\n            var callback = function (buffer) {\n                // Extract the raw linear data.\n                var data = BABYLON.Internals.HDRTools.GetCubeMapTextureData(buffer, _this._size);\n                // Generate harmonics if needed.\n                if (_this._generateHarmonics) {\n                    var sphericalPolynomial = BABYLON.Internals.CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial(data);\n                    _this.sphericalPolynomial = sphericalPolynomial;\n                }\n                var results = [];\n                var byteArray = null;\n                // Push each faces.\n                for (var j = 0; j < 6; j++) {\n                    // Create uintarray fallback.\n                    if (!_this.getScene().getEngine().getCaps().textureFloat) {\n                        // 3 channels of 1 bytes per pixel in bytes.\n                        var byteBuffer = new ArrayBuffer(_this._size * _this._size * 3);\n                        byteArray = new Uint8Array(byteBuffer);\n                    }\n                    var dataFace = data[HDRCubeTexture._facesMapping[j]];\n                    // If special cases.\n                    if (_this._useInGammaSpace || byteArray) {\n                        for (var i = 0; i < _this._size * _this._size; i++) {\n                            // Put in gamma space if requested.\n                            if (_this._useInGammaSpace) {\n                                dataFace[(i * 3) + 0] = Math.pow(dataFace[(i * 3) + 0], BABYLON.ToGammaSpace);\n                                dataFace[(i * 3) + 1] = Math.pow(dataFace[(i * 3) + 1], BABYLON.ToGammaSpace);\n                                dataFace[(i * 3) + 2] = Math.pow(dataFace[(i * 3) + 2], BABYLON.ToGammaSpace);\n                            }\n                            // Convert to int texture for fallback.\n                            if (byteArray) {\n                                var r = Math.max(dataFace[(i * 3) + 0] * 255, 0);\n                                var g = Math.max(dataFace[(i * 3) + 1] * 255, 0);\n                                var b = Math.max(dataFace[(i * 3) + 2] * 255, 0);\n                                // May use luminance instead if the result is not accurate.\n                                var max = Math.max(Math.max(r, g), b);\n                                if (max > 255) {\n                                    var scale = 255 / max;\n                                    r *= scale;\n                                    g *= scale;\n                                    b *= scale;\n                                }\n                                byteArray[(i * 3) + 0] = r;\n                                byteArray[(i * 3) + 1] = g;\n                                byteArray[(i * 3) + 2] = b;\n                            }\n                        }\n                    }\n                    if (byteArray) {\n                        results.push(byteArray);\n                    }\n                    else {\n                        results.push(dataFace);\n                    }\n                }\n                return results;\n            };\n            var mipmapGenerator = null;\n            // TODO. Implement In code PMREM Generator following the LYS toolset generation.\n            // if (!this._noMipmap &&\n            //     this._usePMREMGenerator) {\n            //     mipmapGenerator = (data: ArrayBufferView[]) => {\n            //         // Custom setup of the generator matching with the PBR shader values.\n            //         var generator = new BABYLON.Internals.PMREMGenerator(data,\n            //             this._size,\n            //             this._size,\n            //             0,\n            //             3,\n            //             this.getScene().getEngine().getCaps().textureFloat,\n            //             2048,\n            //             0.25,\n            //             false,\n            //             true);\n            //         return generator.filterCubeMap();\n            //     };\n            // }\n            this._texture = this.getScene().getEngine().createRawCubeTextureFromUrl(this.url, this.getScene(), this._size, BABYLON.Engine.TEXTUREFORMAT_RGB, this.getScene().getEngine().getCaps().textureFloat ? BABYLON.Engine.TEXTURETYPE_FLOAT : BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT, this._noMipmap, callback, mipmapGenerator, this._onLoad, this._onError);\n        };\n        /**\n         * Starts the loading process of the texture.\n         */\n        HDRCubeTexture.prototype.loadTexture = function () {\n            if (this._isBABYLONPreprocessed) {\n                this.loadBabylonTexture();\n            }\n            else {\n                this.loadHDRTexture();\n            }\n        };\n        HDRCubeTexture.prototype.clone = function () {\n            var size = this._isBABYLONPreprocessed ? null : this._size;\n            var newTexture = new HDRCubeTexture(this.url, this.getScene(), size, this._noMipmap, this._generateHarmonics, this._useInGammaSpace, this._usePMREMGenerator);\n            // Base texture\n            newTexture.level = this.level;\n            newTexture.wrapU = this.wrapU;\n            newTexture.wrapV = this.wrapV;\n            newTexture.coordinatesIndex = this.coordinatesIndex;\n            newTexture.coordinatesMode = this.coordinatesMode;\n            return newTexture;\n        };\n        // Methods\n        HDRCubeTexture.prototype.delayLoad = function () {\n            if (this.delayLoadState !== BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                return;\n            }\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n            this._texture = this._getFromCache(this.url, this._noMipmap);\n            if (!this._texture) {\n                this.loadTexture();\n            }\n        };\n        HDRCubeTexture.prototype.getReflectionTextureMatrix = function () {\n            return this._textureMatrix;\n        };\n        HDRCubeTexture.prototype.setReflectionTextureMatrix = function (value) {\n            this._textureMatrix = value;\n        };\n        HDRCubeTexture.Parse = function (parsedTexture, scene, rootUrl) {\n            var texture = null;\n            if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n                var size = parsedTexture.isBABYLONPreprocessed ? null : parsedTexture.size;\n                texture = new BABYLON.HDRCubeTexture(rootUrl + parsedTexture.name, scene, size, parsedTexture.noMipmap, parsedTexture.generateHarmonics, parsedTexture.useInGammaSpace, parsedTexture.usePMREMGenerator);\n                texture.name = parsedTexture.name;\n                texture.hasAlpha = parsedTexture.hasAlpha;\n                texture.level = parsedTexture.level;\n                texture.coordinatesMode = parsedTexture.coordinatesMode;\n                texture.isBlocking = parsedTexture.isBlocking;\n            }\n            return texture;\n        };\n        HDRCubeTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.hasAlpha = this.hasAlpha;\n            serializationObject.isCube = true;\n            serializationObject.level = this.level;\n            serializationObject.size = this._size;\n            serializationObject.coordinatesMode = this.coordinatesMode;\n            serializationObject.useInGammaSpace = this._useInGammaSpace;\n            serializationObject.generateHarmonics = this._generateHarmonics;\n            serializationObject.usePMREMGenerator = this._usePMREMGenerator;\n            serializationObject.isBABYLONPreprocessed = this._isBABYLONPreprocessed;\n            serializationObject.customType = \"BABYLON.HDRCubeTexture\";\n            serializationObject.noMipmap = this._noMipmap;\n            serializationObject.isBlocking = this._isBlocking;\n            return serializationObject;\n        };\n        /**\n         * Saves as a file the data contained in the texture in a binary format.\n         * This can be used to prevent the long loading tie associated with creating the seamless texture as well\n         * as the spherical used in the lighting.\n         * @param url The HDR file url.\n         * @param size The size of the texture data to generate (one of the cubemap face desired width).\n         * @param onError Method called if any error happens during download.\n         * @return The packed binary data.\n         */\n        HDRCubeTexture.generateBabylonHDROnDisk = function (url, size, onError) {\n            if (onError === void 0) { onError = null; }\n            var callback = function (buffer) {\n                var data = new Blob([buffer], { type: 'application/octet-stream' });\n                // Returns a URL you can use as a href.\n                var objUrl = window.URL.createObjectURL(data);\n                // Simulates a link to it and click to dowload.\n                var a = document.createElement(\"a\");\n                document.body.appendChild(a);\n                a.style.display = \"none\";\n                a.href = objUrl;\n                a.download = \"envmap.babylon.hdr\";\n                a.click();\n            };\n            HDRCubeTexture.generateBabylonHDR(url, size, callback, onError);\n        };\n        /**\n         * Serializes the data contained in the texture in a binary format.\n         * This can be used to prevent the long loading tie associated with creating the seamless texture as well\n         * as the spherical used in the lighting.\n         * @param url The HDR file url.\n         * @param size The size of the texture data to generate (one of the cubemap face desired width).\n         * @param onError Method called if any error happens during download.\n         * @return The packed binary data.\n         */\n        HDRCubeTexture.generateBabylonHDR = function (url, size, callback, onError) {\n            if (onError === void 0) { onError = null; }\n            // Needs the url tho create the texture.\n            if (!url) {\n                return null;\n            }\n            // Check Power of two size.\n            if (!BABYLON.Tools.IsExponentOfTwo(size)) {\n                return null;\n            }\n            // Coming Back in 3.1.\n            BABYLON.Tools.Error(\"Generation of Babylon HDR is coming back in 3.1.\");\n            return null;\n        };\n        return HDRCubeTexture;\n    }(BABYLON.BaseTexture));\n    HDRCubeTexture._facesMapping = [\n        \"right\",\n        \"left\",\n        \"up\",\n        \"down\",\n        \"front\",\n        \"back\"\n    ];\n    BABYLON.HDRCubeTexture = HDRCubeTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.hdrCubeTexture.js.map\n\n// All the credit goes to this project and the guy who's behind it https://github.com/mapbox/earcut\n// Huge respect for a such great lib. \n// Earcut license:\n// Copyright (c) 2016, Mapbox\n// \n// Permission to use, copy, modify, and/or distribute this software for any purpose\n// with or without fee is hereby granted, provided that the above copyright notice\n// and this permission notice appear in all copies.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n// FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n// OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n// TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n// THIS SOFTWARE.\nvar Earcut;\n(function (Earcut) {\n    /**\n     * The fastest and smallest JavaScript polygon triangulation library for your WebGL apps\n     * @param data is a flat array of vertice coordinates like [x0, y0, x1, y1, x2, y2, ...].\n     * @param holeIndices is an array of hole indices if any (e.g. [5, 8] for a 12- vertice input would mean one hole with vertices 57 and another with 811).\n     * @param dim is the number of coordinates per vertice in the input array (2 by default).\n     */\n    function earcut(data, holeIndices, dim) {\n        dim = dim || 2;\n        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];\n        if (!outerNode)\n            return triangles;\n        var minX, minY, maxX, maxY, x, y, size;\n        if (hasHoles)\n            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n        if (data.length > 80 * dim) {\n            minX = maxX = data[0];\n            minY = maxY = data[1];\n            for (var i = dim; i < outerLen; i += dim) {\n                x = data[i];\n                y = data[i + 1];\n                if (x < minX)\n                    minX = x;\n                if (y < minY)\n                    minY = y;\n                if (x > maxX)\n                    maxX = x;\n                if (y > maxY)\n                    maxY = y;\n            }\n            // minX, minY and size are later used to transform coords into integers for z-order calculation\n            size = Math.max(maxX - minX, maxY - minY);\n        }\n        earcutLinked(outerNode, triangles, dim, minX, minY, size, undefined);\n        return triangles;\n    }\n    Earcut.earcut = earcut;\n    // create a circular doubly linked list from polygon points in the specified winding order\n    function linkedList(data, start, end, dim, clockwise) {\n        var i, last;\n        if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n            for (i = start; i < end; i += dim)\n                last = insertNode(i, data[i], data[i + 1], last);\n        }\n        else {\n            for (i = end - dim; i >= start; i -= dim)\n                last = insertNode(i, data[i], data[i + 1], last);\n        }\n        if (last && equals(last, last.next)) {\n            removeNode(last);\n            last = last.next;\n        }\n        return last;\n    }\n    // eliminate colinear or duplicate points\n    function filterPoints(start, end) {\n        if (!start)\n            return start;\n        if (!end)\n            end = start;\n        var p = start, again;\n        do {\n            again = false;\n            if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n                removeNode(p);\n                p = end = p.prev;\n                if (p === p.next)\n                    return null;\n                again = true;\n            }\n            else {\n                p = p.next;\n            }\n        } while (again || p !== end);\n        return end;\n    }\n    // main ear slicing loop which triangulates a polygon (given as a linked list)\n    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n        if (!ear)\n            return;\n        // interlink polygon nodes in z-order\n        if (!pass && size)\n            indexCurve(ear, minX, minY, size);\n        var stop = ear, prev, next;\n        // iterate through ears, slicing them one by one\n        while (ear.prev !== ear.next) {\n            prev = ear.prev;\n            next = ear.next;\n            if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n                // cut off the triangle\n                triangles.push(prev.i / dim);\n                triangles.push(ear.i / dim);\n                triangles.push(next.i / dim);\n                removeNode(ear);\n                // skipping the next vertice leads to less sliver triangles\n                ear = next.next;\n                stop = next.next;\n                continue;\n            }\n            ear = next;\n            // if we looped through the whole remaining polygon and can't find any more ears\n            if (ear === stop) {\n                // try filtering points and slicing again\n                if (!pass) {\n                    earcutLinked(filterPoints(ear, undefined), triangles, dim, minX, minY, size, 1);\n                    // if this didn't work, try curing all small self-intersections locally\n                }\n                else if (pass === 1) {\n                    ear = cureLocalIntersections(ear, triangles, dim);\n                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n                    // as a last resort, try splitting the remaining polygon into two\n                }\n                else if (pass === 2) {\n                    splitEarcut(ear, triangles, dim, minX, minY, size);\n                }\n                break;\n            }\n        }\n    }\n    // check whether a polygon node forms a valid ear with adjacent nodes\n    function isEar(ear) {\n        var a = ear.prev, b = ear, c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // now make sure we don't have other points inside the potential ear\n        var p = ear.next.next;\n        while (p !== ear.prev) {\n            if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.next;\n        }\n        return true;\n    }\n    function isEarHashed(ear, minX, minY, size) {\n        var a = ear.prev, b = ear, c = ear.next;\n        if (area(a, b, c) >= 0)\n            return false; // reflex, can't be an ear\n        // triangle bbox; min & max are calculated like this for speed\n        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n        // z-order range for the current triangle bbox;\n        var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n        // first look for points inside the triangle in increasing z-order\n        var p = ear.nextZ;\n        while (p && p.z <= maxZ) {\n            if (p !== ear.prev &&\n                p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.nextZ;\n        }\n        // then look for points in decreasing z-order\n        p = ear.prevZ;\n        while (p && p.z >= minZ) {\n            if (p !== ear.prev &&\n                p !== ear.next &&\n                pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n                area(p.prev, p, p.next) >= 0)\n                return false;\n            p = p.prevZ;\n        }\n        return true;\n    }\n    // go through all polygon nodes and cure small local self-intersections\n    function cureLocalIntersections(start, triangles, dim) {\n        var p = start;\n        do {\n            var a = p.prev, b = p.next.next;\n            if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n                triangles.push(a.i / dim);\n                triangles.push(p.i / dim);\n                triangles.push(b.i / dim);\n                // remove two nodes involved\n                removeNode(p);\n                removeNode(p.next);\n                p = start = b;\n            }\n            p = p.next;\n        } while (p !== start);\n        return p;\n    }\n    // try splitting polygon into two and triangulate them independently\n    function splitEarcut(start, triangles, dim, minX, minY, size) {\n        // look for a valid diagonal that divides the polygon into two\n        var a = start;\n        do {\n            var b = a.next.next;\n            while (b !== a.prev) {\n                if (a.i !== b.i && isValidDiagonal(a, b)) {\n                    // split the polygon in two by the diagonal\n                    var c = splitPolygon(a, b);\n                    // filter colinear points around the cuts\n                    a = filterPoints(a, a.next);\n                    c = filterPoints(c, c.next);\n                    // run earcut on each half\n                    earcutLinked(a, triangles, dim, minX, minY, size, undefined);\n                    earcutLinked(c, triangles, dim, minX, minY, size, undefined);\n                    return;\n                }\n                b = b.next;\n            }\n            a = a.next;\n        } while (a !== start);\n    }\n    // link every hole into the outer loop, producing a single-ring polygon without holes\n    function eliminateHoles(data, holeIndices, outerNode, dim) {\n        var queue = [], i, len, start, end, list;\n        for (i = 0, len = holeIndices.length; i < len; i++) {\n            start = holeIndices[i] * dim;\n            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            list = linkedList(data, start, end, dim, false);\n            if (list === list.next)\n                list.steiner = true;\n            queue.push(getLeftmost(list));\n        }\n        queue.sort(compareX);\n        // process holes from left to right\n        for (i = 0; i < queue.length; i++) {\n            eliminateHole(queue[i], outerNode);\n            outerNode = filterPoints(outerNode, outerNode.next);\n        }\n        return outerNode;\n    }\n    function compareX(a, b) {\n        return a.x - b.x;\n    }\n    // find a bridge between vertices that connects hole with an outer ring and and link it\n    function eliminateHole(hole, outerNode) {\n        outerNode = findHoleBridge(hole, outerNode);\n        if (outerNode) {\n            var b = splitPolygon(outerNode, hole);\n            filterPoints(b, b.next);\n        }\n    }\n    // David Eberly's algorithm for finding a bridge between hole and outer polygon\n    function findHoleBridge(hole, outerNode) {\n        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;\n        // find a segment intersected by a ray from the hole's leftmost point to the left;\n        // segment's endpoint with lesser x will be potential connection point\n        do {\n            if (hy <= p.y && hy >= p.next.y) {\n                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                if (x <= hx && x > qx) {\n                    qx = x;\n                    if (x === hx) {\n                        if (hy === p.y)\n                            return p;\n                        if (hy === p.next.y)\n                            return p.next;\n                    }\n                    m = p.x < p.next.x ? p : p.next;\n                }\n            }\n            p = p.next;\n        } while (p !== outerNode);\n        if (!m)\n            return null;\n        if (hx === qx)\n            return m.prev; // hole touches outer segment; pick lower endpoint\n        // look for points inside the triangle of hole point, segment intersection and endpoint;\n        // if there are no points found, we have a valid connection;\n        // otherwise choose the point of the minimum angle with the ray as connection point\n        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;\n        p = m.next;\n        while (p !== stop) {\n            if (hx >= p.x &&\n                p.x >= mx &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                    m = p;\n                    tanMin = tan;\n                }\n            }\n            p = p.next;\n        }\n        return m;\n    }\n    // interlink polygon nodes in z-order\n    function indexCurve(start, minX, minY, size) {\n        var p = start;\n        do {\n            if (p.z === null)\n                p.z = zOrder(p.x, p.y, minX, minY, size);\n            p.prevZ = p.prev;\n            p.nextZ = p.next;\n            p = p.next;\n        } while (p !== start);\n        p.prevZ.nextZ = null;\n        p.prevZ = null;\n        sortLinked(p);\n    }\n    // Simon Tatham's linked list merge sort algorithm\n    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n    function sortLinked(list) {\n        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n        do {\n            p = list;\n            list = null;\n            tail = null;\n            numMerges = 0;\n            while (p) {\n                numMerges++;\n                q = p;\n                pSize = 0;\n                for (i = 0; i < inSize; i++) {\n                    pSize++;\n                    q = q.nextZ;\n                    if (!q)\n                        break;\n                }\n                qSize = inSize;\n                while (pSize > 0 || (qSize > 0 && q)) {\n                    if (pSize === 0) {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n                    else if (qSize === 0 || !q) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    }\n                    else if (p.z <= q.z) {\n                        e = p;\n                        p = p.nextZ;\n                        pSize--;\n                    }\n                    else {\n                        e = q;\n                        q = q.nextZ;\n                        qSize--;\n                    }\n                    if (tail)\n                        tail.nextZ = e;\n                    else\n                        list = e;\n                    e.prevZ = tail;\n                    tail = e;\n                }\n                p = q;\n            }\n            tail.nextZ = null;\n            inSize *= 2;\n        } while (numMerges > 1);\n        return list;\n    }\n    // z-order of a point given coords and size of the data bounding box\n    function zOrder(x, y, minX, minY, size) {\n        // coords are transformed into non-negative 15-bit integer range\n        x = 32767 * (x - minX) / size;\n        y = 32767 * (y - minY) / size;\n        x = (x | (x << 8)) & 0x00FF00FF;\n        x = (x | (x << 4)) & 0x0F0F0F0F;\n        x = (x | (x << 2)) & 0x33333333;\n        x = (x | (x << 1)) & 0x55555555;\n        y = (y | (y << 8)) & 0x00FF00FF;\n        y = (y | (y << 4)) & 0x0F0F0F0F;\n        y = (y | (y << 2)) & 0x33333333;\n        y = (y | (y << 1)) & 0x55555555;\n        return x | (y << 1);\n    }\n    // find the leftmost node of a polygon ring\n    function getLeftmost(start) {\n        var p = start, leftmost = start;\n        do {\n            if (p.x < leftmost.x)\n                leftmost = p;\n            p = p.next;\n        } while (p !== start);\n        return leftmost;\n    }\n    // check if a point lies within a convex triangle\n    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n    }\n    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n    function isValidDiagonal(a, b) {\n        return a.next.i !== b.i &&\n            a.prev.i !== b.i &&\n            !intersectsPolygon(a, b) &&\n            locallyInside(a, b) &&\n            locallyInside(b, a) &&\n            middleInside(a, b);\n    }\n    // signed area of a triangle\n    function area(p, q, r) {\n        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    }\n    // check if two points are equal\n    function equals(p1, p2) {\n        return p1.x === p2.x && p1.y === p2.y;\n    }\n    // check if two segments intersect\n    function intersects(p1, q1, p2, q2) {\n        if ((equals(p1, q1) && equals(p2, q2)) ||\n            (equals(p1, q2) && equals(p2, q1)))\n            return true;\n        return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n            area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n    }\n    // check if a polygon diagonal intersects any polygon segments\n    function intersectsPolygon(a, b) {\n        var p = a;\n        do {\n            if (p.i !== a.i &&\n                p.next.i !== a.i &&\n                p.i !== b.i &&\n                p.next.i !== b.i &&\n                intersects(p, p.next, a, b))\n                return true;\n            p = p.next;\n        } while (p !== a);\n        return false;\n    }\n    // check if a polygon diagonal is locally inside the polygon\n    function locallyInside(a, b) {\n        return area(a.prev, a, a.next) < 0\n            ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n            : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n    }\n    // check if the middle point of a polygon diagonal is inside the polygon\n    function middleInside(a, b) {\n        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n        do {\n            if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n                inside = !inside;\n            p = p.next;\n        } while (p !== a);\n        return inside;\n    }\n    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n    // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n    function splitPolygon(a, b) {\n        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n        a.next = b;\n        b.prev = a;\n        a2.next = an;\n        an.prev = a2;\n        b2.next = a2;\n        a2.prev = b2;\n        bp.next = b2;\n        b2.prev = bp;\n        return b2;\n    }\n    // create a node and optionally link it with previous one (in a circular doubly linked list)\n    function insertNode(i, x, y, last) {\n        var p = new Node(i, x, y);\n        if (!last) {\n            p.prev = p;\n            p.next = p;\n        }\n        else {\n            p.next = last.next;\n            p.prev = last;\n            last.next.prev = p;\n            last.next = p;\n        }\n        return p;\n    }\n    function removeNode(p) {\n        p.next.prev = p.prev;\n        p.prev.next = p.next;\n        if (p.prevZ)\n            p.prevZ.nextZ = p.nextZ;\n        if (p.nextZ)\n            p.nextZ.prevZ = p.prevZ;\n    }\n    function Node(i, x, y) {\n        // vertice index in coordinates array\n        this.i = i;\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n        // previous and next vertice nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n        // z-order curve value\n        this.z = null;\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n        // indicates whether this is a steiner point\n        this.steiner = false;\n    }\n    /**\n     * return a percentage difference between the polygon area and its triangulation area;\n     * used to verify correctness of triangulation\n     */\n    function deviation(data, holeIndices, dim, triangles) {\n        var hasHoles = holeIndices && holeIndices.length;\n        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n        if (hasHoles) {\n            for (var i = 0, len = holeIndices.length; i < len; i++) {\n                var start = holeIndices[i] * dim;\n                var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                polygonArea -= Math.abs(signedArea(data, start, end, dim));\n            }\n        }\n        var trianglesArea = 0;\n        for (i = 0; i < triangles.length; i += 3) {\n            var a = triangles[i] * dim;\n            var b = triangles[i + 1] * dim;\n            var c = triangles[i + 2] * dim;\n            trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n                (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n        }\n        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n    }\n    Earcut.deviation = deviation;\n    ;\n    function signedArea(data, start, end, dim) {\n        var sum = 0;\n        for (var i = start, j = end - dim; i < end; i += dim) {\n            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n            j = i;\n        }\n        return sum;\n    }\n    /**\n     *  turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n     */\n    function flatten(data) {\n        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;\n        for (var i = 0; i < data.length; i++) {\n            for (var j = 0; j < data[i].length; j++) {\n                for (var d = 0; d < dim; d++)\n                    result.vertices.push(data[i][j][d]);\n            }\n            if (i > 0) {\n                holeIndex += data[i - 1].length;\n                result.holes.push(holeIndex);\n            }\n        }\n        return result;\n    }\n    Earcut.flatten = flatten;\n    ;\n})(Earcut || (Earcut = {}));\n\n//# sourceMappingURL=babylon.earcut.js.map\n\n/// <reference path=\"..\\Math\\babylon.math.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var IndexedVector2 = (function (_super) {\n        __extends(IndexedVector2, _super);\n        function IndexedVector2(original, index) {\n            var _this = _super.call(this, original.x, original.y) || this;\n            _this.index = index;\n            return _this;\n        }\n        return IndexedVector2;\n    }(BABYLON.Vector2));\n    var PolygonPoints = (function () {\n        function PolygonPoints() {\n            this.elements = new Array();\n        }\n        PolygonPoints.prototype.add = function (originalPoints) {\n            var _this = this;\n            var result = new Array();\n            originalPoints.forEach(function (point) {\n                if (result.length === 0 || !point.equalsWithEpsilon(result[0])) {\n                    var newPoint = new IndexedVector2(point, _this.elements.length);\n                    result.push(newPoint);\n                    _this.elements.push(newPoint);\n                }\n            });\n            return result;\n        };\n        PolygonPoints.prototype.computeBounds = function () {\n            var lmin = new BABYLON.Vector2(this.elements[0].x, this.elements[0].y);\n            var lmax = new BABYLON.Vector2(this.elements[0].x, this.elements[0].y);\n            this.elements.forEach(function (point) {\n                // x\n                if (point.x < lmin.x) {\n                    lmin.x = point.x;\n                }\n                else if (point.x > lmax.x) {\n                    lmax.x = point.x;\n                }\n                // y\n                if (point.y < lmin.y) {\n                    lmin.y = point.y;\n                }\n                else if (point.y > lmax.y) {\n                    lmax.y = point.y;\n                }\n            });\n            return {\n                min: lmin,\n                max: lmax,\n                width: lmax.x - lmin.x,\n                height: lmax.y - lmin.y\n            };\n        };\n        return PolygonPoints;\n    }());\n    var Polygon = (function () {\n        function Polygon() {\n        }\n        Polygon.Rectangle = function (xmin, ymin, xmax, ymax) {\n            return [\n                new BABYLON.Vector2(xmin, ymin),\n                new BABYLON.Vector2(xmax, ymin),\n                new BABYLON.Vector2(xmax, ymax),\n                new BABYLON.Vector2(xmin, ymax)\n            ];\n        };\n        Polygon.Circle = function (radius, cx, cy, numberOfSides) {\n            if (cx === void 0) { cx = 0; }\n            if (cy === void 0) { cy = 0; }\n            if (numberOfSides === void 0) { numberOfSides = 32; }\n            var result = new Array();\n            var angle = 0;\n            var increment = (Math.PI * 2) / numberOfSides;\n            for (var i = 0; i < numberOfSides; i++) {\n                result.push(new BABYLON.Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\n                angle -= increment;\n            }\n            return result;\n        };\n        Polygon.Parse = function (input) {\n            var floats = input.split(/[^-+eE\\.\\d]+/).map(parseFloat).filter(function (val) { return (!isNaN(val)); });\n            var i, result = [];\n            for (i = 0; i < (floats.length & 0x7FFFFFFE); i += 2) {\n                result.push(new BABYLON.Vector2(floats[i], floats[i + 1]));\n            }\n            return result;\n        };\n        Polygon.StartingAt = function (x, y) {\n            return BABYLON.Path2.StartingAt(x, y);\n        };\n        return Polygon;\n    }());\n    BABYLON.Polygon = Polygon;\n    var PolygonMeshBuilder = (function () {\n        function PolygonMeshBuilder(name, contours, scene) {\n            this._points = new PolygonPoints();\n            this._outlinepoints = new PolygonPoints();\n            this._holes = [];\n            this._epoints = new Array();\n            this._eholes = new Array();\n            this._name = name;\n            this._scene = scene;\n            var points;\n            if (contours instanceof BABYLON.Path2) {\n                points = contours.getPoints();\n            }\n            else {\n                points = contours;\n            }\n            this._addToepoint(points);\n            this._points.add(points);\n            this._outlinepoints.add(points);\n        }\n        PolygonMeshBuilder.prototype._addToepoint = function (points) {\n            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n                var p = points_1[_i];\n                this._epoints.push(p.x, p.y);\n            }\n        };\n        PolygonMeshBuilder.prototype.addHole = function (hole) {\n            this._points.add(hole);\n            var holepoints = new PolygonPoints();\n            holepoints.add(hole);\n            this._holes.push(holepoints);\n            this._eholes.push(this._epoints.length / 2);\n            this._addToepoint(hole);\n            return this;\n        };\n        PolygonMeshBuilder.prototype.build = function (updatable, depth) {\n            var _this = this;\n            if (updatable === void 0) { updatable = false; }\n            var result = new BABYLON.Mesh(this._name, this._scene);\n            var normals = [];\n            var positions = [];\n            var uvs = [];\n            var bounds = this._points.computeBounds();\n            this._points.elements.forEach(function (p) {\n                normals.push(0, 1.0, 0);\n                positions.push(p.x, 0, p.y);\n                uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\n            });\n            var indices = [];\n            var res = Earcut.earcut(this._epoints, this._eholes, 2);\n            for (var i = 0; i < res.length; i++) {\n                indices.push(res[i]);\n            }\n            if (depth > 0) {\n                var positionscount = (positions.length / 3); //get the current pointcount\n                this._points.elements.forEach(function (p) {\n                    normals.push(0, -1.0, 0);\n                    positions.push(p.x, -depth, p.y);\n                    uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\n                });\n                var totalCount = indices.length;\n                for (var i = 0; i < totalCount; i += 3) {\n                    var i0 = indices[i + 0];\n                    var i1 = indices[i + 1];\n                    var i2 = indices[i + 2];\n                    indices.push(i2 + positionscount);\n                    indices.push(i1 + positionscount);\n                    indices.push(i0 + positionscount);\n                }\n                //Add the sides\n                this.addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false);\n                this._holes.forEach(function (hole) {\n                    _this.addSide(positions, normals, uvs, indices, bounds, hole, depth, true);\n                });\n            }\n            result.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions, updatable);\n            result.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals, updatable);\n            result.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs, updatable);\n            result.setIndices(indices);\n            return result;\n        };\n        PolygonMeshBuilder.prototype.addSide = function (positions, normals, uvs, indices, bounds, points, depth, flip) {\n            var StartIndex = positions.length / 3;\n            var ulength = 0;\n            for (var i = 0; i < points.elements.length; i++) {\n                var p = points.elements[i];\n                var p1;\n                if ((i + 1) > points.elements.length - 1) {\n                    p1 = points.elements[0];\n                }\n                else {\n                    p1 = points.elements[i + 1];\n                }\n                positions.push(p.x, 0, p.y);\n                positions.push(p.x, -depth, p.y);\n                positions.push(p1.x, 0, p1.y);\n                positions.push(p1.x, -depth, p1.y);\n                var v1 = new BABYLON.Vector3(p.x, 0, p.y);\n                var v2 = new BABYLON.Vector3(p1.x, 0, p1.y);\n                var v3 = v2.subtract(v1);\n                var v4 = new BABYLON.Vector3(0, 1, 0);\n                var vn = BABYLON.Vector3.Cross(v3, v4);\n                vn = vn.normalize();\n                uvs.push(ulength / bounds.width, 0);\n                uvs.push(ulength / bounds.width, 1);\n                ulength += v3.length();\n                uvs.push((ulength / bounds.width), 0);\n                uvs.push((ulength / bounds.width), 1);\n                if (!flip) {\n                    normals.push(-vn.x, -vn.y, -vn.z);\n                    normals.push(-vn.x, -vn.y, -vn.z);\n                    normals.push(-vn.x, -vn.y, -vn.z);\n                    normals.push(-vn.x, -vn.y, -vn.z);\n                    indices.push(StartIndex);\n                    indices.push(StartIndex + 1);\n                    indices.push(StartIndex + 2);\n                    indices.push(StartIndex + 1);\n                    indices.push(StartIndex + 3);\n                    indices.push(StartIndex + 2);\n                }\n                else {\n                    normals.push(vn.x, vn.y, vn.z);\n                    normals.push(vn.x, vn.y, vn.z);\n                    normals.push(vn.x, vn.y, vn.z);\n                    normals.push(vn.x, vn.y, vn.z);\n                    indices.push(StartIndex);\n                    indices.push(StartIndex + 2);\n                    indices.push(StartIndex + 1);\n                    indices.push(StartIndex + 1);\n                    indices.push(StartIndex + 2);\n                    indices.push(StartIndex + 3);\n                }\n                StartIndex += 4;\n            }\n            ;\n        };\n        return PolygonMeshBuilder;\n    }());\n    BABYLON.PolygonMeshBuilder = PolygonMeshBuilder;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.polygonMesh.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    // Unique ID when we import meshes from Babylon to CSG\n    var currentCSGMeshId = 0;\n    // # class Vertex\n    // Represents a vertex of a polygon. Use your own vertex class instead of this\n    // one to provide additional features like texture coordinates and vertex\n    // colors. Custom vertex classes need to provide a `pos` property and `clone()`,\n    // `flip()`, and `interpolate()` methods that behave analogous to the ones\n    // defined by `BABYLON.CSG.Vertex`. This class provides `normal` so convenience\n    // functions like `BABYLON.CSG.sphere()` can return a smooth vertex normal, but `normal`\n    // is not used anywhere else. \n    // Same goes for uv, it allows to keep the original vertex uv coordinates of the 2 meshes\n    var Vertex = (function () {\n        function Vertex(pos, normal, uv) {\n            this.pos = pos;\n            this.normal = normal;\n            this.uv = uv;\n        }\n        Vertex.prototype.clone = function () {\n            return new Vertex(this.pos.clone(), this.normal.clone(), this.uv.clone());\n        };\n        // Invert all orientation-specific data (e.g. vertex normal). Called when the\n        // orientation of a polygon is flipped.\n        Vertex.prototype.flip = function () {\n            this.normal = this.normal.scale(-1);\n        };\n        // Create a new vertex between this vertex and `other` by linearly\n        // interpolating all properties using a parameter of `t`. Subclasses should\n        // override this to interpolate additional properties.\n        Vertex.prototype.interpolate = function (other, t) {\n            return new Vertex(BABYLON.Vector3.Lerp(this.pos, other.pos, t), BABYLON.Vector3.Lerp(this.normal, other.normal, t), BABYLON.Vector2.Lerp(this.uv, other.uv, t));\n        };\n        return Vertex;\n    }());\n    // # class Plane\n    // Represents a plane in 3D space.\n    var Plane = (function () {\n        function Plane(normal, w) {\n            this.normal = normal;\n            this.w = w;\n        }\n        Plane.FromPoints = function (a, b, c) {\n            var v0 = c.subtract(a);\n            var v1 = b.subtract(a);\n            if (v0.lengthSquared() === 0 || v1.lengthSquared() === 0) {\n                return null;\n            }\n            var n = BABYLON.Vector3.Normalize(BABYLON.Vector3.Cross(v0, v1));\n            return new Plane(n, BABYLON.Vector3.Dot(n, a));\n        };\n        Plane.prototype.clone = function () {\n            return new Plane(this.normal.clone(), this.w);\n        };\n        Plane.prototype.flip = function () {\n            this.normal.scaleInPlace(-1);\n            this.w = -this.w;\n        };\n        // Split `polygon` by this plane if needed, then put the polygon or polygon\n        // fragments in the appropriate lists. Coplanar polygons go into either\n        // `coplanarFront` or `coplanarBack` depending on their orientation with\n        // respect to this plane. Polygons in front or in back of this plane go into\n        // either `front` or `back`.\n        Plane.prototype.splitPolygon = function (polygon, coplanarFront, coplanarBack, front, back) {\n            var COPLANAR = 0;\n            var FRONT = 1;\n            var BACK = 2;\n            var SPANNING = 3;\n            // Classify each point as well as the entire polygon into one of the above\n            // four classes.\n            var polygonType = 0;\n            var types = [];\n            var i;\n            var t;\n            for (i = 0; i < polygon.vertices.length; i++) {\n                t = BABYLON.Vector3.Dot(this.normal, polygon.vertices[i].pos) - this.w;\n                var type = (t < -Plane.EPSILON) ? BACK : (t > Plane.EPSILON) ? FRONT : COPLANAR;\n                polygonType |= type;\n                types.push(type);\n            }\n            // Put the polygon in the correct list, splitting it when necessary.\n            switch (polygonType) {\n                case COPLANAR:\n                    (BABYLON.Vector3.Dot(this.normal, polygon.plane.normal) > 0 ? coplanarFront : coplanarBack).push(polygon);\n                    break;\n                case FRONT:\n                    front.push(polygon);\n                    break;\n                case BACK:\n                    back.push(polygon);\n                    break;\n                case SPANNING:\n                    var f = [], b = [];\n                    for (i = 0; i < polygon.vertices.length; i++) {\n                        var j = (i + 1) % polygon.vertices.length;\n                        var ti = types[i], tj = types[j];\n                        var vi = polygon.vertices[i], vj = polygon.vertices[j];\n                        if (ti !== BACK)\n                            f.push(vi);\n                        if (ti !== FRONT)\n                            b.push(ti !== BACK ? vi.clone() : vi);\n                        if ((ti | tj) === SPANNING) {\n                            t = (this.w - BABYLON.Vector3.Dot(this.normal, vi.pos)) / BABYLON.Vector3.Dot(this.normal, vj.pos.subtract(vi.pos));\n                            var v = vi.interpolate(vj, t);\n                            f.push(v);\n                            b.push(v.clone());\n                        }\n                    }\n                    var poly;\n                    if (f.length >= 3) {\n                        poly = new Polygon(f, polygon.shared);\n                        if (poly.plane)\n                            front.push(poly);\n                    }\n                    if (b.length >= 3) {\n                        poly = new Polygon(b, polygon.shared);\n                        if (poly.plane)\n                            back.push(poly);\n                    }\n                    break;\n            }\n        };\n        return Plane;\n    }());\n    // `BABYLON.CSG.Plane.EPSILON` is the tolerance used by `splitPolygon()` to decide if a\n    // point is on the plane.\n    Plane.EPSILON = 1e-5;\n    // # class Polygon\n    // Represents a convex polygon. The vertices used to initialize a polygon must\n    // be coplanar and form a convex loop.\n    // \n    // Each convex polygon has a `shared` property, which is shared between all\n    // polygons that are clones of each other or were split from the same polygon.\n    // This can be used to define per-polygon properties (such as surface color).\n    var Polygon = (function () {\n        function Polygon(vertices, shared) {\n            this.vertices = vertices;\n            this.shared = shared;\n            this.plane = Plane.FromPoints(vertices[0].pos, vertices[1].pos, vertices[2].pos);\n        }\n        Polygon.prototype.clone = function () {\n            var vertices = this.vertices.map(function (v) { return v.clone(); });\n            return new Polygon(vertices, this.shared);\n        };\n        Polygon.prototype.flip = function () {\n            this.vertices.reverse().map(function (v) { v.flip(); });\n            this.plane.flip();\n        };\n        return Polygon;\n    }());\n    // # class Node\n    // Holds a node in a BSP tree. A BSP tree is built from a collection of polygons\n    // by picking a polygon to split along. That polygon (and all other coplanar\n    // polygons) are added directly to that node and the other polygons are added to\n    // the front and/or back subtrees. This is not a leafy BSP tree since there is\n    // no distinction between internal and leaf nodes.\n    var Node = (function () {\n        function Node(polygons) {\n            this.plane = null;\n            this.front = null;\n            this.back = null;\n            this.polygons = [];\n            if (polygons) {\n                this.build(polygons);\n            }\n        }\n        Node.prototype.clone = function () {\n            var node = new Node();\n            node.plane = this.plane && this.plane.clone();\n            node.front = this.front && this.front.clone();\n            node.back = this.back && this.back.clone();\n            node.polygons = this.polygons.map(function (p) { return p.clone(); });\n            return node;\n        };\n        // Convert solid space to empty space and empty space to solid space.\n        Node.prototype.invert = function () {\n            for (var i = 0; i < this.polygons.length; i++) {\n                this.polygons[i].flip();\n            }\n            if (this.plane) {\n                this.plane.flip();\n            }\n            if (this.front) {\n                this.front.invert();\n            }\n            if (this.back) {\n                this.back.invert();\n            }\n            var temp = this.front;\n            this.front = this.back;\n            this.back = temp;\n        };\n        // Recursively remove all polygons in `polygons` that are inside this BSP\n        // tree.\n        Node.prototype.clipPolygons = function (polygons) {\n            if (!this.plane)\n                return polygons.slice();\n            var front = [], back = [];\n            for (var i = 0; i < polygons.length; i++) {\n                this.plane.splitPolygon(polygons[i], front, back, front, back);\n            }\n            if (this.front) {\n                front = this.front.clipPolygons(front);\n            }\n            if (this.back) {\n                back = this.back.clipPolygons(back);\n            }\n            else {\n                back = [];\n            }\n            return front.concat(back);\n        };\n        // Remove all polygons in this BSP tree that are inside the other BSP tree\n        // `bsp`.\n        Node.prototype.clipTo = function (bsp) {\n            this.polygons = bsp.clipPolygons(this.polygons);\n            if (this.front)\n                this.front.clipTo(bsp);\n            if (this.back)\n                this.back.clipTo(bsp);\n        };\n        // Return a list of all polygons in this BSP tree.\n        Node.prototype.allPolygons = function () {\n            var polygons = this.polygons.slice();\n            if (this.front)\n                polygons = polygons.concat(this.front.allPolygons());\n            if (this.back)\n                polygons = polygons.concat(this.back.allPolygons());\n            return polygons;\n        };\n        // Build a BSP tree out of `polygons`. When called on an existing tree, the\n        // new polygons are filtered down to the bottom of the tree and become new\n        // nodes there. Each set of polygons is partitioned using the first polygon\n        // (no heuristic is used to pick a good split).\n        Node.prototype.build = function (polygons) {\n            if (!polygons.length)\n                return;\n            if (!this.plane)\n                this.plane = polygons[0].plane.clone();\n            var front = [], back = [];\n            for (var i = 0; i < polygons.length; i++) {\n                this.plane.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);\n            }\n            if (front.length) {\n                if (!this.front)\n                    this.front = new Node();\n                this.front.build(front);\n            }\n            if (back.length) {\n                if (!this.back)\n                    this.back = new Node();\n                this.back.build(back);\n            }\n        };\n        return Node;\n    }());\n    var CSG = (function () {\n        function CSG() {\n            this.polygons = new Array();\n        }\n        // Convert BABYLON.Mesh to BABYLON.CSG\n        CSG.FromMesh = function (mesh) {\n            var vertex, normal, uv, position, polygon, polygons = new Array(), vertices;\n            var matrix, meshPosition, meshRotation, meshRotationQuaternion, meshScaling;\n            if (mesh instanceof BABYLON.Mesh) {\n                mesh.computeWorldMatrix(true);\n                matrix = mesh.getWorldMatrix();\n                meshPosition = mesh.position.clone();\n                meshRotation = mesh.rotation.clone();\n                if (mesh.rotationQuaternion) {\n                    meshRotationQuaternion = mesh.rotationQuaternion.clone();\n                }\n                meshScaling = mesh.scaling.clone();\n            }\n            else {\n                throw 'BABYLON.CSG: Wrong Mesh type, must be BABYLON.Mesh';\n            }\n            var indices = mesh.getIndices(), positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind), normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind), uvs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var subMeshes = mesh.subMeshes;\n            for (var sm = 0, sml = subMeshes.length; sm < sml; sm++) {\n                for (var i = subMeshes[sm].indexStart, il = subMeshes[sm].indexCount + subMeshes[sm].indexStart; i < il; i += 3) {\n                    vertices = [];\n                    for (var j = 0; j < 3; j++) {\n                        var sourceNormal = new BABYLON.Vector3(normals[indices[i + j] * 3], normals[indices[i + j] * 3 + 1], normals[indices[i + j] * 3 + 2]);\n                        uv = new BABYLON.Vector2(uvs[indices[i + j] * 2], uvs[indices[i + j] * 2 + 1]);\n                        var sourcePosition = new BABYLON.Vector3(positions[indices[i + j] * 3], positions[indices[i + j] * 3 + 1], positions[indices[i + j] * 3 + 2]);\n                        position = BABYLON.Vector3.TransformCoordinates(sourcePosition, matrix);\n                        normal = BABYLON.Vector3.TransformNormal(sourceNormal, matrix);\n                        vertex = new Vertex(position, normal, uv);\n                        vertices.push(vertex);\n                    }\n                    polygon = new Polygon(vertices, { subMeshId: sm, meshId: currentCSGMeshId, materialIndex: subMeshes[sm].materialIndex });\n                    // To handle the case of degenerated triangle\n                    // polygon.plane == null <=> the polygon does not represent 1 single plane <=> the triangle is degenerated\n                    if (polygon.plane)\n                        polygons.push(polygon);\n                }\n            }\n            var csg = CSG.FromPolygons(polygons);\n            csg.matrix = matrix;\n            csg.position = meshPosition;\n            csg.rotation = meshRotation;\n            csg.scaling = meshScaling;\n            csg.rotationQuaternion = meshRotationQuaternion;\n            currentCSGMeshId++;\n            return csg;\n        };\n        // Construct a BABYLON.CSG solid from a list of `BABYLON.CSG.Polygon` instances.\n        CSG.FromPolygons = function (polygons) {\n            var csg = new CSG();\n            csg.polygons = polygons;\n            return csg;\n        };\n        CSG.prototype.clone = function () {\n            var csg = new CSG();\n            csg.polygons = this.polygons.map(function (p) { return p.clone(); });\n            csg.copyTransformAttributes(this);\n            return csg;\n        };\n        CSG.prototype.toPolygons = function () {\n            return this.polygons;\n        };\n        CSG.prototype.union = function (csg) {\n            var a = new Node(this.clone().polygons);\n            var b = new Node(csg.clone().polygons);\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n        };\n        CSG.prototype.unionInPlace = function (csg) {\n            var a = new Node(this.polygons);\n            var b = new Node(csg.polygons);\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            this.polygons = a.allPolygons();\n        };\n        CSG.prototype.subtract = function (csg) {\n            var a = new Node(this.clone().polygons);\n            var b = new Node(csg.clone().polygons);\n            a.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            a.invert();\n            return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n        };\n        CSG.prototype.subtractInPlace = function (csg) {\n            var a = new Node(this.polygons);\n            var b = new Node(csg.polygons);\n            a.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            b.invert();\n            b.clipTo(a);\n            b.invert();\n            a.build(b.allPolygons());\n            a.invert();\n            this.polygons = a.allPolygons();\n        };\n        CSG.prototype.intersect = function (csg) {\n            var a = new Node(this.clone().polygons);\n            var b = new Node(csg.clone().polygons);\n            a.invert();\n            b.clipTo(a);\n            b.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            a.build(b.allPolygons());\n            a.invert();\n            return CSG.FromPolygons(a.allPolygons()).copyTransformAttributes(this);\n        };\n        CSG.prototype.intersectInPlace = function (csg) {\n            var a = new Node(this.polygons);\n            var b = new Node(csg.polygons);\n            a.invert();\n            b.clipTo(a);\n            b.invert();\n            a.clipTo(b);\n            b.clipTo(a);\n            a.build(b.allPolygons());\n            a.invert();\n            this.polygons = a.allPolygons();\n        };\n        // Return a new BABYLON.CSG solid with solid and empty space switched. This solid is\n        // not modified.\n        CSG.prototype.inverse = function () {\n            var csg = this.clone();\n            csg.inverseInPlace();\n            return csg;\n        };\n        CSG.prototype.inverseInPlace = function () {\n            this.polygons.map(function (p) { p.flip(); });\n        };\n        // This is used to keep meshes transformations so they can be restored\n        // when we build back a Babylon Mesh\n        // NB : All CSG operations are performed in world coordinates\n        CSG.prototype.copyTransformAttributes = function (csg) {\n            this.matrix = csg.matrix;\n            this.position = csg.position;\n            this.rotation = csg.rotation;\n            this.scaling = csg.scaling;\n            this.rotationQuaternion = csg.rotationQuaternion;\n            return this;\n        };\n        // Build Raw mesh from CSG\n        // Coordinates here are in world space\n        CSG.prototype.buildMeshGeometry = function (name, scene, keepSubMeshes) {\n            var matrix = this.matrix.clone();\n            matrix.invert();\n            var mesh = new BABYLON.Mesh(name, scene), vertices = [], indices = [], normals = [], uvs = [], vertex = BABYLON.Vector3.Zero(), normal = BABYLON.Vector3.Zero(), uv = BABYLON.Vector2.Zero(), polygons = this.polygons, polygonIndices = [0, 0, 0], polygon, vertice_dict = {}, vertex_idx, currentIndex = 0, subMesh_dict = {}, subMesh_obj;\n            if (keepSubMeshes) {\n                // Sort Polygons, since subMeshes are indices range\n                polygons.sort(function (a, b) {\n                    if (a.shared.meshId === b.shared.meshId) {\n                        return a.shared.subMeshId - b.shared.subMeshId;\n                    }\n                    else {\n                        return a.shared.meshId - b.shared.meshId;\n                    }\n                });\n            }\n            for (var i = 0, il = polygons.length; i < il; i++) {\n                polygon = polygons[i];\n                // Building SubMeshes\n                if (!subMesh_dict[polygon.shared.meshId]) {\n                    subMesh_dict[polygon.shared.meshId] = {};\n                }\n                if (!subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId]) {\n                    subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId] = {\n                        indexStart: +Infinity,\n                        indexEnd: -Infinity,\n                        materialIndex: polygon.shared.materialIndex\n                    };\n                }\n                subMesh_obj = subMesh_dict[polygon.shared.meshId][polygon.shared.subMeshId];\n                for (var j = 2, jl = polygon.vertices.length; j < jl; j++) {\n                    polygonIndices[0] = 0;\n                    polygonIndices[1] = j - 1;\n                    polygonIndices[2] = j;\n                    for (var k = 0; k < 3; k++) {\n                        vertex.copyFrom(polygon.vertices[polygonIndices[k]].pos);\n                        normal.copyFrom(polygon.vertices[polygonIndices[k]].normal);\n                        uv.copyFrom(polygon.vertices[polygonIndices[k]].uv);\n                        var localVertex = BABYLON.Vector3.TransformCoordinates(vertex, matrix);\n                        var localNormal = BABYLON.Vector3.TransformNormal(normal, matrix);\n                        vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z];\n                        // Check if 2 points can be merged\n                        if (!(typeof vertex_idx !== 'undefined' &&\n                            normals[vertex_idx * 3] === localNormal.x &&\n                            normals[vertex_idx * 3 + 1] === localNormal.y &&\n                            normals[vertex_idx * 3 + 2] === localNormal.z &&\n                            uvs[vertex_idx * 2] === uv.x &&\n                            uvs[vertex_idx * 2 + 1] === uv.y)) {\n                            vertices.push(localVertex.x, localVertex.y, localVertex.z);\n                            uvs.push(uv.x, uv.y);\n                            normals.push(normal.x, normal.y, normal.z);\n                            vertex_idx = vertice_dict[localVertex.x + ',' + localVertex.y + ',' + localVertex.z] = (vertices.length / 3) - 1;\n                        }\n                        indices.push(vertex_idx);\n                        subMesh_obj.indexStart = Math.min(currentIndex, subMesh_obj.indexStart);\n                        subMesh_obj.indexEnd = Math.max(currentIndex, subMesh_obj.indexEnd);\n                        currentIndex++;\n                    }\n                }\n            }\n            mesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, vertices);\n            mesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, normals);\n            mesh.setVerticesData(BABYLON.VertexBuffer.UVKind, uvs);\n            mesh.setIndices(indices);\n            if (keepSubMeshes) {\n                // We offset the materialIndex by the previous number of materials in the CSG mixed meshes\n                var materialIndexOffset = 0, materialMaxIndex;\n                mesh.subMeshes = new Array();\n                for (var m in subMesh_dict) {\n                    materialMaxIndex = -1;\n                    for (var sm in subMesh_dict[m]) {\n                        subMesh_obj = subMesh_dict[m][sm];\n                        BABYLON.SubMesh.CreateFromIndices(subMesh_obj.materialIndex + materialIndexOffset, subMesh_obj.indexStart, subMesh_obj.indexEnd - subMesh_obj.indexStart + 1, mesh);\n                        materialMaxIndex = Math.max(subMesh_obj.materialIndex, materialMaxIndex);\n                    }\n                    materialIndexOffset += ++materialMaxIndex;\n                }\n            }\n            return mesh;\n        };\n        // Build Mesh from CSG taking material and transforms into account\n        CSG.prototype.toMesh = function (name, material, scene, keepSubMeshes) {\n            var mesh = this.buildMeshGeometry(name, scene, keepSubMeshes);\n            mesh.material = material;\n            mesh.position.copyFrom(this.position);\n            mesh.rotation.copyFrom(this.rotation);\n            if (this.rotationQuaternion) {\n                mesh.rotationQuaternion = this.rotationQuaternion.clone();\n            }\n            mesh.scaling.copyFrom(this.scaling);\n            mesh.computeWorldMatrix(true);\n            return mesh;\n        };\n        return CSG;\n    }());\n    BABYLON.CSG = CSG;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.csg.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var LensFlare = (function () {\n        function LensFlare(size, position, color, imgUrl, system) {\n            this.size = size;\n            this.position = position;\n            this.alphaMode = BABYLON.Engine.ALPHA_ONEONE;\n            this.dispose = function () {\n                if (this.texture) {\n                    this.texture.dispose();\n                }\n                // Remove from scene\n                var index = this._system.lensFlares.indexOf(this);\n                this._system.lensFlares.splice(index, 1);\n            };\n            this.color = color || new BABYLON.Color3(1, 1, 1);\n            this.texture = imgUrl ? new BABYLON.Texture(imgUrl, system.getScene(), true) : null;\n            this._system = system;\n            system.lensFlares.push(this);\n        }\n        return LensFlare;\n    }());\n    BABYLON.LensFlare = LensFlare;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.lensFlare.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var LensFlareSystem = (function () {\n        function LensFlareSystem(name, emitter, scene) {\n            this.name = name;\n            this.lensFlares = new Array();\n            this.borderLimit = 300;\n            this.viewportBorder = 0;\n            this.layerMask = 0x0FFFFFFF;\n            this._vertexBuffers = {};\n            this._isEnabled = true;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._emitter = emitter;\n            this.id = name;\n            scene.lensFlareSystems.push(this);\n            this.meshesSelectionPredicate = function (m) { return m.material && m.isVisible && m.isEnabled() && m.isBlocker && ((m.layerMask & scene.activeCamera.layerMask) != 0); };\n            var engine = scene.getEngine();\n            // VBO\n            var vertices = [];\n            vertices.push(1, 1);\n            vertices.push(-1, 1);\n            vertices.push(-1, -1);\n            vertices.push(1, -1);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = new BABYLON.VertexBuffer(engine, vertices, BABYLON.VertexBuffer.PositionKind, false, false, 2);\n            // Indices\n            var indices = [];\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            this._indexBuffer = engine.createIndexBuffer(indices);\n            // Effects\n            this._effect = engine.createEffect(\"lensFlare\", [BABYLON.VertexBuffer.PositionKind], [\"color\", \"viewportMatrix\"], [\"textureSampler\"], \"\");\n        }\n        Object.defineProperty(LensFlareSystem.prototype, \"isEnabled\", {\n            get: function () {\n                return this._isEnabled;\n            },\n            set: function (value) {\n                this._isEnabled = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LensFlareSystem.prototype.getScene = function () {\n            return this._scene;\n        };\n        LensFlareSystem.prototype.getEmitter = function () {\n            return this._emitter;\n        };\n        LensFlareSystem.prototype.setEmitter = function (newEmitter) {\n            this._emitter = newEmitter;\n        };\n        LensFlareSystem.prototype.getEmitterPosition = function () {\n            return this._emitter.getAbsolutePosition ? this._emitter.getAbsolutePosition() : this._emitter.position;\n        };\n        LensFlareSystem.prototype.computeEffectivePosition = function (globalViewport) {\n            var position = this.getEmitterPosition();\n            position = BABYLON.Vector3.Project(position, BABYLON.Matrix.Identity(), this._scene.getTransformMatrix(), globalViewport);\n            this._positionX = position.x;\n            this._positionY = position.y;\n            position = BABYLON.Vector3.TransformCoordinates(this.getEmitterPosition(), this._scene.getViewMatrix());\n            if (this.viewportBorder > 0) {\n                globalViewport.x -= this.viewportBorder;\n                globalViewport.y -= this.viewportBorder;\n                globalViewport.width += this.viewportBorder * 2;\n                globalViewport.height += this.viewportBorder * 2;\n                position.x += this.viewportBorder;\n                position.y += this.viewportBorder;\n                this._positionX += this.viewportBorder;\n                this._positionY += this.viewportBorder;\n            }\n            if (position.z > 0) {\n                if ((this._positionX > globalViewport.x) && (this._positionX < globalViewport.x + globalViewport.width)) {\n                    if ((this._positionY > globalViewport.y) && (this._positionY < globalViewport.y + globalViewport.height))\n                        return true;\n                }\n                return true;\n            }\n            return false;\n        };\n        LensFlareSystem.prototype._isVisible = function () {\n            if (!this._isEnabled) {\n                return false;\n            }\n            var emitterPosition = this.getEmitterPosition();\n            var direction = emitterPosition.subtract(this._scene.activeCamera.globalPosition);\n            var distance = direction.length();\n            direction.normalize();\n            var ray = new BABYLON.Ray(this._scene.activeCamera.globalPosition, direction);\n            var pickInfo = this._scene.pickWithRay(ray, this.meshesSelectionPredicate, true);\n            return !pickInfo.hit || pickInfo.distance > distance;\n        };\n        LensFlareSystem.prototype.render = function () {\n            if (!this._effect.isReady())\n                return false;\n            var engine = this._scene.getEngine();\n            var viewport = this._scene.activeCamera.viewport;\n            var globalViewport = viewport.toGlobal(engine.getRenderWidth(true), engine.getRenderHeight(true));\n            // Position\n            if (!this.computeEffectivePosition(globalViewport)) {\n                return false;\n            }\n            // Visibility\n            if (!this._isVisible()) {\n                return false;\n            }\n            // Intensity\n            var awayX;\n            var awayY;\n            if (this._positionX < this.borderLimit + globalViewport.x) {\n                awayX = this.borderLimit + globalViewport.x - this._positionX;\n            }\n            else if (this._positionX > globalViewport.x + globalViewport.width - this.borderLimit) {\n                awayX = this._positionX - globalViewport.x - globalViewport.width + this.borderLimit;\n            }\n            else {\n                awayX = 0;\n            }\n            if (this._positionY < this.borderLimit + globalViewport.y) {\n                awayY = this.borderLimit + globalViewport.y - this._positionY;\n            }\n            else if (this._positionY > globalViewport.y + globalViewport.height - this.borderLimit) {\n                awayY = this._positionY - globalViewport.y - globalViewport.height + this.borderLimit;\n            }\n            else {\n                awayY = 0;\n            }\n            var away = (awayX > awayY) ? awayX : awayY;\n            away -= this.viewportBorder;\n            if (away > this.borderLimit) {\n                away = this.borderLimit;\n            }\n            var intensity = 1.0 - (away / this.borderLimit);\n            if (intensity < 0) {\n                return false;\n            }\n            if (intensity > 1.0) {\n                intensity = 1.0;\n            }\n            if (this.viewportBorder > 0) {\n                globalViewport.x += this.viewportBorder;\n                globalViewport.y += this.viewportBorder;\n                globalViewport.width -= this.viewportBorder * 2;\n                globalViewport.height -= this.viewportBorder * 2;\n                this._positionX -= this.viewportBorder;\n                this._positionY -= this.viewportBorder;\n            }\n            // Position\n            var centerX = globalViewport.x + globalViewport.width / 2;\n            var centerY = globalViewport.y + globalViewport.height / 2;\n            var distX = centerX - this._positionX;\n            var distY = centerY - this._positionY;\n            // Effects\n            engine.enableEffect(this._effect);\n            engine.setState(false);\n            engine.setDepthBuffer(false);\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._effect);\n            // Flares\n            for (var index = 0; index < this.lensFlares.length; index++) {\n                var flare = this.lensFlares[index];\n                engine.setAlphaMode(flare.alphaMode);\n                var x = centerX - (distX * flare.position);\n                var y = centerY - (distY * flare.position);\n                var cw = flare.size;\n                var ch = flare.size * engine.getAspectRatio(this._scene.activeCamera, true);\n                var cx = 2 * (x / (globalViewport.width + globalViewport.x * 2)) - 1.0;\n                var cy = 1.0 - 2 * (y / (globalViewport.height + globalViewport.y * 2));\n                var viewportMatrix = BABYLON.Matrix.FromValues(cw / 2, 0, 0, 0, 0, ch / 2, 0, 0, 0, 0, 1, 0, cx, cy, 0, 1);\n                this._effect.setMatrix(\"viewportMatrix\", viewportMatrix);\n                // Texture\n                this._effect.setTexture(\"textureSampler\", flare.texture);\n                // Color\n                this._effect.setFloat4(\"color\", flare.color.r * intensity, flare.color.g * intensity, flare.color.b * intensity, 1.0);\n                // Draw order\n                engine.draw(true, 0, 6);\n            }\n            engine.setDepthBuffer(true);\n            engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n            return true;\n        };\n        LensFlareSystem.prototype.dispose = function () {\n            var vertexBuffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (vertexBuffer) {\n                vertexBuffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n            while (this.lensFlares.length) {\n                this.lensFlares[0].dispose();\n            }\n            // Remove from scene\n            var index = this._scene.lensFlareSystems.indexOf(this);\n            this._scene.lensFlareSystems.splice(index, 1);\n        };\n        LensFlareSystem.Parse = function (parsedLensFlareSystem, scene, rootUrl) {\n            var emitter = scene.getLastEntryByID(parsedLensFlareSystem.emitterId);\n            var name = parsedLensFlareSystem.name || \"lensFlareSystem#\" + parsedLensFlareSystem.emitterId;\n            var lensFlareSystem = new LensFlareSystem(name, emitter, scene);\n            lensFlareSystem.id = parsedLensFlareSystem.id || name;\n            lensFlareSystem.borderLimit = parsedLensFlareSystem.borderLimit;\n            for (var index = 0; index < parsedLensFlareSystem.flares.length; index++) {\n                var parsedFlare = parsedLensFlareSystem.flares[index];\n                var flare = new BABYLON.LensFlare(parsedFlare.size, parsedFlare.position, BABYLON.Color3.FromArray(parsedFlare.color), parsedFlare.textureName ? rootUrl + parsedFlare.textureName : \"\", lensFlareSystem);\n            }\n            return lensFlareSystem;\n        };\n        LensFlareSystem.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.id = this.id;\n            serializationObject.name = this.name;\n            serializationObject.emitterId = this.getEmitter().id;\n            serializationObject.borderLimit = this.borderLimit;\n            serializationObject.flares = [];\n            for (var index = 0; index < this.lensFlares.length; index++) {\n                var flare = this.lensFlares[index];\n                serializationObject.flares.push({\n                    size: flare.size,\n                    position: flare.position,\n                    color: flare.color.asArray(),\n                    textureName: BABYLON.Tools.GetFilename(flare.texture.name)\n                });\n            }\n            return serializationObject;\n        };\n        return LensFlareSystem;\n    }());\n    BABYLON.LensFlareSystem = LensFlareSystem;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.lensFlareSystem.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This is a holder class for the physics joint created by the physics plugin.\n     * It holds a set of functions to control the underlying joint.\n     */\n    var PhysicsJoint = (function () {\n        function PhysicsJoint(type, jointData) {\n            this.type = type;\n            this.jointData = jointData;\n            jointData.nativeParams = jointData.nativeParams || {};\n        }\n        Object.defineProperty(PhysicsJoint.prototype, \"physicsJoint\", {\n            get: function () {\n                return this._physicsJoint;\n            },\n            set: function (newJoint) {\n                if (this._physicsJoint) {\n                    //remove from the wolrd\n                }\n                this._physicsJoint = newJoint;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PhysicsJoint.prototype, \"physicsPlugin\", {\n            set: function (physicsPlugin) {\n                this._physicsPlugin = physicsPlugin;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Execute a function that is physics-plugin specific.\n         * @param {Function} func the function that will be executed.\n         *                        It accepts two parameters: the physics world and the physics joint.\n         */\n        PhysicsJoint.prototype.executeNativeFunction = function (func) {\n            func(this._physicsPlugin.world, this._physicsJoint);\n        };\n        return PhysicsJoint;\n    }());\n    //TODO check if the native joints are the same\n    //Joint Types\n    PhysicsJoint.DistanceJoint = 0;\n    PhysicsJoint.HingeJoint = 1;\n    PhysicsJoint.BallAndSocketJoint = 2;\n    PhysicsJoint.WheelJoint = 3;\n    PhysicsJoint.SliderJoint = 4;\n    //OIMO\n    PhysicsJoint.PrismaticJoint = 5;\n    //ENERGY FTW! (compare with this - http://ode-wiki.org/wiki/index.php?title=Manual:_Joint_Types_and_Functions)\n    PhysicsJoint.UniversalJoint = 6;\n    PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;\n    //Cannon\n    //Similar to a Ball-Joint. Different in params\n    PhysicsJoint.PointToPointJoint = 8;\n    //Cannon only at the moment\n    PhysicsJoint.SpringJoint = 9;\n    PhysicsJoint.LockJoint = 10;\n    BABYLON.PhysicsJoint = PhysicsJoint;\n    /**\n     * A class representing a physics distance joint.\n     */\n    var DistanceJoint = (function (_super) {\n        __extends(DistanceJoint, _super);\n        function DistanceJoint(jointData) {\n            return _super.call(this, PhysicsJoint.DistanceJoint, jointData) || this;\n        }\n        /**\n         * Update the predefined distance.\n         */\n        DistanceJoint.prototype.updateDistance = function (maxDistance, minDistance) {\n            this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);\n        };\n        return DistanceJoint;\n    }(PhysicsJoint));\n    BABYLON.DistanceJoint = DistanceJoint;\n    var MotorEnabledJoint = (function (_super) {\n        __extends(MotorEnabledJoint, _super);\n        function MotorEnabledJoint(type, jointData) {\n            return _super.call(this, type, jointData) || this;\n        }\n        /**\n         * Set the motor values.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         * @param {number} force the force to apply\n         * @param {number} maxForce max force for this motor.\n         */\n        MotorEnabledJoint.prototype.setMotor = function (force, maxForce) {\n            this._physicsPlugin.setMotor(this, force, maxForce);\n        };\n        /**\n         * Set the motor's limits.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         */\n        MotorEnabledJoint.prototype.setLimit = function (upperLimit, lowerLimit) {\n            this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\n        };\n        return MotorEnabledJoint;\n    }(PhysicsJoint));\n    BABYLON.MotorEnabledJoint = MotorEnabledJoint;\n    /**\n     * This class represents a single hinge physics joint\n     */\n    var HingeJoint = (function (_super) {\n        __extends(HingeJoint, _super);\n        function HingeJoint(jointData) {\n            return _super.call(this, PhysicsJoint.HingeJoint, jointData) || this;\n        }\n        /**\n         * Set the motor values.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         * @param {number} force the force to apply\n         * @param {number} maxForce max force for this motor.\n         */\n        HingeJoint.prototype.setMotor = function (force, maxForce) {\n            this._physicsPlugin.setMotor(this, force, maxForce);\n        };\n        /**\n         * Set the motor's limits.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         */\n        HingeJoint.prototype.setLimit = function (upperLimit, lowerLimit) {\n            this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);\n        };\n        return HingeJoint;\n    }(MotorEnabledJoint));\n    BABYLON.HingeJoint = HingeJoint;\n    /**\n     * This class represents a dual hinge physics joint (same as wheel joint)\n     */\n    var Hinge2Joint = (function (_super) {\n        __extends(Hinge2Joint, _super);\n        function Hinge2Joint(jointData) {\n            return _super.call(this, PhysicsJoint.Hinge2Joint, jointData) || this;\n        }\n        /**\n         * Set the motor values.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         * @param {number} force the force to apply\n         * @param {number} maxForce max force for this motor.\n         * @param {motorIndex} the motor's index, 0 or 1.\n         */\n        Hinge2Joint.prototype.setMotor = function (force, maxForce, motorIndex) {\n            if (motorIndex === void 0) { motorIndex = 0; }\n            this._physicsPlugin.setMotor(this, force, maxForce, motorIndex);\n        };\n        /**\n         * Set the motor limits.\n         * Attention, this function is plugin specific. Engines won't react 100% the same.\n         * @param {number} upperLimit the upper limit\n         * @param {number} lowerLimit lower limit\n         * @param {motorIndex} the motor's index, 0 or 1.\n         */\n        Hinge2Joint.prototype.setLimit = function (upperLimit, lowerLimit, motorIndex) {\n            if (motorIndex === void 0) { motorIndex = 0; }\n            this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);\n        };\n        return Hinge2Joint;\n    }(MotorEnabledJoint));\n    BABYLON.Hinge2Joint = Hinge2Joint;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.physicsJoint.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PhysicsImpostor = (function () {\n        function PhysicsImpostor(object, type, _options, _scene) {\n            if (_options === void 0) { _options = { mass: 0 }; }\n            var _this = this;\n            this.object = object;\n            this.type = type;\n            this._options = _options;\n            this._scene = _scene;\n            this._bodyUpdateRequired = false;\n            this._onBeforePhysicsStepCallbacks = new Array();\n            this._onAfterPhysicsStepCallbacks = new Array();\n            this._onPhysicsCollideCallbacks = [];\n            this._deltaPosition = BABYLON.Vector3.Zero();\n            this._isDisposed = false;\n            this._tmpPositionWithDelta = BABYLON.Vector3.Zero();\n            this._tmpRotationWithDelta = new BABYLON.Quaternion();\n            /**\n             * this function is executed by the physics engine.\n             */\n            this.beforeStep = function () {\n                _this.object.position.subtractToRef(_this._deltaPosition, _this._tmpPositionWithDelta);\n                //conjugate deltaRotation\n                if (_this._deltaRotationConjugated) {\n                    _this.object.rotationQuaternion.multiplyToRef(_this._deltaRotationConjugated, _this._tmpRotationWithDelta);\n                }\n                else {\n                    _this._tmpRotationWithDelta.copyFrom(_this.object.rotationQuaternion);\n                }\n                _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this, _this._tmpPositionWithDelta, _this._tmpRotationWithDelta);\n                _this._onBeforePhysicsStepCallbacks.forEach(function (func) {\n                    func(_this);\n                });\n            };\n            /**\n             * this function is executed by the physics engine.\n             */\n            this.afterStep = function () {\n                _this._onAfterPhysicsStepCallbacks.forEach(function (func) {\n                    func(_this);\n                });\n                _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this);\n                _this.object.position.addInPlace(_this._deltaPosition);\n                if (_this._deltaRotation) {\n                    _this.object.rotationQuaternion.multiplyInPlace(_this._deltaRotation);\n                }\n            };\n            /**\n             * Legacy collision detection event support\n             */\n            this.onCollideEvent = null;\n            //event and body object due to cannon's event-based architecture.\n            this.onCollide = function (e) {\n                if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent)\n                    return;\n                var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);\n                if (otherImpostor) {\n                    // Legacy collision detection event support\n                    if (_this.onCollideEvent) {\n                        _this.onCollideEvent(_this, otherImpostor);\n                    }\n                    _this._onPhysicsCollideCallbacks.filter(function (obj) {\n                        return obj.otherImpostors.indexOf(otherImpostor) !== -1;\n                    }).forEach(function (obj) {\n                        obj.callback(_this, otherImpostor);\n                    });\n                }\n            };\n            //sanity check!\n            if (!this.object) {\n                BABYLON.Tools.Error(\"No object was provided. A physics object is obligatory\");\n                return;\n            }\n            //legacy support for old syntax.\n            if (!this._scene && object.getScene) {\n                this._scene = object.getScene();\n            }\n            this._physicsEngine = this._scene.getPhysicsEngine();\n            if (!this._physicsEngine) {\n                BABYLON.Tools.Error(\"Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.\");\n            }\n            else {\n                //set the object's quaternion, if not set\n                if (!this.object.rotationQuaternion) {\n                    if (this.object.rotation) {\n                        this.object.rotationQuaternion = BABYLON.Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);\n                    }\n                    else {\n                        this.object.rotationQuaternion = new BABYLON.Quaternion();\n                    }\n                }\n                //default options params\n                this._options.mass = (_options.mass === void 0) ? 0 : _options.mass;\n                this._options.friction = (_options.friction === void 0) ? 0.2 : _options.friction;\n                this._options.restitution = (_options.restitution === void 0) ? 0.2 : _options.restitution;\n                this._joints = [];\n                //If the mesh has a parent, don't initialize the physicsBody. Instead wait for the parent to do that.\n                if (!this.object.parent) {\n                    this._init();\n                }\n                else if (this.object.parent.physicsImpostor) {\n                    BABYLON.Tools.Warn(\"You must affect impostors to children before affecting impostor to parent.\");\n                }\n            }\n        }\n        Object.defineProperty(PhysicsImpostor.prototype, \"isDisposed\", {\n            get: function () {\n                return this._isDisposed;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PhysicsImpostor.prototype, \"mass\", {\n            get: function () {\n                return this._physicsEngine.getPhysicsPlugin().getBodyMass(this);\n            },\n            set: function (value) {\n                this.setMass(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PhysicsImpostor.prototype, \"friction\", {\n            get: function () {\n                return this._physicsEngine.getPhysicsPlugin().getBodyFriction(this);\n            },\n            set: function (value) {\n                this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PhysicsImpostor.prototype, \"restitution\", {\n            get: function () {\n                return this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this);\n            },\n            set: function (value) {\n                this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * This function will completly initialize this impostor.\n         * It will create a new body - but only if this mesh has no parent.\n         * If it has, this impostor will not be used other than to define the impostor\n         * of the child mesh.\n         */\n        PhysicsImpostor.prototype._init = function () {\n            this._physicsEngine.removeImpostor(this);\n            this.physicsBody = null;\n            this._parent = this._parent || this._getPhysicsParent();\n            if (!this.parent) {\n                this._physicsEngine.addImpostor(this);\n            }\n        };\n        PhysicsImpostor.prototype._getPhysicsParent = function () {\n            if (this.object.parent instanceof BABYLON.AbstractMesh) {\n                var parentMesh = this.object.parent;\n                return parentMesh.physicsImpostor;\n            }\n            return;\n        };\n        /**\n         * Should a new body be generated.\n         */\n        PhysicsImpostor.prototype.isBodyInitRequired = function () {\n            return this._bodyUpdateRequired || (!this._physicsBody && !this._parent);\n        };\n        PhysicsImpostor.prototype.setScalingUpdated = function (updated) {\n            this.forceUpdate();\n        };\n        /**\n         * Force a regeneration of this or the parent's impostor's body.\n         * Use under cautious - This will remove all joints already implemented.\n         */\n        PhysicsImpostor.prototype.forceUpdate = function () {\n            this._init();\n            if (this.parent) {\n                this.parent.forceUpdate();\n            }\n        };\n        Object.defineProperty(PhysicsImpostor.prototype, \"physicsBody\", {\n            /*public get mesh(): AbstractMesh {\n                return this._mesh;\n            }*/\n            /**\n             * Gets the body that holds this impostor. Either its own, or its parent.\n             */\n            get: function () {\n                return this._parent ? this._parent.physicsBody : this._physicsBody;\n            },\n            /**\n             * Set the physics body. Used mainly by the physics engine/plugin\n             */\n            set: function (physicsBody) {\n                if (this._physicsBody) {\n                    this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);\n                }\n                this._physicsBody = physicsBody;\n                this.resetUpdateFlags();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PhysicsImpostor.prototype, \"parent\", {\n            get: function () {\n                return this._parent;\n            },\n            set: function (value) {\n                this._parent = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PhysicsImpostor.prototype.resetUpdateFlags = function () {\n            this._bodyUpdateRequired = false;\n        };\n        PhysicsImpostor.prototype.getObjectExtendSize = function () {\n            if (this.object.getBoundingInfo) {\n                var q = this.object.rotationQuaternion;\n                //reset rotation\n                this.object.rotationQuaternion = PhysicsImpostor.IDENTITY_QUATERNION;\n                //calculate the world matrix with no rotation\n                this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n                var size = this.object.getBoundingInfo().boundingBox.extendSizeWorld.scale(2);\n                //bring back the rotation\n                this.object.rotationQuaternion = q;\n                //calculate the world matrix with the new rotation\n                this.object.computeWorldMatrix && this.object.computeWorldMatrix(true);\n                return size;\n            }\n            else {\n                return PhysicsImpostor.DEFAULT_OBJECT_SIZE;\n            }\n        };\n        PhysicsImpostor.prototype.getObjectCenter = function () {\n            if (this.object.getBoundingInfo) {\n                return this.object.getBoundingInfo().boundingBox.centerWorld;\n            }\n            else {\n                return this.object.position;\n            }\n        };\n        /**\n         * Get a specific parametes from the options parameter.\n         */\n        PhysicsImpostor.prototype.getParam = function (paramName) {\n            return this._options[paramName];\n        };\n        /**\n         * Sets a specific parameter in the options given to the physics plugin\n         */\n        PhysicsImpostor.prototype.setParam = function (paramName, value) {\n            this._options[paramName] = value;\n            this._bodyUpdateRequired = true;\n        };\n        /**\n         * Specifically change the body's mass option. Won't recreate the physics body object\n         */\n        PhysicsImpostor.prototype.setMass = function (mass) {\n            if (this.getParam(\"mass\") !== mass) {\n                this.setParam(\"mass\", mass);\n            }\n            this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);\n        };\n        PhysicsImpostor.prototype.getLinearVelocity = function () {\n            return this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this);\n        };\n        PhysicsImpostor.prototype.setLinearVelocity = function (velocity) {\n            this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);\n        };\n        PhysicsImpostor.prototype.getAngularVelocity = function () {\n            return this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this);\n        };\n        PhysicsImpostor.prototype.setAngularVelocity = function (velocity) {\n            this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);\n        };\n        /**\n         * Execute a function with the physics plugin native code.\n         * Provide a function the will have two variables - the world object and the physics body object.\n         */\n        PhysicsImpostor.prototype.executeNativeFunction = function (func) {\n            func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);\n        };\n        /**\n         * Register a function that will be executed before the physics world is stepping forward.\n         */\n        PhysicsImpostor.prototype.registerBeforePhysicsStep = function (func) {\n            this._onBeforePhysicsStepCallbacks.push(func);\n        };\n        PhysicsImpostor.prototype.unregisterBeforePhysicsStep = function (func) {\n            var index = this._onBeforePhysicsStepCallbacks.indexOf(func);\n            if (index > -1) {\n                this._onBeforePhysicsStepCallbacks.splice(index, 1);\n            }\n            else {\n                BABYLON.Tools.Warn(\"Function to remove was not found\");\n            }\n        };\n        /**\n         * Register a function that will be executed after the physics step\n         */\n        PhysicsImpostor.prototype.registerAfterPhysicsStep = function (func) {\n            this._onAfterPhysicsStepCallbacks.push(func);\n        };\n        PhysicsImpostor.prototype.unregisterAfterPhysicsStep = function (func) {\n            var index = this._onAfterPhysicsStepCallbacks.indexOf(func);\n            if (index > -1) {\n                this._onAfterPhysicsStepCallbacks.splice(index, 1);\n            }\n            else {\n                BABYLON.Tools.Warn(\"Function to remove was not found\");\n            }\n        };\n        /**\n         * register a function that will be executed when this impostor collides against a different body.\n         */\n        PhysicsImpostor.prototype.registerOnPhysicsCollide = function (collideAgainst, func) {\n            var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n            this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });\n        };\n        PhysicsImpostor.prototype.unregisterOnPhysicsCollide = function (collideAgainst, func) {\n            var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];\n            var index = this._onPhysicsCollideCallbacks.indexOf({ callback: func, otherImpostors: collidedAgainstList });\n            if (index > -1) {\n                this._onPhysicsCollideCallbacks.splice(index, 1);\n            }\n            else {\n                BABYLON.Tools.Warn(\"Function to remove was not found\");\n            }\n        };\n        /**\n         * Apply a force\n         */\n        PhysicsImpostor.prototype.applyForce = function (force, contactPoint) {\n            this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);\n        };\n        /**\n         * Apply an impulse\n         */\n        PhysicsImpostor.prototype.applyImpulse = function (force, contactPoint) {\n            this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);\n        };\n        /**\n         * A help function to create a joint.\n         */\n        PhysicsImpostor.prototype.createJoint = function (otherImpostor, jointType, jointData) {\n            var joint = new BABYLON.PhysicsJoint(jointType, jointData);\n            this.addJoint(otherImpostor, joint);\n        };\n        /**\n         * Add a joint to this impostor with a different impostor.\n         */\n        PhysicsImpostor.prototype.addJoint = function (otherImpostor, joint) {\n            this._joints.push({\n                otherImpostor: otherImpostor,\n                joint: joint\n            });\n            this._physicsEngine.addJoint(this, otherImpostor, joint);\n        };\n        /**\n         * Will keep this body still, in a sleep mode.\n         */\n        PhysicsImpostor.prototype.sleep = function () {\n            this._physicsEngine.getPhysicsPlugin().sleepBody(this);\n        };\n        /**\n         * Wake the body up.\n         */\n        PhysicsImpostor.prototype.wakeUp = function () {\n            this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);\n        };\n        PhysicsImpostor.prototype.clone = function (newObject) {\n            if (!newObject)\n                return null;\n            return new PhysicsImpostor(newObject, this.type, this._options, this._scene);\n        };\n        PhysicsImpostor.prototype.dispose = function () {\n            var _this = this;\n            //no dispose if no physics engine is available.\n            if (!this._physicsEngine) {\n                return;\n            }\n            this._joints.forEach(function (j) {\n                _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);\n            });\n            //dispose the physics body\n            this._physicsEngine.removeImpostor(this);\n            if (this.parent) {\n                this.parent.forceUpdate();\n            }\n            else {\n                /*this._object.getChildMeshes().forEach(function(mesh) {\n                    if (mesh.physicsImpostor) {\n                        if (disposeChildren) {\n                            mesh.physicsImpostor.dispose();\n                            mesh.physicsImpostor = null;\n                        }\n                    }\n                })*/\n            }\n            this._isDisposed = true;\n        };\n        PhysicsImpostor.prototype.setDeltaPosition = function (position) {\n            this._deltaPosition.copyFrom(position);\n        };\n        PhysicsImpostor.prototype.setDeltaRotation = function (rotation) {\n            if (!this._deltaRotation) {\n                this._deltaRotation = new BABYLON.Quaternion();\n            }\n            this._deltaRotation.copyFrom(rotation);\n            this._deltaRotationConjugated = this._deltaRotation.conjugate();\n        };\n        PhysicsImpostor.prototype.getBoxSizeToRef = function (result) {\n            this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);\n        };\n        PhysicsImpostor.prototype.getRadius = function () {\n            return this._physicsEngine.getPhysicsPlugin().getRadius(this);\n        };\n        /**\n         * Sync a bone with this impostor\n         * @param bone The bone to sync to the impostor.\n         * @param boneMesh The mesh that the bone is influencing.\n         * @param jointPivot The pivot of the joint / bone in local space.\n         * @param distToJoint Optional distance from the impostor to the joint.\n         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n         */\n        PhysicsImpostor.prototype.syncBoneWithImpostor = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation) {\n            var tempVec = PhysicsImpostor._tmpVecs[0];\n            var mesh = this.object;\n            if (adjustRotation) {\n                var tempQuat = PhysicsImpostor._tmpQuat;\n                mesh.rotationQuaternion.multiplyToRef(adjustRotation, tempQuat);\n                bone.setRotationQuaternion(tempQuat, BABYLON.Space.WORLD, boneMesh);\n            }\n            else {\n                bone.setRotationQuaternion(mesh.rotationQuaternion, BABYLON.Space.WORLD, boneMesh);\n            }\n            tempVec.x = 0;\n            tempVec.y = 0;\n            tempVec.z = 0;\n            if (jointPivot) {\n                tempVec.x = jointPivot.x;\n                tempVec.y = jointPivot.y;\n                tempVec.z = jointPivot.z;\n                bone.getDirectionToRef(tempVec, boneMesh, tempVec);\n                if (distToJoint === undefined || distToJoint === null) {\n                    distToJoint = jointPivot.length();\n                }\n                tempVec.x *= distToJoint;\n                tempVec.y *= distToJoint;\n                tempVec.z *= distToJoint;\n            }\n            if (bone.getParent()) {\n                tempVec.addInPlace(mesh.getAbsolutePosition());\n                bone.setAbsolutePosition(tempVec, boneMesh);\n            }\n            else {\n                boneMesh.setAbsolutePosition(mesh.getAbsolutePosition());\n                boneMesh.position.x -= tempVec.x;\n                boneMesh.position.y -= tempVec.y;\n                boneMesh.position.z -= tempVec.z;\n            }\n        };\n        /**\n         * Sync impostor to a bone\n         * @param bone The bone that the impostor will be synced to.\n         * @param boneMesh The mesh that the bone is influencing.\n         * @param jointPivot The pivot of the joint / bone in local space.\n         * @param distToJoint Optional distance from the impostor to the joint.\n         * @param adjustRotation Optional quaternion for adjusting the local rotation of the bone.\n         * @param boneAxis Optional vector3 axis the bone is aligned with\n         */\n        PhysicsImpostor.prototype.syncImpostorWithBone = function (bone, boneMesh, jointPivot, distToJoint, adjustRotation, boneAxis) {\n            var mesh = this.object;\n            if (adjustRotation) {\n                var tempQuat = PhysicsImpostor._tmpQuat;\n                bone.getRotationQuaternionToRef(BABYLON.Space.WORLD, boneMesh, tempQuat);\n                tempQuat.multiplyToRef(adjustRotation, mesh.rotationQuaternion);\n            }\n            else {\n                bone.getRotationQuaternionToRef(BABYLON.Space.WORLD, boneMesh, mesh.rotationQuaternion);\n            }\n            var pos = PhysicsImpostor._tmpVecs[0];\n            var boneDir = PhysicsImpostor._tmpVecs[1];\n            if (!boneAxis) {\n                boneAxis = PhysicsImpostor._tmpVecs[2];\n                boneAxis.x = 0;\n                boneAxis.y = 1;\n                boneAxis.z = 0;\n            }\n            bone.getDirectionToRef(boneAxis, boneMesh, boneDir);\n            bone.getAbsolutePositionToRef(boneMesh, pos);\n            if ((distToJoint === undefined || distToJoint === null) && jointPivot) {\n                distToJoint = jointPivot.length();\n            }\n            if (distToJoint !== undefined && distToJoint !== null) {\n                pos.x += boneDir.x * distToJoint;\n                pos.y += boneDir.y * distToJoint;\n                pos.z += boneDir.z * distToJoint;\n            }\n            mesh.setAbsolutePosition(pos);\n        };\n        return PhysicsImpostor;\n    }());\n    PhysicsImpostor.DEFAULT_OBJECT_SIZE = new BABYLON.Vector3(1, 1, 1);\n    PhysicsImpostor.IDENTITY_QUATERNION = BABYLON.Quaternion.Identity();\n    PhysicsImpostor._tmpVecs = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n    PhysicsImpostor._tmpQuat = BABYLON.Quaternion.Identity();\n    //Impostor types\n    PhysicsImpostor.NoImpostor = 0;\n    PhysicsImpostor.SphereImpostor = 1;\n    PhysicsImpostor.BoxImpostor = 2;\n    PhysicsImpostor.PlaneImpostor = 3;\n    PhysicsImpostor.MeshImpostor = 4;\n    PhysicsImpostor.CylinderImpostor = 7;\n    PhysicsImpostor.ParticleImpostor = 8;\n    PhysicsImpostor.HeightmapImpostor = 9;\n    BABYLON.PhysicsImpostor = PhysicsImpostor;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.physicsImpostor.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var PhysicsEngine = (function () {\n        function PhysicsEngine(gravity, _physicsPlugin) {\n            if (_physicsPlugin === void 0) { _physicsPlugin = new BABYLON.CannonJSPlugin(); }\n            this._physicsPlugin = _physicsPlugin;\n            //new methods and parameters\n            this._impostors = [];\n            this._joints = [];\n            if (!this._physicsPlugin.isSupported()) {\n                throw new Error(\"Physics Engine \" + this._physicsPlugin.name + \" cannot be found. \"\n                    + \"Please make sure it is included.\");\n            }\n            gravity = gravity || new BABYLON.Vector3(0, -9.807, 0);\n            this.setGravity(gravity);\n            this.setTimeStep();\n        }\n        PhysicsEngine.prototype.setGravity = function (gravity) {\n            this.gravity = gravity;\n            this._physicsPlugin.setGravity(this.gravity);\n        };\n        /**\n         * Set the time step of the physics engine.\n         * default is 1/60.\n         * To slow it down, enter 1/600 for example.\n         * To speed it up, 1/30\n         * @param {number} newTimeStep the new timestep to apply to this world.\n         */\n        PhysicsEngine.prototype.setTimeStep = function (newTimeStep) {\n            if (newTimeStep === void 0) { newTimeStep = 1 / 60; }\n            this._physicsPlugin.setTimeStep(newTimeStep);\n        };\n        PhysicsEngine.prototype.dispose = function () {\n            this._impostors.forEach(function (impostor) {\n                impostor.dispose();\n            });\n            this._physicsPlugin.dispose();\n        };\n        PhysicsEngine.prototype.getPhysicsPluginName = function () {\n            return this._physicsPlugin.name;\n        };\n        /**\n         * Adding a new impostor for the impostor tracking.\n         * This will be done by the impostor itself.\n         * @param {PhysicsImpostor} impostor the impostor to add\n         */\n        PhysicsEngine.prototype.addImpostor = function (impostor) {\n            impostor.uniqueId = this._impostors.push(impostor);\n            //if no parent, generate the body\n            if (!impostor.parent) {\n                this._physicsPlugin.generatePhysicsBody(impostor);\n            }\n        };\n        /**\n         * Remove an impostor from the engine.\n         * This impostor and its mesh will not longer be updated by the physics engine.\n         * @param {PhysicsImpostor} impostor the impostor to remove\n         */\n        PhysicsEngine.prototype.removeImpostor = function (impostor) {\n            var index = this._impostors.indexOf(impostor);\n            if (index > -1) {\n                var removed = this._impostors.splice(index, 1);\n                //Is it needed?\n                if (removed.length) {\n                    //this will also remove it from the world.\n                    removed[0].physicsBody = null;\n                }\n            }\n        };\n        /**\n         * Add a joint to the physics engine\n         * @param {PhysicsImpostor} mainImpostor the main impostor to which the joint is added.\n         * @param {PhysicsImpostor} connectedImpostor the impostor that is connected to the main impostor using this joint\n         * @param {PhysicsJoint} the joint that will connect both impostors.\n         */\n        PhysicsEngine.prototype.addJoint = function (mainImpostor, connectedImpostor, joint) {\n            var impostorJoint = {\n                mainImpostor: mainImpostor,\n                connectedImpostor: connectedImpostor,\n                joint: joint\n            };\n            joint.physicsPlugin = this._physicsPlugin;\n            this._joints.push(impostorJoint);\n            this._physicsPlugin.generateJoint(impostorJoint);\n        };\n        PhysicsEngine.prototype.removeJoint = function (mainImpostor, connectedImpostor, joint) {\n            var matchingJoints = this._joints.filter(function (impostorJoint) {\n                return (impostorJoint.connectedImpostor === connectedImpostor\n                    && impostorJoint.joint === joint\n                    && impostorJoint.mainImpostor === mainImpostor);\n            });\n            if (matchingJoints.length) {\n                this._physicsPlugin.removeJoint(matchingJoints[0]);\n                //TODO remove it from the list as well\n            }\n        };\n        /**\n         * Called by the scene. no need to call it.\n         */\n        PhysicsEngine.prototype._step = function (delta) {\n            var _this = this;\n            //check if any mesh has no body / requires an update\n            this._impostors.forEach(function (impostor) {\n                if (impostor.isBodyInitRequired()) {\n                    _this._physicsPlugin.generatePhysicsBody(impostor);\n                }\n            });\n            if (delta > 0.1) {\n                delta = 0.1;\n            }\n            else if (delta <= 0) {\n                delta = 1.0 / 60.0;\n            }\n            this._physicsPlugin.executeStep(delta, this._impostors);\n        };\n        PhysicsEngine.prototype.getPhysicsPlugin = function () {\n            return this._physicsPlugin;\n        };\n        PhysicsEngine.prototype.getImpostorForPhysicsObject = function (object) {\n            for (var i = 0; i < this._impostors.length; ++i) {\n                if (this._impostors[i].object === object) {\n                    return this._impostors[i];\n                }\n            }\n        };\n        PhysicsEngine.prototype.getImpostorWithPhysicsBody = function (body) {\n            for (var i = 0; i < this._impostors.length; ++i) {\n                if (this._impostors[i].physicsBody === body) {\n                    return this._impostors[i];\n                }\n            }\n        };\n        return PhysicsEngine;\n    }());\n    // Statics\n    PhysicsEngine.Epsilon = 0.001;\n    BABYLON.PhysicsEngine = PhysicsEngine;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.physicsEngine.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var CannonJSPlugin = (function () {\n        function CannonJSPlugin(_useDeltaForWorldStep, iterations) {\n            if (_useDeltaForWorldStep === void 0) { _useDeltaForWorldStep = true; }\n            if (iterations === void 0) { iterations = 10; }\n            this._useDeltaForWorldStep = _useDeltaForWorldStep;\n            this.name = \"CannonJSPlugin\";\n            this._physicsMaterials = [];\n            this._fixedTimeStep = 1 / 60;\n            //See https://github.com/schteppe/cannon.js/blob/gh-pages/demos/collisionFilter.html\n            this._currentCollisionGroup = 2;\n            this._minus90X = new BABYLON.Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);\n            this._plus90X = new BABYLON.Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);\n            this._tmpPosition = BABYLON.Vector3.Zero();\n            this._tmpQuaternion = new BABYLON.Quaternion();\n            this._tmpDeltaPosition = BABYLON.Vector3.Zero();\n            this._tmpDeltaRotation = new BABYLON.Quaternion();\n            this._tmpUnityRotation = new BABYLON.Quaternion();\n            if (!this.isSupported()) {\n                BABYLON.Tools.Error(\"CannonJS is not available. Please make sure you included the js file.\");\n                return;\n            }\n            this.world = new CANNON.World();\n            this.world.broadphase = new CANNON.NaiveBroadphase();\n            this.world.solver.iterations = iterations;\n        }\n        CannonJSPlugin.prototype.setGravity = function (gravity) {\n            this.world.gravity.copy(gravity);\n        };\n        CannonJSPlugin.prototype.setTimeStep = function (timeStep) {\n            this._fixedTimeStep = timeStep;\n        };\n        CannonJSPlugin.prototype.executeStep = function (delta, impostors) {\n            // Delta is in seconds, should be provided in milliseconds\n            this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? delta * 1000 : 0, 3);\n        };\n        CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n            var worldPoint = new CANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n            var impulse = new CANNON.Vec3(force.x, force.y, force.z);\n            impostor.physicsBody.applyImpulse(impulse, worldPoint);\n        };\n        CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n            var worldPoint = new CANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);\n            var impulse = new CANNON.Vec3(force.x, force.y, force.z);\n            impostor.physicsBody.applyForce(impulse, worldPoint);\n        };\n        CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n            //parent-child relationship. Does this impostor has a parent impostor?\n            if (impostor.parent) {\n                if (impostor.physicsBody) {\n                    this.removePhysicsBody(impostor);\n                    //TODO is that needed?\n                    impostor.forceUpdate();\n                }\n                return;\n            }\n            //should a new body be created for this impostor?\n            if (impostor.isBodyInitRequired()) {\n                var shape = this._createShape(impostor);\n                //unregister events, if body is being changed\n                var oldBody = impostor.physicsBody;\n                if (oldBody) {\n                    this.removePhysicsBody(impostor);\n                }\n                //create the body and material\n                var material = this._addMaterial(\"mat-\" + impostor.uniqueId, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\"));\n                var bodyCreationObject = {\n                    mass: impostor.getParam(\"mass\"),\n                    material: material\n                };\n                // A simple extend, in case native options were used.\n                var nativeOptions = impostor.getParam(\"nativeOptions\");\n                for (var key in nativeOptions) {\n                    if (nativeOptions.hasOwnProperty(key)) {\n                        bodyCreationObject[key] = nativeOptions[key];\n                    }\n                }\n                impostor.physicsBody = new CANNON.Body(bodyCreationObject);\n                impostor.physicsBody.addEventListener(\"collide\", impostor.onCollide);\n                this.world.addEventListener(\"preStep\", impostor.beforeStep);\n                this.world.addEventListener(\"postStep\", impostor.afterStep);\n                impostor.physicsBody.addShape(shape);\n                this.world.add(impostor.physicsBody);\n                //try to keep the body moving in the right direction by taking old properties.\n                //Should be tested!\n                if (oldBody) {\n                    ['force', 'torque', 'velocity', 'angularVelocity'].forEach(function (param) {\n                        impostor.physicsBody[param].copy(oldBody[param]);\n                    });\n                }\n                this._processChildMeshes(impostor);\n            }\n            //now update the body's transformation\n            this._updatePhysicsBodyTransformation(impostor);\n        };\n        CannonJSPlugin.prototype._processChildMeshes = function (mainImpostor) {\n            var _this = this;\n            var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes() : [];\n            if (meshChildren.length) {\n                var processMesh = function (localPosition, mesh) {\n                    var childImpostor = mesh.getPhysicsImpostor();\n                    if (childImpostor) {\n                        var parent = childImpostor.parent;\n                        if (parent !== mainImpostor) {\n                            var localPosition = mesh.position;\n                            if (childImpostor.physicsBody) {\n                                _this.removePhysicsBody(childImpostor);\n                                childImpostor.physicsBody = null;\n                            }\n                            childImpostor.parent = mainImpostor;\n                            childImpostor.resetUpdateFlags();\n                            mainImpostor.physicsBody.addShape(_this._createShape(childImpostor), new CANNON.Vec3(localPosition.x, localPosition.y, localPosition.z));\n                            //Add the mass of the children.\n                            mainImpostor.physicsBody.mass += childImpostor.getParam(\"mass\");\n                        }\n                    }\n                    mesh.getChildMeshes().forEach(processMesh.bind(_this, mesh.position));\n                };\n                meshChildren.forEach(processMesh.bind(this, BABYLON.Vector3.Zero()));\n            }\n        };\n        CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {\n            impostor.physicsBody.removeEventListener(\"collide\", impostor.onCollide);\n            this.world.removeEventListener(\"preStep\", impostor.beforeStep);\n            this.world.removeEventListener(\"postStep\", impostor.afterStep);\n            this.world.remove(impostor.physicsBody);\n        };\n        CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {\n            var mainBody = impostorJoint.mainImpostor.physicsBody;\n            var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n            if (!mainBody || !connectedBody) {\n                return;\n            }\n            var constraint;\n            var jointData = impostorJoint.joint.jointData;\n            //TODO - https://github.com/schteppe/cannon.js/blob/gh-pages/demos/collisionFilter.html\n            var constraintData = {\n                pivotA: jointData.mainPivot ? new CANNON.Vec3().copy(jointData.mainPivot) : null,\n                pivotB: jointData.connectedPivot ? new CANNON.Vec3().copy(jointData.connectedPivot) : null,\n                axisA: jointData.mainAxis ? new CANNON.Vec3().copy(jointData.mainAxis) : null,\n                axisB: jointData.connectedAxis ? new CANNON.Vec3().copy(jointData.connectedAxis) : null,\n                maxForce: jointData.nativeParams.maxForce,\n                collideConnected: !!jointData.collision\n            };\n            switch (impostorJoint.joint.type) {\n                case BABYLON.PhysicsJoint.HingeJoint:\n                case BABYLON.PhysicsJoint.Hinge2Joint:\n                    constraint = new CANNON.HingeConstraint(mainBody, connectedBody, constraintData);\n                    break;\n                case BABYLON.PhysicsJoint.DistanceJoint:\n                    constraint = new CANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);\n                    break;\n                case BABYLON.PhysicsJoint.SpringJoint:\n                    var springData = jointData;\n                    constraint = new CANNON.Spring(mainBody, connectedBody, {\n                        restLength: springData.length,\n                        stiffness: springData.stiffness,\n                        damping: springData.damping,\n                        localAnchorA: constraintData.pivotA,\n                        localAnchorB: constraintData.pivotB\n                    });\n                    break;\n                case BABYLON.PhysicsJoint.LockJoint:\n                    constraint = new CANNON.LockConstraint(mainBody, connectedBody, constraintData);\n                    break;\n                case BABYLON.PhysicsJoint.PointToPointJoint:\n                case BABYLON.PhysicsJoint.BallAndSocketJoint:\n                default:\n                    constraint = new CANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotA, constraintData.maxForce);\n                    break;\n            }\n            //set the collideConnected flag after the creation, since DistanceJoint ignores it.\n            constraint.collideConnected = !!jointData.collision;\n            impostorJoint.joint.physicsJoint = constraint;\n            //don't add spring as constraint, as it is not one.\n            if (impostorJoint.joint.type !== BABYLON.PhysicsJoint.SpringJoint) {\n                this.world.addConstraint(constraint);\n            }\n            else {\n                impostorJoint.mainImpostor.registerAfterPhysicsStep(function () {\n                    constraint.applyForce();\n                });\n            }\n        };\n        CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {\n            this.world.removeConstraint(impostorJoint.joint.physicsJoint);\n        };\n        CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {\n            var index;\n            var mat;\n            for (index = 0; index < this._physicsMaterials.length; index++) {\n                mat = this._physicsMaterials[index];\n                if (mat.friction === friction && mat.restitution === restitution) {\n                    return mat;\n                }\n            }\n            var currentMat = new CANNON.Material(name);\n            currentMat.friction = friction;\n            currentMat.restitution = restitution;\n            this._physicsMaterials.push(currentMat);\n            return currentMat;\n        };\n        CannonJSPlugin.prototype._checkWithEpsilon = function (value) {\n            return value < BABYLON.PhysicsEngine.Epsilon ? BABYLON.PhysicsEngine.Epsilon : value;\n        };\n        CannonJSPlugin.prototype._createShape = function (impostor) {\n            var object = impostor.object;\n            var returnValue;\n            var extendSize = impostor.getObjectExtendSize();\n            switch (impostor.type) {\n                case BABYLON.PhysicsImpostor.SphereImpostor:\n                    var radiusX = extendSize.x;\n                    var radiusY = extendSize.y;\n                    var radiusZ = extendSize.z;\n                    returnValue = new CANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);\n                    break;\n                //TMP also for cylinder - TODO Cannon supports cylinder natively.\n                case BABYLON.PhysicsImpostor.CylinderImpostor:\n                    returnValue = new CANNON.Cylinder(this._checkWithEpsilon(extendSize.x) / 2, this._checkWithEpsilon(extendSize.x) / 2, this._checkWithEpsilon(extendSize.y), 16);\n                    break;\n                case BABYLON.PhysicsImpostor.BoxImpostor:\n                    var box = extendSize.scale(0.5);\n                    returnValue = new CANNON.Box(new CANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));\n                    break;\n                case BABYLON.PhysicsImpostor.PlaneImpostor:\n                    BABYLON.Tools.Warn(\"Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead\");\n                    returnValue = new CANNON.Plane();\n                    break;\n                case BABYLON.PhysicsImpostor.MeshImpostor:\n                    var rawVerts = object.getVerticesData ? object.getVerticesData(BABYLON.VertexBuffer.PositionKind) : [];\n                    var rawFaces = object.getIndices ? object.getIndices() : [];\n                    BABYLON.Tools.Warn(\"MeshImpostor only collides against spheres.\");\n                    returnValue = new CANNON.Trimesh(rawVerts, rawFaces);\n                    break;\n                case BABYLON.PhysicsImpostor.HeightmapImpostor:\n                    returnValue = this._createHeightmap(object);\n                    break;\n                case BABYLON.PhysicsImpostor.ParticleImpostor:\n                    returnValue = new CANNON.Particle();\n                    break;\n            }\n            return returnValue;\n        };\n        CannonJSPlugin.prototype._createHeightmap = function (object, pointDepth) {\n            var pos = object.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var matrix = [];\n            //For now pointDepth will not be used and will be automatically calculated.\n            //Future reference - try and find the best place to add a reference to the pointDepth variable.\n            var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);\n            var dim = Math.min(object.getBoundingInfo().boundingBox.extendSizeWorld.x, object.getBoundingInfo().boundingBox.extendSizeWorld.z);\n            var elementSize = dim * 2 / arraySize;\n            var minY = object.getBoundingInfo().boundingBox.extendSizeWorld.y;\n            for (var i = 0; i < pos.length; i = i + 3) {\n                var x = Math.round((pos[i + 0]) / elementSize + arraySize / 2);\n                var z = Math.round(((pos[i + 2]) / elementSize - arraySize / 2) * -1);\n                var y = pos[i + 1] + minY;\n                if (!matrix[x]) {\n                    matrix[x] = [];\n                }\n                if (!matrix[x][z]) {\n                    matrix[x][z] = y;\n                }\n                matrix[x][z] = Math.max(y, matrix[x][z]);\n            }\n            for (var x = 0; x <= arraySize; ++x) {\n                if (!matrix[x]) {\n                    var loc = 1;\n                    while (!matrix[(x + loc) % arraySize]) {\n                        loc++;\n                    }\n                    matrix[x] = matrix[(x + loc) % arraySize].slice();\n                    //console.log(\"missing x\", x);\n                }\n                for (var z = 0; z <= arraySize; ++z) {\n                    if (!matrix[x][z]) {\n                        var loc = 1;\n                        var newValue;\n                        while (newValue === undefined) {\n                            newValue = matrix[x][(z + loc++) % arraySize];\n                        }\n                        matrix[x][z] = newValue;\n                    }\n                }\n            }\n            var shape = new CANNON.Heightfield(matrix, {\n                elementSize: elementSize\n            });\n            //For future reference, needed for body transformation\n            shape.minY = minY;\n            return shape;\n        };\n        CannonJSPlugin.prototype._updatePhysicsBodyTransformation = function (impostor) {\n            var object = impostor.object;\n            //make sure it is updated...\n            object.computeWorldMatrix && object.computeWorldMatrix(true);\n            // The delta between the mesh position and the mesh bounding box center\n            var center = impostor.getObjectCenter();\n            this._tmpDeltaPosition.copyFrom(object.position.subtract(center));\n            this._tmpPosition.copyFrom(center);\n            var quaternion = object.rotationQuaternion;\n            //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.\n            if (impostor.type === BABYLON.PhysicsImpostor.PlaneImpostor || impostor.type === BABYLON.PhysicsImpostor.HeightmapImpostor || impostor.type === BABYLON.PhysicsImpostor.CylinderImpostor) {\n                //-90 DEG in X, precalculated\n                quaternion = quaternion.multiply(this._minus90X);\n                //Invert! (Precalculated, 90 deg in X)\n                //No need to clone. this will never change.\n                impostor.setDeltaRotation(this._plus90X);\n            }\n            //If it is a heightfield, if should be centered.\n            if (impostor.type === BABYLON.PhysicsImpostor.HeightmapImpostor) {\n                var mesh = object;\n                //calculate the correct body position:\n                var rotationQuaternion = mesh.rotationQuaternion;\n                mesh.rotationQuaternion = this._tmpUnityRotation;\n                mesh.computeWorldMatrix(true);\n                //get original center with no rotation\n                var c = center.clone();\n                var oldPivot = mesh.getPivotMatrix() || BABYLON.Matrix.Translation(0, 0, 0);\n                //rotation is back\n                mesh.rotationQuaternion = rotationQuaternion;\n                //calculate the new center using a pivot (since Cannon.js doesn't center height maps)\n                var p = BABYLON.Matrix.Translation(mesh.getBoundingInfo().boundingBox.extendSizeWorld.x, 0, -mesh.getBoundingInfo().boundingBox.extendSizeWorld.z);\n                mesh.setPivotMatrix(p);\n                mesh.computeWorldMatrix(true);\n                //calculate the translation\n                var translation = mesh.getBoundingInfo().boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();\n                this._tmpPosition.copyFromFloats(translation.x, translation.y - mesh.getBoundingInfo().boundingBox.extendSizeWorld.y, translation.z);\n                //add it inverted to the delta \n                this._tmpDeltaPosition.copyFrom(mesh.getBoundingInfo().boundingBox.centerWorld.subtract(c));\n                this._tmpDeltaPosition.y += mesh.getBoundingInfo().boundingBox.extendSizeWorld.y;\n                mesh.setPivotMatrix(oldPivot);\n                mesh.computeWorldMatrix(true);\n            }\n            else if (impostor.type === BABYLON.PhysicsImpostor.MeshImpostor) {\n                this._tmpDeltaPosition.copyFromFloats(0, 0, 0);\n                this._tmpPosition.copyFrom(object.position);\n            }\n            impostor.setDeltaPosition(this._tmpDeltaPosition);\n            //Now update the impostor object\n            impostor.physicsBody.position.copy(this._tmpPosition);\n            impostor.physicsBody.quaternion.copy(quaternion);\n        };\n        CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n            impostor.object.position.copyFrom(impostor.physicsBody.position);\n            impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.quaternion);\n        };\n        CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n            impostor.physicsBody.position.copy(newPosition);\n            impostor.physicsBody.quaternion.copy(newRotation);\n        };\n        CannonJSPlugin.prototype.isSupported = function () {\n            return window.CANNON !== undefined;\n        };\n        CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n            impostor.physicsBody.velocity.copy(velocity);\n        };\n        CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n            impostor.physicsBody.angularVelocity.copy(velocity);\n        };\n        CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {\n            var v = impostor.physicsBody.velocity;\n            if (!v)\n                return null;\n            return new BABYLON.Vector3(v.x, v.y, v.z);\n        };\n        CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {\n            var v = impostor.physicsBody.angularVelocity;\n            if (!v)\n                return null;\n            return new BABYLON.Vector3(v.x, v.y, v.z);\n        };\n        CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n            impostor.physicsBody.mass = mass;\n            impostor.physicsBody.updateMassProperties();\n        };\n        CannonJSPlugin.prototype.getBodyMass = function (impostor) {\n            return impostor.physicsBody.mass;\n        };\n        CannonJSPlugin.prototype.getBodyFriction = function (impostor) {\n            return impostor.physicsBody.material.friction;\n        };\n        CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n            impostor.physicsBody.material.friction = friction;\n        };\n        CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {\n            return impostor.physicsBody.material.restitution;\n        };\n        CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n            impostor.physicsBody.material.restitution = restitution;\n        };\n        CannonJSPlugin.prototype.sleepBody = function (impostor) {\n            impostor.physicsBody.sleep();\n        };\n        CannonJSPlugin.prototype.wakeUpBody = function (impostor) {\n            impostor.physicsBody.wakeUp();\n        };\n        CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {\n            joint.physicsJoint.distance = maxDistance;\n        };\n        CannonJSPlugin.prototype.enableMotor = function (joint, motorIndex) {\n            if (!motorIndex) {\n                joint.physicsJoint.enableMotor();\n            }\n        };\n        CannonJSPlugin.prototype.disableMotor = function (joint, motorIndex) {\n            if (!motorIndex) {\n                joint.physicsJoint.disableMotor();\n            }\n        };\n        CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n            if (!motorIndex) {\n                joint.physicsJoint.enableMotor();\n                joint.physicsJoint.setMotorSpeed(speed);\n                if (maxForce) {\n                    this.setLimit(joint, maxForce);\n                }\n            }\n        };\n        CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {\n            joint.physicsJoint.motorEquation.maxForce = upperLimit;\n            joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;\n        };\n        CannonJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n            var body = impostor.physicsBody;\n            mesh.position.x = body.position.x;\n            mesh.position.y = body.position.y;\n            mesh.position.z = body.position.z;\n            mesh.rotationQuaternion.x = body.quaternion.x;\n            mesh.rotationQuaternion.y = body.quaternion.y;\n            mesh.rotationQuaternion.z = body.quaternion.z;\n            mesh.rotationQuaternion.w = body.quaternion.w;\n        };\n        CannonJSPlugin.prototype.getRadius = function (impostor) {\n            var shape = impostor.physicsBody.shapes[0];\n            return shape.boundingSphereRadius;\n        };\n        CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n            var shape = impostor.physicsBody.shapes[0];\n            result.x = shape.halfExtents.x * 2;\n            result.y = shape.halfExtents.y * 2;\n            result.z = shape.halfExtents.z * 2;\n        };\n        CannonJSPlugin.prototype.dispose = function () {\n        };\n        return CannonJSPlugin;\n    }());\n    BABYLON.CannonJSPlugin = CannonJSPlugin;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.cannonJSPlugin.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var OimoJSPlugin = (function () {\n        function OimoJSPlugin(iterations) {\n            this.name = \"OimoJSPlugin\";\n            this._tmpImpostorsArray = [];\n            this._tmpPositionVector = BABYLON.Vector3.Zero();\n            this.world = new OIMO.World(1 / 60, 2, iterations, true);\n            this.world.worldscale(1);\n            this.world.clear();\n            //making sure no stats are calculated\n            this.world.isNoStat = true;\n        }\n        OimoJSPlugin.prototype.setGravity = function (gravity) {\n            this.world.gravity.copy(gravity);\n        };\n        OimoJSPlugin.prototype.setTimeStep = function (timeStep) {\n            this.world.timeStep = timeStep;\n        };\n        OimoJSPlugin.prototype.executeStep = function (delta, impostors) {\n            var _this = this;\n            impostors.forEach(function (impostor) {\n                impostor.beforeStep();\n            });\n            this.world.step();\n            impostors.forEach(function (impostor) {\n                impostor.afterStep();\n                //update the ordered impostors array\n                _this._tmpImpostorsArray[impostor.uniqueId] = impostor;\n            });\n            //check for collisions\n            var contact = this.world.contacts;\n            while (contact !== null) {\n                if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {\n                    contact = contact.next;\n                    continue;\n                }\n                //is this body colliding with any other? get the impostor\n                var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];\n                var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];\n                if (!mainImpostor || !collidingImpostor) {\n                    contact = contact.next;\n                    continue;\n                }\n                mainImpostor.onCollide({ body: collidingImpostor.physicsBody });\n                collidingImpostor.onCollide({ body: mainImpostor.physicsBody });\n                contact = contact.next;\n            }\n        };\n        OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {\n            var mass = impostor.physicsBody.massInfo.mass;\n            impostor.physicsBody.applyImpulse(contactPoint.scale(OIMO.INV_SCALE), force.scale(OIMO.INV_SCALE * mass));\n        };\n        OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {\n            BABYLON.Tools.Warn(\"Oimo doesn't support applying force. Using impule instead.\");\n            this.applyImpulse(impostor, force, contactPoint);\n        };\n        OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {\n            var _this = this;\n            //parent-child relationship. Does this impostor has a parent impostor?\n            if (impostor.parent) {\n                if (impostor.physicsBody) {\n                    this.removePhysicsBody(impostor);\n                    //TODO is that needed?\n                    impostor.forceUpdate();\n                }\n                return;\n            }\n            if (impostor.isBodyInitRequired()) {\n                var bodyConfig = {\n                    name: impostor.uniqueId,\n                    //Oimo must have mass, also for static objects.\n                    config: [impostor.getParam(\"mass\") || 1, impostor.getParam(\"friction\"), impostor.getParam(\"restitution\")],\n                    size: [],\n                    type: [],\n                    pos: [],\n                    rot: [],\n                    move: impostor.getParam(\"mass\") !== 0,\n                    //Supporting older versions of Oimo\n                    world: this.world\n                };\n                var impostors = [impostor];\n                var addToArray = function (parent) {\n                    if (!parent.getChildMeshes)\n                        return;\n                    parent.getChildMeshes().forEach(function (m) {\n                        if (m.physicsImpostor) {\n                            impostors.push(m.physicsImpostor);\n                            m.physicsImpostor._init();\n                        }\n                    });\n                };\n                addToArray(impostor.object);\n                var checkWithEpsilon_1 = function (value) {\n                    return Math.max(value, BABYLON.PhysicsEngine.Epsilon);\n                };\n                impostors.forEach(function (i) {\n                    //get the correct bounding box\n                    var oldQuaternion = i.object.rotationQuaternion;\n                    var rot = new OIMO.Euler().setFromQuaternion({\n                        x: impostor.object.rotationQuaternion.x,\n                        y: impostor.object.rotationQuaternion.y,\n                        z: impostor.object.rotationQuaternion.z,\n                        s: impostor.object.rotationQuaternion.w\n                    });\n                    var extendSize = i.getObjectExtendSize();\n                    if (i === impostor) {\n                        var center = impostor.getObjectCenter();\n                        impostor.object.position.subtractToRef(center, _this._tmpPositionVector);\n                        //Can also use Array.prototype.push.apply\n                        bodyConfig.pos.push(center.x);\n                        bodyConfig.pos.push(center.y);\n                        bodyConfig.pos.push(center.z);\n                        //tmp solution\n                        bodyConfig.rot.push(rot.x / (OIMO.degtorad || OIMO.TO_RAD));\n                        bodyConfig.rot.push(rot.y / (OIMO.degtorad || OIMO.TO_RAD));\n                        bodyConfig.rot.push(rot.z / (OIMO.degtorad || OIMO.TO_RAD));\n                    }\n                    else {\n                        bodyConfig.pos.push(i.object.position.x);\n                        bodyConfig.pos.push(i.object.position.y);\n                        bodyConfig.pos.push(i.object.position.z);\n                        //tmp solution until https://github.com/lo-th/Oimo.js/pull/37 is merged\n                        bodyConfig.rot.push(0);\n                        bodyConfig.rot.push(0);\n                        bodyConfig.rot.push(0);\n                    }\n                    // register mesh\n                    switch (i.type) {\n                        case BABYLON.PhysicsImpostor.ParticleImpostor:\n                            BABYLON.Tools.Warn(\"No Particle support in Oimo.js. using SphereImpostor instead\");\n                        case BABYLON.PhysicsImpostor.SphereImpostor:\n                            var radiusX = extendSize.x;\n                            var radiusY = extendSize.y;\n                            var radiusZ = extendSize.z;\n                            var size = Math.max(checkWithEpsilon_1(radiusX), checkWithEpsilon_1(radiusY), checkWithEpsilon_1(radiusZ)) / 2;\n                            bodyConfig.type.push('sphere');\n                            //due to the way oimo works with compounds, add 3 times\n                            bodyConfig.size.push(size);\n                            bodyConfig.size.push(size);\n                            bodyConfig.size.push(size);\n                            break;\n                        case BABYLON.PhysicsImpostor.CylinderImpostor:\n                            var sizeX = checkWithEpsilon_1(extendSize.x) / 2;\n                            var sizeY = checkWithEpsilon_1(extendSize.y);\n                            bodyConfig.type.push('cylinder');\n                            bodyConfig.size.push(sizeX);\n                            bodyConfig.size.push(sizeY);\n                            //due to the way oimo works with compounds, add one more value.\n                            bodyConfig.size.push(sizeY);\n                            break;\n                        case BABYLON.PhysicsImpostor.PlaneImpostor:\n                        case BABYLON.PhysicsImpostor.BoxImpostor:\n                        default:\n                            var sizeX = checkWithEpsilon_1(extendSize.x);\n                            var sizeY = checkWithEpsilon_1(extendSize.y);\n                            var sizeZ = checkWithEpsilon_1(extendSize.z);\n                            bodyConfig.type.push('box');\n                            bodyConfig.size.push(sizeX);\n                            bodyConfig.size.push(sizeY);\n                            bodyConfig.size.push(sizeZ);\n                            break;\n                    }\n                    //actually not needed, but hey...\n                    i.object.rotationQuaternion = oldQuaternion;\n                });\n                impostor.physicsBody = new OIMO.Body(bodyConfig).body; //this.world.add(bodyConfig);\n            }\n            else {\n                this._tmpPositionVector.copyFromFloats(0, 0, 0);\n            }\n            impostor.setDeltaPosition(this._tmpPositionVector);\n            //this._tmpPositionVector.addInPlace(impostor.mesh.getBoundingInfo().boundingBox.center);\n            //this.setPhysicsBodyTransformation(impostor, this._tmpPositionVector, impostor.mesh.rotationQuaternion);\n        };\n        OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {\n            //impostor.physicsBody.dispose();\n            //Same as : (older oimo versions)\n            this.world.removeRigidBody(impostor.physicsBody);\n        };\n        OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {\n            var mainBody = impostorJoint.mainImpostor.physicsBody;\n            var connectedBody = impostorJoint.connectedImpostor.physicsBody;\n            if (!mainBody || !connectedBody) {\n                return;\n            }\n            var jointData = impostorJoint.joint.jointData;\n            var options = jointData.nativeParams || {};\n            var type;\n            var nativeJointData = {\n                body1: mainBody,\n                body2: connectedBody,\n                axe1: options.axe1 || (jointData.mainAxis ? jointData.mainAxis.asArray() : null),\n                axe2: options.axe2 || (jointData.connectedAxis ? jointData.connectedAxis.asArray() : null),\n                pos1: options.pos1 || (jointData.mainPivot ? jointData.mainPivot.asArray() : null),\n                pos2: options.pos2 || (jointData.connectedPivot ? jointData.connectedPivot.asArray() : null),\n                min: options.min,\n                max: options.max,\n                collision: options.collision || jointData.collision,\n                spring: options.spring,\n                //supporting older version of Oimo\n                world: this.world\n            };\n            switch (impostorJoint.joint.type) {\n                case BABYLON.PhysicsJoint.BallAndSocketJoint:\n                    type = \"jointBall\";\n                    break;\n                case BABYLON.PhysicsJoint.SpringJoint:\n                    BABYLON.Tools.Warn(\"Oimo.js doesn't support Spring Constraint. Simulating using DistanceJoint instead\");\n                    var springData = jointData;\n                    nativeJointData.min = springData.length || nativeJointData.min;\n                    //Max should also be set, just make sure it is at least min\n                    nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);\n                case BABYLON.PhysicsJoint.DistanceJoint:\n                    type = \"jointDistance\";\n                    nativeJointData.max = jointData.maxDistance;\n                    break;\n                case BABYLON.PhysicsJoint.PrismaticJoint:\n                    type = \"jointPrisme\";\n                    break;\n                case BABYLON.PhysicsJoint.SliderJoint:\n                    type = \"jointSlide\";\n                    break;\n                case BABYLON.PhysicsJoint.WheelJoint:\n                    type = \"jointWheel\";\n                    break;\n                case BABYLON.PhysicsJoint.HingeJoint:\n                default:\n                    type = \"jointHinge\";\n                    break;\n            }\n            nativeJointData.type = type;\n            impostorJoint.joint.physicsJoint = new OIMO.Link(nativeJointData).joint; //this.world.add(nativeJointData);\n        };\n        OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {\n            //Bug in Oimo prevents us from disposing a joint in the playground\n            //joint.joint.physicsJoint.dispose();\n            //So we will bruteforce it!\n            try {\n                this.world.removeJoint(impostorJoint.joint.physicsJoint);\n            }\n            catch (e) {\n                BABYLON.Tools.Warn(e);\n            }\n        };\n        OimoJSPlugin.prototype.isSupported = function () {\n            return OIMO !== undefined;\n        };\n        OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {\n            if (!impostor.physicsBody.sleeping) {\n                //TODO check that\n                if (impostor.physicsBody.shapes.next) {\n                    var parentShape = this._getLastShape(impostor.physicsBody);\n                    impostor.object.position.x = parentShape.position.x * OIMO.WORLD_SCALE;\n                    impostor.object.position.y = parentShape.position.y * OIMO.WORLD_SCALE;\n                    impostor.object.position.z = parentShape.position.z * OIMO.WORLD_SCALE;\n                }\n                else {\n                    impostor.object.position.copyFrom(impostor.physicsBody.getPosition());\n                }\n                impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.getQuaternion());\n                impostor.object.rotationQuaternion.normalize();\n            }\n        };\n        OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {\n            var body = impostor.physicsBody;\n            body.position.init(newPosition.x * OIMO.INV_SCALE, newPosition.y * OIMO.INV_SCALE, newPosition.z * OIMO.INV_SCALE);\n            body.orientation.init(newRotation.w, newRotation.x, newRotation.y, newRotation.z);\n            body.syncShapes();\n            body.awake();\n        };\n        OimoJSPlugin.prototype._getLastShape = function (body) {\n            var lastShape = body.shapes;\n            while (lastShape.next) {\n                lastShape = lastShape.next;\n            }\n            return lastShape;\n        };\n        OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {\n            impostor.physicsBody.linearVelocity.init(velocity.x, velocity.y, velocity.z);\n        };\n        OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {\n            impostor.physicsBody.angularVelocity.init(velocity.x, velocity.y, velocity.z);\n        };\n        OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {\n            var v = impostor.physicsBody.linearVelocity;\n            if (!v)\n                return null;\n            return new BABYLON.Vector3(v.x, v.y, v.z);\n        };\n        OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {\n            var v = impostor.physicsBody.angularVelocity;\n            if (!v)\n                return null;\n            return new BABYLON.Vector3(v.x, v.y, v.z);\n        };\n        OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {\n            var staticBody = mass === 0;\n            //this will actually set the body's density and not its mass.\n            //But this is how oimo treats the mass variable.\n            impostor.physicsBody.shapes.density = staticBody ? 1 : mass;\n            impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);\n        };\n        OimoJSPlugin.prototype.getBodyMass = function (impostor) {\n            return impostor.physicsBody.shapes.density;\n        };\n        OimoJSPlugin.prototype.getBodyFriction = function (impostor) {\n            return impostor.physicsBody.shapes.friction;\n        };\n        OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {\n            impostor.physicsBody.shapes.friction = friction;\n        };\n        OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {\n            return impostor.physicsBody.shapes.restitution;\n        };\n        OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {\n            impostor.physicsBody.shapes.restitution = restitution;\n        };\n        OimoJSPlugin.prototype.sleepBody = function (impostor) {\n            impostor.physicsBody.sleep();\n        };\n        OimoJSPlugin.prototype.wakeUpBody = function (impostor) {\n            impostor.physicsBody.awake();\n        };\n        OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {\n            joint.physicsJoint.limitMotor.upperLimit = maxDistance;\n            if (minDistance !== void 0) {\n                joint.physicsJoint.limitMotor.lowerLimit = minDistance;\n            }\n        };\n        OimoJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {\n            //TODO separate rotational and transational motors.\n            var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n            if (motor) {\n                motor.setMotor(speed, maxForce);\n            }\n        };\n        OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {\n            //TODO separate rotational and transational motors.\n            var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;\n            if (motor) {\n                motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);\n            }\n        };\n        OimoJSPlugin.prototype.syncMeshWithImpostor = function (mesh, impostor) {\n            var body = impostor.physicsBody;\n            mesh.position.x = body.position.x;\n            mesh.position.y = body.position.y;\n            mesh.position.z = body.position.z;\n            mesh.rotationQuaternion.x = body.orientation.x;\n            mesh.rotationQuaternion.y = body.orientation.y;\n            mesh.rotationQuaternion.z = body.orientation.z;\n            mesh.rotationQuaternion.w = body.orientation.s;\n        };\n        OimoJSPlugin.prototype.getRadius = function (impostor) {\n            return impostor.physicsBody.shapes.radius;\n        };\n        OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {\n            var shape = impostor.physicsBody.shapes;\n            result.x = shape.halfWidth * 2;\n            result.y = shape.halfHeight * 2;\n            result.z = shape.halfDepth * 2;\n        };\n        OimoJSPlugin.prototype.dispose = function () {\n            this.world.clear();\n        };\n        return OimoJSPlugin;\n    }());\n    BABYLON.OimoJSPlugin = OimoJSPlugin;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.oimoJSPlugin.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        /*\n        * Based on jsTGALoader - Javascript loader for TGA file\n        * By Vincent Thibault\n        * @blog http://blog.robrowser.com/javascript-tga-loader.html\n        */\n        var TGATools = (function () {\n            function TGATools() {\n            }\n            TGATools.GetTGAHeader = function (data) {\n                var offset = 0;\n                var header = {\n                    id_length: data[offset++],\n                    colormap_type: data[offset++],\n                    image_type: data[offset++],\n                    colormap_index: data[offset++] | data[offset++] << 8,\n                    colormap_length: data[offset++] | data[offset++] << 8,\n                    colormap_size: data[offset++],\n                    origin: [\n                        data[offset++] | data[offset++] << 8,\n                        data[offset++] | data[offset++] << 8\n                    ],\n                    width: data[offset++] | data[offset++] << 8,\n                    height: data[offset++] | data[offset++] << 8,\n                    pixel_size: data[offset++],\n                    flags: data[offset++]\n                };\n                return header;\n            };\n            TGATools.UploadContent = function (gl, data) {\n                // Not enough data to contain header ?\n                if (data.length < 19) {\n                    BABYLON.Tools.Error(\"Unable to load TGA file - Not enough data to contain header\");\n                    return;\n                }\n                // Read Header\n                var offset = 18;\n                var header = TGATools.GetTGAHeader(data);\n                // Assume it's a valid Targa file.\n                if (header.id_length + offset > data.length) {\n                    BABYLON.Tools.Error(\"Unable to load TGA file - Not enough data\");\n                    return;\n                }\n                // Skip not needed data\n                offset += header.id_length;\n                var use_rle = false;\n                var use_pal = false;\n                var use_rgb = false;\n                var use_grey = false;\n                // Get some informations.\n                switch (header.image_type) {\n                    case TGATools._TYPE_RLE_INDEXED:\n                        use_rle = true;\n                    case TGATools._TYPE_INDEXED:\n                        use_pal = true;\n                        break;\n                    case TGATools._TYPE_RLE_RGB:\n                        use_rle = true;\n                    case TGATools._TYPE_RGB:\n                        use_rgb = true;\n                        break;\n                    case TGATools._TYPE_RLE_GREY:\n                        use_rle = true;\n                    case TGATools._TYPE_GREY:\n                        use_grey = true;\n                        break;\n                }\n                var pixel_data;\n                var numAlphaBits = header.flags & 0xf;\n                var pixel_size = header.pixel_size >> 3;\n                var pixel_total = header.width * header.height * pixel_size;\n                // Read palettes\n                var palettes;\n                if (use_pal) {\n                    palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n                }\n                // Read LRE\n                if (use_rle) {\n                    pixel_data = new Uint8Array(pixel_total);\n                    var c, count, i;\n                    var localOffset = 0;\n                    var pixels = new Uint8Array(pixel_size);\n                    while (offset < pixel_total && localOffset < pixel_total) {\n                        c = data[offset++];\n                        count = (c & 0x7f) + 1;\n                        // RLE pixels\n                        if (c & 0x80) {\n                            // Bind pixel tmp array\n                            for (i = 0; i < pixel_size; ++i) {\n                                pixels[i] = data[offset++];\n                            }\n                            // Copy pixel array\n                            for (i = 0; i < count; ++i) {\n                                pixel_data.set(pixels, localOffset + i * pixel_size);\n                            }\n                            localOffset += pixel_size * count;\n                        }\n                        else {\n                            count *= pixel_size;\n                            for (i = 0; i < count; ++i) {\n                                pixel_data[localOffset + i] = data[offset++];\n                            }\n                            localOffset += count;\n                        }\n                    }\n                }\n                else {\n                    pixel_data = data.subarray(offset, offset += (use_pal ? header.width * header.height : pixel_total));\n                }\n                // Load to texture\n                var x_start, y_start, x_step, y_step, y_end, x_end;\n                switch ((header.flags & TGATools._ORIGIN_MASK) >> TGATools._ORIGIN_SHIFT) {\n                    default:\n                    case TGATools._ORIGIN_UL:\n                        x_start = 0;\n                        x_step = 1;\n                        x_end = header.width;\n                        y_start = 0;\n                        y_step = 1;\n                        y_end = header.height;\n                        break;\n                    case TGATools._ORIGIN_BL:\n                        x_start = 0;\n                        x_step = 1;\n                        x_end = header.width;\n                        y_start = header.height - 1;\n                        y_step = -1;\n                        y_end = -1;\n                        break;\n                    case TGATools._ORIGIN_UR:\n                        x_start = header.width - 1;\n                        x_step = -1;\n                        x_end = -1;\n                        y_start = 0;\n                        y_step = 1;\n                        y_end = header.height;\n                        break;\n                    case TGATools._ORIGIN_BR:\n                        x_start = header.width - 1;\n                        x_step = -1;\n                        x_end = -1;\n                        y_start = header.height - 1;\n                        y_step = -1;\n                        y_end = -1;\n                        break;\n                }\n                // Load the specify method\n                var func = '_getImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n                var imageData = TGATools[func](header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, header.width, header.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n            };\n            TGATools._getImageData8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data, colormap = palettes;\n                var width = header.width, height = header.height;\n                var color, i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i++) {\n                        color = image[i];\n                        imageData[(x + width * y) * 4 + 3] = 255;\n                        imageData[(x + width * y) * 4 + 2] = colormap[(color * 3) + 0];\n                        imageData[(x + width * y) * 4 + 1] = colormap[(color * 3) + 1];\n                        imageData[(x + width * y) * 4 + 0] = colormap[(color * 3) + 2];\n                    }\n                }\n                return imageData;\n            };\n            TGATools._getImageData16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data;\n                var width = header.width, height = header.height;\n                var color, i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n                        color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n                        imageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n                        imageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n                        imageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;\n                        imageData[(x + width * y) * 4 + 3] = (color & 0x8000) ? 0 : 255;\n                    }\n                }\n                return imageData;\n            };\n            TGATools._getImageData24bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data;\n                var width = header.width, height = header.height;\n                var i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i += 3) {\n                        imageData[(x + width * y) * 4 + 3] = 255;\n                        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                        imageData[(x + width * y) * 4 + 1] = image[i + 1];\n                        imageData[(x + width * y) * 4 + 0] = image[i + 2];\n                    }\n                }\n                return imageData;\n            };\n            TGATools._getImageData32bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data;\n                var width = header.width, height = header.height;\n                var i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i += 4) {\n                        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                        imageData[(x + width * y) * 4 + 1] = image[i + 1];\n                        imageData[(x + width * y) * 4 + 0] = image[i + 2];\n                        imageData[(x + width * y) * 4 + 3] = image[i + 3];\n                    }\n                }\n                return imageData;\n            };\n            TGATools._getImageDataGrey8bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data;\n                var width = header.width, height = header.height;\n                var color, i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i++) {\n                        color = image[i];\n                        imageData[(x + width * y) * 4 + 0] = color;\n                        imageData[(x + width * y) * 4 + 1] = color;\n                        imageData[(x + width * y) * 4 + 2] = color;\n                        imageData[(x + width * y) * 4 + 3] = 255;\n                    }\n                }\n                return imageData;\n            };\n            TGATools._getImageDataGrey16bits = function (header, palettes, pixel_data, y_start, y_step, y_end, x_start, x_step, x_end) {\n                var image = pixel_data;\n                var width = header.width, height = header.height;\n                var i = 0, x, y;\n                var imageData = new Uint8Array(width * height * 4);\n                for (y = y_start; y !== y_end; y += y_step) {\n                    for (x = x_start; x !== x_end; x += x_step, i += 2) {\n                        imageData[(x + width * y) * 4 + 0] = image[i + 0];\n                        imageData[(x + width * y) * 4 + 1] = image[i + 0];\n                        imageData[(x + width * y) * 4 + 2] = image[i + 0];\n                        imageData[(x + width * y) * 4 + 3] = image[i + 1];\n                    }\n                }\n                return imageData;\n            };\n            return TGATools;\n        }());\n        TGATools._TYPE_NO_DATA = 0;\n        TGATools._TYPE_INDEXED = 1;\n        TGATools._TYPE_RGB = 2;\n        TGATools._TYPE_GREY = 3;\n        TGATools._TYPE_RLE_INDEXED = 9;\n        TGATools._TYPE_RLE_RGB = 10;\n        TGATools._TYPE_RLE_GREY = 11;\n        TGATools._ORIGIN_MASK = 0x30;\n        TGATools._ORIGIN_SHIFT = 0x04;\n        TGATools._ORIGIN_BL = 0x00;\n        TGATools._ORIGIN_BR = 0x01;\n        TGATools._ORIGIN_UL = 0x02;\n        TGATools._ORIGIN_UR = 0x03;\n        Internals.TGATools = TGATools;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.tga.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        // Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n        // All values and structures referenced from:\n        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n        var DDS_MAGIC = 0x20534444;\n        var DDSD_CAPS = 0x1, DDSD_HEIGHT = 0x2, DDSD_WIDTH = 0x4, DDSD_PITCH = 0x8, DDSD_PIXELFORMAT = 0x1000, DDSD_MIPMAPCOUNT = 0x20000, DDSD_LINEARSIZE = 0x80000, DDSD_DEPTH = 0x800000;\n        var DDSCAPS_COMPLEX = 0x8, DDSCAPS_MIPMAP = 0x400000, DDSCAPS_TEXTURE = 0x1000;\n        var DDSCAPS2_CUBEMAP = 0x200, DDSCAPS2_CUBEMAP_POSITIVEX = 0x400, DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800, DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000, DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000, DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000, DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000, DDSCAPS2_VOLUME = 0x200000;\n        var DDPF_ALPHAPIXELS = 0x1, DDPF_ALPHA = 0x2, DDPF_FOURCC = 0x4, DDPF_RGB = 0x40, DDPF_YUV = 0x200, DDPF_LUMINANCE = 0x20000;\n        function FourCCToInt32(value) {\n            return value.charCodeAt(0) +\n                (value.charCodeAt(1) << 8) +\n                (value.charCodeAt(2) << 16) +\n                (value.charCodeAt(3) << 24);\n        }\n        function Int32ToFourCC(value) {\n            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n        }\n        var FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\n        var FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\n        var FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\n        var FOURCC_DX10 = FourCCToInt32(\"DX10\");\n        var FOURCC_D3DFMT_R16G16B16A16F = 113;\n        var FOURCC_D3DFMT_R32G32B32A32F = 116;\n        var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\n        var DXGI_FORMAT_B8G8R8X8_UNORM = 88;\n        var headerLengthInt = 31; // The header length in 32 bit ints\n        // Offsets into the header array\n        var off_magic = 0;\n        var off_size = 1;\n        var off_flags = 2;\n        var off_height = 3;\n        var off_width = 4;\n        var off_mipmapCount = 7;\n        var off_pfFlags = 20;\n        var off_pfFourCC = 21;\n        var off_RGBbpp = 22;\n        var off_RMask = 23;\n        var off_GMask = 24;\n        var off_BMask = 25;\n        var off_AMask = 26;\n        var off_caps1 = 27;\n        var off_caps2 = 28;\n        var off_caps3 = 29;\n        var off_caps4 = 30;\n        var off_dxgiFormat = 32;\n        ;\n        var DDSTools = (function () {\n            function DDSTools() {\n            }\n            DDSTools.GetDDSInfo = function (arrayBuffer) {\n                var header = new Int32Array(arrayBuffer, 0, headerLengthInt);\n                var extendedHeader = new Int32Array(arrayBuffer, 0, headerLengthInt + 4);\n                var mipmapCount = 1;\n                if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n                    mipmapCount = Math.max(1, header[off_mipmapCount]);\n                }\n                var fourCC = header[off_pfFourCC];\n                var dxgiFormat = (fourCC === FOURCC_DX10) ? extendedHeader[off_dxgiFormat] : 0;\n                var textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                switch (fourCC) {\n                    case FOURCC_D3DFMT_R16G16B16A16F:\n                        textureType = BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                        break;\n                    case FOURCC_D3DFMT_R32G32B32A32F:\n                        textureType = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                        break;\n                    case FOURCC_DX10:\n                        if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n                            textureType = BABYLON.Engine.TEXTURETYPE_HALF_FLOAT;\n                            break;\n                        }\n                }\n                return {\n                    width: header[off_width],\n                    height: header[off_height],\n                    mipmapCount: mipmapCount,\n                    isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n                    isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n                    isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n                    isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n                    isCompressed: (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || FOURCC_DXT1 === FOURCC_DXT5),\n                    dxgiFormat: dxgiFormat,\n                    textureType: textureType\n                };\n            };\n            DDSTools._ToHalfFloat = function (value) {\n                if (!DDSTools._FloatView) {\n                    DDSTools._FloatView = new Float32Array(1);\n                    DDSTools._Int32View = new Int32Array(DDSTools._FloatView.buffer);\n                }\n                DDSTools._FloatView[0] = value;\n                var x = DDSTools._Int32View[0];\n                var bits = (x >> 16) & 0x8000; /* Get the sign */\n                var m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\n                var e = (x >> 23) & 0xff; /* Using int is faster here */\n                /* If zero, or denormal, or exponent underflows too much for a denormal\n                * half, return signed zero. */\n                if (e < 103) {\n                    return bits;\n                }\n                /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n                if (e > 142) {\n                    bits |= 0x7c00;\n                    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n                    * not Inf, so make sure we set one mantissa bit too. */\n                    bits |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n                    return bits;\n                }\n                /* If exponent underflows but not too much, return a denormal */\n                if (e < 113) {\n                    m |= 0x0800;\n                    /* Extra rounding may overflow and set mantissa to 0 and exponent\n                    * to 1, which is OK. */\n                    bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n                    return bits;\n                }\n                bits |= ((e - 112) << 10) | (m >> 1);\n                bits += m & 1;\n                return bits;\n            };\n            DDSTools._FromHalfFloat = function (value) {\n                var s = (value & 0x8000) >> 15;\n                var e = (value & 0x7C00) >> 10;\n                var f = value & 0x03FF;\n                if (e === 0) {\n                    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n                }\n                else if (e == 0x1F) {\n                    return f ? NaN : ((s ? -1 : 1) * Infinity);\n                }\n                return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\n            };\n            DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n                var destArray = new Float32Array(dataLength);\n                var srcData = new Uint16Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width) * 4;\n                        destArray[index] = DDSTools._FromHalfFloat(srcData[srcPos]);\n                        destArray[index + 1] = DDSTools._FromHalfFloat(srcData[srcPos + 1]);\n                        destArray[index + 2] = DDSTools._FromHalfFloat(srcData[srcPos + 2]);\n                        if (DDSTools.StoreLODInAlphaChannel) {\n                            destArray[index + 3] = lod;\n                        }\n                        else {\n                            destArray[index + 3] = DDSTools._FromHalfFloat(srcData[srcPos + 3]);\n                        }\n                        index += 4;\n                    }\n                }\n                return destArray;\n            };\n            DDSTools._GetHalfFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    var destArray = new Uint16Array(dataLength);\n                    var srcData = new Uint16Array(arrayBuffer, dataOffset);\n                    var index = 0;\n                    for (var y = 0; y < height; y++) {\n                        for (var x = 0; x < width; x++) {\n                            var srcPos = (x + y * width) * 4;\n                            destArray[index] = srcData[srcPos];\n                            destArray[index + 1] = srcData[srcPos + 1];\n                            destArray[index + 2] = srcData[srcPos + 2];\n                            destArray[index + 3] = DDSTools._ToHalfFloat(lod);\n                            index += 4;\n                        }\n                    }\n                    return destArray;\n                }\n                return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n            };\n            DDSTools._GetFloatRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    var destArray = new Float32Array(dataLength);\n                    var srcData = new Float32Array(arrayBuffer, dataOffset);\n                    var index = 0;\n                    for (var y = 0; y < height; y++) {\n                        for (var x = 0; x < width; x++) {\n                            var srcPos = (x + y * width) * 4;\n                            destArray[index] = srcData[srcPos];\n                            destArray[index + 1] = srcData[srcPos + 1];\n                            destArray[index + 2] = srcData[srcPos + 2];\n                            destArray[index + 3] = lod;\n                            index += 4;\n                        }\n                    }\n                    return destArray;\n                }\n                return new Float32Array(arrayBuffer, dataOffset, dataLength);\n            };\n            DDSTools._GetFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n                var destArray = new Uint8Array(dataLength);\n                var srcData = new Float32Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width) * 4;\n                        destArray[index] = BABYLON.MathTools.Clamp(srcData[srcPos]) * 255;\n                        destArray[index + 1] = BABYLON.MathTools.Clamp(srcData[srcPos + 1]) * 255;\n                        destArray[index + 2] = BABYLON.MathTools.Clamp(srcData[srcPos + 2]) * 255;\n                        if (DDSTools.StoreLODInAlphaChannel) {\n                            destArray[index + 3] = lod;\n                        }\n                        else {\n                            destArray[index + 3] = BABYLON.MathTools.Clamp(srcData[srcPos + 3]) * 255;\n                        }\n                        index += 4;\n                    }\n                }\n                return destArray;\n            };\n            DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer, lod) {\n                var destArray = new Uint8Array(dataLength);\n                var srcData = new Uint16Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width) * 4;\n                        destArray[index] = BABYLON.MathTools.Clamp(DDSTools._FromHalfFloat(srcData[srcPos])) * 255;\n                        destArray[index + 1] = BABYLON.MathTools.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 1])) * 255;\n                        destArray[index + 2] = BABYLON.MathTools.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 2])) * 255;\n                        if (DDSTools.StoreLODInAlphaChannel) {\n                            destArray[index + 3] = lod;\n                        }\n                        else {\n                            destArray[index + 3] = BABYLON.MathTools.Clamp(DDSTools._FromHalfFloat(srcData[srcPos + 3])) * 255;\n                        }\n                        index += 4;\n                    }\n                }\n                return destArray;\n            };\n            DDSTools._GetRGBAArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n                var byteArray = new Uint8Array(dataLength);\n                var srcData = new Uint8Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width) * 4;\n                        byteArray[index] = srcData[srcPos + 2];\n                        byteArray[index + 1] = srcData[srcPos + 1];\n                        byteArray[index + 2] = srcData[srcPos];\n                        byteArray[index + 3] = srcData[srcPos + 3];\n                        index += 4;\n                    }\n                }\n                return byteArray;\n            };\n            DDSTools._GetRGBArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n                var byteArray = new Uint8Array(dataLength);\n                var srcData = new Uint8Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width) * 3;\n                        byteArray[index] = srcData[srcPos + 2];\n                        byteArray[index + 1] = srcData[srcPos + 1];\n                        byteArray[index + 2] = srcData[srcPos];\n                        index += 3;\n                    }\n                }\n                return byteArray;\n            };\n            DDSTools._GetLuminanceArrayBuffer = function (width, height, dataOffset, dataLength, arrayBuffer) {\n                var byteArray = new Uint8Array(dataLength);\n                var srcData = new Uint8Array(arrayBuffer, dataOffset);\n                var index = 0;\n                for (var y = 0; y < height; y++) {\n                    for (var x = 0; x < width; x++) {\n                        var srcPos = (x + y * width);\n                        byteArray[index] = srcData[srcPos];\n                        index++;\n                    }\n                }\n                return byteArray;\n            };\n            DDSTools.UploadDDSLevels = function (engine, arrayBuffer, info, loadMipmaps, faces, lodIndex) {\n                if (lodIndex === void 0) { lodIndex = -1; }\n                var gl = engine._gl;\n                var ext = engine.getCaps().s3tc;\n                var header = new Int32Array(arrayBuffer, 0, headerLengthInt), fourCC, blockBytes, internalFormat, format, width, height, dataLength, dataOffset, byteArray, mipmapCount, mip;\n                if (header[off_magic] != DDS_MAGIC) {\n                    BABYLON.Tools.Error(\"Invalid magic number in DDS header\");\n                    return;\n                }\n                if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n                    BABYLON.Tools.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n                    return;\n                }\n                if (info.isCompressed && !ext) {\n                    BABYLON.Tools.Error(\"Compressed textures are not supported on this platform.\");\n                    return;\n                }\n                var bpp = header[off_RGBbpp];\n                dataOffset = header[off_size] + 4;\n                var computeFormats = false;\n                if (info.isFourCC) {\n                    fourCC = header[off_pfFourCC];\n                    switch (fourCC) {\n                        case FOURCC_DXT1:\n                            blockBytes = 8;\n                            internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n                            break;\n                        case FOURCC_DXT3:\n                            blockBytes = 16;\n                            internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n                            break;\n                        case FOURCC_DXT5:\n                            blockBytes = 16;\n                            internalFormat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n                            break;\n                        case FOURCC_D3DFMT_R16G16B16A16F:\n                            computeFormats = true;\n                            break;\n                        case FOURCC_D3DFMT_R32G32B32A32F:\n                            computeFormats = true;\n                            break;\n                        case FOURCC_DX10:\n                            // There is an additionnal header so dataOffset need to be changed\n                            dataOffset += 5 * 4; // 5 uints\n                            var supported = false;\n                            switch (info.dxgiFormat) {\n                                case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                                    computeFormats = true;\n                                    supported = true;\n                                    break;\n                                case DXGI_FORMAT_B8G8R8X8_UNORM:\n                                    info.isRGB = true;\n                                    info.isFourCC = false;\n                                    bpp = 32;\n                                    supported = true;\n                                    break;\n                            }\n                            if (supported) {\n                                break;\n                            }\n                        default:\n                            console.error(\"Unsupported FourCC code:\", Int32ToFourCC(fourCC));\n                            return;\n                    }\n                }\n                if (computeFormats) {\n                    format = engine._getWebGLTextureType(info.textureType);\n                    internalFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n                }\n                mipmapCount = 1;\n                if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n                    mipmapCount = Math.max(1, header[off_mipmapCount]);\n                }\n                for (var face = 0; face < faces; face++) {\n                    var sampler = faces === 1 ? gl.TEXTURE_2D : (gl.TEXTURE_CUBE_MAP_POSITIVE_X + face);\n                    width = header[off_width];\n                    height = header[off_height];\n                    for (mip = 0; mip < mipmapCount; ++mip) {\n                        if (lodIndex === -1 || lodIndex === mip) {\n                            // In case of fixed LOD, if the lod has just been uploaded, early exit.\n                            var i = (lodIndex === -1) ? mip : 0;\n                            if (!info.isCompressed && info.isFourCC) {\n                                dataLength = width * height * 4;\n                                var floatArray;\n                                if (engine.badOS || engine.badDesktopOS || (!engine.getCaps().textureHalfFloat && !engine.getCaps().textureFloat)) {\n                                    if (bpp === 128) {\n                                        floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);\n                                    }\n                                    else if (bpp === 64) {\n                                        floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);\n                                    }\n                                    info.textureType = BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT;\n                                    format = engine._getWebGLTextureType(info.textureType);\n                                    internalFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n                                }\n                                else {\n                                    if (bpp === 128) {\n                                        floatArray = DDSTools._GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);\n                                    }\n                                    else if (bpp === 64 && !engine.getCaps().textureHalfFloat) {\n                                        floatArray = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);\n                                        info.textureType = BABYLON.Engine.TEXTURETYPE_FLOAT;\n                                        format = engine._getWebGLTextureType(info.textureType);\n                                        internalFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n                                    }\n                                    else {\n                                        floatArray = DDSTools._GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, i);\n                                    }\n                                }\n                                engine._uploadDataToTexture(sampler, i, internalFormat, width, height, gl.RGBA, format, floatArray);\n                            }\n                            else if (info.isRGB) {\n                                if (bpp === 24) {\n                                    dataLength = width * height * 3;\n                                    byteArray = DDSTools._GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer);\n                                    engine._uploadDataToTexture(sampler, i, gl.RGB, width, height, gl.RGB, gl.UNSIGNED_BYTE, byteArray);\n                                }\n                                else {\n                                    dataLength = width * height * 4;\n                                    byteArray = DDSTools._GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer);\n                                    engine._uploadDataToTexture(sampler, i, gl.RGBA, width, height, gl.RGBA, gl.UNSIGNED_BYTE, byteArray);\n                                }\n                            }\n                            else if (info.isLuminance) {\n                                var unpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n                                var unpaddedRowSize = width;\n                                var paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n                                dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n                                byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer);\n                                engine._uploadDataToTexture(sampler, i, gl.LUMINANCE, width, height, gl.LUMINANCE, gl.UNSIGNED_BYTE, byteArray);\n                            }\n                            else {\n                                dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n                                byteArray = new Uint8Array(arrayBuffer, dataOffset, dataLength);\n                                engine._uploadCompressedDataToTexture(sampler, i, internalFormat, width, height, byteArray);\n                            }\n                        }\n                        dataOffset += width * height * (bpp / 8);\n                        width *= 0.5;\n                        height *= 0.5;\n                        width = Math.max(1.0, width);\n                        height = Math.max(1.0, height);\n                    }\n                }\n            };\n            return DDSTools;\n        }());\n        DDSTools.StoreLODInAlphaChannel = false;\n        Internals.DDSTools = DDSTools;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.dds.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        /**\n         * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n         * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n         */\n        var KhronosTextureContainer = (function () {\n            /**\n             * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n             * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n             * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n             * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n             */\n            function KhronosTextureContainer(arrayBuffer, facesExpected, threeDExpected, textureArrayExpected) {\n                this.arrayBuffer = arrayBuffer;\n                // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n                // '', 'K', 'T', 'X', ' ', '1', '1', '', '\\r', '\\n', '\\x1A', '\\n'\n                // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n                var identifier = new Uint8Array(this.arrayBuffer, 0, 12);\n                if (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 ||\n                    identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {\n                    BABYLON.Tools.Error(\"texture missing KTX identifier\");\n                    return;\n                }\n                // load the reset of the header in native 32 bit int\n                var header = new Int32Array(this.arrayBuffer, 12, 13);\n                // determine of the remaining header values are recorded in the opposite endianness & require conversion\n                var oppositeEndianess = header[0] === 0x01020304;\n                // read all the header elements in order they exist in the file, without modification (sans endainness)\n                this.glType = oppositeEndianess ? this.switchEndainness(header[1]) : header[1]; // must be 0 for compressed textures\n                this.glTypeSize = oppositeEndianess ? this.switchEndainness(header[2]) : header[2]; // must be 1 for compressed textures\n                this.glFormat = oppositeEndianess ? this.switchEndainness(header[3]) : header[3]; // must be 0 for compressed textures\n                this.glInternalFormat = oppositeEndianess ? this.switchEndainness(header[4]) : header[4]; // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n                this.glBaseInternalFormat = oppositeEndianess ? this.switchEndainness(header[5]) : header[5]; // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n                this.pixelWidth = oppositeEndianess ? this.switchEndainness(header[6]) : header[6]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n                this.pixelHeight = oppositeEndianess ? this.switchEndainness(header[7]) : header[7]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n                this.pixelDepth = oppositeEndianess ? this.switchEndainness(header[8]) : header[8]; // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n                this.numberOfArrayElements = oppositeEndianess ? this.switchEndainness(header[9]) : header[9]; // used for texture arrays\n                this.numberOfFaces = oppositeEndianess ? this.switchEndainness(header[10]) : header[10]; // used for cubemap textures, should either be 1 or 6\n                this.numberOfMipmapLevels = oppositeEndianess ? this.switchEndainness(header[11]) : header[11]; // number of levels; disregard possibility of 0 for compressed textures\n                this.bytesOfKeyValueData = oppositeEndianess ? this.switchEndainness(header[12]) : header[12]; // the amount of space after the header for meta-data\n                // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n                if (this.glType !== 0) {\n                    BABYLON.Tools.Error(\"only compressed formats currently supported\");\n                    return;\n                }\n                else {\n                    // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n                    this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n                }\n                if (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n                    BABYLON.Tools.Error(\"only 2D textures currently supported\");\n                    return;\n                }\n                if (this.numberOfArrayElements !== 0) {\n                    BABYLON.Tools.Error(\"texture arrays not currently supported\");\n                    return;\n                }\n                if (this.numberOfFaces !== facesExpected) {\n                    BABYLON.Tools.Error(\"number of faces expected\" + facesExpected + \", but found \" + this.numberOfFaces);\n                    return;\n                }\n                // we now have a completely validated file, so could use existence of loadType as success\n                // would need to make this more elaborate & adjust checks above to support more than one load type\n                this.loadType = KhronosTextureContainer.COMPRESSED_2D;\n            }\n            // not as fast hardware based, but will probably never need to use\n            KhronosTextureContainer.prototype.switchEndainness = function (val) {\n                return ((val & 0xFF) << 24)\n                    | ((val & 0xFF00) << 8)\n                    | ((val >> 8) & 0xFF00)\n                    | ((val >> 24) & 0xFF);\n            };\n            /**\n             * It is assumed that the texture has already been created & is currently bound\n             */\n            KhronosTextureContainer.prototype.uploadLevels = function (gl, loadMipmaps) {\n                switch (this.loadType) {\n                    case KhronosTextureContainer.COMPRESSED_2D:\n                        this._upload2DCompressedLevels(gl, loadMipmaps);\n                        break;\n                    case KhronosTextureContainer.TEX_2D:\n                    case KhronosTextureContainer.COMPRESSED_3D:\n                    case KhronosTextureContainer.TEX_3D:\n                }\n            };\n            KhronosTextureContainer.prototype._upload2DCompressedLevels = function (gl, loadMipmaps) {\n                // initialize width & height for level 1\n                var dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n                var width = this.pixelWidth;\n                var height = this.pixelHeight;\n                var mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n                for (var level = 0; level < mipmapCount; level++) {\n                    var imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n                    for (var face = 0; face < this.numberOfFaces; face++) {\n                        var sampler = this.numberOfFaces === 1 ? gl.TEXTURE_2D : (gl.TEXTURE_CUBE_MAP_POSITIVE_X + face);\n                        var byteArray = new Uint8Array(this.arrayBuffer, dataOffset + 4, imageSize);\n                        gl.compressedTexImage2D(sampler, level, this.glInternalFormat, width, height, 0, byteArray);\n                        dataOffset += imageSize + 4; // size of the image + 4 for the imageSize field\n                        dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image\n                    }\n                    width = Math.max(1.0, width * 0.5);\n                    height = Math.max(1.0, height * 0.5);\n                }\n            };\n            return KhronosTextureContainer;\n        }());\n        KhronosTextureContainer.HEADER_LEN = 12 + (13 * 4); // identifier + header elements (not including key value meta-data pairs)\n        // load types\n        KhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n        KhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n        KhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n        KhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n        Internals.KhronosTextureContainer = KhronosTextureContainer;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.khronosTextureContainer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var DynamicFloatArrayElementInfo = (function () {\n        function DynamicFloatArrayElementInfo() {\n        }\n        return DynamicFloatArrayElementInfo;\n    }());\n    BABYLON.DynamicFloatArrayElementInfo = DynamicFloatArrayElementInfo;\n    /**\n    * The purpose of this class is to store float32 based elements of a given size (defined by the stride argument) in a dynamic fashion, that is, you can add/free elements. You can then access to a defragmented/packed version of the underlying Float32Array by calling the pack() method.\n    * The intent is to maintain through time data that will be bound to a WebGlBuffer with the ability to change add/remove elements.\n    * It was first built to efficiently maintain the WebGlBuffer that contain instancing based data.\n    * Allocating an Element will return a instance of DynamicFloatArrayElement which contains the offset into the Float32Array of where the element starts, you are then responsible to copy your data using this offset.\n    * Beware, calling pack() may change the offset of some Entries because this method will defragment the Float32Array to replace empty elements by moving allocated ones at their location.\n     * This method will return an ArrayBufferView on the existing Float32Array that describes the used elements. Use this View to update the WebGLBuffer and NOT the \"buffer\" field of the class. The pack() method won't shrink/reallocate the buffer to keep it GC friendly, all the empty space will be put at the end of the buffer, the method just ensure there are no \"free holes\".\n    */\n    var DynamicFloatArray = (function () {\n        /**\n         * Construct an instance of the dynamic float array\n         * @param stride size of one element in float (i.e. not bytes!)\n         * @param initialElementCount the number of available entries at construction\n         */\n        function DynamicFloatArray(stride, initialElementCount) {\n            this.compareValueOffset = null;\n            this.sortingAscending = true;\n            this._stride = stride;\n            this.buffer = new Float32Array(stride * initialElementCount);\n            this._lastUsed = 0;\n            this._firstFree = 0;\n            this._allEntries = new Array(initialElementCount);\n            this._freeEntries = new Array(initialElementCount);\n            for (var i = 0; i < initialElementCount; i++) {\n                var element = new DynamicFloatArrayElementInfo();\n                element.offset = i * stride;\n                this._allEntries[i] = element;\n                this._freeEntries[initialElementCount - i - 1] = element;\n            }\n        }\n        /**\n         * Allocate an element in the array.\n         * @return the element info instance that contains the offset into the main buffer of the element's location.\n         * Beware, this offset may change when you call pack()\n         */\n        DynamicFloatArray.prototype.allocElement = function () {\n            if (this._freeEntries.length === 0) {\n                this._growBuffer();\n            }\n            var el = this._freeEntries.pop();\n            this._lastUsed = Math.max(el.offset, this._lastUsed);\n            if (el.offset === this._firstFree) {\n                if (this._freeEntries.length > 0) {\n                    this._firstFree = this._freeEntries[this._freeEntries.length - 1].offset;\n                }\n                else {\n                    this._firstFree += this._stride;\n                }\n            }\n            return el;\n        };\n        /**\n         * Free the element corresponding to the given element info\n         * @param elInfo the element that describe the allocated element\n         */\n        DynamicFloatArray.prototype.freeElement = function (elInfo) {\n            this._firstFree = Math.min(elInfo.offset, this._firstFree);\n            this._freeEntries.push(elInfo);\n        };\n        /**\n         * This method will pack all the used elements into a linear sequence and put all the free space at the end.\n         * Instances of DynamicFloatArrayElement may have their 'offset' member changed as data could be copied from one location to another, so be sure to read/write your data based on the value inside this member after you called pack().\n         * @return the subArray that is the view of the used elements area, you can use it as a source to update a WebGLBuffer\n         */\n        DynamicFloatArray.prototype.pack = function () {\n            // no free slot? no need to pack\n            if (this._freeEntries.length === 0) {\n                return this.buffer;\n            }\n            // If the buffer is already packed the last used will always be lower than the first free\n            // The opposite may not be true, we can have a lastUsed greater than firstFree but the array still packed, because when an element is freed, lastUsed is not updated (for speed reason) so we may have a lastUsed of a freed element. But that's ok, well soon realize this case.\n            if (this._lastUsed < this._firstFree) {\n                var elementsBuffer_1 = this.buffer.subarray(0, this._lastUsed + this._stride);\n                return elementsBuffer_1;\n            }\n            var s = this._stride;\n            // Make sure there's a free element at the very end, we need it to create a range where we'll move the used elements that may appear before\n            var lastFree = new DynamicFloatArrayElementInfo();\n            lastFree.offset = this.totalElementCount * s;\n            this._freeEntries.push(lastFree);\n            var sortedFree = this._freeEntries.sort(function (a, b) { return a.offset - b.offset; });\n            var sortedAll = this._allEntries.sort(function (a, b) { return a.offset - b.offset; });\n            var firstFreeSlotOffset = sortedFree[0].offset;\n            var freeZoneSize = 1;\n            var occupiedZoneSize = (this.usedElementCount + 1) * s;\n            var prevOffset = sortedFree[0].offset;\n            for (var i = 1; i < sortedFree.length; i++) {\n                // If the first free (which means everything before is occupied) is greater or equal the occupied zone size, it means everything is defragmented, we can quit\n                if (firstFreeSlotOffset >= occupiedZoneSize) {\n                    break;\n                }\n                var curFree = sortedFree[i];\n                var curOffset = curFree.offset;\n                // Compute the distance between this offset and the previous\n                var distance = curOffset - prevOffset;\n                // If the distance is the stride size, they are adjacent, it good, move to the next\n                if (distance === s) {\n                    // Free zone is one element bigger\n                    ++freeZoneSize;\n                    // as we're about to iterate to the next, the cur becomes the previous...\n                    prevOffset = curOffset;\n                    continue;\n                }\n                // Distance is bigger, which means there's x element between the previous free and this one\n                var usedRange = (distance / s) - 1;\n                // Two cases the free zone is smaller than the data to move or bigger\n                // Copy what can fit in the free zone\n                var curMoveOffset = curOffset - s;\n                var copyCount = Math.min(freeZoneSize, usedRange);\n                for (var j = 0; j < copyCount; j++) {\n                    var freeI = firstFreeSlotOffset / s;\n                    var curI = curMoveOffset / s;\n                    var moveEl = sortedAll[curI];\n                    this._moveElement(moveEl, firstFreeSlotOffset);\n                    var replacedEl = sortedAll[freeI];\n                    // set the offset of the element we replaced with a value that will make it discard at the end of the method\n                    replacedEl.offset = curMoveOffset;\n                    // Swap the element we moved and the one it replaced in the sorted array to reflect the action we've made\n                    sortedAll[freeI] = moveEl;\n                    sortedAll[curI] = replacedEl;\n                    curMoveOffset -= s;\n                    firstFreeSlotOffset += s;\n                }\n                // Free Zone is smaller or equal so it's no longer a free zone, set the new one to the current location\n                if (freeZoneSize <= usedRange) {\n                    firstFreeSlotOffset = curMoveOffset + s;\n                    freeZoneSize = 1 + copyCount;\n                }\n                else {\n                    freeZoneSize = ((curOffset - firstFreeSlotOffset) / s) + 1;\n                }\n                // as we're about to iterate to the next, the cur becomes the previous...\n                prevOffset = curOffset;\n            }\n            var elementsBuffer = this.buffer.subarray(0, firstFreeSlotOffset);\n            this._lastUsed = firstFreeSlotOffset - s;\n            this._firstFree = firstFreeSlotOffset;\n            sortedFree.pop(); // Remove the last free because that's the one we added at the start of the method\n            this._freeEntries = sortedFree.sort(function (a, b) { return b.offset - a.offset; });\n            this._allEntries = sortedAll;\n            return elementsBuffer;\n        };\n        DynamicFloatArray.prototype._moveElement = function (element, destOffset) {\n            for (var i = 0; i < this._stride; i++) {\n                this.buffer[destOffset + i] = this.buffer[element.offset + i];\n            }\n            element.offset = destOffset;\n        };\n        DynamicFloatArray.prototype._growBuffer = function () {\n            // Allocate the new buffer with 50% more entries, copy the content of the current one\n            var newElCount = Math.floor(this.totalElementCount * 1.5);\n            var newBuffer = new Float32Array(newElCount * this._stride);\n            newBuffer.set(this.buffer);\n            var curCount = this.totalElementCount;\n            var addedCount = newElCount - this.totalElementCount;\n            for (var i = 0; i < addedCount; i++) {\n                var element = new DynamicFloatArrayElementInfo();\n                element.offset = (curCount + i) * this.stride;\n                this._allEntries.push(element);\n                this._freeEntries[addedCount - i - 1] = element;\n            }\n            this._firstFree = curCount * this.stride;\n            this.buffer = newBuffer;\n        };\n        Object.defineProperty(DynamicFloatArray.prototype, \"totalElementCount\", {\n            /**\n             * Get the total count of entries that can fit in the current buffer\n             * @returns the elements count\n             */\n            get: function () {\n                return this._allEntries.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicFloatArray.prototype, \"freeElementCount\", {\n            /**\n             * Get the count of free entries that can still be allocated without resizing the buffer\n             * @returns the free elements count\n             */\n            get: function () {\n                return this._freeEntries.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicFloatArray.prototype, \"usedElementCount\", {\n            /**\n             * Get the count of allocated elements\n             * @returns the allocated elements count\n             */\n            get: function () {\n                return this._allEntries.length - this._freeEntries.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DynamicFloatArray.prototype, \"stride\", {\n            /**\n             * Return the size of one element in float\n             * @returns the size in float\n             */\n            get: function () {\n                return this._stride;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        DynamicFloatArray.prototype.sort = function () {\n            var _this = this;\n            if (!this.compareValueOffset) {\n                throw new Error(\"The DynamicFloatArray.sort() method needs a valid 'compareValueOffset' property\");\n            }\n            var count = this.usedElementCount;\n            // Do we have to (re)create the sort table?\n            if (!this._sortTable || this._sortTable.length < count) {\n                // Small heuristic... We don't want to allocate totalElementCount right away because it may have 50 for 3 used elements, but on the other side we don't want to allocate just 3 when we just need 2, so double this value to give us some air to breath...\n                var newCount = Math.min(this.totalElementCount, count * 2);\n                this._sortTable = new Array(newCount);\n            }\n            if (!this._sortedTable || this._sortedTable.length !== count) {\n                this._sortedTable = new Array(count);\n            }\n            // Because, you know...\n            this.pack();\n            //let stride = this.stride;\n            //for (let i = 0; i < count; i++) {\n            //    let si = this._sortTable[i];\n            //    if (!si) {\n            //        si = new SortInfo();\n            //        this._sortTable[i] = si;\n            //    }\n            //    si.entry = this._allEntries[i];\n            //    si.compareData = this.buffer[si.entry.offset + this.compareValueOffset];\n            //    si.swapedOffset = null;\n            //    this._sortedTable[i] = si;\n            //}\n            var curOffset = 0;\n            var stride = this.stride;\n            for (var i = 0; i < count; i++, curOffset += stride) {\n                var si = this._sortTable[i];\n                if (!si) {\n                    si = new SortInfo();\n                    this._sortTable[i] = si;\n                }\n                si.compareData = this.buffer[curOffset + this.compareValueOffset];\n                si.offset = curOffset;\n                si.swapedOffset = null;\n                this._sortedTable[i] = si;\n            }\n            // Let's sort the sorted table, we want to keep a track of the original one (that's why we have two buffers)\n            if (this.sortingAscending) {\n                this._sortedTable.sort(function (a, b) { return a.compareData - b.compareData; });\n            }\n            else {\n                this._sortedTable.sort(function (a, b) { return b.compareData - a.compareData; });\n            }\n            var swapElements = function (src, dst) {\n                for (var i = 0; i < stride; i++) {\n                    var tps = _this.buffer[dst + i];\n                    _this.buffer[dst + i] = _this.buffer[src + i];\n                    _this.buffer[src + i] = tps;\n                }\n            };\n            // The fun part begin, sortedTable give us the ordered layout to obtain, to get that we have to move elements, but when we move an element: \n            //  it replaces an existing one.I don't want to allocate a new Float32Array and do a raw copy, because it's awful (GC - wise), \n            //  and I still want something with a good algorithm complexity.\n            // So here's the deal: we are going to swap elements, but we have to track the change of location of the element being replaced, \n            //  we need sortTable for that, it contains the original layout of SortInfo object, not the sorted one.\n            // The best way is to use an extra field in SortInfo, because potentially every element can be replaced.\n            // When we'll look for and element, we'll check if its swapedOffset is set, if so we reiterate the operation with the one there \n            //  until we find a SortInfo object without a swapedOffset which means we got the right location\n            // Yes, we may have to do multiple iterations to find the right location, but hey, it won't be huge: <3 in most cases, and it's better \n            //  than a double allocation of the whole float32Array or a O(n/2) typical algorithm.\n            for (var i = 0; i < count; i++) {\n                // Get the element to move\n                var sourceSI = this._sortedTable[i];\n                var destSI = this._sortTable[i];\n                var sourceOff = sourceSI.offset;\n                // If the source changed location, find the new one\n                if (sourceSI.swapedOffset) {\n                    // Follow the swapedOffset until there's none, it will mean that curSI contains the new location in its offset member\n                    var curSI = sourceSI;\n                    while (curSI.swapedOffset) {\n                        curSI = this._sortTable[curSI.swapedOffset / stride];\n                    }\n                    // Finally get the right location\n                    sourceOff = curSI.offset;\n                }\n                // Tag the element being replaced with its new location\n                destSI.swapedOffset = sourceOff;\n                // Swap elements (only if needed)\n                if (sourceOff !== destSI.offset) {\n                    swapElements(sourceOff, destSI.offset);\n                }\n                // Update the offset in the corresponding DFAE\n                //sourceSI.entry.offset = destSI.entry.offset;\n                this._allEntries[sourceSI.offset / stride].offset = destSI.offset;\n            }\n            this._allEntries.sort(function (a, b) { return a.offset - b.offset; });\n            return true;\n        };\n        return DynamicFloatArray;\n    }());\n    BABYLON.DynamicFloatArray = DynamicFloatArray;\n    var SortInfo = (function () {\n        function SortInfo() {\n            this.compareData = this.offset = this.swapedOffset = null;\n        }\n        return SortInfo;\n    }());\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.dynamicFloatArray.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Debug;\n    (function (Debug) {\n        /**\n        * Demo available here: http://www.babylonjs-playground.com/#1BZJVJ#8\n        */\n        var SkeletonViewer = (function () {\n            function SkeletonViewer(skeleton, mesh, scene, autoUpdateBonesMatrices, renderingGroupId) {\n                if (autoUpdateBonesMatrices === void 0) { autoUpdateBonesMatrices = true; }\n                if (renderingGroupId === void 0) { renderingGroupId = 1; }\n                this.skeleton = skeleton;\n                this.mesh = mesh;\n                this.autoUpdateBonesMatrices = autoUpdateBonesMatrices;\n                this.renderingGroupId = renderingGroupId;\n                this.color = BABYLON.Color3.White();\n                this._debugLines = [];\n                this._isEnabled = false;\n                this._scene = scene;\n                this.update();\n                this._renderFunction = this.update.bind(this);\n            }\n            Object.defineProperty(SkeletonViewer.prototype, \"isEnabled\", {\n                get: function () {\n                    return this._isEnabled;\n                },\n                set: function (value) {\n                    if (this._isEnabled === value) {\n                        return;\n                    }\n                    this._isEnabled = value;\n                    if (value) {\n                        this._scene.registerBeforeRender(this._renderFunction);\n                    }\n                    else {\n                        this._scene.unregisterBeforeRender(this._renderFunction);\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SkeletonViewer.prototype._getBonePosition = function (position, bone, meshMat, x, y, z) {\n                if (x === void 0) { x = 0; }\n                if (y === void 0) { y = 0; }\n                if (z === void 0) { z = 0; }\n                var tmat = BABYLON.Tmp.Matrix[0];\n                var parentBone = bone.getParent();\n                tmat.copyFrom(bone.getLocalMatrix());\n                if (x !== 0 || y !== 0 || z !== 0) {\n                    var tmat2 = BABYLON.Tmp.Matrix[1];\n                    BABYLON.Matrix.IdentityToRef(tmat2);\n                    tmat2.m[12] = x;\n                    tmat2.m[13] = y;\n                    tmat2.m[14] = z;\n                    tmat2.multiplyToRef(tmat, tmat);\n                }\n                if (parentBone) {\n                    tmat.multiplyToRef(parentBone.getAbsoluteTransform(), tmat);\n                }\n                tmat.multiplyToRef(meshMat, tmat);\n                position.x = tmat.m[12];\n                position.y = tmat.m[13];\n                position.z = tmat.m[14];\n            };\n            SkeletonViewer.prototype._getLinesForBonesWithLength = function (bones, meshMat) {\n                var len = bones.length;\n                var meshPos = this.mesh.position;\n                for (var i = 0; i < len; i++) {\n                    var bone = bones[i];\n                    var points = this._debugLines[i];\n                    if (!points) {\n                        points = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n                        this._debugLines[i] = points;\n                    }\n                    this._getBonePosition(points[0], bone, meshMat);\n                    this._getBonePosition(points[1], bone, meshMat, 0, bone.length, 0);\n                    points[0].subtractInPlace(meshPos);\n                    points[1].subtractInPlace(meshPos);\n                }\n            };\n            SkeletonViewer.prototype._getLinesForBonesNoLength = function (bones, meshMat) {\n                var len = bones.length;\n                var boneNum = 0;\n                var meshPos = this.mesh.position;\n                for (var i = len - 1; i >= 0; i--) {\n                    var childBone = bones[i];\n                    var parentBone = childBone.getParent();\n                    if (!parentBone) {\n                        continue;\n                    }\n                    var points = this._debugLines[boneNum];\n                    if (!points) {\n                        points = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n                        this._debugLines[boneNum] = points;\n                    }\n                    childBone.getAbsolutePositionToRef(this.mesh, points[0]);\n                    parentBone.getAbsolutePositionToRef(this.mesh, points[1]);\n                    points[0].subtractInPlace(meshPos);\n                    points[1].subtractInPlace(meshPos);\n                    boneNum++;\n                }\n            };\n            SkeletonViewer.prototype.update = function () {\n                if (this.autoUpdateBonesMatrices) {\n                    this.skeleton.computeAbsoluteTransforms();\n                }\n                if (this.skeleton.bones[0].length === undefined) {\n                    this._getLinesForBonesNoLength(this.skeleton.bones, this.mesh.getWorldMatrix());\n                }\n                else {\n                    this._getLinesForBonesWithLength(this.skeleton.bones, this.mesh.getWorldMatrix());\n                }\n                if (!this._debugMesh) {\n                    this._debugMesh = BABYLON.MeshBuilder.CreateLineSystem(null, { lines: this._debugLines, updatable: true }, this._scene);\n                    this._debugMesh.renderingGroupId = this.renderingGroupId;\n                }\n                else {\n                    BABYLON.MeshBuilder.CreateLineSystem(null, { lines: this._debugLines, updatable: true, instance: this._debugMesh }, this._scene);\n                }\n                this._debugMesh.position.copyFrom(this.mesh.position);\n                this._debugMesh.color = this.color;\n            };\n            SkeletonViewer.prototype.dispose = function () {\n                if (this._debugMesh) {\n                    this.isEnabled = false;\n                    this._debugMesh.dispose();\n                    this._debugMesh = null;\n                }\n            };\n            return SkeletonViewer;\n        }());\n        Debug.SkeletonViewer = SkeletonViewer;\n    })(Debug = BABYLON.Debug || (BABYLON.Debug = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.skeletonViewer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Debug;\n    (function (Debug) {\n        var AxesViewer = (function () {\n            function AxesViewer(scene, scaleLines) {\n                if (scaleLines === void 0) { scaleLines = 1; }\n                this._xline = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n                this._yline = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n                this._zline = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];\n                this.scaleLines = 1;\n                this.scaleLines = scaleLines;\n                this._xmesh = BABYLON.Mesh.CreateLines(\"xline\", this._xline, scene, true);\n                this._ymesh = BABYLON.Mesh.CreateLines(\"yline\", this._yline, scene, true);\n                this._zmesh = BABYLON.Mesh.CreateLines(\"zline\", this._zline, scene, true);\n                this._xmesh.renderingGroupId = 2;\n                this._ymesh.renderingGroupId = 2;\n                this._zmesh.renderingGroupId = 2;\n                this._xmesh.material.checkReadyOnlyOnce = true;\n                this._xmesh.color = new BABYLON.Color3(1, 0, 0);\n                this._ymesh.material.checkReadyOnlyOnce = true;\n                this._ymesh.color = new BABYLON.Color3(0, 1, 0);\n                this._zmesh.material.checkReadyOnlyOnce = true;\n                this._zmesh.color = new BABYLON.Color3(0, 0, 1);\n                this.scene = scene;\n            }\n            AxesViewer.prototype.update = function (position, xaxis, yaxis, zaxis) {\n                var scaleLines = this.scaleLines;\n                this._xmesh.position.copyFrom(position);\n                this._ymesh.position.copyFrom(position);\n                this._zmesh.position.copyFrom(position);\n                var point2 = this._xline[1];\n                point2.x = xaxis.x * scaleLines;\n                point2.y = xaxis.y * scaleLines;\n                point2.z = xaxis.z * scaleLines;\n                BABYLON.Mesh.CreateLines(null, this._xline, null, null, this._xmesh);\n                point2 = this._yline[1];\n                point2.x = yaxis.x * scaleLines;\n                point2.y = yaxis.y * scaleLines;\n                point2.z = yaxis.z * scaleLines;\n                BABYLON.Mesh.CreateLines(null, this._yline, null, null, this._ymesh);\n                point2 = this._zline[1];\n                point2.x = zaxis.x * scaleLines;\n                point2.y = zaxis.y * scaleLines;\n                point2.z = zaxis.z * scaleLines;\n                BABYLON.Mesh.CreateLines(null, this._zline, null, null, this._zmesh);\n            };\n            AxesViewer.prototype.dispose = function () {\n                if (this._xmesh) {\n                    this._xmesh.dispose();\n                    this._ymesh.dispose();\n                    this._zmesh.dispose();\n                    this._xmesh = null;\n                    this._ymesh = null;\n                    this._zmesh = null;\n                    this._xline = null;\n                    this._yline = null;\n                    this._zline = null;\n                    this.scene = null;\n                }\n            };\n            return AxesViewer;\n        }());\n        Debug.AxesViewer = AxesViewer;\n    })(Debug = BABYLON.Debug || (BABYLON.Debug = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.axesViewer.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var Debug;\n    (function (Debug) {\n        var BoneAxesViewer = (function (_super) {\n            __extends(BoneAxesViewer, _super);\n            function BoneAxesViewer(scene, bone, mesh, scaleLines) {\n                if (scaleLines === void 0) { scaleLines = 1; }\n                var _this = _super.call(this, scene, scaleLines) || this;\n                _this.pos = BABYLON.Vector3.Zero();\n                _this.xaxis = BABYLON.Vector3.Zero();\n                _this.yaxis = BABYLON.Vector3.Zero();\n                _this.zaxis = BABYLON.Vector3.Zero();\n                _this.mesh = mesh;\n                _this.bone = bone;\n                return _this;\n            }\n            BoneAxesViewer.prototype.update = function () {\n                var bone = this.bone;\n                bone.getAbsolutePositionToRef(this.mesh, this.pos);\n                bone.getDirectionToRef(BABYLON.Axis.X, this.mesh, this.xaxis);\n                bone.getDirectionToRef(BABYLON.Axis.Y, this.mesh, this.yaxis);\n                bone.getDirectionToRef(BABYLON.Axis.Z, this.mesh, this.zaxis);\n                _super.prototype.update.call(this, this.pos, this.xaxis, this.yaxis, this.zaxis);\n            };\n            BoneAxesViewer.prototype.dispose = function () {\n                if (this.pos) {\n                    this.pos = null;\n                    this.xaxis = null;\n                    this.yaxis = null;\n                    this.zaxis = null;\n                    this.mesh = null;\n                    this.bone = null;\n                    _super.prototype.dispose.call(this);\n                }\n            };\n            return BoneAxesViewer;\n        }(Debug.AxesViewer));\n        Debug.BoneAxesViewer = BoneAxesViewer;\n    })(Debug = BABYLON.Debug || (BABYLON.Debug = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boneAxesViewer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var RayHelper = (function () {\n        function RayHelper(ray) {\n            this.ray = ray;\n        }\n        RayHelper.CreateAndShow = function (ray, scene, color) {\n            var helper = new RayHelper(ray);\n            helper.show(scene, color);\n            return helper;\n        };\n        RayHelper.prototype.show = function (scene, color) {\n            if (!this._renderFunction) {\n                var ray = this.ray;\n                this._renderFunction = this._render.bind(this);\n                this._scene = scene;\n                this._renderPoints = [ray.origin, ray.origin.add(ray.direction.scale(ray.length))];\n                this._renderLine = BABYLON.Mesh.CreateLines(\"ray\", this._renderPoints, scene, true);\n                this._scene.registerBeforeRender(this._renderFunction);\n            }\n            if (color) {\n                this._renderLine.color.copyFrom(color);\n            }\n        };\n        RayHelper.prototype.hide = function () {\n            if (this._renderFunction) {\n                this._scene.unregisterBeforeRender(this._renderFunction);\n                this._scene = null;\n                this._renderFunction = null;\n                this._renderLine.dispose();\n                this._renderLine = null;\n                this._renderPoints = null;\n            }\n        };\n        RayHelper.prototype._render = function () {\n            var ray = this.ray;\n            var point = this._renderPoints[1];\n            var len = Math.min(ray.length, 1000000);\n            point.copyFrom(ray.direction);\n            point.scaleInPlace(len);\n            point.addInPlace(ray.origin);\n            BABYLON.Mesh.CreateLines(\"ray\", this._renderPoints, this._scene, true, this._renderLine);\n        };\n        RayHelper.prototype.attachToMesh = function (mesh, meshSpaceDirection, meshSpaceOrigin, length) {\n            this._attachedToMesh = mesh;\n            var ray = this.ray;\n            if (!ray.direction) {\n                ray.direction = BABYLON.Vector3.Zero();\n            }\n            if (!ray.origin) {\n                ray.origin = BABYLON.Vector3.Zero();\n            }\n            if (length) {\n                ray.length = length;\n            }\n            if (!meshSpaceOrigin) {\n                meshSpaceOrigin = BABYLON.Vector3.Zero();\n            }\n            if (!meshSpaceDirection) {\n                // -1 so that this will work with Mesh.lookAt\n                meshSpaceDirection = new BABYLON.Vector3(0, 0, -1);\n            }\n            if (!this._meshSpaceDirection) {\n                this._meshSpaceDirection = meshSpaceDirection.clone();\n                this._meshSpaceOrigin = meshSpaceOrigin.clone();\n            }\n            else {\n                this._meshSpaceDirection.copyFrom(meshSpaceDirection);\n                this._meshSpaceOrigin.copyFrom(meshSpaceOrigin);\n            }\n            if (!this._updateToMeshFunction) {\n                this._updateToMeshFunction = this._updateToMesh.bind(this);\n                this._attachedToMesh.getScene().registerBeforeRender(this._updateToMeshFunction);\n            }\n            this._updateToMesh();\n        };\n        RayHelper.prototype.detachFromMesh = function () {\n            if (this._attachedToMesh) {\n                this._attachedToMesh.getScene().unregisterBeforeRender(this._updateToMeshFunction);\n                this._attachedToMesh = null;\n                this._updateToMeshFunction = null;\n            }\n        };\n        RayHelper.prototype._updateToMesh = function () {\n            var ray = this.ray;\n            if (this._attachedToMesh._isDisposed) {\n                this.detachFromMesh();\n                return;\n            }\n            this._attachedToMesh.getDirectionToRef(this._meshSpaceDirection, ray.direction);\n            BABYLON.Vector3.TransformCoordinatesToRef(this._meshSpaceOrigin, this._attachedToMesh.getWorldMatrix(), ray.origin);\n        };\n        RayHelper.prototype.dispose = function () {\n            this.hide();\n            this.detachFromMesh();\n            this.ray = null;\n        };\n        return RayHelper;\n    }());\n    BABYLON.RayHelper = RayHelper;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.rayHelper.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var DebugLayer = (function () {\n        function DebugLayer(scene) {\n            this._scene = scene;\n        }\n        /** Creates the inspector window. */\n        DebugLayer.prototype._createInspector = function (config) {\n            if (config === void 0) { config = {}; }\n            var popup = config.popup || false;\n            var initialTab = config.initialTab || 0;\n            var parentElement = config.parentElement || null;\n            if (!this._inspector) {\n                this._inspector = new INSPECTOR.Inspector(this._scene, popup, initialTab, parentElement, config.newColors);\n            } // else nothing to do,; instance is already existing\n        };\n        DebugLayer.prototype.isVisible = function () {\n            if (!this._inspector) {\n                return false;\n            }\n            return true;\n        };\n        DebugLayer.prototype.hide = function () {\n            if (this._inspector) {\n                try {\n                    this._inspector.dispose();\n                }\n                catch (e) {\n                    // If the inspector has been removed directly from the inspector tool\n                }\n                this._inspector = null;\n            }\n        };\n        DebugLayer.prototype.show = function (config) {\n            if (config === void 0) { config = {}; }\n            if (typeof INSPECTOR == 'undefined') {\n                // Load inspector and add it to the DOM\n                BABYLON.Tools.LoadScript(DebugLayer.InspectorURL, this._createInspector.bind(this, config));\n            }\n            else {\n                // Otherwise creates the inspector\n                this._createInspector(config);\n            }\n        };\n        return DebugLayer;\n    }());\n    // Get protocol used - http or https\n    DebugLayer.InspectorURL = window.location.href.split('/')[0] + '//preview.babylonjs.com/inspector/babylon.inspector.bundle.js';\n    BABYLON.DebugLayer = DebugLayer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.debugLayer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Debug;\n    (function (Debug) {\n        var PhysicsViewer = (function () {\n            function PhysicsViewer(scene) {\n                this._impostors = [];\n                this._meshes = [];\n                this._numMeshes = 0;\n                this._scene = scene || BABYLON.Engine.LastCreatedScene;\n                this._physicsEnginePlugin = this._scene.getPhysicsEngine().getPhysicsPlugin();\n            }\n            PhysicsViewer.prototype._updateDebugMeshes = function () {\n                var plugin = this._physicsEnginePlugin;\n                for (var i = 0; i < this._numMeshes; i++) {\n                    if (this._impostors[i].isDisposed) {\n                        this.hideImpostor(this._impostors[i--]);\n                    }\n                    else {\n                        plugin.syncMeshWithImpostor(this._meshes[i], this._impostors[i]);\n                    }\n                }\n            };\n            PhysicsViewer.prototype.showImpostor = function (impostor) {\n                for (var i = 0; i < this._numMeshes; i++) {\n                    if (this._impostors[i] == impostor) {\n                        return;\n                    }\n                }\n                var debugMesh = this._getDebugMesh(impostor, this._scene);\n                if (debugMesh) {\n                    this._impostors[this._numMeshes] = impostor;\n                    this._meshes[this._numMeshes] = debugMesh;\n                    if (this._numMeshes === 0) {\n                        this._renderFunction = this._updateDebugMeshes.bind(this);\n                        this._scene.registerBeforeRender(this._renderFunction);\n                    }\n                    this._numMeshes++;\n                }\n            };\n            PhysicsViewer.prototype.hideImpostor = function (impostor) {\n                var removed = false;\n                for (var i = 0; i < this._numMeshes; i++) {\n                    if (this._impostors[i] == impostor) {\n                        this._scene.removeMesh(this._meshes[i]);\n                        this._meshes[i].dispose();\n                        this._numMeshes--;\n                        if (this._numMeshes > 0) {\n                            this._meshes[i] = this._meshes[this._numMeshes];\n                            this._impostors[i] = this._impostors[this._numMeshes];\n                            this._meshes[this._numMeshes] = null;\n                            this._impostors[this._numMeshes] = null;\n                        }\n                        else {\n                            this._meshes[0] = null;\n                            this._impostors[0] = null;\n                        }\n                        removed = true;\n                        break;\n                    }\n                }\n                if (removed && this._numMeshes === 0) {\n                    this._scene.unregisterBeforeRender(this._renderFunction);\n                }\n            };\n            PhysicsViewer.prototype._getDebugMaterial = function (scene) {\n                if (!this._debugMaterial) {\n                    this._debugMaterial = new BABYLON.StandardMaterial('', scene);\n                    this._debugMaterial.wireframe = true;\n                }\n                return this._debugMaterial;\n            };\n            PhysicsViewer.prototype._getDebugBoxMesh = function (scene) {\n                if (!this._debugBoxMesh) {\n                    this._debugBoxMesh = BABYLON.MeshBuilder.CreateBox('physicsBodyBoxViewMesh', { size: 1 }, scene);\n                    this._debugBoxMesh.renderingGroupId = 1;\n                    this._debugBoxMesh.rotationQuaternion = BABYLON.Quaternion.Identity();\n                    this._debugBoxMesh.material = this._getDebugMaterial(scene);\n                    scene.removeMesh(this._debugBoxMesh);\n                }\n                return this._debugBoxMesh.createInstance('physicsBodyBoxViewInstance');\n            };\n            PhysicsViewer.prototype._getDebugSphereMesh = function (scene) {\n                if (!this._debugSphereMesh) {\n                    this._debugSphereMesh = BABYLON.MeshBuilder.CreateSphere('physicsBodySphereViewMesh', { diameter: 1 }, scene);\n                    this._debugSphereMesh.renderingGroupId = 1;\n                    this._debugSphereMesh.rotationQuaternion = BABYLON.Quaternion.Identity();\n                    this._debugSphereMesh.material = this._getDebugMaterial(scene);\n                    scene.removeMesh(this._debugSphereMesh);\n                }\n                return this._debugSphereMesh.createInstance('physicsBodyBoxViewInstance');\n            };\n            PhysicsViewer.prototype._getDebugMesh = function (impostor, scene) {\n                var body = impostor.physicsBody;\n                var shape = body.shapes[0];\n                var mesh;\n                if (impostor.type == BABYLON.PhysicsImpostor.BoxImpostor) {\n                    mesh = this._getDebugBoxMesh(scene);\n                    impostor.getBoxSizeToRef(mesh.scaling);\n                }\n                else if (impostor.type == BABYLON.PhysicsImpostor.SphereImpostor) {\n                    mesh = this._getDebugSphereMesh(scene);\n                    var radius = impostor.getRadius();\n                    mesh.scaling.x = radius * 2;\n                    mesh.scaling.y = radius * 2;\n                    mesh.scaling.z = radius * 2;\n                }\n                return mesh;\n            };\n            PhysicsViewer.prototype.dispose = function () {\n                for (var i = 0; i < this._numMeshes; i++) {\n                    this.hideImpostor(this._impostors[i]);\n                }\n                if (this._debugBoxMesh) {\n                    this._debugBoxMesh.dispose();\n                }\n                if (this._debugSphereMesh) {\n                    this._debugSphereMesh.dispose();\n                }\n                if (this._debugMaterial) {\n                    this._debugMaterial.dispose();\n                }\n                this._impostors.length = 0;\n                this._scene = null;\n                this._physicsEnginePlugin = null;\n            };\n            return PhysicsViewer;\n        }());\n        Debug.PhysicsViewer = PhysicsViewer;\n    })(Debug = BABYLON.Debug || (BABYLON.Debug = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.physicsViewer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var BoundingBoxRenderer = (function () {\n        function BoundingBoxRenderer(scene) {\n            this.frontColor = new BABYLON.Color3(1, 1, 1);\n            this.backColor = new BABYLON.Color3(0.1, 0.1, 0.1);\n            this.showBackLines = true;\n            this.renderList = new BABYLON.SmartArray(32);\n            this._vertexBuffers = {};\n            this._scene = scene;\n        }\n        BoundingBoxRenderer.prototype._prepareRessources = function () {\n            if (this._colorShader) {\n                return;\n            }\n            this._colorShader = new BABYLON.ShaderMaterial(\"colorShader\", this._scene, \"color\", {\n                attributes: [BABYLON.VertexBuffer.PositionKind],\n                uniforms: [\"world\", \"viewProjection\", \"color\"]\n            });\n            var engine = this._scene.getEngine();\n            var boxdata = BABYLON.VertexData.CreateBox(1.0);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = new BABYLON.VertexBuffer(engine, boxdata.positions, BABYLON.VertexBuffer.PositionKind, false);\n            this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\n        };\n        BoundingBoxRenderer.prototype.reset = function () {\n            this.renderList.reset();\n        };\n        BoundingBoxRenderer.prototype.render = function () {\n            if (this.renderList.length === 0) {\n                return;\n            }\n            this._prepareRessources();\n            if (!this._colorShader.isReady()) {\n                return;\n            }\n            var engine = this._scene.getEngine();\n            engine.setDepthWrite(false);\n            this._colorShader._preBind();\n            for (var boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\n                var boundingBox = this.renderList.data[boundingBoxIndex];\n                var min = boundingBox.minimum;\n                var max = boundingBox.maximum;\n                var diff = max.subtract(min);\n                var median = min.add(diff.scale(0.5));\n                var worldMatrix = BABYLON.Matrix.Scaling(diff.x, diff.y, diff.z)\n                    .multiply(BABYLON.Matrix.Translation(median.x, median.y, median.z))\n                    .multiply(boundingBox.getWorldMatrix());\n                // VBOs\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\n                if (this.showBackLines) {\n                    // Back\n                    engine.setDepthFunctionToGreaterOrEqual();\n                    this._scene.resetCachedMaterial();\n                    this._colorShader.setColor4(\"color\", this.backColor.toColor4());\n                    this._colorShader.bind(worldMatrix);\n                    // Draw order\n                    engine.draw(false, 0, 24);\n                }\n                // Front\n                engine.setDepthFunctionToLess();\n                this._scene.resetCachedMaterial();\n                this._colorShader.setColor4(\"color\", this.frontColor.toColor4());\n                this._colorShader.bind(worldMatrix);\n                // Draw order\n                engine.draw(false, 0, 24);\n            }\n            this._colorShader.unbind();\n            engine.setDepthFunctionToLessOrEqual();\n            engine.setDepthWrite(true);\n        };\n        BoundingBoxRenderer.prototype.dispose = function () {\n            if (!this._colorShader) {\n                return;\n            }\n            this.renderList.dispose();\n            this._colorShader.dispose();\n            var buffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (buffer) {\n                buffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n        };\n        return BoundingBoxRenderer;\n    }());\n    BABYLON.BoundingBoxRenderer = BoundingBoxRenderer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.boundingBoxRenderer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var MorphTarget = (function () {\n        function MorphTarget(name, influence) {\n            if (influence === void 0) { influence = 0; }\n            this.name = name;\n            this.animations = new Array();\n            this.onInfluenceChanged = new BABYLON.Observable();\n            this.influence = influence;\n        }\n        Object.defineProperty(MorphTarget.prototype, \"influence\", {\n            get: function () {\n                return this._influence;\n            },\n            set: function (influence) {\n                if (this._influence === influence) {\n                    return;\n                }\n                var previous = this._influence;\n                this._influence = influence;\n                if (this.onInfluenceChanged.hasObservers) {\n                    this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTarget.prototype, \"hasNormals\", {\n            get: function () {\n                return this._normals !== undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTarget.prototype, \"hasTangents\", {\n            get: function () {\n                return this._tangents !== undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MorphTarget.prototype.setPositions = function (data) {\n            this._positions = new Float32Array(data);\n        };\n        MorphTarget.prototype.getPositions = function () {\n            return this._positions;\n        };\n        MorphTarget.prototype.setNormals = function (data) {\n            this._normals = new Float32Array(data);\n        };\n        MorphTarget.prototype.getNormals = function () {\n            return this._normals;\n        };\n        MorphTarget.prototype.setTangents = function (data) {\n            this._tangents = new Float32Array(data);\n        };\n        MorphTarget.prototype.getTangents = function () {\n            return this._tangents;\n        };\n        /**\n         * Serializes the current target into a Serialization object.\n         * Returns the serialized object.\n         */\n        MorphTarget.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.influence = this.influence;\n            serializationObject.positions = Array.prototype.slice.call(this.getPositions());\n            if (this.hasNormals) {\n                serializationObject.normals = Array.prototype.slice.call(this.getNormals());\n            }\n            if (this.hasTangents) {\n                serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\n            }\n            return serializationObject;\n        };\n        // Statics\n        MorphTarget.Parse = function (serializationObject) {\n            var result = new MorphTarget(serializationObject.name, serializationObject.influence);\n            result.setPositions(serializationObject.positions);\n            if (serializationObject.normals) {\n                result.setNormals(serializationObject.normals);\n            }\n            if (serializationObject.tangents) {\n                result.setTangents(serializationObject.tangents);\n            }\n            return result;\n        };\n        MorphTarget.FromMesh = function (mesh, name, influence) {\n            if (!name) {\n                name = mesh.name;\n            }\n            var result = new MorphTarget(name, influence);\n            result.setPositions(mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind));\n            if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.NormalKind)) {\n                result.setNormals(mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind));\n            }\n            if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.TangentKind)) {\n                result.setTangents(mesh.getVerticesData(BABYLON.VertexBuffer.TangentKind));\n            }\n            return result;\n        };\n        return MorphTarget;\n    }());\n    BABYLON.MorphTarget = MorphTarget;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.morphTarget.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var MorphTargetManager = (function () {\n        function MorphTargetManager(scene) {\n            this._targets = new Array();\n            this._targetObservable = new Array();\n            this._activeTargets = new BABYLON.SmartArray(16);\n            this._supportsNormals = false;\n            this._supportsTangents = false;\n            this._vertexCount = 0;\n            this._uniqueId = 0;\n            if (!scene) {\n                scene = BABYLON.Engine.LastCreatedScene;\n            }\n            this._scene = scene;\n            this._scene.morphTargetManagers.push(this);\n            this._uniqueId = scene.getUniqueId();\n        }\n        Object.defineProperty(MorphTargetManager.prototype, \"uniqueId\", {\n            get: function () {\n                return this._uniqueId;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"vertexCount\", {\n            get: function () {\n                return this._vertexCount;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"supportsNormals\", {\n            get: function () {\n                return this._supportsNormals;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"supportsTangents\", {\n            get: function () {\n                return this._supportsTangents;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"numTargets\", {\n            get: function () {\n                return this._targets.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"numInfluencers\", {\n            get: function () {\n                return this._activeTargets.length;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MorphTargetManager.prototype, \"influences\", {\n            get: function () {\n                return this._influences;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MorphTargetManager.prototype.getActiveTarget = function (index) {\n            return this._activeTargets.data[index];\n        };\n        MorphTargetManager.prototype.getTarget = function (index) {\n            return this._targets[index];\n        };\n        MorphTargetManager.prototype.addTarget = function (target) {\n            var _this = this;\n            if (this._vertexCount) {\n                if (this._vertexCount !== target.getPositions().length / 3) {\n                    BABYLON.Tools.Error(\"Incompatible target. Targets must all have the same vertices count.\");\n                    return;\n                }\n            }\n            this._targets.push(target);\n            this._targetObservable.push(target.onInfluenceChanged.add(function (needUpdate) {\n                _this._syncActiveTargets(needUpdate);\n            }));\n            this._syncActiveTargets(true);\n        };\n        MorphTargetManager.prototype.removeTarget = function (target) {\n            var index = this._targets.indexOf(target);\n            if (index >= 0) {\n                this._targets.splice(index, 1);\n                target.onInfluenceChanged.remove(this._targetObservable.splice(index, 1)[0]);\n                this._vertexCount = 0;\n                this._syncActiveTargets(true);\n            }\n        };\n        /**\n         * Serializes the current manager into a Serialization object.\n         * Returns the serialized object.\n         */\n        MorphTargetManager.prototype.serialize = function () {\n            var serializationObject = {};\n            serializationObject.id = this.uniqueId;\n            serializationObject.targets = [];\n            for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n                var target = _a[_i];\n                serializationObject.targets.push(target.serialize());\n            }\n            return serializationObject;\n        };\n        MorphTargetManager.prototype._onInfluenceChanged = function (needUpdate) {\n            this._syncActiveTargets(needUpdate);\n        };\n        MorphTargetManager.prototype._syncActiveTargets = function (needUpdate) {\n            this._activeTargets.reset();\n            var tempInfluences = [];\n            this._supportsNormals = true;\n            this._supportsTangents = true;\n            for (var _i = 0, _a = this._targets; _i < _a.length; _i++) {\n                var target = _a[_i];\n                if (target.influence > 0) {\n                    this._activeTargets.push(target);\n                    tempInfluences.push(target.influence);\n                    this._supportsNormals = this._supportsNormals && target.hasNormals;\n                    this._supportsTangents = this._supportsTangents && target.hasTangents;\n                    if (this._vertexCount === 0) {\n                        this._vertexCount = target.getPositions().length / 3;\n                    }\n                }\n            }\n            this._influences = new Float32Array(tempInfluences);\n            if (needUpdate) {\n                // Flag meshes as dirty to resync with the active targets\n                for (var _b = 0, _c = this._scene.meshes; _b < _c.length; _b++) {\n                    var mesh = _c[_b];\n                    if (mesh.morphTargetManager === this) {\n                        mesh._syncGeometryWithMorphTargetManager();\n                    }\n                }\n            }\n        };\n        // Statics\n        MorphTargetManager.Parse = function (serializationObject, scene) {\n            var result = new MorphTargetManager(scene);\n            result._uniqueId = serializationObject.id;\n            for (var _i = 0, _a = serializationObject.targets; _i < _a.length; _i++) {\n                var targetData = _a[_i];\n                result.addTarget(BABYLON.MorphTarget.Parse(targetData));\n            }\n            return result;\n        };\n        return MorphTargetManager;\n    }());\n    BABYLON.MorphTargetManager = MorphTargetManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.morphTargetManager.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This represents a color grading texture. This acts as a lookup table LUT, useful during post process\n     * It can help converting any input color in a desired output one. This can then be used to create effects\n     * from sepia, black and white to sixties or futuristic rendering...\n     *\n     * The only supported format is currently 3dl.\n     * More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table/\n     */\n    var ColorGradingTexture = (function (_super) {\n        __extends(ColorGradingTexture, _super);\n        /**\n         * Instantiates a ColorGradingTexture from the following parameters.\n         *\n         * @param url The location of the color gradind data (currently only supporting 3dl)\n         * @param scene The scene the texture will be used in\n         */\n        function ColorGradingTexture(url, scene) {\n            var _this = _super.call(this, scene) || this;\n            if (!url) {\n                return _this;\n            }\n            _this._textureMatrix = BABYLON.Matrix.Identity();\n            _this.name = url;\n            _this.url = url;\n            _this.hasAlpha = false;\n            _this.isCube = false;\n            _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.anisotropicFilteringLevel = 1;\n            _this._texture = _this._getFromCache(url, true);\n            if (!_this._texture) {\n                if (!scene.useDelayedTextureLoading) {\n                    _this.loadTexture();\n                }\n                else {\n                    _this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_NOTLOADED;\n                }\n            }\n            return _this;\n        }\n        /**\n         * Returns the texture matrix used in most of the material.\n         * This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).\n         */\n        ColorGradingTexture.prototype.getTextureMatrix = function () {\n            return this._textureMatrix;\n        };\n        /**\n         * Occurs when the file being loaded is a .3dl LUT file.\n         */\n        ColorGradingTexture.prototype.load3dlTexture = function () {\n            var _this = this;\n            var mipLevels = 0;\n            var floatArrayView = null;\n            var texture = this.getScene().getEngine().createRawTexture(null, 1, 1, BABYLON.Engine.TEXTUREFORMAT_RGBA, false, false, BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            this._texture = texture;\n            var callback = function (text) {\n                var data;\n                var tempData;\n                var line;\n                var lines = text.split('\\n');\n                var size = 0, pixelIndexW = 0, pixelIndexH = 0, pixelIndexSlice = 0;\n                var maxColor = 0;\n                for (var i = 0; i < lines.length; i++) {\n                    line = lines[i];\n                    if (!ColorGradingTexture._noneEmptyLineRegex.test(line))\n                        continue;\n                    if (line.indexOf('#') === 0)\n                        continue;\n                    var words = line.split(\" \");\n                    if (size === 0) {\n                        // Number of space + one\n                        size = words.length;\n                        data = new Uint8Array(size * size * size * 4); // volume texture of side size and rgb 8\n                        tempData = new Float32Array(size * size * size * 4);\n                        continue;\n                    }\n                    if (size != 0) {\n                        var r = Math.max(parseInt(words[0]), 0);\n                        var g = Math.max(parseInt(words[1]), 0);\n                        var b = Math.max(parseInt(words[2]), 0);\n                        maxColor = Math.max(r, maxColor);\n                        maxColor = Math.max(g, maxColor);\n                        maxColor = Math.max(b, maxColor);\n                        var pixelStorageIndex = (pixelIndexW + pixelIndexSlice * size + pixelIndexH * size * size) * 4;\n                        tempData[pixelStorageIndex + 0] = r;\n                        tempData[pixelStorageIndex + 1] = g;\n                        tempData[pixelStorageIndex + 2] = b;\n                        pixelIndexSlice++;\n                        if (pixelIndexSlice % size == 0) {\n                            pixelIndexH++;\n                            pixelIndexSlice = 0;\n                            if (pixelIndexH % size == 0) {\n                                pixelIndexW++;\n                                pixelIndexH = 0;\n                            }\n                        }\n                    }\n                }\n                for (var i = 0; i < tempData.length; i++) {\n                    if (i > 0 && (i + 1) % 4 === 0) {\n                        data[i] = 255;\n                    }\n                    else {\n                        var value = tempData[i];\n                        data[i] = (value / maxColor * 255);\n                    }\n                }\n                _this.getScene().getEngine().updateTextureSize(texture, size * size, size);\n                _this.getScene().getEngine().updateRawTexture(texture, data, BABYLON.Engine.TEXTUREFORMAT_RGBA, false);\n            };\n            BABYLON.Tools.LoadFile(this.url, callback);\n            return this._texture;\n        };\n        /**\n         * Starts the loading process of the texture.\n         */\n        ColorGradingTexture.prototype.loadTexture = function () {\n            if (this.url && this.url.toLocaleLowerCase().indexOf(\".3dl\") == (this.url.length - 4)) {\n                this.load3dlTexture();\n            }\n        };\n        /**\n         * Clones the color gradind texture.\n         */\n        ColorGradingTexture.prototype.clone = function () {\n            var newTexture = new ColorGradingTexture(this.url, this.getScene());\n            // Base texture\n            newTexture.level = this.level;\n            return newTexture;\n        };\n        /**\n         * Called during delayed load for textures.\n         */\n        ColorGradingTexture.prototype.delayLoad = function () {\n            if (this.delayLoadState !== BABYLON.Engine.DELAYLOADSTATE_NOTLOADED) {\n                return;\n            }\n            this.delayLoadState = BABYLON.Engine.DELAYLOADSTATE_LOADED;\n            this._texture = this._getFromCache(this.url, true);\n            if (!this._texture) {\n                this.loadTexture();\n            }\n        };\n        /**\n         * Parses a color grading texture serialized by Babylon.\n         * @param parsedTexture The texture information being parsedTexture\n         * @param scene The scene to load the texture in\n         * @param rootUrl The root url of the data assets to load\n         * @return A color gradind texture\n         */\n        ColorGradingTexture.Parse = function (parsedTexture, scene, rootUrl) {\n            var texture = null;\n            if (parsedTexture.name && !parsedTexture.isRenderTarget) {\n                texture = new BABYLON.ColorGradingTexture(parsedTexture.name, scene);\n                texture.name = parsedTexture.name;\n                texture.level = parsedTexture.level;\n            }\n            return texture;\n        };\n        /**\n         * Serializes the LUT texture to json format.\n         */\n        ColorGradingTexture.prototype.serialize = function () {\n            if (!this.name) {\n                return null;\n            }\n            var serializationObject = {};\n            serializationObject.name = this.name;\n            serializationObject.level = this.level;\n            serializationObject.customType = \"BABYLON.ColorGradingTexture\";\n            return serializationObject;\n        };\n        return ColorGradingTexture;\n    }(BABYLON.BaseTexture));\n    /**\n     * Empty line regex stored for GC.\n     */\n    ColorGradingTexture._noneEmptyLineRegex = /\\S+/;\n    BABYLON.ColorGradingTexture = ColorGradingTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.colorGradingTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).\n     * They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.\n     * These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;\n     * corresponding to low luminance, medium luminance, and high luminance areas respectively.\n     */\n    var ColorCurves = (function () {\n        function ColorCurves() {\n            this._dirty = true;\n            this._tempColor = new BABYLON.Color4(0, 0, 0, 0);\n            this._globalCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._highlightsCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._midtonesCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._shadowsCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._positiveCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._negativeCurve = new BABYLON.Color4(0, 0, 0, 0);\n            this._globalHue = 30;\n            this._globalDensity = 0;\n            this._globalSaturation = 0;\n            this._globalExposure = 0;\n            this._highlightsHue = 30;\n            this._highlightsDensity = 0;\n            this._highlightsSaturation = 0;\n            this._highlightsExposure = 0;\n            this._midtonesHue = 30;\n            this._midtonesDensity = 0;\n            this._midtonesSaturation = 0;\n            this._midtonesExposure = 0;\n            this._shadowsHue = 30;\n            this._shadowsDensity = 0;\n            this._shadowsSaturation = 0;\n            this._shadowsExposure = 0;\n        }\n        Object.defineProperty(ColorCurves.prototype, \"globalHue\", {\n            /**\n             * Gets the global Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            get: function () {\n                return this._globalHue;\n            },\n            /**\n             * Sets the global Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            set: function (value) {\n                this._globalHue = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"globalDensity\", {\n            /**\n             * Gets the global Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            get: function () {\n                return this._globalDensity;\n            },\n            /**\n             * Sets the global Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            set: function (value) {\n                this._globalDensity = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"globalSaturation\", {\n            /**\n             * Gets the global Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            get: function () {\n                return this._globalSaturation;\n            },\n            /**\n             * Sets the global Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            set: function (value) {\n                this._globalSaturation = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"highlightsHue\", {\n            /**\n             * Gets the highlights Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            get: function () {\n                return this._highlightsHue;\n            },\n            /**\n             * Sets the highlights Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            set: function (value) {\n                this._highlightsHue = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"highlightsDensity\", {\n            /**\n             * Gets the highlights Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            get: function () {\n                return this._highlightsDensity;\n            },\n            /**\n             * Sets the highlights Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            set: function (value) {\n                this._highlightsDensity = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"highlightsSaturation\", {\n            /**\n             * Gets the highlights Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            get: function () {\n                return this._highlightsSaturation;\n            },\n            /**\n             * Sets the highlights Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            set: function (value) {\n                this._highlightsSaturation = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"highlightsExposure\", {\n            /**\n             * Gets the highlights Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            get: function () {\n                return this._highlightsExposure;\n            },\n            /**\n             * Sets the highlights Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            set: function (value) {\n                this._highlightsExposure = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"midtonesHue\", {\n            /**\n             * Gets the midtones Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            get: function () {\n                return this._midtonesHue;\n            },\n            /**\n             * Sets the midtones Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            set: function (value) {\n                this._midtonesHue = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"midtonesDensity\", {\n            /**\n             * Gets the midtones Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            get: function () {\n                return this._midtonesDensity;\n            },\n            /**\n             * Sets the midtones Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            set: function (value) {\n                this._midtonesDensity = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"midtonesSaturation\", {\n            /**\n             * Gets the midtones Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            get: function () {\n                return this._midtonesSaturation;\n            },\n            /**\n             * Sets the midtones Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            set: function (value) {\n                this._midtonesSaturation = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"midtonesExposure\", {\n            /**\n             * Gets the midtones Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            get: function () {\n                return this._midtonesExposure;\n            },\n            /**\n             * Sets the midtones Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            set: function (value) {\n                this._midtonesExposure = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"shadowsHue\", {\n            /**\n             * Gets the shadows Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            get: function () {\n                return this._shadowsHue;\n            },\n            /**\n             * Sets the shadows Hue value.\n             * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).\n             */\n            set: function (value) {\n                this._shadowsHue = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"shadowsDensity\", {\n            /**\n             * Gets the shadows Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            get: function () {\n                return this._shadowsDensity;\n            },\n            /**\n             * Sets the shadows Density value.\n             * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.\n             * Values less than zero provide a filter of opposite hue.\n             */\n            set: function (value) {\n                this._shadowsDensity = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"shadowsSaturation\", {\n            /**\n             * Gets the shadows Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            get: function () {\n                return this._shadowsSaturation;\n            },\n            /**\n             * Sets the shadows Saturation value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.\n             */\n            set: function (value) {\n                this._shadowsSaturation = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ColorCurves.prototype, \"shadowsExposure\", {\n            /**\n             * Gets the shadows Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            get: function () {\n                return this._shadowsExposure;\n            },\n            /**\n             * Sets the shadows Exposure value.\n             * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.\n             */\n            set: function (value) {\n                this._shadowsExposure = value;\n                this._dirty = true;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Binds the color curves to the shader.\n         * @param colorCurves The color curve to bind\n         * @param effect The effect to bind to\n         */\n        ColorCurves.Bind = function (colorCurves, effect, positiveUniform, neutralUniform, negativeUniform) {\n            if (positiveUniform === void 0) { positiveUniform = \"vCameraColorCurvePositive\"; }\n            if (neutralUniform === void 0) { neutralUniform = \"vCameraColorCurveNeutral\"; }\n            if (negativeUniform === void 0) { negativeUniform = \"vCameraColorCurveNegative\"; }\n            if (colorCurves._dirty) {\n                colorCurves._dirty = false;\n                // Fill in global info.\n                colorCurves.getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);\n                // Compute highlights info.\n                colorCurves.getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);\n                colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);\n                // Compute midtones info.\n                colorCurves.getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);\n                colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);\n                // Compute shadows info.\n                colorCurves.getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);\n                colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);\n                // Compute deltas (neutral is midtones).\n                colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);\n                colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);\n            }\n            if (effect) {\n                effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);\n                effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);\n                effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);\n            }\n        };\n        /**\n         * Prepare the list of uniforms associated with the ColorCurves effects.\n         * @param uniformsList The list of uniforms used in the effect\n         */\n        ColorCurves.PrepareUniforms = function (uniformsList) {\n            uniformsList.push(\"vCameraColorCurveNeutral\", \"vCameraColorCurvePositive\", \"vCameraColorCurveNegative\");\n        };\n        /**\n         * Returns color grading data based on a hue, density, saturation and exposure value.\n         * @param filterHue The hue of the color filter.\n         * @param filterDensity The density of the color filter.\n         * @param saturation The saturation.\n         * @param exposure The exposure.\n         * @param result The result data container.\n         */\n        ColorCurves.prototype.getColorGradingDataToRef = function (hue, density, saturation, exposure, result) {\n            if (hue == null) {\n                return;\n            }\n            hue = ColorCurves.clamp(hue, 0, 360);\n            density = ColorCurves.clamp(density, -100, 100);\n            saturation = ColorCurves.clamp(saturation, -100, 100);\n            exposure = ColorCurves.clamp(exposure, -100, 100);\n            // Remap the slider/config filter density with non-linear mapping and also scale by half\n            // so that the maximum filter density is only 50% control. This provides fine control \n            // for small values and reasonable range.\n            density = ColorCurves.applyColorGradingSliderNonlinear(density);\n            density *= 0.5;\n            exposure = ColorCurves.applyColorGradingSliderNonlinear(exposure);\n            if (density < 0) {\n                density *= -1;\n                hue = (hue + 180) % 360;\n            }\n            ColorCurves.fromHSBToRef(hue, density, 50 + 0.25 * exposure, result);\n            result.scaleToRef(2, result);\n            result.a = 1 + 0.01 * saturation;\n        };\n        /**\n         * Takes an input slider value and returns an adjusted value that provides extra control near the centre.\n         * @param value The input slider value in range [-100,100].\n         * @returns Adjusted value.\n         */\n        ColorCurves.applyColorGradingSliderNonlinear = function (value) {\n            value /= 100;\n            var x = Math.abs(value);\n            x = Math.pow(x, 2);\n            if (value < 0) {\n                x *= -1;\n            }\n            x *= 100;\n            return x;\n        };\n        /**\n         * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).\n         * @param hue The hue (H) input.\n         * @param saturation The saturation (S) input.\n         * @param brightness The brightness (B) input.\n         * @result An RGBA color represented as Vector4.\n         */\n        ColorCurves.fromHSBToRef = function (hue, saturation, brightness, result) {\n            var h = ColorCurves.clamp(hue, 0, 360);\n            var s = ColorCurves.clamp(saturation / 100, 0, 1);\n            var v = ColorCurves.clamp(brightness / 100, 0, 1);\n            if (s === 0) {\n                result.r = v;\n                result.g = v;\n                result.b = v;\n            }\n            else {\n                // sector 0 to 5\n                h /= 60;\n                var i = Math.floor(h);\n                // fractional part of h\n                var f = h - i;\n                var p = v * (1 - s);\n                var q = v * (1 - s * f);\n                var t = v * (1 - s * (1 - f));\n                switch (i) {\n                    case 0:\n                        result.r = v;\n                        result.g = t;\n                        result.b = p;\n                        break;\n                    case 1:\n                        result.r = q;\n                        result.g = v;\n                        result.b = p;\n                        break;\n                    case 2:\n                        result.r = p;\n                        result.g = v;\n                        result.b = t;\n                        break;\n                    case 3:\n                        result.r = p;\n                        result.g = q;\n                        result.b = v;\n                        break;\n                    case 4:\n                        result.r = t;\n                        result.g = p;\n                        result.b = v;\n                        break;\n                    default:\n                        result.r = v;\n                        result.g = p;\n                        result.b = q;\n                        break;\n                }\n            }\n            result.a = 1;\n        };\n        /**\n         * Returns a value clamped between min and max\n         * @param value The value to clamp\n         * @param min The minimum of value\n         * @param max The maximum of value\n         * @returns The clamped value.\n         */\n        ColorCurves.clamp = function (value, min, max) {\n            return Math.min(Math.max(value, min), max);\n        };\n        /**\n         * Clones the current color curve instance.\n         * @return The cloned curves\n         */\n        ColorCurves.prototype.clone = function () {\n            return BABYLON.SerializationHelper.Clone(function () { return new ColorCurves(); }, this);\n        };\n        /**\n         * Serializes the current color curve instance to a json representation.\n         * @return a JSON representation\n         */\n        ColorCurves.prototype.serialize = function () {\n            return BABYLON.SerializationHelper.Serialize(this);\n        };\n        /**\n         * Parses the color curve from a json representation.\n         * @param source the JSON source to parse\n         * @return The parsed curves\n         */\n        ColorCurves.Parse = function (source) {\n            return BABYLON.SerializationHelper.Parse(function () { return new ColorCurves(); }, source, null, null);\n        };\n        return ColorCurves;\n    }());\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_globalHue\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_globalDensity\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_globalSaturation\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_globalExposure\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_highlightsHue\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_highlightsDensity\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_highlightsSaturation\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_highlightsExposure\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_midtonesHue\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_midtonesDensity\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_midtonesSaturation\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ColorCurves.prototype, \"_midtonesExposure\", void 0);\n    BABYLON.ColorCurves = ColorCurves;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.colorCurves.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Octree = (function () {\n        function Octree(creationFunc, maxBlockCapacity, maxDepth) {\n            if (maxDepth === void 0) { maxDepth = 2; }\n            this.maxDepth = maxDepth;\n            this.dynamicContent = new Array();\n            this._maxBlockCapacity = maxBlockCapacity || 64;\n            this._selectionContent = new BABYLON.SmartArray(1024);\n            this._creationFunc = creationFunc;\n        }\n        // Methods\n        Octree.prototype.update = function (worldMin, worldMax, entries) {\n            Octree._CreateBlocks(worldMin, worldMax, entries, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc);\n        };\n        Octree.prototype.addMesh = function (entry) {\n            for (var index = 0; index < this.blocks.length; index++) {\n                var block = this.blocks[index];\n                block.addEntry(entry);\n            }\n        };\n        Octree.prototype.select = function (frustumPlanes, allowDuplicate) {\n            this._selectionContent.reset();\n            for (var index = 0; index < this.blocks.length; index++) {\n                var block = this.blocks[index];\n                block.select(frustumPlanes, this._selectionContent, allowDuplicate);\n            }\n            if (allowDuplicate) {\n                this._selectionContent.concat(this.dynamicContent);\n            }\n            else {\n                this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n            }\n            return this._selectionContent;\n        };\n        Octree.prototype.intersects = function (sphereCenter, sphereRadius, allowDuplicate) {\n            this._selectionContent.reset();\n            for (var index = 0; index < this.blocks.length; index++) {\n                var block = this.blocks[index];\n                block.intersects(sphereCenter, sphereRadius, this._selectionContent, allowDuplicate);\n            }\n            if (allowDuplicate) {\n                this._selectionContent.concat(this.dynamicContent);\n            }\n            else {\n                this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n            }\n            return this._selectionContent;\n        };\n        Octree.prototype.intersectsRay = function (ray) {\n            this._selectionContent.reset();\n            for (var index = 0; index < this.blocks.length; index++) {\n                var block = this.blocks[index];\n                block.intersectsRay(ray, this._selectionContent);\n            }\n            this._selectionContent.concatWithNoDuplicate(this.dynamicContent);\n            return this._selectionContent;\n        };\n        Octree._CreateBlocks = function (worldMin, worldMax, entries, maxBlockCapacity, currentDepth, maxDepth, target, creationFunc) {\n            target.blocks = new Array();\n            var blockSize = new BABYLON.Vector3((worldMax.x - worldMin.x) / 2, (worldMax.y - worldMin.y) / 2, (worldMax.z - worldMin.z) / 2);\n            // Segmenting space\n            for (var x = 0; x < 2; x++) {\n                for (var y = 0; y < 2; y++) {\n                    for (var z = 0; z < 2; z++) {\n                        var localMin = worldMin.add(blockSize.multiplyByFloats(x, y, z));\n                        var localMax = worldMin.add(blockSize.multiplyByFloats(x + 1, y + 1, z + 1));\n                        var block = new BABYLON.OctreeBlock(localMin, localMax, maxBlockCapacity, currentDepth + 1, maxDepth, creationFunc);\n                        block.addEntries(entries);\n                        target.blocks.push(block);\n                    }\n                }\n            }\n        };\n        return Octree;\n    }());\n    Octree.CreationFuncForMeshes = function (entry, block) {\n        if (!entry.isBlocked && entry.getBoundingInfo().boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n            block.entries.push(entry);\n        }\n    };\n    Octree.CreationFuncForSubMeshes = function (entry, block) {\n        if (entry.getBoundingInfo().boundingBox.intersectsMinMax(block.minPoint, block.maxPoint)) {\n            block.entries.push(entry);\n        }\n    };\n    BABYLON.Octree = Octree;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.octree.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var OctreeBlock = (function () {\n        function OctreeBlock(minPoint, maxPoint, capacity, depth, maxDepth, creationFunc) {\n            this.entries = new Array();\n            this._boundingVectors = new Array();\n            this._capacity = capacity;\n            this._depth = depth;\n            this._maxDepth = maxDepth;\n            this._creationFunc = creationFunc;\n            this._minPoint = minPoint;\n            this._maxPoint = maxPoint;\n            this._boundingVectors.push(minPoint.clone());\n            this._boundingVectors.push(maxPoint.clone());\n            this._boundingVectors.push(minPoint.clone());\n            this._boundingVectors[2].x = maxPoint.x;\n            this._boundingVectors.push(minPoint.clone());\n            this._boundingVectors[3].y = maxPoint.y;\n            this._boundingVectors.push(minPoint.clone());\n            this._boundingVectors[4].z = maxPoint.z;\n            this._boundingVectors.push(maxPoint.clone());\n            this._boundingVectors[5].z = minPoint.z;\n            this._boundingVectors.push(maxPoint.clone());\n            this._boundingVectors[6].x = minPoint.x;\n            this._boundingVectors.push(maxPoint.clone());\n            this._boundingVectors[7].y = minPoint.y;\n        }\n        Object.defineProperty(OctreeBlock.prototype, \"capacity\", {\n            // Property\n            get: function () {\n                return this._capacity;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OctreeBlock.prototype, \"minPoint\", {\n            get: function () {\n                return this._minPoint;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(OctreeBlock.prototype, \"maxPoint\", {\n            get: function () {\n                return this._maxPoint;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        OctreeBlock.prototype.addEntry = function (entry) {\n            if (this.blocks) {\n                for (var index = 0; index < this.blocks.length; index++) {\n                    var block = this.blocks[index];\n                    block.addEntry(entry);\n                }\n                return;\n            }\n            this._creationFunc(entry, this);\n            if (this.entries.length > this.capacity && this._depth < this._maxDepth) {\n                this.createInnerBlocks();\n            }\n        };\n        OctreeBlock.prototype.addEntries = function (entries) {\n            for (var index = 0; index < entries.length; index++) {\n                var mesh = entries[index];\n                this.addEntry(mesh);\n            }\n        };\n        OctreeBlock.prototype.select = function (frustumPlanes, selection, allowDuplicate) {\n            if (BABYLON.BoundingBox.IsInFrustum(this._boundingVectors, frustumPlanes)) {\n                if (this.blocks) {\n                    for (var index = 0; index < this.blocks.length; index++) {\n                        var block = this.blocks[index];\n                        block.select(frustumPlanes, selection, allowDuplicate);\n                    }\n                    return;\n                }\n                if (allowDuplicate) {\n                    selection.concat(this.entries);\n                }\n                else {\n                    selection.concatWithNoDuplicate(this.entries);\n                }\n            }\n        };\n        OctreeBlock.prototype.intersects = function (sphereCenter, sphereRadius, selection, allowDuplicate) {\n            if (BABYLON.BoundingBox.IntersectsSphere(this._minPoint, this._maxPoint, sphereCenter, sphereRadius)) {\n                if (this.blocks) {\n                    for (var index = 0; index < this.blocks.length; index++) {\n                        var block = this.blocks[index];\n                        block.intersects(sphereCenter, sphereRadius, selection, allowDuplicate);\n                    }\n                    return;\n                }\n                if (allowDuplicate) {\n                    selection.concat(this.entries);\n                }\n                else {\n                    selection.concatWithNoDuplicate(this.entries);\n                }\n            }\n        };\n        OctreeBlock.prototype.intersectsRay = function (ray, selection) {\n            if (ray.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {\n                if (this.blocks) {\n                    for (var index = 0; index < this.blocks.length; index++) {\n                        var block = this.blocks[index];\n                        block.intersectsRay(ray, selection);\n                    }\n                    return;\n                }\n                selection.concatWithNoDuplicate(this.entries);\n            }\n        };\n        OctreeBlock.prototype.createInnerBlocks = function () {\n            BABYLON.Octree._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc);\n        };\n        return OctreeBlock;\n    }());\n    BABYLON.OctreeBlock = OctreeBlock;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.octreeBlock.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SIMDVector3 = (function () {\n        function SIMDVector3() {\n        }\n        SIMDVector3.TransformCoordinatesToRefSIMD = function (vector, transformation, result) {\n            SIMDVector3.TransformCoordinatesFromFloatsToRefSIMD(vector.x, vector.y, vector.z, transformation, result);\n        };\n        SIMDVector3.TransformCoordinatesFromFloatsToRefSIMD = function (x, y, z, transformation, result) {\n            var m = transformation.m;\n            var m0 = SIMD.Float32x4.load(m, 0);\n            var m1 = SIMD.Float32x4.load(m, 4);\n            var m2 = SIMD.Float32x4.load(m, 8);\n            var m3 = SIMD.Float32x4.load(m, 12);\n            var r = SIMD.Float32x4.add(SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(x), m0), SIMD.Float32x4.mul(SIMD.Float32x4.splat(y), m1)), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(z), m2), m3));\n            r = SIMD.Float32x4.div(r, SIMD.Float32x4.swizzle(r, 3, 3, 3, 3));\n            result.x = SIMD.Float32x4.extractLane(r, 0);\n            result.y = SIMD.Float32x4.extractLane(r, 1);\n            result.z = SIMD.Float32x4.extractLane(r, 2);\n        };\n        return SIMDVector3;\n    }());\n    var SIMDMatrix = (function () {\n        function SIMDMatrix() {\n        }\n        SIMDMatrix.prototype.multiplyToArraySIMD = function (other, result, offset) {\n            var tm = this.m;\n            var om = other.m;\n            var m0 = SIMD.Float32x4.load(om, 0);\n            var m1 = SIMD.Float32x4.load(om, 4);\n            var m2 = SIMD.Float32x4.load(om, 8);\n            var m3 = SIMD.Float32x4.load(om, 12);\n            for (var i = 0; i < 16; i += 4) {\n                SIMD.Float32x4.store(result, i + offset, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(tm[i]), m0), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(tm[i + 1]), m1), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.splat(tm[i + 2]), m2), SIMD.Float32x4.mul(SIMD.Float32x4.splat(tm[i + 3]), m3)))));\n            }\n            return this;\n        };\n        SIMDMatrix.prototype.invertToRefSIMD = function (other) {\n            var src = this.m;\n            var dest = other.m;\n            // Load the 4 rows\n            var src0 = SIMD.Float32x4.load(src, 0);\n            var src1 = SIMD.Float32x4.load(src, 4);\n            var src2 = SIMD.Float32x4.load(src, 8);\n            var src3 = SIMD.Float32x4.load(src, 12);\n            // Transpose the source matrix.  Sort of.  Not a true transpose operation\n            var tmp1 = SIMD.Float32x4.shuffle(src0, src1, 0, 1, 4, 5);\n            var row1 = SIMD.Float32x4.shuffle(src2, src3, 0, 1, 4, 5);\n            var row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n            row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n            tmp1 = SIMD.Float32x4.shuffle(src0, src1, 2, 3, 6, 7);\n            var row3 = SIMD.Float32x4.shuffle(src2, src3, 2, 3, 6, 7);\n            var row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n            row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n            // This is a true transposition, but it will lead to an incorrect result\n            //tmp1 = shuffle(src0, src1, 0, 1, 4, 5);\n            //tmp2 = shuffle(src2, src3, 0, 1, 4, 5);\n            //row0  = shuffle(tmp1, tmp2, 0, 2, 4, 6);\n            //row1  = shuffle(tmp1, tmp2, 1, 3, 5, 7);\n            //tmp1 = shuffle(src0, src1, 2, 3, 6, 7);\n            //tmp2 = shuffle(src2, src3, 2, 3, 6, 7);\n            //row2  = shuffle(tmp1, tmp2, 0, 2, 4, 6);\n            //row3  = shuffle(tmp1, tmp2, 1, 3, 5, 7);\n            // ----\n            tmp1 = SIMD.Float32x4.mul(row2, row3);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            var minor0 = SIMD.Float32x4.mul(row1, tmp1);\n            var minor1 = SIMD.Float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n            minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n            minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1); // 0x4E = 01001110\n            // ----\n            tmp1 = SIMD.Float32x4.mul(row1, row2);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n            var minor3 = SIMD.Float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n            minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n            minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1); // 0x4E = 01001110\n            // ----\n            tmp1 = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3); // 0x4E = 01001110\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            row2 = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1); // 0x4E = 01001110\n            minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n            var minor2 = SIMD.Float32x4.mul(row0, tmp1);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n            minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n            minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1); // 0x4E = 01001110\n            // ----\n            tmp1 = SIMD.Float32x4.mul(row0, row1);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n            minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n            minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n            // ----\n            tmp1 = SIMD.Float32x4.mul(row0, row3);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n            minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n            minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n            // ----\n            tmp1 = SIMD.Float32x4.mul(row0, row2);\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2); // 0xB1 = 10110001\n            minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n            minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n            tmp1 = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1); // 0x4E = 01001110\n            minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n            minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n            // Compute determinant\n            var det = SIMD.Float32x4.mul(row0, minor0);\n            det = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det); // 0x4E = 01001110\n            det = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det); // 0xB1 = 10110001\n            tmp1 = SIMD.Float32x4.reciprocalApproximation(det);\n            det = SIMD.Float32x4.sub(SIMD.Float32x4.add(tmp1, tmp1), SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));\n            det = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);\n            // These shuffles aren't necessary if the faulty transposition is done\n            // up at the top of this function.\n            //minor0 =SIMD.Float32x4.swizzle(minor0, 2, 1, 0, 3);\n            //minor1 =SIMD.Float32x4.swizzle(minor1, 2, 1, 0, 3);\n            //minor2 =SIMD.Float32x4.swizzle(minor2, 2, 1, 0, 3);\n            //minor3 =SIMD.Float32x4.swizzle(minor3, 2, 1, 0, 3);\n            // Compute final values by multiplying with 1/det\n            SIMD.Float32x4.store(dest, 0, SIMD.Float32x4.mul(det, minor0));\n            SIMD.Float32x4.store(dest, 4, SIMD.Float32x4.mul(det, minor1));\n            SIMD.Float32x4.store(dest, 8, minor2 = SIMD.Float32x4.mul(det, minor2));\n            SIMD.Float32x4.store(dest, 12, SIMD.Float32x4.mul(det, minor3));\n            return this;\n        };\n        SIMDMatrix.LookAtLHToRefSIMD = function (eyeRef, targetRef, upRef, result) {\n            var out = result.m;\n            var center = SIMD.Float32x4(targetRef.x, targetRef.y, targetRef.z, 0.0);\n            var eye = SIMD.Float32x4(eyeRef.x, eyeRef.y, eyeRef.z, 0.0);\n            var up = SIMD.Float32x4(upRef.x, upRef.y, upRef.z, 0.0);\n            // cc.kmVec3Subtract(f, pCenter, pEye);\n            var f = SIMD.Float32x4.sub(center, eye);\n            // cc.kmVec3Normalize(f, f);    \n            var tmp = SIMD.Float32x4.mul(f, f);\n            tmp = SIMD.Float32x4.add(tmp, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.Float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            f = SIMD.Float32x4.mul(f, SIMD.Float32x4.reciprocalSqrtApproximation(tmp));\n            // cc.kmVec3Assign(up, pUp);\n            // cc.kmVec3Normalize(up, up);\n            tmp = SIMD.Float32x4.mul(up, up);\n            tmp = SIMD.Float32x4.add(tmp, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.Float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            up = SIMD.Float32x4.mul(up, SIMD.Float32x4.reciprocalSqrtApproximation(tmp));\n            // cc.kmVec3Cross(s, f, up);\n            var s = SIMD.Float32x4.sub(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f, 1, 2, 0, 3), SIMD.Float32x4.swizzle(up, 2, 0, 1, 3)), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(f, 2, 0, 1, 3), SIMD.Float32x4.swizzle(up, 1, 2, 0, 3)));\n            // cc.kmVec3Normalize(s, s);\n            tmp = SIMD.Float32x4.mul(s, s);\n            tmp = SIMD.Float32x4.add(tmp, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.Float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            s = SIMD.Float32x4.mul(s, SIMD.Float32x4.reciprocalSqrtApproximation(tmp));\n            // cc.kmVec3Cross(u, s, f);\n            var u = SIMD.Float32x4.sub(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s, 1, 2, 0, 3), SIMD.Float32x4.swizzle(f, 2, 0, 1, 3)), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(s, 2, 0, 1, 3), SIMD.Float32x4.swizzle(f, 1, 2, 0, 3)));\n            // cc.kmVec3Normalize(s, s);\n            tmp = SIMD.Float32x4.mul(s, s);\n            tmp = SIMD.Float32x4.add(tmp, SIMD.Float32x4.add(SIMD.Float32x4.swizzle(tmp, 1, 2, 0, 3), SIMD.Float32x4.swizzle(tmp, 2, 0, 1, 3)));\n            s = SIMD.Float32x4.mul(s, SIMD.Float32x4.reciprocalSqrtApproximation(tmp));\n            var zero = SIMD.Float32x4.splat(0.0);\n            s = SIMD.Float32x4.neg(s);\n            var tmp01 = SIMD.Float32x4.shuffle(s, u, 0, 1, 4, 5);\n            var tmp23 = SIMD.Float32x4.shuffle(f, zero, 0, 1, 4, 5);\n            var a0 = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n            var a1 = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n            var a2 = SIMD.Float32x4.shuffle(SIMD.Float32x4.shuffle(s, u, 2, 3, 6, 7), SIMD.Float32x4.shuffle(f, zero, 2, 3, 6, 7), 0, 2, 4, 6);\n            var a3 = SIMD.Float32x4(0.0, 0.0, 0.0, 1.0);\n            var b = SIMD.Float32x4(1.0, 0.0, 0.0, 0.0);\n            SIMD.Float32x4.store(out, 0, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 0, 0, 0, 0), a0), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 1, 1, 1, 1), a1), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 2, 2, 2, 2), a2), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 3, 3, 3, 3), a3)))));\n            b = SIMD.Float32x4(0.0, 1.0, 0.0, 0.0);\n            SIMD.Float32x4.store(out, 4, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 0, 0, 0, 0), a0), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 1, 1, 1, 1), a1), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 2, 2, 2, 2), a2), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 3, 3, 3, 3), a3)))));\n            b = SIMD.Float32x4(0.0, 0.0, 1.0, 0.0);\n            SIMD.Float32x4.store(out, 8, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 0, 0, 0, 0), a0), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 1, 1, 1, 1), a1), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 2, 2, 2, 2), a2), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 3, 3, 3, 3), a3)))));\n            b = SIMD.Float32x4.replaceLane(SIMD.Float32x4.neg(eye), 3, 1.0);\n            SIMD.Float32x4.store(out, 12, SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 0, 0, 0, 0), a0), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 1, 1, 1, 1), a1), SIMD.Float32x4.add(SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 2, 2, 2, 2), a2), SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b, 3, 3, 3, 3), a3)))));\n        };\n        return SIMDMatrix;\n    }());\n    var previousMultiplyToArray = BABYLON.Matrix.prototype.multiplyToArray;\n    var previousInvertToRef = BABYLON.Matrix.prototype.invertToRef;\n    var previousLookAtLHToRef = BABYLON.Matrix.LookAtLHToRef;\n    var previousTransformCoordinatesToRef = BABYLON.Vector3.TransformCoordinatesToRef;\n    var previousTransformCoordinatesFromFloatsToRef = BABYLON.Vector3.TransformCoordinatesFromFloatsToRef;\n    var SIMDHelper = (function () {\n        function SIMDHelper() {\n        }\n        Object.defineProperty(SIMDHelper, \"IsEnabled\", {\n            get: function () {\n                return SIMDHelper._isEnabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        SIMDHelper.DisableSIMD = function () {\n            // Replace functions\n            BABYLON.Matrix.prototype.multiplyToArray = previousMultiplyToArray;\n            BABYLON.Matrix.prototype.invertToRef = previousInvertToRef;\n            BABYLON.Matrix.LookAtLHToRef = previousLookAtLHToRef;\n            BABYLON.Vector3.TransformCoordinatesToRef = previousTransformCoordinatesToRef;\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef = previousTransformCoordinatesFromFloatsToRef;\n            SIMDHelper._isEnabled = false;\n        };\n        SIMDHelper.EnableSIMD = function () {\n            if (self.SIMD === undefined) {\n                return;\n            }\n            // check if polyfills needed\n            if (!self.Math.fround) {\n                self.Math.fround = (function (array) { return function (x) {\n                    return array[0] = x, array[0];\n                }; })(new Float32Array(1));\n            }\n            if (!self.Math.imul) {\n                self.Math.imul = function (a, b) {\n                    var ah = (a >>> 16) & 0xffff;\n                    var al = a & 0xffff;\n                    var bh = (b >>> 16) & 0xffff;\n                    var bl = b & 0xffff;\n                    // the shift by 0 fixes the sign on the high part\n                    // the final |0 converts the unsigned value into a signed value\n                    return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);\n                };\n            }\n            // Replace functions\n            BABYLON.Matrix.prototype.multiplyToArray = SIMDMatrix.prototype.multiplyToArraySIMD;\n            BABYLON.Matrix.prototype.invertToRef = SIMDMatrix.prototype.invertToRefSIMD;\n            BABYLON.Matrix.LookAtLHToRef = SIMDMatrix.LookAtLHToRefSIMD;\n            BABYLON.Vector3.TransformCoordinatesToRef = SIMDVector3.TransformCoordinatesToRefSIMD;\n            BABYLON.Vector3.TransformCoordinatesFromFloatsToRef = SIMDVector3.TransformCoordinatesFromFloatsToRefSIMD;\n            SIMDHelper._isEnabled = true;\n        };\n        return SIMDHelper;\n    }());\n    SIMDHelper._isEnabled = false;\n    BABYLON.SIMDHelper = SIMDHelper;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.math.SIMD.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var VRDistortionCorrectionPostProcess = (function (_super) {\n        __extends(VRDistortionCorrectionPostProcess, _super);\n        //ANY\n        function VRDistortionCorrectionPostProcess(name, camera, isRightEye, vrMetrics) {\n            var _this = _super.call(this, name, \"vrDistortionCorrection\", [\n                'LensCenter',\n                'Scale',\n                'ScaleIn',\n                'HmdWarpParam'\n            ], null, vrMetrics.postProcessScaleFactor, camera, BABYLON.Texture.BILINEAR_SAMPLINGMODE, null, null) || this;\n            _this._isRightEye = isRightEye;\n            _this._distortionFactors = vrMetrics.distortionK;\n            _this._postProcessScaleFactor = vrMetrics.postProcessScaleFactor;\n            _this._lensCenterOffset = vrMetrics.lensCenterOffset;\n            _this.onSizeChangedObservable.add(function () {\n                _this.aspectRatio = _this.width * .5 / _this.height;\n                _this._scaleIn = new BABYLON.Vector2(2, 2 / _this.aspectRatio);\n                _this._scaleFactor = new BABYLON.Vector2(.5 * (1 / _this._postProcessScaleFactor), .5 * (1 / _this._postProcessScaleFactor) * _this.aspectRatio);\n                _this._lensCenter = new BABYLON.Vector2(_this._isRightEye ? 0.5 - _this._lensCenterOffset * 0.5 : 0.5 + _this._lensCenterOffset * 0.5, 0.5);\n            });\n            _this.onApplyObservable.add(function (effect) {\n                effect.setFloat2(\"LensCenter\", _this._lensCenter.x, _this._lensCenter.y);\n                effect.setFloat2(\"Scale\", _this._scaleFactor.x, _this._scaleFactor.y);\n                effect.setFloat2(\"ScaleIn\", _this._scaleIn.x, _this._scaleIn.y);\n                effect.setFloat4(\"HmdWarpParam\", _this._distortionFactors[0], _this._distortionFactors[1], _this._distortionFactors[2], _this._distortionFactors[3]);\n            });\n            return _this;\n        }\n        return VRDistortionCorrectionPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.VRDistortionCorrectionPostProcess = VRDistortionCorrectionPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.vrDistortionCorrectionPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var AnaglyphPostProcess = (function (_super) {\n        __extends(AnaglyphPostProcess, _super);\n        function AnaglyphPostProcess(name, options, rigCameras, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"anaglyph\", null, [\"leftSampler\"], options, rigCameras[1], samplingMode, engine, reusable) || this;\n            _this._passedProcess = rigCameras[0]._rigPostProcess;\n            _this.onApplyObservable.add(function (effect) {\n                effect.setTextureFromPostProcess(\"leftSampler\", _this._passedProcess);\n            });\n            return _this;\n        }\n        return AnaglyphPostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.AnaglyphPostProcess = AnaglyphPostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.anaglyphPostProcess.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var StereoscopicInterlacePostProcess = (function (_super) {\n        __extends(StereoscopicInterlacePostProcess, _super);\n        function StereoscopicInterlacePostProcess(name, rigCameras, isStereoscopicHoriz, samplingMode, engine, reusable) {\n            var _this = _super.call(this, name, \"stereoscopicInterlace\", ['stepSize'], ['camASampler'], 1, rigCameras[1], samplingMode, engine, reusable, isStereoscopicHoriz ? \"#define IS_STEREOSCOPIC_HORIZ 1\" : undefined) || this;\n            _this._passedProcess = rigCameras[0]._rigPostProcess;\n            _this._stepSize = new BABYLON.Vector2(1 / _this.width, 1 / _this.height);\n            _this.onSizeChangedObservable.add(function () {\n                _this._stepSize = new BABYLON.Vector2(1 / _this.width, 1 / _this.height);\n            });\n            _this.onApplyObservable.add(function (effect) {\n                effect.setTextureFromPostProcess(\"camASampler\", _this._passedProcess);\n                effect.setFloat2(\"stepSize\", _this._stepSize.x, _this._stepSize.y);\n            });\n            return _this;\n        }\n        return StereoscopicInterlacePostProcess;\n    }(BABYLON.PostProcess));\n    BABYLON.StereoscopicInterlacePostProcess = StereoscopicInterlacePostProcess;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.stereoscopicInterlacePostProcess.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraDeviceOrientationInput = (function () {\n        function FreeCameraDeviceOrientationInput() {\n            var _this = this;\n            this._screenOrientationAngle = 0;\n            this._screenQuaternion = new BABYLON.Quaternion();\n            this._alpha = 0;\n            this._beta = 0;\n            this._gamma = 0;\n            this._orientationChanged = function () {\n                _this._screenOrientationAngle = (window.orientation !== undefined ? +window.orientation : (window.screen.orientation && window.screen.orientation['angle'] ? window.screen.orientation.angle : 0));\n                _this._screenOrientationAngle = -BABYLON.Tools.ToRadians(_this._screenOrientationAngle / 2);\n                _this._screenQuaternion.copyFromFloats(0, Math.sin(_this._screenOrientationAngle), 0, Math.cos(_this._screenOrientationAngle));\n            };\n            this._deviceOrientation = function (evt) {\n                _this._alpha = evt.alpha;\n                _this._beta = evt.beta;\n                _this._gamma = evt.gamma;\n            };\n            this._constantTranform = new BABYLON.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));\n            this._orientationChanged();\n        }\n        Object.defineProperty(FreeCameraDeviceOrientationInput.prototype, \"camera\", {\n            get: function () {\n                return this._camera;\n            },\n            set: function (camera) {\n                this._camera = camera;\n                if (!this._camera.rotationQuaternion)\n                    this._camera.rotationQuaternion = new BABYLON.Quaternion();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        FreeCameraDeviceOrientationInput.prototype.attachControl = function (element, noPreventDefault) {\n            window.addEventListener(\"orientationchange\", this._orientationChanged);\n            window.addEventListener(\"deviceorientation\", this._deviceOrientation);\n            //In certain cases, the attach control is called AFTER orientation was changed,\n            //So this is needed.\n            this._orientationChanged();\n        };\n        FreeCameraDeviceOrientationInput.prototype.detachControl = function (element) {\n            window.removeEventListener(\"orientationchange\", this._orientationChanged);\n            window.removeEventListener(\"deviceorientation\", this._deviceOrientation);\n        };\n        FreeCameraDeviceOrientationInput.prototype.checkInputs = function () {\n            //if no device orientation provided, don't update the rotation.\n            //Only testing against alpha under the assumption thatnorientation will never be so exact when set.\n            if (!this._alpha)\n                return;\n            BABYLON.Quaternion.RotationYawPitchRollToRef(BABYLON.Tools.ToRadians(this._alpha), BABYLON.Tools.ToRadians(this._beta), -BABYLON.Tools.ToRadians(this._gamma), this.camera.rotationQuaternion);\n            this._camera.rotationQuaternion.multiplyInPlace(this._screenQuaternion);\n            this._camera.rotationQuaternion.multiplyInPlace(this._constantTranform);\n            //Mirror on XY Plane\n            this._camera.rotationQuaternion.z *= -1;\n            this._camera.rotationQuaternion.w *= -1;\n        };\n        FreeCameraDeviceOrientationInput.prototype.getTypeName = function () {\n            return \"FreeCameraDeviceOrientationInput\";\n        };\n        FreeCameraDeviceOrientationInput.prototype.getSimpleName = function () {\n            return \"deviceOrientation\";\n        };\n        return FreeCameraDeviceOrientationInput;\n    }());\n    BABYLON.FreeCameraDeviceOrientationInput = FreeCameraDeviceOrientationInput;\n    BABYLON.CameraInputTypes[\"FreeCameraDeviceOrientationInput\"] = FreeCameraDeviceOrientationInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraDeviceOrientationInput.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var ArcRotateCameraVRDeviceOrientationInput = (function () {\n        function ArcRotateCameraVRDeviceOrientationInput() {\n            this.alphaCorrection = 1;\n            this.betaCorrection = 1;\n            this.gammaCorrection = 1;\n            this._alpha = 0;\n            this._beta = 0;\n            this._gamma = 0;\n            this._dirty = false;\n            this._deviceOrientationHandler = this._onOrientationEvent.bind(this);\n        }\n        ArcRotateCameraVRDeviceOrientationInput.prototype.attachControl = function (element, noPreventDefault) {\n            this.camera.attachControl(element, noPreventDefault);\n            window.addEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n        };\n        ArcRotateCameraVRDeviceOrientationInput.prototype._onOrientationEvent = function (evt) {\n            var camera = this.camera;\n            this._alpha = +evt.alpha | 0;\n            this._beta = +evt.beta | 0;\n            this._gamma = +evt.gamma | 0;\n            this._dirty = true;\n        };\n        ArcRotateCameraVRDeviceOrientationInput.prototype.checkInputs = function () {\n            if (this._dirty) {\n                this._dirty = false;\n                if (this._gamma < 0) {\n                    this._gamma = 180 + this._gamma;\n                }\n                this.camera.alpha = (-this._alpha / 180.0 * Math.PI) % Math.PI * 2;\n                this.camera.beta = (this._gamma / 180.0 * Math.PI);\n            }\n        };\n        ArcRotateCameraVRDeviceOrientationInput.prototype.detachControl = function (element) {\n            window.removeEventListener(\"deviceorientation\", this._deviceOrientationHandler);\n        };\n        ArcRotateCameraVRDeviceOrientationInput.prototype.getTypeName = function () {\n            return \"ArcRotateCameraVRDeviceOrientationInput\";\n        };\n        ArcRotateCameraVRDeviceOrientationInput.prototype.getSimpleName = function () {\n            return \"VRDeviceOrientation\";\n        };\n        return ArcRotateCameraVRDeviceOrientationInput;\n    }());\n    BABYLON.ArcRotateCameraVRDeviceOrientationInput = ArcRotateCameraVRDeviceOrientationInput;\n    BABYLON.CameraInputTypes[\"ArcRotateCameraVRDeviceOrientationInput\"] = ArcRotateCameraVRDeviceOrientationInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.arcRotateCameraVRDeviceOrientationInput.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var VRCameraMetrics = (function () {\n        function VRCameraMetrics() {\n            this.compensateDistortion = true;\n        }\n        Object.defineProperty(VRCameraMetrics.prototype, \"aspectRatio\", {\n            get: function () {\n                return this.hResolution / (2 * this.vResolution);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VRCameraMetrics.prototype, \"aspectRatioFov\", {\n            get: function () {\n                return (2 * Math.atan((this.postProcessScaleFactor * this.vScreenSize) / (2 * this.eyeToScreenDistance)));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VRCameraMetrics.prototype, \"leftHMatrix\", {\n            get: function () {\n                var meters = (this.hScreenSize / 4) - (this.lensSeparationDistance / 2);\n                var h = (4 * meters) / this.hScreenSize;\n                return BABYLON.Matrix.Translation(h, 0, 0);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VRCameraMetrics.prototype, \"rightHMatrix\", {\n            get: function () {\n                var meters = (this.hScreenSize / 4) - (this.lensSeparationDistance / 2);\n                var h = (4 * meters) / this.hScreenSize;\n                return BABYLON.Matrix.Translation(-h, 0, 0);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VRCameraMetrics.prototype, \"leftPreViewMatrix\", {\n            get: function () {\n                return BABYLON.Matrix.Translation(0.5 * this.interpupillaryDistance, 0, 0);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(VRCameraMetrics.prototype, \"rightPreViewMatrix\", {\n            get: function () {\n                return BABYLON.Matrix.Translation(-0.5 * this.interpupillaryDistance, 0, 0);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        VRCameraMetrics.GetDefault = function () {\n            var result = new VRCameraMetrics();\n            result.hResolution = 1280;\n            result.vResolution = 800;\n            result.hScreenSize = 0.149759993;\n            result.vScreenSize = 0.0935999975;\n            result.vScreenCenter = 0.0467999987;\n            result.eyeToScreenDistance = 0.0410000011;\n            result.lensSeparationDistance = 0.0635000020;\n            result.interpupillaryDistance = 0.0640000030;\n            result.distortionK = [1.0, 0.219999999, 0.239999995, 0.0];\n            result.chromaAbCorrection = [0.995999992, -0.00400000019, 1.01400006, 0.0];\n            result.postProcessScaleFactor = 1.714605507808412;\n            result.lensCenterOffset = 0.151976421;\n            return result;\n        };\n        return VRCameraMetrics;\n    }());\n    BABYLON.VRCameraMetrics = VRCameraMetrics;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.vrCameraMetrics.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var WebVRFreeCamera = (function (_super) {\n        __extends(WebVRFreeCamera, _super);\n        function WebVRFreeCamera(name, position, scene, webVROptions) {\n            if (webVROptions === void 0) { webVROptions = {}; }\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.webVROptions = webVROptions;\n            _this._vrDevice = null;\n            _this.rawPose = null;\n            _this._vrEnabled = false;\n            _this._specsVersion = 1.1;\n            _this._attached = false;\n            _this._positionOffset = BABYLON.Vector3.Zero();\n            _this._descendants = [];\n            _this.devicePosition = BABYLON.Vector3.Zero();\n            _this.deviceScaleFactor = 1;\n            _this.controllers = [];\n            _this.nonVRControllers = [];\n            _this.rigParenting = true; // should the rig cameras be used as parent instead of this camera.\n            //legacy support - the compensation boolean was removed.\n            if (arguments.length === 5) {\n                _this.webVROptions = arguments[4];\n            }\n            // default webVR options\n            if (_this.webVROptions.trackPosition == undefined) {\n                _this.webVROptions.trackPosition = true;\n            }\n            if (_this.webVROptions.controllerMeshes == undefined) {\n                _this.webVROptions.controllerMeshes = true;\n            }\n            if (_this.webVROptions.defaultLightningOnControllers == undefined) {\n                _this.webVROptions.defaultLightningOnControllers = true;\n            }\n            _this.rotationQuaternion = new BABYLON.Quaternion();\n            _this.deviceRotationQuaternion = new BABYLON.Quaternion();\n            if (_this.webVROptions && _this.webVROptions.positionScale) {\n                _this.deviceScaleFactor = _this.webVROptions.positionScale;\n            }\n            //enable VR\n            _this.getEngine().initWebVR();\n            //check specs version\n            if (!window.VRFrameData) {\n                _this._specsVersion = 1.0;\n                _this._frameData = {};\n            }\n            else {\n                _this._frameData = new VRFrameData();\n            }\n            _this.getEngine().getVRDevice(_this.webVROptions.displayName, function (device) {\n                if (!device) {\n                    return;\n                }\n                _this._vrEnabled = true;\n                _this._vrDevice = device;\n                //reset the rig parameters.\n                _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_WEBVR, { parentCamera: _this, vrDisplay: _this._vrDevice, frameData: _this._frameData, specs: _this._specsVersion });\n                if (_this._attached) {\n                    _this.getEngine().enableVR(_this._vrDevice);\n                }\n            });\n            // try to attach the controllers, if found.\n            _this.initControllers();\n            /**\n             * The idea behind the following lines:\n             * objects that have the camera as parent should actually have the rig cameras as a parent.\n             * BUT, each of those cameras has a different view matrix, which means that if we set the parent to the first rig camera,\n             * the second will not show it correctly.\n             *\n             * To solve this - each object that has the camera as parent will be added to a protected array.\n             * When the rig camera renders, it will take this array and set all of those to be its children.\n             * This way, the right camera will be used as a parent, and the mesh will be rendered correctly.\n             * Amazing!\n             */\n            scene.onBeforeCameraRenderObservable.add(function (camera) {\n                if (camera.parent === _this && _this.rigParenting) {\n                    _this._descendants = _this.getDescendants(true, function (n) {\n                        // don't take the cameras or the controllers!\n                        var isController = _this.controllers.some(function (controller) { return controller._mesh === n; });\n                        var isRigCamera = _this._rigCameras.indexOf(n) !== -1;\n                        return !isController && !isRigCamera;\n                    });\n                    _this._descendants.forEach(function (node) {\n                        node.parent = camera;\n                    });\n                }\n            });\n            scene.onAfterCameraRenderObservable.add(function (camera) {\n                if (camera.parent === _this && _this.rigParenting) {\n                    _this._descendants.forEach(function (node) {\n                        node.parent = _this;\n                    });\n                }\n            });\n            return _this;\n        }\n        Object.defineProperty(WebVRFreeCamera.prototype, \"onControllersAttached\", {\n            set: function (callback) {\n                this._onControllersAttached = callback;\n                // after setting - if the controllers are already set, execute the callback.\n                if (this.controllers.length >= 2) {\n                    callback(this.controllers);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(WebVRFreeCamera.prototype, \"onNonVRControllerAttached\", {\n            set: function (callback) {\n                this._onNonVRControllerAttached = callback;\n                this.nonVRControllers.forEach(function (controller) {\n                    callback(controller);\n                });\n            },\n            enumerable: true,\n            configurable: true\n        });\n        WebVRFreeCamera.prototype.getControllerByName = function (name) {\n            for (var _i = 0, _a = this.controllers; _i < _a.length; _i++) {\n                var gp = _a[_i];\n                if (gp.hand === name) {\n                    return gp;\n                }\n            }\n            return undefined;\n        };\n        Object.defineProperty(WebVRFreeCamera.prototype, \"leftController\", {\n            get: function () {\n                if (!this._leftController) {\n                    this._leftController = this.getControllerByName(\"left\");\n                }\n                return this._leftController;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        Object.defineProperty(WebVRFreeCamera.prototype, \"rightController\", {\n            get: function () {\n                if (!this._rightController) {\n                    this._rightController = this.getControllerByName(\"right\");\n                }\n                return this._rightController;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ;\n        WebVRFreeCamera.prototype.getForwardRay = function (length) {\n            if (length === void 0) { length = 100; }\n            if (this.leftCamera) {\n                return _super.prototype.getForwardRay.call(this, length, this.leftCamera.getWorldMatrix(), this.position.add(this.devicePosition)); // Need the actual rendered camera\n            }\n            else {\n                return _super.prototype.getForwardRay.call(this, length);\n            }\n        };\n        WebVRFreeCamera.prototype._checkInputs = function () {\n            if (this._vrEnabled) {\n                if (this._specsVersion === 1.1) {\n                    this._vrDevice.getFrameData(this._frameData);\n                }\n                else {\n                    //backwards comp\n                    var pose = this._vrDevice.getPose();\n                    this._frameData.pose = pose;\n                    // calculate view and projection matrix\n                }\n                this.updateFromDevice(this._frameData.pose);\n            }\n            _super.prototype._checkInputs.call(this);\n        };\n        WebVRFreeCamera.prototype.updateFromDevice = function (poseData) {\n            if (poseData && poseData.orientation) {\n                this.rawPose = poseData;\n                this.deviceRotationQuaternion.copyFromFloats(this.rawPose.orientation[0], this.rawPose.orientation[1], -this.rawPose.orientation[2], -this.rawPose.orientation[3]);\n                if (this.getScene().useRightHandedSystem) {\n                    this.deviceRotationQuaternion.z *= -1;\n                    this.deviceRotationQuaternion.w *= -1;\n                }\n                if (this.webVROptions.trackPosition && this.rawPose.position) {\n                    this.devicePosition.copyFromFloats(this.rawPose.position[0], this.rawPose.position[1], -this.rawPose.position[2]);\n                    if (this.getScene().useRightHandedSystem) {\n                        this.devicePosition.z *= -1;\n                    }\n                }\n            }\n        };\n        /**\n         * WebVR's attach control will start broadcasting frames to the device.\n         * Note that in certain browsers (chrome for example) this function must be called\n         * within a user-interaction callback. Example:\n         * <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>\n         *\n         * @param {HTMLElement} element\n         * @param {boolean} [noPreventDefault]\n         *\n         * @memberOf WebVRFreeCamera\n         */\n        WebVRFreeCamera.prototype.attachControl = function (element, noPreventDefault) {\n            _super.prototype.attachControl.call(this, element, noPreventDefault);\n            this._attached = true;\n            noPreventDefault = BABYLON.Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\n            if (this._vrEnabled) {\n                this.getEngine().enableVR(this._vrDevice);\n            }\n        };\n        WebVRFreeCamera.prototype.detachControl = function (element) {\n            _super.prototype.detachControl.call(this, element);\n            this._vrEnabled = false;\n            this._attached = false;\n            this.getEngine().disableVR();\n        };\n        WebVRFreeCamera.prototype.getClassName = function () {\n            return \"WebVRFreeCamera\";\n        };\n        WebVRFreeCamera.prototype.resetToCurrentRotation = function () {\n            //uses the vrDisplay's \"resetPose()\".\n            //pitch and roll won't be affected.\n            this._vrDevice.resetPose();\n        };\n        WebVRFreeCamera.prototype._updateRigCameras = function () {\n            var camLeft = this._rigCameras[0];\n            var camRight = this._rigCameras[1];\n            camLeft.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);\n            camRight.rotationQuaternion.copyFrom(this.deviceRotationQuaternion);\n            camLeft.position.copyFrom(this.devicePosition);\n            camRight.position.copyFrom(this.devicePosition);\n        };\n        /**\n         * This function is called by the two RIG cameras.\n         * 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)\n         */\n        WebVRFreeCamera.prototype._getWebVRViewMatrix = function () {\n            var _this = this;\n            //WebVR 1.0\n            if (this._cameraRigParams[\"specs\"] === 1.0) {\n                this._updateCameraRotationMatrix();\n                BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n                // Computing target and final matrix\n                this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n                if (this.getScene().useRightHandedSystem) {\n                    BABYLON.Matrix.LookAtRHToRef(this.position, this._currentTarget, this.upVector, this._webvrViewMatrix);\n                }\n                else {\n                    BABYLON.Matrix.LookAtLHToRef(this.position, this._currentTarget, this.upVector, this._webvrViewMatrix);\n                }\n                //now move the eye in the right direction\n                var eyeParams = this._cameraRigParams[\"eyeParameters\"];\n                var offset = eyeParams.offset;\n                // it will actually always be 0, but just in case\n                if (this.getScene().useRightHandedSystem) {\n                    offset[2] *= -1;\n                }\n                BABYLON.Matrix.TranslationToRef(-offset[0], offset[1], -offset[2], BABYLON.Tmp.Matrix[0]);\n                this._webvrViewMatrix.multiplyToRef(BABYLON.Tmp.Matrix[0], this._webvrViewMatrix);\n            }\n            else {\n                var viewArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftViewMatrix : this._cameraRigParams[\"frameData\"].rightViewMatrix;\n                BABYLON.Matrix.FromArrayToRef(viewArray, 0, this._webvrViewMatrix);\n                if (!this.getScene().useRightHandedSystem) {\n                    [2, 6, 8, 9, 14].forEach(function (num) {\n                        _this._webvrViewMatrix.m[num] *= -1;\n                    });\n                }\n                // update the camera rotation matrix\n                this._webvrViewMatrix.getRotationMatrixToRef(this._cameraRotationMatrix);\n                BABYLON.Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\n                // Computing target and final matrix\n                this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\n            }\n            var parentCamera = this._cameraRigParams[\"parentCamera\"];\n            // should the view matrix be updated with scale and position offset?\n            if (parentCamera.deviceScaleFactor !== 1) {\n                this._webvrViewMatrix.invert();\n                // scale the position, if set\n                if (parentCamera.deviceScaleFactor) {\n                    this._webvrViewMatrix.m[12] *= parentCamera.deviceScaleFactor;\n                    this._webvrViewMatrix.m[13] *= parentCamera.deviceScaleFactor;\n                    this._webvrViewMatrix.m[14] *= parentCamera.deviceScaleFactor;\n                }\n                this._webvrViewMatrix.invert();\n            }\n            return this._webvrViewMatrix;\n        };\n        WebVRFreeCamera.prototype._getWebVRProjectionMatrix = function () {\n            var _this = this;\n            if (this._cameraRigParams[\"specs\"] === 1.0) {\n                var eyeParams = this._cameraRigParams[\"eyeParameters\"];\n                // deprecated!!\n                BABYLON.Matrix.PerspectiveFovWebVRToRef(eyeParams.fieldOfView, 0.1, 1000, this._projectionMatrix, this.getScene().useRightHandedSystem);\n            }\n            else {\n                var projectionArray = this._cameraRigParams[\"left\"] ? this._cameraRigParams[\"frameData\"].leftProjectionMatrix : this._cameraRigParams[\"frameData\"].rightProjectionMatrix;\n                BABYLON.Matrix.FromArrayToRef(projectionArray, 0, this._projectionMatrix);\n                //babylon compatible matrix\n                if (!this.getScene().useRightHandedSystem) {\n                    [8, 9, 10, 11].forEach(function (num) {\n                        _this._projectionMatrix.m[num] *= -1;\n                    });\n                }\n            }\n            return this._projectionMatrix;\n        };\n        WebVRFreeCamera.prototype.initControllers = function () {\n            var _this = this;\n            this.controllers = [];\n            new BABYLON.Gamepads(function (gp) {\n                if (gp.type === BABYLON.Gamepad.POSE_ENABLED) {\n                    var webVrController = gp;\n                    if (_this.webVROptions.controllerMeshes) {\n                        webVrController.initControllerMesh(_this.getScene(), function (loadedMesh) {\n                            if (_this.webVROptions.defaultLightningOnControllers) {\n                                if (!_this._lightOnControllers) {\n                                    _this._lightOnControllers = new BABYLON.HemisphericLight(\"vrControllersLight\", new BABYLON.Vector3(0, 1, 0), _this.getScene());\n                                }\n                                loadedMesh.getChildren().forEach(function (mesh) {\n                                    _this._lightOnControllers.includedOnlyMeshes.push(mesh);\n                                });\n                            }\n                        });\n                    }\n                    webVrController.attachToPoseControlledCamera(_this);\n                    // since this is async - sanity check. Is the controller already stored?\n                    if (_this.controllers.indexOf(webVrController) === -1) {\n                        //add to the controllers array\n                        _this.controllers.push(webVrController);\n                        //did we find enough controllers? Great! let the developer know.\n                        if (_this._onControllersAttached && _this.controllers.length >= 2) {\n                            // Forced to add some control code for Vive as it doesn't always fill properly the \"hand\" property\n                            // Sometimes, both controllers are set correctly (left and right), sometimes none, sometimes only one of them...\n                            // So we're overriding setting left & right manually to be sure\n                            var firstViveWandDetected = false;\n                            for (var i = 0; i < _this.controllers.length; i++) {\n                                if (_this.controllers[i].controllerType === BABYLON.PoseEnabledControllerType.VIVE) {\n                                    if (!firstViveWandDetected) {\n                                        firstViveWandDetected = true;\n                                        _this.controllers[i].hand = \"left\";\n                                    }\n                                    else {\n                                        _this.controllers[i].hand = \"right\";\n                                    }\n                                }\n                            }\n                            _this._onControllersAttached(_this.controllers);\n                        }\n                    }\n                }\n                else {\n                    _this.nonVRControllers.push(gp);\n                    if (_this._onNonVRControllerAttached) {\n                        _this._onNonVRControllerAttached(gp);\n                    }\n                }\n            });\n        };\n        return WebVRFreeCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.WebVRFreeCamera = WebVRFreeCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.webVRCamera.js.map\n\n/// <reference path=\"babylon.freeCamera.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    // We're mainly based on the logic defined into the FreeCamera code\n    var DeviceOrientationCamera = (function (_super) {\n        __extends(DeviceOrientationCamera, _super);\n        function DeviceOrientationCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this._quaternionCache = new BABYLON.Quaternion();\n            _this.inputs.addDeviceOrientation();\n            return _this;\n        }\n        DeviceOrientationCamera.prototype.getClassName = function () {\n            return \"DeviceOrientationCamera\";\n        };\n        DeviceOrientationCamera.prototype._checkInputs = function () {\n            _super.prototype._checkInputs.call(this);\n            this._quaternionCache.copyFrom(this.rotationQuaternion);\n            if (this._initialQuaternion) {\n                this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n            }\n        };\n        DeviceOrientationCamera.prototype.resetToCurrentRotation = function (axis) {\n            var _this = this;\n            if (axis === void 0) { axis = BABYLON.Axis.Y; }\n            //can only work if this camera has a rotation quaternion already.\n            if (!this.rotationQuaternion)\n                return;\n            if (!this._initialQuaternion) {\n                this._initialQuaternion = new BABYLON.Quaternion();\n            }\n            this._initialQuaternion.copyFrom(this._quaternionCache || this.rotationQuaternion);\n            ['x', 'y', 'z'].forEach(function (axisName) {\n                if (!axis[axisName]) {\n                    _this._initialQuaternion[axisName] = 0;\n                }\n                else {\n                    _this._initialQuaternion[axisName] *= -1;\n                }\n            });\n            this._initialQuaternion.normalize();\n            //force rotation update\n            this._initialQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);\n        };\n        return DeviceOrientationCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.DeviceOrientationCamera = DeviceOrientationCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.deviceOrientationCamera.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var VRDeviceOrientationFreeCamera = (function (_super) {\n        __extends(VRDeviceOrientationFreeCamera, _super);\n        function VRDeviceOrientationFreeCamera(name, position, scene, compensateDistortion, vrCameraMetrics) {\n            if (compensateDistortion === void 0) { compensateDistortion = true; }\n            if (vrCameraMetrics === void 0) { vrCameraMetrics = BABYLON.VRCameraMetrics.GetDefault(); }\n            var _this = _super.call(this, name, position, scene) || this;\n            vrCameraMetrics.compensateDistortion = compensateDistortion;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\n            return _this;\n        }\n        VRDeviceOrientationFreeCamera.prototype.getClassName = function () {\n            return \"VRDeviceOrientationFreeCamera\";\n        };\n        return VRDeviceOrientationFreeCamera;\n    }(BABYLON.DeviceOrientationCamera));\n    BABYLON.VRDeviceOrientationFreeCamera = VRDeviceOrientationFreeCamera;\n    var VRDeviceOrientationGamepadCamera = (function (_super) {\n        __extends(VRDeviceOrientationGamepadCamera, _super);\n        function VRDeviceOrientationGamepadCamera(name, position, scene, compensateDistortion, vrCameraMetrics) {\n            if (compensateDistortion === void 0) { compensateDistortion = true; }\n            if (vrCameraMetrics === void 0) { vrCameraMetrics = BABYLON.VRCameraMetrics.GetDefault(); }\n            var _this = _super.call(this, name, position, scene, compensateDistortion, vrCameraMetrics) || this;\n            _this.inputs.addGamepad();\n            return _this;\n        }\n        VRDeviceOrientationGamepadCamera.prototype.getClassName = function () {\n            return \"VRDeviceOrientationGamepadCamera\";\n        };\n        return VRDeviceOrientationGamepadCamera;\n    }(VRDeviceOrientationFreeCamera));\n    BABYLON.VRDeviceOrientationGamepadCamera = VRDeviceOrientationGamepadCamera;\n    var VRDeviceOrientationArcRotateCamera = (function (_super) {\n        __extends(VRDeviceOrientationArcRotateCamera, _super);\n        function VRDeviceOrientationArcRotateCamera(name, alpha, beta, radius, target, scene, compensateDistortion, vrCameraMetrics) {\n            if (compensateDistortion === void 0) { compensateDistortion = true; }\n            if (vrCameraMetrics === void 0) { vrCameraMetrics = BABYLON.VRCameraMetrics.GetDefault(); }\n            var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;\n            vrCameraMetrics.compensateDistortion = compensateDistortion;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_VR, { vrCameraMetrics: vrCameraMetrics });\n            _this.inputs.addVRDeviceOrientation();\n            return _this;\n        }\n        VRDeviceOrientationArcRotateCamera.prototype.getClassName = function () {\n            return \"VRDeviceOrientationArcRotateCamera\";\n        };\n        return VRDeviceOrientationArcRotateCamera;\n    }(BABYLON.ArcRotateCamera));\n    BABYLON.VRDeviceOrientationArcRotateCamera = VRDeviceOrientationArcRotateCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.vrDeviceOrientationCamera.js.map\n\n/// <reference path=\"babylon.freeCamera.ts\" />\n/// <reference path=\"babylon.arcRotateCamera.ts\" />\n/// <reference path=\"babylon.gamepadCamera.ts\" />\n/// <reference path=\"babylon.universalCamera.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    var AnaglyphFreeCamera = (function (_super) {\n        __extends(AnaglyphFreeCamera, _super);\n        function AnaglyphFreeCamera(name, position, interaxialDistance, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        AnaglyphFreeCamera.prototype.getClassName = function () {\n            return \"AnaglyphFreeCamera\";\n        };\n        return AnaglyphFreeCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.AnaglyphFreeCamera = AnaglyphFreeCamera;\n    var AnaglyphArcRotateCamera = (function (_super) {\n        __extends(AnaglyphArcRotateCamera, _super);\n        function AnaglyphArcRotateCamera(name, alpha, beta, radius, target, interaxialDistance, scene) {\n            var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        AnaglyphArcRotateCamera.prototype.getClassName = function () {\n            return \"AnaglyphArcRotateCamera\";\n        };\n        return AnaglyphArcRotateCamera;\n    }(BABYLON.ArcRotateCamera));\n    BABYLON.AnaglyphArcRotateCamera = AnaglyphArcRotateCamera;\n    var AnaglyphGamepadCamera = (function (_super) {\n        __extends(AnaglyphGamepadCamera, _super);\n        function AnaglyphGamepadCamera(name, position, interaxialDistance, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        AnaglyphGamepadCamera.prototype.getClassName = function () {\n            return \"AnaglyphGamepadCamera\";\n        };\n        return AnaglyphGamepadCamera;\n    }(BABYLON.GamepadCamera));\n    BABYLON.AnaglyphGamepadCamera = AnaglyphGamepadCamera;\n    var AnaglyphUniversalCamera = (function (_super) {\n        __extends(AnaglyphUniversalCamera, _super);\n        function AnaglyphUniversalCamera(name, position, interaxialDistance, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.setCameraRigMode(BABYLON.Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        AnaglyphUniversalCamera.prototype.getClassName = function () {\n            return \"AnaglyphUniversalCamera\";\n        };\n        return AnaglyphUniversalCamera;\n    }(BABYLON.UniversalCamera));\n    BABYLON.AnaglyphUniversalCamera = AnaglyphUniversalCamera;\n    var StereoscopicFreeCamera = (function (_super) {\n        __extends(StereoscopicFreeCamera, _super);\n        function StereoscopicFreeCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n            _this.setCameraRigMode(isStereoscopicSideBySide ? BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        StereoscopicFreeCamera.prototype.getClassName = function () {\n            return \"StereoscopicFreeCamera\";\n        };\n        return StereoscopicFreeCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.StereoscopicFreeCamera = StereoscopicFreeCamera;\n    var StereoscopicArcRotateCamera = (function (_super) {\n        __extends(StereoscopicArcRotateCamera, _super);\n        function StereoscopicArcRotateCamera(name, alpha, beta, radius, target, interaxialDistance, isStereoscopicSideBySide, scene) {\n            var _this = _super.call(this, name, alpha, beta, radius, target, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n            _this.setCameraRigMode(isStereoscopicSideBySide ? BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        StereoscopicArcRotateCamera.prototype.getClassName = function () {\n            return \"StereoscopicArcRotateCamera\";\n        };\n        return StereoscopicArcRotateCamera;\n    }(BABYLON.ArcRotateCamera));\n    BABYLON.StereoscopicArcRotateCamera = StereoscopicArcRotateCamera;\n    var StereoscopicGamepadCamera = (function (_super) {\n        __extends(StereoscopicGamepadCamera, _super);\n        function StereoscopicGamepadCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n            _this.setCameraRigMode(isStereoscopicSideBySide ? BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        StereoscopicGamepadCamera.prototype.getClassName = function () {\n            return \"StereoscopicGamepadCamera\";\n        };\n        return StereoscopicGamepadCamera;\n    }(BABYLON.GamepadCamera));\n    BABYLON.StereoscopicGamepadCamera = StereoscopicGamepadCamera;\n    var StereoscopicUniversalCamera = (function (_super) {\n        __extends(StereoscopicUniversalCamera, _super);\n        function StereoscopicUniversalCamera(name, position, interaxialDistance, isStereoscopicSideBySide, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.interaxialDistance = interaxialDistance;\n            _this.isStereoscopicSideBySide = isStereoscopicSideBySide;\n            _this.setCameraRigMode(isStereoscopicSideBySide ? BABYLON.Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL : BABYLON.Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER, { interaxialDistance: interaxialDistance });\n            return _this;\n        }\n        StereoscopicUniversalCamera.prototype.getClassName = function () {\n            return \"StereoscopicUniversalCamera\";\n        };\n        return StereoscopicUniversalCamera;\n    }(BABYLON.UniversalCamera));\n    BABYLON.StereoscopicUniversalCamera = StereoscopicUniversalCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.stereoscopicCameras.js.map\n\n// Mainly based on these 2 articles : \n// Creating an universal virtual touch joystick working for all Touch models thanks to Hand.JS : http://blogs.msdn.com/b/davrous/archive/2013/02/22/creating-an-universal-virtual-touch-joystick-working-for-all-touch-models-thanks-to-hand-js.aspx\n// & on Seb Lee-Delisle original work: http://seb.ly/2011/04/multi-touch-game-controller-in-javascripthtml5-for-ipad/ \nvar BABYLON;\n(function (BABYLON) {\n    var JoystickAxis;\n    (function (JoystickAxis) {\n        JoystickAxis[JoystickAxis[\"X\"] = 0] = \"X\";\n        JoystickAxis[JoystickAxis[\"Y\"] = 1] = \"Y\";\n        JoystickAxis[JoystickAxis[\"Z\"] = 2] = \"Z\";\n    })(JoystickAxis = BABYLON.JoystickAxis || (BABYLON.JoystickAxis = {}));\n    var VirtualJoystick = (function () {\n        function VirtualJoystick(leftJoystick) {\n            var _this = this;\n            if (leftJoystick) {\n                this._leftJoystick = true;\n            }\n            else {\n                this._leftJoystick = false;\n            }\n            this._joystickIndex = VirtualJoystick._globalJoystickIndex;\n            VirtualJoystick._globalJoystickIndex++;\n            // By default left & right arrow keys are moving the X\n            // and up & down keys are moving the Y\n            this._axisTargetedByLeftAndRight = JoystickAxis.X;\n            this._axisTargetedByUpAndDown = JoystickAxis.Y;\n            this.reverseLeftRight = false;\n            this.reverseUpDown = false;\n            // collections of pointers\n            this._touches = new BABYLON.StringDictionary();\n            this.deltaPosition = BABYLON.Vector3.Zero();\n            this._joystickSensibility = 25;\n            this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n            this._rotationSpeed = 25;\n            this._inverseRotationSpeed = 1 / (this._rotationSpeed / 1000);\n            this._rotateOnAxisRelativeToMesh = false;\n            this._onResize = function (evt) {\n                VirtualJoystick.vjCanvasWidth = window.innerWidth;\n                VirtualJoystick.vjCanvasHeight = window.innerHeight;\n                VirtualJoystick.vjCanvas.width = VirtualJoystick.vjCanvasWidth;\n                VirtualJoystick.vjCanvas.height = VirtualJoystick.vjCanvasHeight;\n                VirtualJoystick.halfWidth = VirtualJoystick.vjCanvasWidth / 2;\n                VirtualJoystick.halfHeight = VirtualJoystick.vjCanvasHeight / 2;\n            };\n            // injecting a canvas element on top of the canvas 3D game\n            if (!VirtualJoystick.vjCanvas) {\n                window.addEventListener(\"resize\", this._onResize, false);\n                VirtualJoystick.vjCanvas = document.createElement(\"canvas\");\n                VirtualJoystick.vjCanvasWidth = window.innerWidth;\n                VirtualJoystick.vjCanvasHeight = window.innerHeight;\n                VirtualJoystick.vjCanvas.width = window.innerWidth;\n                VirtualJoystick.vjCanvas.height = window.innerHeight;\n                VirtualJoystick.vjCanvas.style.width = \"100%\";\n                VirtualJoystick.vjCanvas.style.height = \"100%\";\n                VirtualJoystick.vjCanvas.style.position = \"absolute\";\n                VirtualJoystick.vjCanvas.style.backgroundColor = \"transparent\";\n                VirtualJoystick.vjCanvas.style.top = \"0px\";\n                VirtualJoystick.vjCanvas.style.left = \"0px\";\n                VirtualJoystick.vjCanvas.style.zIndex = \"5\";\n                VirtualJoystick.vjCanvas.style.msTouchAction = \"none\";\n                // Support for jQuery PEP polyfill\n                VirtualJoystick.vjCanvas.setAttribute(\"touch-action\", \"none\");\n                VirtualJoystick.vjCanvasContext = VirtualJoystick.vjCanvas.getContext('2d');\n                VirtualJoystick.vjCanvasContext.strokeStyle = \"#ffffff\";\n                VirtualJoystick.vjCanvasContext.lineWidth = 2;\n                document.body.appendChild(VirtualJoystick.vjCanvas);\n            }\n            VirtualJoystick.halfWidth = VirtualJoystick.vjCanvas.width / 2;\n            VirtualJoystick.halfHeight = VirtualJoystick.vjCanvas.height / 2;\n            this.pressed = false;\n            // default joystick color\n            this._joystickColor = \"cyan\";\n            this._joystickPointerID = -1;\n            // current joystick position\n            this._joystickPointerPos = new BABYLON.Vector2(0, 0);\n            this._joystickPreviousPointerPos = new BABYLON.Vector2(0, 0);\n            // origin joystick position\n            this._joystickPointerStartPos = new BABYLON.Vector2(0, 0);\n            this._deltaJoystickVector = new BABYLON.Vector2(0, 0);\n            this._onPointerDownHandlerRef = function (evt) {\n                _this._onPointerDown(evt);\n            };\n            this._onPointerMoveHandlerRef = function (evt) {\n                _this._onPointerMove(evt);\n            };\n            this._onPointerOutHandlerRef = function (evt) {\n                _this._onPointerUp(evt);\n            };\n            this._onPointerUpHandlerRef = function (evt) {\n                _this._onPointerUp(evt);\n            };\n            VirtualJoystick.vjCanvas.addEventListener('pointerdown', this._onPointerDownHandlerRef, false);\n            VirtualJoystick.vjCanvas.addEventListener('pointermove', this._onPointerMoveHandlerRef, false);\n            VirtualJoystick.vjCanvas.addEventListener('pointerup', this._onPointerUpHandlerRef, false);\n            VirtualJoystick.vjCanvas.addEventListener('pointerout', this._onPointerUpHandlerRef, false);\n            VirtualJoystick.vjCanvas.addEventListener(\"contextmenu\", function (evt) {\n                evt.preventDefault(); // Disables system menu\n            }, false);\n            requestAnimationFrame(function () { _this._drawVirtualJoystick(); });\n        }\n        VirtualJoystick.prototype.setJoystickSensibility = function (newJoystickSensibility) {\n            this._joystickSensibility = newJoystickSensibility;\n            this._inversedSensibility = 1 / (this._joystickSensibility / 1000);\n        };\n        VirtualJoystick.prototype._onPointerDown = function (e) {\n            var positionOnScreenCondition;\n            e.preventDefault();\n            if (this._leftJoystick === true) {\n                positionOnScreenCondition = (e.clientX < VirtualJoystick.halfWidth);\n            }\n            else {\n                positionOnScreenCondition = (e.clientX > VirtualJoystick.halfWidth);\n            }\n            if (positionOnScreenCondition && this._joystickPointerID < 0) {\n                // First contact will be dedicated to the virtual joystick\n                this._joystickPointerID = e.pointerId;\n                this._joystickPointerStartPos.x = e.clientX;\n                this._joystickPointerStartPos.y = e.clientY;\n                this._joystickPointerPos = this._joystickPointerStartPos.clone();\n                this._joystickPreviousPointerPos = this._joystickPointerStartPos.clone();\n                this._deltaJoystickVector.x = 0;\n                this._deltaJoystickVector.y = 0;\n                this.pressed = true;\n                this._touches.add(e.pointerId.toString(), e);\n            }\n            else {\n                // You can only trigger the action buttons with a joystick declared\n                if (VirtualJoystick._globalJoystickIndex < 2 && this._action) {\n                    this._action();\n                    this._touches.add(e.pointerId.toString(), { x: e.clientX, y: e.clientY, prevX: e.clientX, prevY: e.clientY });\n                }\n            }\n        };\n        VirtualJoystick.prototype._onPointerMove = function (e) {\n            // If the current pointer is the one associated to the joystick (first touch contact)\n            if (this._joystickPointerID == e.pointerId) {\n                this._joystickPointerPos.x = e.clientX;\n                this._joystickPointerPos.y = e.clientY;\n                this._deltaJoystickVector = this._joystickPointerPos.clone();\n                this._deltaJoystickVector = this._deltaJoystickVector.subtract(this._joystickPointerStartPos);\n                var directionLeftRight = this.reverseLeftRight ? -1 : 1;\n                var deltaJoystickX = directionLeftRight * this._deltaJoystickVector.x / this._inversedSensibility;\n                switch (this._axisTargetedByLeftAndRight) {\n                    case JoystickAxis.X:\n                        this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickX));\n                        break;\n                    case JoystickAxis.Y:\n                        this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickX));\n                        break;\n                    case JoystickAxis.Z:\n                        this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickX));\n                        break;\n                }\n                var directionUpDown = this.reverseUpDown ? 1 : -1;\n                var deltaJoystickY = directionUpDown * this._deltaJoystickVector.y / this._inversedSensibility;\n                switch (this._axisTargetedByUpAndDown) {\n                    case JoystickAxis.X:\n                        this.deltaPosition.x = Math.min(1, Math.max(-1, deltaJoystickY));\n                        break;\n                    case JoystickAxis.Y:\n                        this.deltaPosition.y = Math.min(1, Math.max(-1, deltaJoystickY));\n                        break;\n                    case JoystickAxis.Z:\n                        this.deltaPosition.z = Math.min(1, Math.max(-1, deltaJoystickY));\n                        break;\n                }\n            }\n            else {\n                var data = this._touches.get(e.pointerId.toString());\n                if (data) {\n                    data.x = e.clientX;\n                    data.y = e.clientY;\n                }\n            }\n        };\n        VirtualJoystick.prototype._onPointerUp = function (e) {\n            if (this._joystickPointerID == e.pointerId) {\n                VirtualJoystick.vjCanvasContext.clearRect(this._joystickPointerStartPos.x - 64, this._joystickPointerStartPos.y - 64, 128, 128);\n                VirtualJoystick.vjCanvasContext.clearRect(this._joystickPreviousPointerPos.x - 42, this._joystickPreviousPointerPos.y - 42, 84, 84);\n                this._joystickPointerID = -1;\n                this.pressed = false;\n            }\n            else {\n                var touch = this._touches.get(e.pointerId.toString());\n                if (touch) {\n                    VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n                }\n            }\n            this._deltaJoystickVector.x = 0;\n            this._deltaJoystickVector.y = 0;\n            this._touches.remove(e.pointerId.toString());\n        };\n        /**\n        * Change the color of the virtual joystick\n        * @param newColor a string that must be a CSS color value (like \"red\") or the hexa value (like \"#FF0000\")\n        */\n        VirtualJoystick.prototype.setJoystickColor = function (newColor) {\n            this._joystickColor = newColor;\n        };\n        VirtualJoystick.prototype.setActionOnTouch = function (action) {\n            this._action = action;\n        };\n        // Define which axis you'd like to control for left & right \n        VirtualJoystick.prototype.setAxisForLeftRight = function (axis) {\n            switch (axis) {\n                case JoystickAxis.X:\n                case JoystickAxis.Y:\n                case JoystickAxis.Z:\n                    this._axisTargetedByLeftAndRight = axis;\n                    break;\n                default:\n                    this._axisTargetedByLeftAndRight = JoystickAxis.X;\n                    break;\n            }\n        };\n        // Define which axis you'd like to control for up & down \n        VirtualJoystick.prototype.setAxisForUpDown = function (axis) {\n            switch (axis) {\n                case JoystickAxis.X:\n                case JoystickAxis.Y:\n                case JoystickAxis.Z:\n                    this._axisTargetedByUpAndDown = axis;\n                    break;\n                default:\n                    this._axisTargetedByUpAndDown = JoystickAxis.Y;\n                    break;\n            }\n        };\n        VirtualJoystick.prototype._clearCanvas = function () {\n            if (this._leftJoystick) {\n                VirtualJoystick.vjCanvasContext.clearRect(0, 0, VirtualJoystick.vjCanvasWidth / 2, VirtualJoystick.vjCanvasHeight);\n            }\n            else {\n                VirtualJoystick.vjCanvasContext.clearRect(VirtualJoystick.vjCanvasWidth / 2, 0, VirtualJoystick.vjCanvasWidth, VirtualJoystick.vjCanvasHeight);\n            }\n        };\n        VirtualJoystick.prototype._drawVirtualJoystick = function () {\n            var _this = this;\n            if (this.pressed) {\n                this._touches.forEach(function (key, touch) {\n                    if (touch.pointerId === _this._joystickPointerID) {\n                        VirtualJoystick.vjCanvasContext.clearRect(_this._joystickPointerStartPos.x - 64, _this._joystickPointerStartPos.y - 64, 128, 128);\n                        VirtualJoystick.vjCanvasContext.clearRect(_this._joystickPreviousPointerPos.x - 42, _this._joystickPreviousPointerPos.y - 42, 84, 84);\n                        VirtualJoystick.vjCanvasContext.beginPath();\n                        VirtualJoystick.vjCanvasContext.lineWidth = 6;\n                        VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;\n                        VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerStartPos.x, _this._joystickPointerStartPos.y, 40, 0, Math.PI * 2, true);\n                        VirtualJoystick.vjCanvasContext.stroke();\n                        VirtualJoystick.vjCanvasContext.closePath();\n                        VirtualJoystick.vjCanvasContext.beginPath();\n                        VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;\n                        VirtualJoystick.vjCanvasContext.lineWidth = 2;\n                        VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerStartPos.x, _this._joystickPointerStartPos.y, 60, 0, Math.PI * 2, true);\n                        VirtualJoystick.vjCanvasContext.stroke();\n                        VirtualJoystick.vjCanvasContext.closePath();\n                        VirtualJoystick.vjCanvasContext.beginPath();\n                        VirtualJoystick.vjCanvasContext.strokeStyle = _this._joystickColor;\n                        VirtualJoystick.vjCanvasContext.arc(_this._joystickPointerPos.x, _this._joystickPointerPos.y, 40, 0, Math.PI * 2, true);\n                        VirtualJoystick.vjCanvasContext.stroke();\n                        VirtualJoystick.vjCanvasContext.closePath();\n                        _this._joystickPreviousPointerPos = _this._joystickPointerPos.clone();\n                    }\n                    else {\n                        VirtualJoystick.vjCanvasContext.clearRect(touch.prevX - 44, touch.prevY - 44, 88, 88);\n                        VirtualJoystick.vjCanvasContext.beginPath();\n                        VirtualJoystick.vjCanvasContext.fillStyle = \"white\";\n                        VirtualJoystick.vjCanvasContext.beginPath();\n                        VirtualJoystick.vjCanvasContext.strokeStyle = \"red\";\n                        VirtualJoystick.vjCanvasContext.lineWidth = 6;\n                        VirtualJoystick.vjCanvasContext.arc(touch.x, touch.y, 40, 0, Math.PI * 2, true);\n                        VirtualJoystick.vjCanvasContext.stroke();\n                        VirtualJoystick.vjCanvasContext.closePath();\n                        touch.prevX = touch.x;\n                        touch.prevY = touch.y;\n                    }\n                    ;\n                });\n            }\n            requestAnimationFrame(function () { _this._drawVirtualJoystick(); });\n        };\n        VirtualJoystick.prototype.releaseCanvas = function () {\n            if (VirtualJoystick.vjCanvas) {\n                VirtualJoystick.vjCanvas.removeEventListener('pointerdown', this._onPointerDownHandlerRef);\n                VirtualJoystick.vjCanvas.removeEventListener('pointermove', this._onPointerMoveHandlerRef);\n                VirtualJoystick.vjCanvas.removeEventListener('pointerup', this._onPointerUpHandlerRef);\n                VirtualJoystick.vjCanvas.removeEventListener('pointerout', this._onPointerUpHandlerRef);\n                window.removeEventListener(\"resize\", this._onResize);\n                document.body.removeChild(VirtualJoystick.vjCanvas);\n                VirtualJoystick.vjCanvas = null;\n            }\n        };\n        return VirtualJoystick;\n    }());\n    // Used to draw the virtual joystick inside a 2D canvas on top of the WebGL rendering canvas\n    VirtualJoystick._globalJoystickIndex = 0;\n    BABYLON.VirtualJoystick = VirtualJoystick;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.virtualJoystick.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    // We're mainly based on the logic defined into the FreeCamera code\n    var VirtualJoysticksCamera = (function (_super) {\n        __extends(VirtualJoysticksCamera, _super);\n        function VirtualJoysticksCamera(name, position, scene) {\n            var _this = _super.call(this, name, position, scene) || this;\n            _this.inputs.addVirtualJoystick();\n            return _this;\n        }\n        VirtualJoysticksCamera.prototype.getClassName = function () {\n            return \"VirtualJoysticksCamera\";\n        };\n        return VirtualJoysticksCamera;\n    }(BABYLON.FreeCamera));\n    BABYLON.VirtualJoysticksCamera = VirtualJoysticksCamera;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.virtualJoysticksCamera.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var FreeCameraVirtualJoystickInput = (function () {\n        function FreeCameraVirtualJoystickInput() {\n        }\n        FreeCameraVirtualJoystickInput.prototype.getLeftJoystick = function () {\n            return this._leftjoystick;\n        };\n        FreeCameraVirtualJoystickInput.prototype.getRightJoystick = function () {\n            return this._rightjoystick;\n        };\n        FreeCameraVirtualJoystickInput.prototype.checkInputs = function () {\n            if (this._leftjoystick) {\n                var camera = this.camera;\n                var speed = camera._computeLocalCameraSpeed() * 50;\n                var cameraTransform = BABYLON.Matrix.RotationYawPitchRoll(camera.rotation.y, camera.rotation.x, 0);\n                var deltaTransform = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(this._leftjoystick.deltaPosition.x * speed, this._leftjoystick.deltaPosition.y * speed, this._leftjoystick.deltaPosition.z * speed), cameraTransform);\n                camera.cameraDirection = camera.cameraDirection.add(deltaTransform);\n                camera.cameraRotation = camera.cameraRotation.addVector3(this._rightjoystick.deltaPosition);\n                if (!this._leftjoystick.pressed) {\n                    this._leftjoystick.deltaPosition = this._leftjoystick.deltaPosition.scale(0.9);\n                }\n                if (!this._rightjoystick.pressed) {\n                    this._rightjoystick.deltaPosition = this._rightjoystick.deltaPosition.scale(0.9);\n                }\n            }\n        };\n        FreeCameraVirtualJoystickInput.prototype.attachControl = function (element, noPreventDefault) {\n            this._leftjoystick = new BABYLON.VirtualJoystick(true);\n            this._leftjoystick.setAxisForUpDown(BABYLON.JoystickAxis.Z);\n            this._leftjoystick.setAxisForLeftRight(BABYLON.JoystickAxis.X);\n            this._leftjoystick.setJoystickSensibility(0.15);\n            this._rightjoystick = new BABYLON.VirtualJoystick(false);\n            this._rightjoystick.setAxisForUpDown(BABYLON.JoystickAxis.X);\n            this._rightjoystick.setAxisForLeftRight(BABYLON.JoystickAxis.Y);\n            this._rightjoystick.reverseUpDown = true;\n            this._rightjoystick.setJoystickSensibility(0.05);\n            this._rightjoystick.setJoystickColor(\"yellow\");\n        };\n        FreeCameraVirtualJoystickInput.prototype.detachControl = function (element) {\n            this._leftjoystick.releaseCanvas();\n            this._rightjoystick.releaseCanvas();\n        };\n        FreeCameraVirtualJoystickInput.prototype.getTypeName = function () {\n            return \"FreeCameraVirtualJoystickInput\";\n        };\n        FreeCameraVirtualJoystickInput.prototype.getSimpleName = function () {\n            return \"virtualJoystick\";\n        };\n        return FreeCameraVirtualJoystickInput;\n    }());\n    BABYLON.FreeCameraVirtualJoystickInput = FreeCameraVirtualJoystickInput;\n    BABYLON.CameraInputTypes[\"FreeCameraVirtualJoystickInput\"] = FreeCameraVirtualJoystickInput;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.freeCameraVirtualJoystickInput.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var SimplificationSettings = (function () {\n        function SimplificationSettings(quality, distance, optimizeMesh) {\n            this.quality = quality;\n            this.distance = distance;\n            this.optimizeMesh = optimizeMesh;\n        }\n        return SimplificationSettings;\n    }());\n    BABYLON.SimplificationSettings = SimplificationSettings;\n    var SimplificationQueue = (function () {\n        function SimplificationQueue() {\n            this.running = false;\n            this._simplificationArray = [];\n        }\n        SimplificationQueue.prototype.addTask = function (task) {\n            this._simplificationArray.push(task);\n        };\n        SimplificationQueue.prototype.executeNext = function () {\n            var task = this._simplificationArray.pop();\n            if (task) {\n                this.running = true;\n                this.runSimplification(task);\n            }\n            else {\n                this.running = false;\n            }\n        };\n        SimplificationQueue.prototype.runSimplification = function (task) {\n            var _this = this;\n            if (task.parallelProcessing) {\n                //parallel simplifier\n                task.settings.forEach(function (setting) {\n                    var simplifier = _this.getSimplifier(task);\n                    simplifier.simplify(setting, function (newMesh) {\n                        task.mesh.addLODLevel(setting.distance, newMesh);\n                        newMesh.isVisible = true;\n                        //check if it is the last\n                        if (setting.quality === task.settings[task.settings.length - 1].quality && task.successCallback) {\n                            //all done, run the success callback.\n                            task.successCallback();\n                        }\n                        _this.executeNext();\n                    });\n                });\n            }\n            else {\n                //single simplifier.\n                var simplifier = this.getSimplifier(task);\n                var runDecimation = function (setting, callback) {\n                    simplifier.simplify(setting, function (newMesh) {\n                        task.mesh.addLODLevel(setting.distance, newMesh);\n                        newMesh.isVisible = true;\n                        //run the next quality level\n                        callback();\n                    });\n                };\n                BABYLON.AsyncLoop.Run(task.settings.length, function (loop) {\n                    runDecimation(task.settings[loop.index], function () {\n                        loop.executeNext();\n                    });\n                }, function () {\n                    //execution ended, run the success callback.\n                    if (task.successCallback) {\n                        task.successCallback();\n                    }\n                    _this.executeNext();\n                });\n            }\n        };\n        SimplificationQueue.prototype.getSimplifier = function (task) {\n            switch (task.simplificationType) {\n                case SimplificationType.QUADRATIC:\n                default:\n                    return new QuadraticErrorSimplification(task.mesh);\n            }\n        };\n        return SimplificationQueue;\n    }());\n    BABYLON.SimplificationQueue = SimplificationQueue;\n    /**\n     * The implemented types of simplification.\n     * At the moment only Quadratic Error Decimation is implemented.\n     */\n    var SimplificationType;\n    (function (SimplificationType) {\n        SimplificationType[SimplificationType[\"QUADRATIC\"] = 0] = \"QUADRATIC\";\n    })(SimplificationType = BABYLON.SimplificationType || (BABYLON.SimplificationType = {}));\n    var DecimationTriangle = (function () {\n        function DecimationTriangle(vertices) {\n            this.vertices = vertices;\n            this.error = new Array(4);\n            this.deleted = false;\n            this.isDirty = false;\n            this.deletePending = false;\n            this.borderFactor = 0;\n        }\n        return DecimationTriangle;\n    }());\n    BABYLON.DecimationTriangle = DecimationTriangle;\n    var DecimationVertex = (function () {\n        function DecimationVertex(position, id) {\n            this.position = position;\n            this.id = id;\n            this.isBorder = true;\n            this.q = new QuadraticMatrix();\n            this.triangleCount = 0;\n            this.triangleStart = 0;\n            this.originalOffsets = [];\n        }\n        DecimationVertex.prototype.updatePosition = function (newPosition) {\n            this.position.copyFrom(newPosition);\n        };\n        return DecimationVertex;\n    }());\n    BABYLON.DecimationVertex = DecimationVertex;\n    var QuadraticMatrix = (function () {\n        function QuadraticMatrix(data) {\n            this.data = new Array(10);\n            for (var i = 0; i < 10; ++i) {\n                if (data && data[i]) {\n                    this.data[i] = data[i];\n                }\n                else {\n                    this.data[i] = 0;\n                }\n            }\n        }\n        QuadraticMatrix.prototype.det = function (a11, a12, a13, a21, a22, a23, a31, a32, a33) {\n            var det = this.data[a11] * this.data[a22] * this.data[a33] + this.data[a13] * this.data[a21] * this.data[a32] +\n                this.data[a12] * this.data[a23] * this.data[a31] - this.data[a13] * this.data[a22] * this.data[a31] -\n                this.data[a11] * this.data[a23] * this.data[a32] - this.data[a12] * this.data[a21] * this.data[a33];\n            return det;\n        };\n        QuadraticMatrix.prototype.addInPlace = function (matrix) {\n            for (var i = 0; i < 10; ++i) {\n                this.data[i] += matrix.data[i];\n            }\n        };\n        QuadraticMatrix.prototype.addArrayInPlace = function (data) {\n            for (var i = 0; i < 10; ++i) {\n                this.data[i] += data[i];\n            }\n        };\n        QuadraticMatrix.prototype.add = function (matrix) {\n            var m = new QuadraticMatrix();\n            for (var i = 0; i < 10; ++i) {\n                m.data[i] = this.data[i] + matrix.data[i];\n            }\n            return m;\n        };\n        QuadraticMatrix.FromData = function (a, b, c, d) {\n            return new QuadraticMatrix(QuadraticMatrix.DataFromNumbers(a, b, c, d));\n        };\n        //returning an array to avoid garbage collection\n        QuadraticMatrix.DataFromNumbers = function (a, b, c, d) {\n            return [a * a, a * b, a * c, a * d, b * b, b * c, b * d, c * c, c * d, d * d];\n        };\n        return QuadraticMatrix;\n    }());\n    BABYLON.QuadraticMatrix = QuadraticMatrix;\n    var Reference = (function () {\n        function Reference(vertexId, triangleId) {\n            this.vertexId = vertexId;\n            this.triangleId = triangleId;\n        }\n        return Reference;\n    }());\n    BABYLON.Reference = Reference;\n    /**\n     * An implementation of the Quadratic Error simplification algorithm.\n     * Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf\n     * Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS\n     * @author RaananW\n     */\n    var QuadraticErrorSimplification = (function () {\n        function QuadraticErrorSimplification(_mesh) {\n            this._mesh = _mesh;\n            this.initialized = false;\n            this.syncIterations = 5000;\n            this.aggressiveness = 7;\n            this.decimationIterations = 100;\n            this.boundingBoxEpsilon = BABYLON.Epsilon;\n        }\n        QuadraticErrorSimplification.prototype.simplify = function (settings, successCallback) {\n            var _this = this;\n            this.initDecimatedMesh();\n            //iterating through the submeshes array, one after the other.\n            BABYLON.AsyncLoop.Run(this._mesh.subMeshes.length, function (loop) {\n                _this.initWithMesh(loop.index, function () {\n                    _this.runDecimation(settings, loop.index, function () {\n                        loop.executeNext();\n                    });\n                }, settings.optimizeMesh);\n            }, function () {\n                setTimeout(function () {\n                    successCallback(_this._reconstructedMesh);\n                }, 0);\n            });\n        };\n        QuadraticErrorSimplification.prototype.isTriangleOnBoundingBox = function (triangle) {\n            var _this = this;\n            var gCount = 0;\n            triangle.vertices.forEach(function (vertex) {\n                var count = 0;\n                var vPos = vertex.position;\n                var bbox = _this._mesh.getBoundingInfo().boundingBox;\n                if (bbox.maximum.x - vPos.x < _this.boundingBoxEpsilon || vPos.x - bbox.minimum.x > _this.boundingBoxEpsilon)\n                    ++count;\n                if (bbox.maximum.y === vPos.y || vPos.y === bbox.minimum.y)\n                    ++count;\n                if (bbox.maximum.z === vPos.z || vPos.z === bbox.minimum.z)\n                    ++count;\n                if (count > 1) {\n                    ++gCount;\n                }\n                ;\n            });\n            if (gCount > 1) {\n                console.log(triangle, gCount);\n            }\n            return gCount > 1;\n        };\n        QuadraticErrorSimplification.prototype.runDecimation = function (settings, submeshIndex, successCallback) {\n            var _this = this;\n            var targetCount = ~~(this.triangles.length * settings.quality);\n            var deletedTriangles = 0;\n            var triangleCount = this.triangles.length;\n            var iterationFunction = function (iteration, callback) {\n                setTimeout(function () {\n                    if (iteration % 5 === 0) {\n                        _this.updateMesh(iteration === 0);\n                    }\n                    for (var i = 0; i < _this.triangles.length; ++i) {\n                        _this.triangles[i].isDirty = false;\n                    }\n                    var threshold = 0.000000001 * Math.pow((iteration + 3), _this.aggressiveness);\n                    var trianglesIterator = function (i) {\n                        var tIdx = ~~(((_this.triangles.length / 2) + i) % _this.triangles.length);\n                        var t = _this.triangles[tIdx];\n                        if (!t)\n                            return;\n                        if (t.error[3] > threshold || t.deleted || t.isDirty) {\n                            return;\n                        }\n                        for (var j = 0; j < 3; ++j) {\n                            if (t.error[j] < threshold) {\n                                var deleted0 = [];\n                                var deleted1 = [];\n                                var v0 = t.vertices[j];\n                                var v1 = t.vertices[(j + 1) % 3];\n                                if (v0.isBorder || v1.isBorder)\n                                    continue;\n                                var p = BABYLON.Vector3.Zero();\n                                var n = BABYLON.Vector3.Zero();\n                                var uv = BABYLON.Vector2.Zero();\n                                var color = new BABYLON.Color4(0, 0, 0, 1);\n                                _this.calculateError(v0, v1, p, n, uv, color);\n                                var delTr = [];\n                                if (_this.isFlipped(v0, v1, p, deleted0, t.borderFactor, delTr))\n                                    continue;\n                                if (_this.isFlipped(v1, v0, p, deleted1, t.borderFactor, delTr))\n                                    continue;\n                                if (deleted0.indexOf(true) < 0 || deleted1.indexOf(true) < 0)\n                                    continue;\n                                var uniqueArray = [];\n                                delTr.forEach(function (deletedT) {\n                                    if (uniqueArray.indexOf(deletedT) === -1) {\n                                        deletedT.deletePending = true;\n                                        uniqueArray.push(deletedT);\n                                    }\n                                });\n                                if (uniqueArray.length % 2 !== 0) {\n                                    continue;\n                                }\n                                v0.q = v1.q.add(v0.q);\n                                v0.updatePosition(p);\n                                var tStart = _this.references.length;\n                                deletedTriangles = _this.updateTriangles(v0, v0, deleted0, deletedTriangles);\n                                deletedTriangles = _this.updateTriangles(v0, v1, deleted1, deletedTriangles);\n                                var tCount = _this.references.length - tStart;\n                                if (tCount <= v0.triangleCount) {\n                                    if (tCount) {\n                                        for (var c = 0; c < tCount; c++) {\n                                            _this.references[v0.triangleStart + c] = _this.references[tStart + c];\n                                        }\n                                    }\n                                }\n                                else {\n                                    v0.triangleStart = tStart;\n                                }\n                                v0.triangleCount = tCount;\n                                break;\n                            }\n                        }\n                    };\n                    BABYLON.AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, trianglesIterator, callback, function () { return (triangleCount - deletedTriangles <= targetCount); });\n                }, 0);\n            };\n            BABYLON.AsyncLoop.Run(this.decimationIterations, function (loop) {\n                if (triangleCount - deletedTriangles <= targetCount)\n                    loop.breakLoop();\n                else {\n                    iterationFunction(loop.index, function () {\n                        loop.executeNext();\n                    });\n                }\n            }, function () {\n                setTimeout(function () {\n                    //reconstruct this part of the mesh\n                    _this.reconstructMesh(submeshIndex);\n                    successCallback();\n                }, 0);\n            });\n        };\n        QuadraticErrorSimplification.prototype.initWithMesh = function (submeshIndex, callback, optimizeMesh) {\n            var _this = this;\n            this.vertices = [];\n            this.triangles = [];\n            var positionData = this._mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var indices = this._mesh.getIndices();\n            var submesh = this._mesh.subMeshes[submeshIndex];\n            var findInVertices = function (positionToSearch) {\n                if (optimizeMesh) {\n                    for (var ii = 0; ii < _this.vertices.length; ++ii) {\n                        if (_this.vertices[ii].position.equals(positionToSearch)) {\n                            return _this.vertices[ii];\n                        }\n                    }\n                }\n                return null;\n            };\n            var vertexReferences = [];\n            var vertexInit = function (i) {\n                var offset = i + submesh.verticesStart;\n                var position = BABYLON.Vector3.FromArray(positionData, offset * 3);\n                var vertex = findInVertices(position) || new DecimationVertex(position, _this.vertices.length);\n                vertex.originalOffsets.push(offset);\n                if (vertex.id === _this.vertices.length) {\n                    _this.vertices.push(vertex);\n                }\n                vertexReferences.push(vertex.id);\n            };\n            //var totalVertices = mesh.getTotalVertices();\n            var totalVertices = submesh.verticesCount;\n            BABYLON.AsyncLoop.SyncAsyncForLoop(totalVertices, (this.syncIterations / 4) >> 0, vertexInit, function () {\n                var indicesInit = function (i) {\n                    var offset = (submesh.indexStart / 3) + i;\n                    var pos = (offset * 3);\n                    var i0 = indices[pos + 0];\n                    var i1 = indices[pos + 1];\n                    var i2 = indices[pos + 2];\n                    var v0 = _this.vertices[vertexReferences[i0 - submesh.verticesStart]];\n                    var v1 = _this.vertices[vertexReferences[i1 - submesh.verticesStart]];\n                    var v2 = _this.vertices[vertexReferences[i2 - submesh.verticesStart]];\n                    var triangle = new DecimationTriangle([v0, v1, v2]);\n                    triangle.originalOffset = pos;\n                    _this.triangles.push(triangle);\n                };\n                BABYLON.AsyncLoop.SyncAsyncForLoop(submesh.indexCount / 3, _this.syncIterations, indicesInit, function () {\n                    _this.init(callback);\n                });\n            });\n        };\n        QuadraticErrorSimplification.prototype.init = function (callback) {\n            var _this = this;\n            var triangleInit1 = function (i) {\n                var t = _this.triangles[i];\n                t.normal = BABYLON.Vector3.Cross(t.vertices[1].position.subtract(t.vertices[0].position), t.vertices[2].position.subtract(t.vertices[0].position)).normalize();\n                for (var j = 0; j < 3; j++) {\n                    t.vertices[j].q.addArrayInPlace(QuadraticMatrix.DataFromNumbers(t.normal.x, t.normal.y, t.normal.z, -(BABYLON.Vector3.Dot(t.normal, t.vertices[0].position))));\n                }\n            };\n            BABYLON.AsyncLoop.SyncAsyncForLoop(this.triangles.length, this.syncIterations, triangleInit1, function () {\n                var triangleInit2 = function (i) {\n                    var t = _this.triangles[i];\n                    for (var j = 0; j < 3; ++j) {\n                        t.error[j] = _this.calculateError(t.vertices[j], t.vertices[(j + 1) % 3]);\n                    }\n                    t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n                };\n                BABYLON.AsyncLoop.SyncAsyncForLoop(_this.triangles.length, _this.syncIterations, triangleInit2, function () {\n                    _this.initialized = true;\n                    callback();\n                });\n            });\n        };\n        QuadraticErrorSimplification.prototype.reconstructMesh = function (submeshIndex) {\n            var newTriangles = [];\n            var i;\n            for (i = 0; i < this.vertices.length; ++i) {\n                this.vertices[i].triangleCount = 0;\n            }\n            var t;\n            var j;\n            for (i = 0; i < this.triangles.length; ++i) {\n                if (!this.triangles[i].deleted) {\n                    t = this.triangles[i];\n                    for (j = 0; j < 3; ++j) {\n                        t.vertices[j].triangleCount = 1;\n                    }\n                    newTriangles.push(t);\n                }\n            }\n            var newPositionData = (this._reconstructedMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind) || []);\n            var newNormalData = (this._reconstructedMesh.getVerticesData(BABYLON.VertexBuffer.NormalKind) || []);\n            var newUVsData = (this._reconstructedMesh.getVerticesData(BABYLON.VertexBuffer.UVKind) || []);\n            var newColorsData = (this._reconstructedMesh.getVerticesData(BABYLON.VertexBuffer.ColorKind) || []);\n            var normalData = this._mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);\n            var uvs = this._mesh.getVerticesData(BABYLON.VertexBuffer.UVKind);\n            var colorsData = this._mesh.getVerticesData(BABYLON.VertexBuffer.ColorKind);\n            var vertexCount = 0;\n            for (i = 0; i < this.vertices.length; ++i) {\n                var vertex = this.vertices[i];\n                vertex.id = vertexCount;\n                if (vertex.triangleCount) {\n                    vertex.originalOffsets.forEach(function (originalOffset) {\n                        newPositionData.push(vertex.position.x);\n                        newPositionData.push(vertex.position.y);\n                        newPositionData.push(vertex.position.z);\n                        newNormalData.push(normalData[originalOffset * 3]);\n                        newNormalData.push(normalData[(originalOffset * 3) + 1]);\n                        newNormalData.push(normalData[(originalOffset * 3) + 2]);\n                        if (uvs && uvs.length) {\n                            newUVsData.push(uvs[(originalOffset * 2)]);\n                            newUVsData.push(uvs[(originalOffset * 2) + 1]);\n                        }\n                        else if (colorsData && colorsData.length) {\n                            newColorsData.push(colorsData[(originalOffset * 4)]);\n                            newColorsData.push(colorsData[(originalOffset * 4) + 1]);\n                            newColorsData.push(colorsData[(originalOffset * 4) + 2]);\n                            newColorsData.push(colorsData[(originalOffset * 4) + 3]);\n                        }\n                        ++vertexCount;\n                    });\n                }\n            }\n            var startingIndex = this._reconstructedMesh.getTotalIndices();\n            var startingVertex = this._reconstructedMesh.getTotalVertices();\n            var submeshesArray = this._reconstructedMesh.subMeshes;\n            this._reconstructedMesh.subMeshes = [];\n            var newIndicesArray = this._reconstructedMesh.getIndices(); //[];\n            var originalIndices = this._mesh.getIndices();\n            for (i = 0; i < newTriangles.length; ++i) {\n                t = newTriangles[i]; //now get the new referencing point for each vertex\n                [0, 1, 2].forEach(function (idx) {\n                    var id = originalIndices[t.originalOffset + idx];\n                    var offset = t.vertices[idx].originalOffsets.indexOf(id);\n                    if (offset < 0)\n                        offset = 0;\n                    newIndicesArray.push(t.vertices[idx].id + offset + startingVertex);\n                });\n            }\n            //overwriting the old vertex buffers and indices.\n            this._reconstructedMesh.setIndices(newIndicesArray);\n            this._reconstructedMesh.setVerticesData(BABYLON.VertexBuffer.PositionKind, newPositionData);\n            this._reconstructedMesh.setVerticesData(BABYLON.VertexBuffer.NormalKind, newNormalData);\n            if (newUVsData.length > 0)\n                this._reconstructedMesh.setVerticesData(BABYLON.VertexBuffer.UVKind, newUVsData);\n            if (newColorsData.length > 0)\n                this._reconstructedMesh.setVerticesData(BABYLON.VertexBuffer.ColorKind, newColorsData);\n            //create submesh\n            var originalSubmesh = this._mesh.subMeshes[submeshIndex];\n            if (submeshIndex > 0) {\n                this._reconstructedMesh.subMeshes = [];\n                submeshesArray.forEach(function (submesh) {\n                    new BABYLON.SubMesh(submesh.materialIndex, submesh.verticesStart, submesh.verticesCount, /* 0, newPositionData.length/3, */ submesh.indexStart, submesh.indexCount, submesh.getMesh());\n                });\n                var newSubmesh = new BABYLON.SubMesh(originalSubmesh.materialIndex, startingVertex, vertexCount, /* 0, newPositionData.length / 3, */ startingIndex, newTriangles.length * 3, this._reconstructedMesh);\n            }\n        };\n        QuadraticErrorSimplification.prototype.initDecimatedMesh = function () {\n            this._reconstructedMesh = new BABYLON.Mesh(this._mesh.name + \"Decimated\", this._mesh.getScene());\n            this._reconstructedMesh.material = this._mesh.material;\n            this._reconstructedMesh.parent = this._mesh.parent;\n            this._reconstructedMesh.isVisible = false;\n            this._reconstructedMesh.renderingGroupId = this._mesh.renderingGroupId;\n        };\n        QuadraticErrorSimplification.prototype.isFlipped = function (vertex1, vertex2, point, deletedArray, borderFactor, delTr) {\n            for (var i = 0; i < vertex1.triangleCount; ++i) {\n                var t = this.triangles[this.references[vertex1.triangleStart + i].triangleId];\n                if (t.deleted)\n                    continue;\n                var s = this.references[vertex1.triangleStart + i].vertexId;\n                var v1 = t.vertices[(s + 1) % 3];\n                var v2 = t.vertices[(s + 2) % 3];\n                if ((v1 === vertex2 || v2 === vertex2) /* && !this.isTriangleOnBoundingBox(t)*/) {\n                    deletedArray[i] = true;\n                    delTr.push(t);\n                    continue;\n                }\n                var d1 = v1.position.subtract(point);\n                d1 = d1.normalize();\n                var d2 = v2.position.subtract(point);\n                d2 = d2.normalize();\n                if (Math.abs(BABYLON.Vector3.Dot(d1, d2)) > 0.999)\n                    return true;\n                var normal = BABYLON.Vector3.Cross(d1, d2).normalize();\n                deletedArray[i] = false;\n                if (BABYLON.Vector3.Dot(normal, t.normal) < 0.2)\n                    return true;\n            }\n            return false;\n        };\n        QuadraticErrorSimplification.prototype.updateTriangles = function (origVertex, vertex, deletedArray, deletedTriangles) {\n            var newDeleted = deletedTriangles;\n            for (var i = 0; i < vertex.triangleCount; ++i) {\n                var ref = this.references[vertex.triangleStart + i];\n                var t = this.triangles[ref.triangleId];\n                if (t.deleted)\n                    continue;\n                if (deletedArray[i] && t.deletePending) {\n                    t.deleted = true;\n                    newDeleted++;\n                    continue;\n                }\n                t.vertices[ref.vertexId] = origVertex;\n                t.isDirty = true;\n                t.error[0] = this.calculateError(t.vertices[0], t.vertices[1]) + (t.borderFactor / 2);\n                t.error[1] = this.calculateError(t.vertices[1], t.vertices[2]) + (t.borderFactor / 2);\n                t.error[2] = this.calculateError(t.vertices[2], t.vertices[0]) + (t.borderFactor / 2);\n                t.error[3] = Math.min(t.error[0], t.error[1], t.error[2]);\n                this.references.push(ref);\n            }\n            return newDeleted;\n        };\n        QuadraticErrorSimplification.prototype.identifyBorder = function () {\n            for (var i = 0; i < this.vertices.length; ++i) {\n                var vCount = [];\n                var vId = [];\n                var v = this.vertices[i];\n                var j;\n                for (j = 0; j < v.triangleCount; ++j) {\n                    var triangle = this.triangles[this.references[v.triangleStart + j].triangleId];\n                    for (var ii = 0; ii < 3; ii++) {\n                        var ofs = 0;\n                        var vv = triangle.vertices[ii];\n                        while (ofs < vCount.length) {\n                            if (vId[ofs] === vv.id)\n                                break;\n                            ++ofs;\n                        }\n                        if (ofs === vCount.length) {\n                            vCount.push(1);\n                            vId.push(vv.id);\n                        }\n                        else {\n                            vCount[ofs]++;\n                        }\n                    }\n                }\n                for (j = 0; j < vCount.length; ++j) {\n                    if (vCount[j] === 1) {\n                        this.vertices[vId[j]].isBorder = true;\n                    }\n                    else {\n                        this.vertices[vId[j]].isBorder = false;\n                    }\n                }\n            }\n        };\n        QuadraticErrorSimplification.prototype.updateMesh = function (identifyBorders) {\n            if (identifyBorders === void 0) { identifyBorders = false; }\n            var i;\n            if (!identifyBorders) {\n                var newTrianglesVector = [];\n                for (i = 0; i < this.triangles.length; ++i) {\n                    if (!this.triangles[i].deleted) {\n                        newTrianglesVector.push(this.triangles[i]);\n                    }\n                }\n                this.triangles = newTrianglesVector;\n            }\n            for (i = 0; i < this.vertices.length; ++i) {\n                this.vertices[i].triangleCount = 0;\n                this.vertices[i].triangleStart = 0;\n            }\n            var t;\n            var j;\n            var v;\n            for (i = 0; i < this.triangles.length; ++i) {\n                t = this.triangles[i];\n                for (j = 0; j < 3; ++j) {\n                    v = t.vertices[j];\n                    v.triangleCount++;\n                }\n            }\n            var tStart = 0;\n            for (i = 0; i < this.vertices.length; ++i) {\n                this.vertices[i].triangleStart = tStart;\n                tStart += this.vertices[i].triangleCount;\n                this.vertices[i].triangleCount = 0;\n            }\n            var newReferences = new Array(this.triangles.length * 3);\n            for (i = 0; i < this.triangles.length; ++i) {\n                t = this.triangles[i];\n                for (j = 0; j < 3; ++j) {\n                    v = t.vertices[j];\n                    newReferences[v.triangleStart + v.triangleCount] = new Reference(j, i);\n                    v.triangleCount++;\n                }\n            }\n            this.references = newReferences;\n            if (identifyBorders) {\n                this.identifyBorder();\n            }\n        };\n        QuadraticErrorSimplification.prototype.vertexError = function (q, point) {\n            var x = point.x;\n            var y = point.y;\n            var z = point.z;\n            return q.data[0] * x * x + 2 * q.data[1] * x * y + 2 * q.data[2] * x * z + 2 * q.data[3] * x + q.data[4] * y * y\n                + 2 * q.data[5] * y * z + 2 * q.data[6] * y + q.data[7] * z * z + 2 * q.data[8] * z + q.data[9];\n        };\n        QuadraticErrorSimplification.prototype.calculateError = function (vertex1, vertex2, pointResult, normalResult, uvResult, colorResult) {\n            var q = vertex1.q.add(vertex2.q);\n            var border = vertex1.isBorder && vertex2.isBorder;\n            var error = 0;\n            var qDet = q.det(0, 1, 2, 1, 4, 5, 2, 5, 7);\n            if (qDet !== 0 && !border) {\n                if (!pointResult) {\n                    pointResult = BABYLON.Vector3.Zero();\n                }\n                pointResult.x = -1 / qDet * (q.det(1, 2, 3, 4, 5, 6, 5, 7, 8));\n                pointResult.y = 1 / qDet * (q.det(0, 2, 3, 1, 5, 6, 2, 7, 8));\n                pointResult.z = -1 / qDet * (q.det(0, 1, 3, 1, 4, 6, 2, 5, 8));\n                error = this.vertexError(q, pointResult);\n            }\n            else {\n                var p3 = (vertex1.position.add(vertex2.position)).divide(new BABYLON.Vector3(2, 2, 2));\n                //var norm3 = (vertex1.normal.add(vertex2.normal)).divide(new Vector3(2, 2, 2)).normalize();\n                var error1 = this.vertexError(q, vertex1.position);\n                var error2 = this.vertexError(q, vertex2.position);\n                var error3 = this.vertexError(q, p3);\n                error = Math.min(error1, error2, error3);\n                if (error === error1) {\n                    if (pointResult) {\n                        pointResult.copyFrom(vertex1.position);\n                    }\n                }\n                else if (error === error2) {\n                    if (pointResult) {\n                        pointResult.copyFrom(vertex2.position);\n                    }\n                }\n                else {\n                    if (pointResult) {\n                        pointResult.copyFrom(p3);\n                    }\n                }\n            }\n            return error;\n        };\n        return QuadraticErrorSimplification;\n    }());\n    BABYLON.QuadraticErrorSimplification = QuadraticErrorSimplification;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.meshSimplification.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Internals;\n    (function (Internals) {\n        var MeshLODLevel = (function () {\n            function MeshLODLevel(distance, mesh) {\n                this.distance = distance;\n                this.mesh = mesh;\n            }\n            return MeshLODLevel;\n        }());\n        Internals.MeshLODLevel = MeshLODLevel;\n    })(Internals = BABYLON.Internals || (BABYLON.Internals = {}));\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.meshLODLevel.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    // Standard optimizations\n    var SceneOptimization = (function () {\n        function SceneOptimization(priority) {\n            if (priority === void 0) { priority = 0; }\n            this.priority = priority;\n            this.apply = function (scene) {\n                return true; // Return true if everything that can be done was applied\n            };\n        }\n        return SceneOptimization;\n    }());\n    BABYLON.SceneOptimization = SceneOptimization;\n    var TextureOptimization = (function (_super) {\n        __extends(TextureOptimization, _super);\n        function TextureOptimization(priority, maximumSize) {\n            if (priority === void 0) { priority = 0; }\n            if (maximumSize === void 0) { maximumSize = 1024; }\n            var _this = _super.call(this, priority) || this;\n            _this.priority = priority;\n            _this.maximumSize = maximumSize;\n            _this.apply = function (scene) {\n                var allDone = true;\n                for (var index = 0; index < scene.textures.length; index++) {\n                    var texture = scene.textures[index];\n                    if (!texture.canRescale) {\n                        continue;\n                    }\n                    var currentSize = texture.getSize();\n                    var maxDimension = Math.max(currentSize.width, currentSize.height);\n                    if (maxDimension > _this.maximumSize) {\n                        texture.scale(0.5);\n                        allDone = false;\n                    }\n                }\n                return allDone;\n            };\n            return _this;\n        }\n        return TextureOptimization;\n    }(SceneOptimization));\n    BABYLON.TextureOptimization = TextureOptimization;\n    var HardwareScalingOptimization = (function (_super) {\n        __extends(HardwareScalingOptimization, _super);\n        function HardwareScalingOptimization(priority, maximumScale) {\n            if (priority === void 0) { priority = 0; }\n            if (maximumScale === void 0) { maximumScale = 2; }\n            var _this = _super.call(this, priority) || this;\n            _this.priority = priority;\n            _this.maximumScale = maximumScale;\n            _this._currentScale = 1;\n            _this.apply = function (scene) {\n                _this._currentScale++;\n                scene.getEngine().setHardwareScalingLevel(_this._currentScale);\n                return _this._currentScale >= _this.maximumScale;\n            };\n            return _this;\n        }\n        return HardwareScalingOptimization;\n    }(SceneOptimization));\n    BABYLON.HardwareScalingOptimization = HardwareScalingOptimization;\n    var ShadowsOptimization = (function (_super) {\n        __extends(ShadowsOptimization, _super);\n        function ShadowsOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.apply = function (scene) {\n                scene.shadowsEnabled = false;\n                return true;\n            };\n            return _this;\n        }\n        return ShadowsOptimization;\n    }(SceneOptimization));\n    BABYLON.ShadowsOptimization = ShadowsOptimization;\n    var PostProcessesOptimization = (function (_super) {\n        __extends(PostProcessesOptimization, _super);\n        function PostProcessesOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.apply = function (scene) {\n                scene.postProcessesEnabled = false;\n                return true;\n            };\n            return _this;\n        }\n        return PostProcessesOptimization;\n    }(SceneOptimization));\n    BABYLON.PostProcessesOptimization = PostProcessesOptimization;\n    var LensFlaresOptimization = (function (_super) {\n        __extends(LensFlaresOptimization, _super);\n        function LensFlaresOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.apply = function (scene) {\n                scene.lensFlaresEnabled = false;\n                return true;\n            };\n            return _this;\n        }\n        return LensFlaresOptimization;\n    }(SceneOptimization));\n    BABYLON.LensFlaresOptimization = LensFlaresOptimization;\n    var ParticlesOptimization = (function (_super) {\n        __extends(ParticlesOptimization, _super);\n        function ParticlesOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.apply = function (scene) {\n                scene.particlesEnabled = false;\n                return true;\n            };\n            return _this;\n        }\n        return ParticlesOptimization;\n    }(SceneOptimization));\n    BABYLON.ParticlesOptimization = ParticlesOptimization;\n    var RenderTargetsOptimization = (function (_super) {\n        __extends(RenderTargetsOptimization, _super);\n        function RenderTargetsOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.apply = function (scene) {\n                scene.renderTargetsEnabled = false;\n                return true;\n            };\n            return _this;\n        }\n        return RenderTargetsOptimization;\n    }(SceneOptimization));\n    BABYLON.RenderTargetsOptimization = RenderTargetsOptimization;\n    var MergeMeshesOptimization = (function (_super) {\n        __extends(MergeMeshesOptimization, _super);\n        function MergeMeshesOptimization() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._canBeMerged = function (abstractMesh) {\n                if (!(abstractMesh instanceof BABYLON.Mesh)) {\n                    return false;\n                }\n                var mesh = abstractMesh;\n                if (!mesh.isVisible || !mesh.isEnabled()) {\n                    return false;\n                }\n                if (mesh.instances.length > 0) {\n                    return false;\n                }\n                if (mesh.skeleton || mesh.hasLODLevels) {\n                    return false;\n                }\n                if (mesh.parent) {\n                    return false;\n                }\n                return true;\n            };\n            _this.apply = function (scene, updateSelectionTree) {\n                var globalPool = scene.meshes.slice(0);\n                var globalLength = globalPool.length;\n                for (var index = 0; index < globalLength; index++) {\n                    var currentPool = new Array();\n                    var current = globalPool[index];\n                    // Checks\n                    if (!_this._canBeMerged(current)) {\n                        continue;\n                    }\n                    currentPool.push(current);\n                    // Find compatible meshes\n                    for (var subIndex = index + 1; subIndex < globalLength; subIndex++) {\n                        var otherMesh = globalPool[subIndex];\n                        if (!_this._canBeMerged(otherMesh)) {\n                            continue;\n                        }\n                        if (otherMesh.material !== current.material) {\n                            continue;\n                        }\n                        if (otherMesh.checkCollisions !== current.checkCollisions) {\n                            continue;\n                        }\n                        currentPool.push(otherMesh);\n                        globalLength--;\n                        globalPool.splice(subIndex, 1);\n                        subIndex--;\n                    }\n                    if (currentPool.length < 2) {\n                        continue;\n                    }\n                    // Merge meshes\n                    BABYLON.Mesh.MergeMeshes(currentPool);\n                }\n                if (updateSelectionTree != undefined) {\n                    if (updateSelectionTree) {\n                        scene.createOrUpdateSelectionOctree();\n                    }\n                }\n                else if (MergeMeshesOptimization.UpdateSelectionTree) {\n                    scene.createOrUpdateSelectionOctree();\n                }\n                return true;\n            };\n            return _this;\n        }\n        Object.defineProperty(MergeMeshesOptimization, \"UpdateSelectionTree\", {\n            get: function () {\n                return MergeMeshesOptimization._UpdateSelectionTree;\n            },\n            set: function (value) {\n                MergeMeshesOptimization._UpdateSelectionTree = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MergeMeshesOptimization;\n    }(SceneOptimization));\n    MergeMeshesOptimization._UpdateSelectionTree = false;\n    BABYLON.MergeMeshesOptimization = MergeMeshesOptimization;\n    // Options\n    var SceneOptimizerOptions = (function () {\n        function SceneOptimizerOptions(targetFrameRate, trackerDuration) {\n            if (targetFrameRate === void 0) { targetFrameRate = 60; }\n            if (trackerDuration === void 0) { trackerDuration = 2000; }\n            this.targetFrameRate = targetFrameRate;\n            this.trackerDuration = trackerDuration;\n            this.optimizations = new Array();\n        }\n        SceneOptimizerOptions.LowDegradationAllowed = function (targetFrameRate) {\n            var result = new SceneOptimizerOptions(targetFrameRate);\n            var priority = 0;\n            result.optimizations.push(new MergeMeshesOptimization(priority));\n            result.optimizations.push(new ShadowsOptimization(priority));\n            result.optimizations.push(new LensFlaresOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new PostProcessesOptimization(priority));\n            result.optimizations.push(new ParticlesOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new TextureOptimization(priority, 1024));\n            return result;\n        };\n        SceneOptimizerOptions.ModerateDegradationAllowed = function (targetFrameRate) {\n            var result = new SceneOptimizerOptions(targetFrameRate);\n            var priority = 0;\n            result.optimizations.push(new MergeMeshesOptimization(priority));\n            result.optimizations.push(new ShadowsOptimization(priority));\n            result.optimizations.push(new LensFlaresOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new PostProcessesOptimization(priority));\n            result.optimizations.push(new ParticlesOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new TextureOptimization(priority, 512));\n            // Next priority\n            priority++;\n            result.optimizations.push(new RenderTargetsOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new HardwareScalingOptimization(priority, 2));\n            return result;\n        };\n        SceneOptimizerOptions.HighDegradationAllowed = function (targetFrameRate) {\n            var result = new SceneOptimizerOptions(targetFrameRate);\n            var priority = 0;\n            result.optimizations.push(new MergeMeshesOptimization(priority));\n            result.optimizations.push(new ShadowsOptimization(priority));\n            result.optimizations.push(new LensFlaresOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new PostProcessesOptimization(priority));\n            result.optimizations.push(new ParticlesOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new TextureOptimization(priority, 256));\n            // Next priority\n            priority++;\n            result.optimizations.push(new RenderTargetsOptimization(priority));\n            // Next priority\n            priority++;\n            result.optimizations.push(new HardwareScalingOptimization(priority, 4));\n            return result;\n        };\n        return SceneOptimizerOptions;\n    }());\n    BABYLON.SceneOptimizerOptions = SceneOptimizerOptions;\n    // Scene optimizer tool\n    var SceneOptimizer = (function () {\n        function SceneOptimizer() {\n        }\n        SceneOptimizer._CheckCurrentState = function (scene, options, currentPriorityLevel, onSuccess, onFailure) {\n            // TODO: add an epsilon\n            if (scene.getEngine().getFps() >= options.targetFrameRate) {\n                if (onSuccess) {\n                    onSuccess();\n                }\n                return;\n            }\n            // Apply current level of optimizations\n            var allDone = true;\n            var noOptimizationApplied = true;\n            for (var index = 0; index < options.optimizations.length; index++) {\n                var optimization = options.optimizations[index];\n                if (optimization.priority === currentPriorityLevel) {\n                    noOptimizationApplied = false;\n                    allDone = allDone && optimization.apply(scene);\n                }\n            }\n            // If no optimization was applied, this is a failure :(\n            if (noOptimizationApplied) {\n                if (onFailure) {\n                    onFailure();\n                }\n                return;\n            }\n            // If all optimizations were done, move to next level\n            if (allDone) {\n                currentPriorityLevel++;\n            }\n            // Let's the system running for a specific amount of time before checking FPS\n            scene.executeWhenReady(function () {\n                setTimeout(function () {\n                    SceneOptimizer._CheckCurrentState(scene, options, currentPriorityLevel, onSuccess, onFailure);\n                }, options.trackerDuration);\n            });\n        };\n        SceneOptimizer.OptimizeAsync = function (scene, options, onSuccess, onFailure) {\n            if (!options) {\n                options = SceneOptimizerOptions.ModerateDegradationAllowed();\n            }\n            // Let's the system running for a specific amount of time before checking FPS\n            scene.executeWhenReady(function () {\n                setTimeout(function () {\n                    SceneOptimizer._CheckCurrentState(scene, options, 0, onSuccess, onFailure);\n                }, options.trackerDuration);\n            });\n        };\n        return SceneOptimizer;\n    }());\n    BABYLON.SceneOptimizer = SceneOptimizer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sceneOptimizer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var OutlineRenderer = (function () {\n        function OutlineRenderer(scene) {\n            this.zOffset = 1;\n            this._scene = scene;\n        }\n        OutlineRenderer.prototype.render = function (subMesh, batch, useOverlay) {\n            var _this = this;\n            if (useOverlay === void 0) { useOverlay = false; }\n            var scene = this._scene;\n            var engine = this._scene.getEngine();\n            var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);\n            if (!this.isReady(subMesh, hardwareInstancedRendering)) {\n                return;\n            }\n            var mesh = subMesh.getRenderingMesh();\n            var material = subMesh.getMaterial();\n            engine.enableEffect(this._effect);\n            this._effect.setFloat(\"offset\", useOverlay ? 0 : mesh.outlineWidth);\n            this._effect.setColor4(\"color\", useOverlay ? mesh.overlayColor : mesh.outlineColor, useOverlay ? mesh.overlayAlpha : material.alpha);\n            this._effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                this._effect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n            }\n            mesh._bind(subMesh, this._effect, BABYLON.Material.TriangleFillMode);\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                var alphaTexture = material.getAlphaTestTexture();\n                this._effect.setTexture(\"diffuseSampler\", alphaTexture);\n                this._effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n            }\n            engine.setZOffset(-this.zOffset);\n            mesh._processRendering(subMesh, this._effect, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { _this._effect.setMatrix(\"world\", world); });\n            engine.setZOffset(0);\n        };\n        OutlineRenderer.prototype.isReady = function (subMesh, useInstances) {\n            var defines = [];\n            var attribs = [BABYLON.VertexBuffer.PositionKind, BABYLON.VertexBuffer.NormalKind];\n            var mesh = subMesh.getMesh();\n            var material = subMesh.getMaterial();\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                defines.push(\"#define ALPHATEST\");\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                    attribs.push(BABYLON.VertexBuffer.UVKind);\n                    defines.push(\"#define UV1\");\n                }\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind)) {\n                    attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                    defines.push(\"#define UV2\");\n                }\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect      \n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._effect = this._scene.getEngine().createEffect(\"outline\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"offset\", \"color\"], [\"diffuseSampler\"], join);\n            }\n            return this._effect.isReady();\n        };\n        return OutlineRenderer;\n    }());\n    BABYLON.OutlineRenderer = OutlineRenderer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.outlineRenderer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var FaceAdjacencies = (function () {\n        function FaceAdjacencies() {\n            this.edges = new Array();\n            this.edgesConnectedCount = 0;\n        }\n        return FaceAdjacencies;\n    }());\n    var EdgesRenderer = (function () {\n        // Beware when you use this class with complex objects as the adjacencies computation can be really long\n        function EdgesRenderer(source, epsilon, checkVerticesInsteadOfIndices) {\n            if (epsilon === void 0) { epsilon = 0.95; }\n            if (checkVerticesInsteadOfIndices === void 0) { checkVerticesInsteadOfIndices = false; }\n            this.edgesWidthScalerForOrthographic = 1000.0;\n            this.edgesWidthScalerForPerspective = 50.0;\n            this._linesPositions = new Array();\n            this._linesNormals = new Array();\n            this._linesIndices = new Array();\n            this._buffers = {};\n            this._checkVerticesInsteadOfIndices = false;\n            this._source = source;\n            this._checkVerticesInsteadOfIndices = checkVerticesInsteadOfIndices;\n            this._epsilon = epsilon;\n            this._prepareRessources();\n            this._generateEdgesLines();\n        }\n        EdgesRenderer.prototype._prepareRessources = function () {\n            if (this._lineShader) {\n                return;\n            }\n            this._lineShader = new BABYLON.ShaderMaterial(\"lineShader\", this._source.getScene(), \"line\", {\n                attributes: [\"position\", \"normal\"],\n                uniforms: [\"worldViewProjection\", \"color\", \"width\", \"aspectRatio\"]\n            });\n            this._lineShader.disableDepthWrite = true;\n            this._lineShader.backFaceCulling = false;\n        };\n        EdgesRenderer.prototype.dispose = function () {\n            var buffer = this._buffers[BABYLON.VertexBuffer.PositionKind];\n            if (buffer) {\n                buffer.dispose();\n                this._buffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            buffer = this._buffers[BABYLON.VertexBuffer.NormalKind];\n            if (buffer) {\n                buffer.dispose();\n                this._buffers[BABYLON.VertexBuffer.NormalKind] = null;\n            }\n            this._source.getScene().getEngine()._releaseBuffer(this._ib);\n            this._lineShader.dispose();\n        };\n        EdgesRenderer.prototype._processEdgeForAdjacencies = function (pa, pb, p0, p1, p2) {\n            if (pa === p0 && pb === p1 || pa === p1 && pb === p0) {\n                return 0;\n            }\n            if (pa === p1 && pb === p2 || pa === p2 && pb === p1) {\n                return 1;\n            }\n            if (pa === p2 && pb === p0 || pa === p0 && pb === p2) {\n                return 2;\n            }\n            return -1;\n        };\n        EdgesRenderer.prototype._processEdgeForAdjacenciesWithVertices = function (pa, pb, p0, p1, p2) {\n            if (pa.equalsWithEpsilon(p0) && pb.equalsWithEpsilon(p1) || pa.equalsWithEpsilon(p1) && pb.equalsWithEpsilon(p0)) {\n                return 0;\n            }\n            if (pa.equalsWithEpsilon(p1) && pb.equalsWithEpsilon(p2) || pa.equalsWithEpsilon(p2) && pb.equalsWithEpsilon(p1)) {\n                return 1;\n            }\n            if (pa.equalsWithEpsilon(p2) && pb.equalsWithEpsilon(p0) || pa.equalsWithEpsilon(p0) && pb.equalsWithEpsilon(p2)) {\n                return 2;\n            }\n            return -1;\n        };\n        EdgesRenderer.prototype._checkEdge = function (faceIndex, edge, faceNormals, p0, p1) {\n            var needToCreateLine;\n            if (edge === undefined) {\n                needToCreateLine = true;\n            }\n            else {\n                var dotProduct = BABYLON.Vector3.Dot(faceNormals[faceIndex], faceNormals[edge]);\n                needToCreateLine = dotProduct < this._epsilon;\n            }\n            if (needToCreateLine) {\n                var offset = this._linesPositions.length / 3;\n                var normal = p0.subtract(p1);\n                normal.normalize();\n                // Positions\n                this._linesPositions.push(p0.x);\n                this._linesPositions.push(p0.y);\n                this._linesPositions.push(p0.z);\n                this._linesPositions.push(p0.x);\n                this._linesPositions.push(p0.y);\n                this._linesPositions.push(p0.z);\n                this._linesPositions.push(p1.x);\n                this._linesPositions.push(p1.y);\n                this._linesPositions.push(p1.z);\n                this._linesPositions.push(p1.x);\n                this._linesPositions.push(p1.y);\n                this._linesPositions.push(p1.z);\n                // Normals\n                this._linesNormals.push(p1.x);\n                this._linesNormals.push(p1.y);\n                this._linesNormals.push(p1.z);\n                this._linesNormals.push(-1);\n                this._linesNormals.push(p1.x);\n                this._linesNormals.push(p1.y);\n                this._linesNormals.push(p1.z);\n                this._linesNormals.push(1);\n                this._linesNormals.push(p0.x);\n                this._linesNormals.push(p0.y);\n                this._linesNormals.push(p0.z);\n                this._linesNormals.push(-1);\n                this._linesNormals.push(p0.x);\n                this._linesNormals.push(p0.y);\n                this._linesNormals.push(p0.z);\n                this._linesNormals.push(1);\n                // Indices\n                this._linesIndices.push(offset);\n                this._linesIndices.push(offset + 1);\n                this._linesIndices.push(offset + 2);\n                this._linesIndices.push(offset);\n                this._linesIndices.push(offset + 2);\n                this._linesIndices.push(offset + 3);\n            }\n        };\n        EdgesRenderer.prototype._generateEdgesLines = function () {\n            var positions = this._source.getVerticesData(BABYLON.VertexBuffer.PositionKind);\n            var indices = this._source.getIndices();\n            // First let's find adjacencies\n            var adjacencies = new Array();\n            var faceNormals = new Array();\n            var index;\n            var faceAdjacencies;\n            // Prepare faces\n            for (index = 0; index < indices.length; index += 3) {\n                faceAdjacencies = new FaceAdjacencies();\n                var p0Index = indices[index];\n                var p1Index = indices[index + 1];\n                var p2Index = indices[index + 2];\n                faceAdjacencies.p0 = new BABYLON.Vector3(positions[p0Index * 3], positions[p0Index * 3 + 1], positions[p0Index * 3 + 2]);\n                faceAdjacencies.p1 = new BABYLON.Vector3(positions[p1Index * 3], positions[p1Index * 3 + 1], positions[p1Index * 3 + 2]);\n                faceAdjacencies.p2 = new BABYLON.Vector3(positions[p2Index * 3], positions[p2Index * 3 + 1], positions[p2Index * 3 + 2]);\n                var faceNormal = BABYLON.Vector3.Cross(faceAdjacencies.p1.subtract(faceAdjacencies.p0), faceAdjacencies.p2.subtract(faceAdjacencies.p1));\n                faceNormal.normalize();\n                faceNormals.push(faceNormal);\n                adjacencies.push(faceAdjacencies);\n            }\n            // Scan\n            for (index = 0; index < adjacencies.length; index++) {\n                faceAdjacencies = adjacencies[index];\n                for (var otherIndex = index + 1; otherIndex < adjacencies.length; otherIndex++) {\n                    var otherFaceAdjacencies = adjacencies[otherIndex];\n                    if (faceAdjacencies.edgesConnectedCount === 3) {\n                        break;\n                    }\n                    if (otherFaceAdjacencies.edgesConnectedCount === 3) {\n                        continue;\n                    }\n                    var otherP0 = indices[otherIndex * 3];\n                    var otherP1 = indices[otherIndex * 3 + 1];\n                    var otherP2 = indices[otherIndex * 3 + 2];\n                    for (var edgeIndex = 0; edgeIndex < 3; edgeIndex++) {\n                        var otherEdgeIndex;\n                        if (faceAdjacencies.edges[edgeIndex] !== undefined) {\n                            continue;\n                        }\n                        switch (edgeIndex) {\n                            case 0:\n                                if (this._checkVerticesInsteadOfIndices) {\n                                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p0, faceAdjacencies.p1, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                                }\n                                else {\n                                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3], indices[index * 3 + 1], otherP0, otherP1, otherP2);\n                                }\n                                break;\n                            case 1:\n                                if (this._checkVerticesInsteadOfIndices) {\n                                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p1, faceAdjacencies.p2, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                                }\n                                else {\n                                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 1], indices[index * 3 + 2], otherP0, otherP1, otherP2);\n                                }\n                                break;\n                            case 2:\n                                if (this._checkVerticesInsteadOfIndices) {\n                                    otherEdgeIndex = this._processEdgeForAdjacenciesWithVertices(faceAdjacencies.p2, faceAdjacencies.p0, otherFaceAdjacencies.p0, otherFaceAdjacencies.p1, otherFaceAdjacencies.p2);\n                                }\n                                else {\n                                    otherEdgeIndex = this._processEdgeForAdjacencies(indices[index * 3 + 2], indices[index * 3], otherP0, otherP1, otherP2);\n                                }\n                                break;\n                        }\n                        if (otherEdgeIndex === -1) {\n                            continue;\n                        }\n                        faceAdjacencies.edges[edgeIndex] = otherIndex;\n                        otherFaceAdjacencies.edges[otherEdgeIndex] = index;\n                        faceAdjacencies.edgesConnectedCount++;\n                        otherFaceAdjacencies.edgesConnectedCount++;\n                        if (faceAdjacencies.edgesConnectedCount === 3) {\n                            break;\n                        }\n                    }\n                }\n            }\n            // Create lines\n            for (index = 0; index < adjacencies.length; index++) {\n                // We need a line when a face has no adjacency on a specific edge or if all the adjacencies has an angle greater than epsilon\n                var current = adjacencies[index];\n                this._checkEdge(index, current.edges[0], faceNormals, current.p0, current.p1);\n                this._checkEdge(index, current.edges[1], faceNormals, current.p1, current.p2);\n                this._checkEdge(index, current.edges[2], faceNormals, current.p2, current.p0);\n            }\n            // Merge into a single mesh\n            var engine = this._source.getScene().getEngine();\n            this._buffers[BABYLON.VertexBuffer.PositionKind] = new BABYLON.VertexBuffer(engine, this._linesPositions, BABYLON.VertexBuffer.PositionKind, false);\n            this._buffers[BABYLON.VertexBuffer.NormalKind] = new BABYLON.VertexBuffer(engine, this._linesNormals, BABYLON.VertexBuffer.NormalKind, false, false, 4);\n            this._ib = engine.createIndexBuffer(this._linesIndices);\n            this._indicesCount = this._linesIndices.length;\n        };\n        EdgesRenderer.prototype.render = function () {\n            if (!this._lineShader.isReady()) {\n                return;\n            }\n            var scene = this._source.getScene();\n            var engine = scene.getEngine();\n            this._lineShader._preBind();\n            // VBOs\n            engine.bindBuffers(this._buffers, this._ib, this._lineShader.getEffect());\n            scene.resetCachedMaterial();\n            this._lineShader.setColor4(\"color\", this._source.edgesColor);\n            if (scene.activeCamera.mode === BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {\n                this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForOrthographic);\n            }\n            else {\n                this._lineShader.setFloat(\"width\", this._source.edgesWidth / this.edgesWidthScalerForPerspective);\n            }\n            this._lineShader.setFloat(\"aspectRatio\", engine.getAspectRatio(scene.activeCamera));\n            this._lineShader.bind(this._source.getWorldMatrix());\n            // Draw order\n            engine.draw(true, 0, this._indicesCount);\n            this._lineShader.unbind();\n            engine.setDepthWrite(true);\n        };\n        return EdgesRenderer;\n    }());\n    BABYLON.EdgesRenderer = EdgesRenderer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.edgesRenderer.js.map\n\n/// <reference path=\"..\\PostProcess\\babylon.postProcess.ts\" />\n/// <reference path=\"..\\Math\\babylon.math.ts\" />\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * Special Glow Blur post process only blurring the alpha channel\n     * It enforces keeping the most luminous color in the color channel.\n     */\n    var GlowBlurPostProcess = (function (_super) {\n        __extends(GlowBlurPostProcess, _super);\n        function GlowBlurPostProcess(name, direction, kernel, options, camera, samplingMode, engine, reusable) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.BILINEAR_SAMPLINGMODE; }\n            var _this = _super.call(this, name, \"glowBlurPostProcess\", [\"screenSize\", \"direction\", \"blurWidth\"], null, options, camera, samplingMode, engine, reusable) || this;\n            _this.direction = direction;\n            _this.kernel = kernel;\n            _this.onApplyObservable.add(function (effect) {\n                effect.setFloat2(\"screenSize\", _this.width, _this.height);\n                effect.setVector2(\"direction\", _this.direction);\n                effect.setFloat(\"blurWidth\", _this.kernel);\n            });\n            return _this;\n        }\n        return GlowBlurPostProcess;\n    }(BABYLON.PostProcess));\n    /**\n     * The highlight layer Helps adding a glow effect around a mesh.\n     *\n     * Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove\n     * glowy meshes to your scene.\n     *\n     * !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!\n     */\n    var HighlightLayer = (function () {\n        /**\n         * Instantiates a new highlight Layer and references it to the scene..\n         * @param name The name of the layer\n         * @param scene The scene to use the layer in\n         * @param options Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)\n         */\n        function HighlightLayer(name, scene, options) {\n            this.name = name;\n            this._vertexBuffers = {};\n            this._mainTextureDesiredSize = { width: 0, height: 0 };\n            this._meshes = {};\n            this._maxSize = 0;\n            this._shouldRender = false;\n            this._instanceGlowingMeshStencilReference = HighlightLayer.glowingMeshStencilReference++;\n            this._excludedMeshes = {};\n            /**\n             * Specifies whether or not the inner glow is ACTIVE in the layer.\n             */\n            this.innerGlow = true;\n            /**\n             * Specifies whether or not the outer glow is ACTIVE in the layer.\n             */\n            this.outerGlow = true;\n            /**\n             * Specifies wether the highlight layer is enabled or not.\n             */\n            this.isEnabled = true;\n            /**\n             * An event triggered when the highlight layer has been disposed.\n             * @type {BABYLON.Observable}\n             */\n            this.onDisposeObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the highlight layer is about rendering the main texture with the glowy parts.\n             * @type {BABYLON.Observable}\n             */\n            this.onBeforeRenderMainTextureObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the highlight layer is being blurred.\n             * @type {BABYLON.Observable}\n             */\n            this.onBeforeBlurObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the highlight layer has been blurred.\n             * @type {BABYLON.Observable}\n             */\n            this.onAfterBlurObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the glowing blurred texture is being merged in the scene.\n             * @type {BABYLON.Observable}\n             */\n            this.onBeforeComposeObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the glowing blurred texture has been merged in the scene.\n             * @type {BABYLON.Observable}\n             */\n            this.onAfterComposeObservable = new BABYLON.Observable();\n            /**\n             * An event triggered when the highlight layer changes its size.\n             * @type {BABYLON.Observable}\n             */\n            this.onSizeChangedObservable = new BABYLON.Observable();\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            var engine = scene.getEngine();\n            this._engine = engine;\n            this._maxSize = this._engine.getCaps().maxTextureSize;\n            this._scene.highlightLayers.push(this);\n            // Warn on stencil.\n            if (!this._engine.isStencilEnable) {\n                BABYLON.Tools.Warn(\"Rendering the Highlight Layer requires the stencil to be active on the canvas. var engine = new BABYLON.Engine(canvas, antialias, { stencil: true }\");\n            }\n            // Adapt options\n            this._options = options || {\n                mainTextureRatio: 0.25,\n                blurTextureSizeRatio: 0.5,\n                blurHorizontalSize: 1,\n                blurVerticalSize: 1,\n                alphaBlendingMode: BABYLON.Engine.ALPHA_COMBINE\n            };\n            this._options.mainTextureRatio = this._options.mainTextureRatio || 0.25;\n            this._options.blurTextureSizeRatio = this._options.blurTextureSizeRatio || 0.5;\n            this._options.blurHorizontalSize = this._options.blurHorizontalSize || 1;\n            this._options.blurVerticalSize = this._options.blurVerticalSize || 1;\n            this._options.alphaBlendingMode = this._options.alphaBlendingMode || BABYLON.Engine.ALPHA_COMBINE;\n            // VBO\n            var vertices = [];\n            vertices.push(1, 1);\n            vertices.push(-1, 1);\n            vertices.push(-1, -1);\n            vertices.push(1, -1);\n            var vertexBuffer = new BABYLON.VertexBuffer(engine, vertices, BABYLON.VertexBuffer.PositionKind, false, false, 2);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = vertexBuffer;\n            // Indices\n            var indices = [];\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            this._indexBuffer = engine.createIndexBuffer(indices);\n            // Effect\n            this._glowMapMergeEffect = engine.createEffect(\"glowMapMerge\", [BABYLON.VertexBuffer.PositionKind], [\"offset\"], [\"textureSampler\"], \"\");\n            // Render target\n            this.setMainTextureSize();\n            // Create Textures and post processes\n            this.createTextureAndPostProcesses();\n        }\n        Object.defineProperty(HighlightLayer.prototype, \"blurHorizontalSize\", {\n            /**\n             * Gets the horizontal size of the blur.\n             */\n            get: function () {\n                return this._horizontalBlurPostprocess.kernel;\n            },\n            /**\n             * Specifies the horizontal size of the blur.\n             */\n            set: function (value) {\n                this._horizontalBlurPostprocess.kernel = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(HighlightLayer.prototype, \"blurVerticalSize\", {\n            /**\n             * Gets the vertical size of the blur.\n             */\n            get: function () {\n                return this._verticalBlurPostprocess.kernel;\n            },\n            /**\n             * Specifies the vertical size of the blur.\n             */\n            set: function (value) {\n                this._verticalBlurPostprocess.kernel = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(HighlightLayer.prototype, \"camera\", {\n            /**\n             * Gets the camera attached to the layer.\n             */\n            get: function () {\n                return this._options.camera;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Creates the render target textures and post processes used in the highlight layer.\n         */\n        HighlightLayer.prototype.createTextureAndPostProcesses = function () {\n            var _this = this;\n            var blurTextureWidth = this._mainTextureDesiredSize.width * this._options.blurTextureSizeRatio;\n            var blurTextureHeight = this._mainTextureDesiredSize.height * this._options.blurTextureSizeRatio;\n            blurTextureWidth = BABYLON.Tools.GetExponentOfTwo(blurTextureWidth, this._maxSize);\n            blurTextureHeight = BABYLON.Tools.GetExponentOfTwo(blurTextureHeight, this._maxSize);\n            this._mainTexture = new BABYLON.RenderTargetTexture(\"HighlightLayerMainRTT\", {\n                width: this._mainTextureDesiredSize.width,\n                height: this._mainTextureDesiredSize.height\n            }, this._scene, false, true, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this._mainTexture.activeCamera = this._options.camera;\n            this._mainTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._mainTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._mainTexture.anisotropicFilteringLevel = 1;\n            this._mainTexture.updateSamplingMode(BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n            this._mainTexture.renderParticles = false;\n            this._mainTexture.renderList = null;\n            this._blurTexture = new BABYLON.RenderTargetTexture(\"HighlightLayerBlurRTT\", {\n                width: blurTextureWidth,\n                height: blurTextureHeight\n            }, this._scene, false, true, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            this._blurTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._blurTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            this._blurTexture.anisotropicFilteringLevel = 16;\n            this._blurTexture.updateSamplingMode(BABYLON.Texture.TRILINEAR_SAMPLINGMODE);\n            this._blurTexture.renderParticles = false;\n            this._downSamplePostprocess = new BABYLON.PassPostProcess(\"HighlightLayerPPP\", this._options.blurTextureSizeRatio, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n            this._downSamplePostprocess.onApplyObservable.add(function (effect) {\n                effect.setTexture(\"textureSampler\", _this._mainTexture);\n            });\n            if (this._options.alphaBlendingMode === BABYLON.Engine.ALPHA_COMBINE) {\n                this._horizontalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerHBP\", new BABYLON.Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n                this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n                });\n                this._verticalBlurPostprocess = new GlowBlurPostProcess(\"HighlightLayerVBP\", new BABYLON.Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n                this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n                });\n            }\n            else {\n                this._horizontalBlurPostprocess = new BABYLON.BlurPostProcess(\"HighlightLayerHBP\", new BABYLON.Vector2(1.0, 0), this._options.blurHorizontalSize, 1, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n                this._horizontalBlurPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n                });\n                this._verticalBlurPostprocess = new BABYLON.BlurPostProcess(\"HighlightLayerVBP\", new BABYLON.Vector2(0, 1.0), this._options.blurVerticalSize, 1, null, BABYLON.Texture.BILINEAR_SAMPLINGMODE, this._scene.getEngine());\n                this._verticalBlurPostprocess.onApplyObservable.add(function (effect) {\n                    effect.setFloat2(\"screenSize\", blurTextureWidth, blurTextureHeight);\n                });\n            }\n            this._mainTexture.onAfterUnbindObservable.add(function () {\n                _this.onBeforeBlurObservable.notifyObservers(_this);\n                _this._scene.postProcessManager.directRender([_this._downSamplePostprocess, _this._horizontalBlurPostprocess, _this._verticalBlurPostprocess], _this._blurTexture.getInternalTexture());\n                _this.onAfterBlurObservable.notifyObservers(_this);\n            });\n            // Custom render function\n            var renderSubMesh = function (subMesh) {\n                var mesh = subMesh.getRenderingMesh();\n                var scene = _this._scene;\n                var engine = scene.getEngine();\n                // Culling\n                engine.setState(subMesh.getMaterial().backFaceCulling);\n                // Managing instances\n                var batch = mesh._getInstancesRenderList(subMesh._id);\n                if (batch.mustReturn) {\n                    return;\n                }\n                // Excluded Mesh\n                if (_this._excludedMeshes[mesh.uniqueId]) {\n                    return;\n                }\n                ;\n                var hardwareInstancedRendering = (engine.getCaps().instancedArrays) && (batch.visibleInstances[subMesh._id] !== null) && (batch.visibleInstances[subMesh._id] !== undefined);\n                var highlightLayerMesh = _this._meshes[mesh.uniqueId];\n                var material = subMesh.getMaterial();\n                var emissiveTexture = null;\n                if (highlightLayerMesh && highlightLayerMesh.glowEmissiveOnly && material) {\n                    emissiveTexture = material.emissiveTexture;\n                }\n                if (_this.isReady(subMesh, hardwareInstancedRendering, emissiveTexture)) {\n                    engine.enableEffect(_this._glowMapGenerationEffect);\n                    mesh._bind(subMesh, _this._glowMapGenerationEffect, BABYLON.Material.TriangleFillMode);\n                    _this._glowMapGenerationEffect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                    if (highlightLayerMesh) {\n                        _this._glowMapGenerationEffect.setFloat4(\"color\", highlightLayerMesh.color.r, highlightLayerMesh.color.g, highlightLayerMesh.color.b, 1.0);\n                    }\n                    else {\n                        _this._glowMapGenerationEffect.setFloat4(\"color\", HighlightLayer.neutralColor.r, HighlightLayer.neutralColor.g, HighlightLayer.neutralColor.b, HighlightLayer.neutralColor.a);\n                    }\n                    // Alpha test\n                    if (material && material.needAlphaTesting()) {\n                        var alphaTexture = material.getAlphaTestTexture();\n                        _this._glowMapGenerationEffect.setTexture(\"diffuseSampler\", alphaTexture);\n                        _this._glowMapGenerationEffect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                    // Glow emissive only\n                    if (emissiveTexture) {\n                        _this._glowMapGenerationEffect.setTexture(\"emissiveSampler\", emissiveTexture);\n                        _this._glowMapGenerationEffect.setMatrix(\"emissiveMatrix\", emissiveTexture.getTextureMatrix());\n                    }\n                    // Bones\n                    if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                        _this._glowMapGenerationEffect.setMatrices(\"mBones\", mesh.skeleton.getTransformMatrices(mesh));\n                    }\n                    // Draw\n                    mesh._processRendering(subMesh, _this._glowMapGenerationEffect, BABYLON.Material.TriangleFillMode, batch, hardwareInstancedRendering, function (isInstance, world) { return _this._glowMapGenerationEffect.setMatrix(\"world\", world); });\n                }\n                else {\n                    // Need to reset refresh rate of the shadowMap\n                    _this._mainTexture.resetRefreshCounter();\n                }\n            };\n            this._mainTexture.customRenderFunction = function (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes) {\n                _this.onBeforeRenderMainTextureObservable.notifyObservers(_this);\n                var index;\n                for (index = 0; index < opaqueSubMeshes.length; index++) {\n                    renderSubMesh(opaqueSubMeshes.data[index]);\n                }\n                for (index = 0; index < alphaTestSubMeshes.length; index++) {\n                    renderSubMesh(alphaTestSubMeshes.data[index]);\n                }\n                for (index = 0; index < transparentSubMeshes.length; index++) {\n                    renderSubMesh(transparentSubMeshes.data[index]);\n                }\n            };\n            this._mainTexture.onClearObservable.add(function (engine) {\n                engine.clear(HighlightLayer.neutralColor, true, true, true);\n            });\n        };\n        /**\n         * Checks for the readiness of the element composing the layer.\n         * @param subMesh the mesh to check for\n         * @param useInstances specify wether or not to use instances to render the mesh\n         * @param emissiveTexture the associated emissive texture used to generate the glow\n         * @return true if ready otherwise, false\n         */\n        HighlightLayer.prototype.isReady = function (subMesh, useInstances, emissiveTexture) {\n            if (!subMesh.getMaterial().isReady(subMesh.getMesh(), useInstances)) {\n                return false;\n            }\n            var defines = [];\n            var attribs = [BABYLON.VertexBuffer.PositionKind];\n            var mesh = subMesh.getMesh();\n            var material = subMesh.getMaterial();\n            var uv1 = false;\n            var uv2 = false;\n            // Alpha test\n            if (material && material.needAlphaTesting()) {\n                var alphaTexture = material.getAlphaTestTexture();\n                if (alphaTexture) {\n                    defines.push(\"#define ALPHATEST\");\n                    if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind) &&\n                        alphaTexture.coordinatesIndex === 1) {\n                        defines.push(\"#define DIFFUSEUV2\");\n                        uv2 = true;\n                    }\n                    else if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                        defines.push(\"#define DIFFUSEUV1\");\n                        uv1 = true;\n                    }\n                }\n            }\n            // Emissive\n            if (emissiveTexture) {\n                defines.push(\"#define EMISSIVE\");\n                if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UV2Kind) &&\n                    emissiveTexture.coordinatesIndex === 1) {\n                    defines.push(\"#define EMISSIVEUV2\");\n                    uv2 = true;\n                }\n                else if (mesh.isVerticesDataPresent(BABYLON.VertexBuffer.UVKind)) {\n                    defines.push(\"#define EMISSIVEUV1\");\n                    uv1 = true;\n                }\n            }\n            if (uv1) {\n                attribs.push(BABYLON.VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n            }\n            if (uv2) {\n                attribs.push(BABYLON.VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n            }\n            // Bones\n            if (mesh.useBones && mesh.computeBonesUsingShaders) {\n                attribs.push(BABYLON.VertexBuffer.MatricesIndicesKind);\n                attribs.push(BABYLON.VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(BABYLON.VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(BABYLON.VertexBuffer.MatricesWeightsExtraKind);\n                }\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                defines.push(\"#define BonesPerMesh \" + (mesh.skeleton.bones.length + 1));\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Instances\n            if (useInstances) {\n                defines.push(\"#define INSTANCES\");\n                attribs.push(\"world0\");\n                attribs.push(\"world1\");\n                attribs.push(\"world2\");\n                attribs.push(\"world3\");\n            }\n            // Get correct effect      \n            var join = defines.join(\"\\n\");\n            if (this._cachedDefines !== join) {\n                this._cachedDefines = join;\n                this._glowMapGenerationEffect = this._scene.getEngine().createEffect(\"glowMapGeneration\", attribs, [\"world\", \"mBones\", \"viewProjection\", \"diffuseMatrix\", \"color\", \"emissiveMatrix\"], [\"diffuseSampler\", \"emissiveSampler\"], join);\n            }\n            return this._glowMapGenerationEffect.isReady();\n        };\n        /**\n         * Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.\n         */\n        HighlightLayer.prototype.render = function () {\n            var currentEffect = this._glowMapMergeEffect;\n            // Check\n            if (!currentEffect.isReady() || !this._blurTexture.isReady())\n                return;\n            var engine = this._scene.getEngine();\n            this.onBeforeComposeObservable.notifyObservers(this);\n            // Render\n            engine.enableEffect(currentEffect);\n            engine.setState(false);\n            // Cache\n            var previousStencilBuffer = engine.getStencilBuffer();\n            var previousStencilFunction = engine.getStencilFunction();\n            var previousStencilMask = engine.getStencilMask();\n            var previousStencilOperationPass = engine.getStencilOperationPass();\n            var previousStencilOperationFail = engine.getStencilOperationFail();\n            var previousStencilOperationDepthFail = engine.getStencilOperationDepthFail();\n            var previousAlphaMode = engine.getAlphaMode();\n            // Texture\n            currentEffect.setTexture(\"textureSampler\", this._blurTexture);\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\n            // Stencil operations\n            engine.setStencilOperationPass(BABYLON.Engine.REPLACE);\n            engine.setStencilOperationFail(BABYLON.Engine.KEEP);\n            engine.setStencilOperationDepthFail(BABYLON.Engine.KEEP);\n            // Draw order\n            engine.setAlphaMode(this._options.alphaBlendingMode);\n            engine.setStencilMask(0x00);\n            engine.setStencilBuffer(true);\n            engine.setStencilFunctionReference(this._instanceGlowingMeshStencilReference);\n            if (this.outerGlow) {\n                currentEffect.setFloat(\"offset\", 0);\n                engine.setStencilFunction(BABYLON.Engine.NOTEQUAL);\n                engine.draw(true, 0, 6);\n            }\n            if (this.innerGlow) {\n                currentEffect.setFloat(\"offset\", 1);\n                engine.setStencilFunction(BABYLON.Engine.EQUAL);\n                engine.draw(true, 0, 6);\n            }\n            // Restore Cache\n            engine.setStencilFunction(previousStencilFunction);\n            engine.setStencilMask(previousStencilMask);\n            engine.setAlphaMode(previousAlphaMode);\n            engine.setStencilBuffer(previousStencilBuffer);\n            engine.setStencilOperationPass(previousStencilOperationPass);\n            engine.setStencilOperationFail(previousStencilOperationFail);\n            engine.setStencilOperationDepthFail(previousStencilOperationDepthFail);\n            engine._stencilState.reset();\n            this.onAfterComposeObservable.notifyObservers(this);\n            // Handle size changes.\n            var size = this._mainTexture.getSize();\n            this.setMainTextureSize();\n            if (size.width !== this._mainTextureDesiredSize.width || size.height !== this._mainTextureDesiredSize.height) {\n                // Recreate RTT and post processes on size change.\n                this.onSizeChangedObservable.notifyObservers(this);\n                this.disposeTextureAndPostProcesses();\n                this.createTextureAndPostProcesses();\n            }\n        };\n        /**\n         * Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.\n         * @param mesh The mesh to exclude from the highlight layer\n         */\n        HighlightLayer.prototype.addExcludedMesh = function (mesh) {\n            var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n            if (!meshExcluded) {\n                this._excludedMeshes[mesh.uniqueId] = {\n                    mesh: mesh,\n                    beforeRender: mesh.onBeforeRenderObservable.add(function (mesh) {\n                        mesh.getEngine().setStencilBuffer(false);\n                    }),\n                    afterRender: mesh.onAfterRenderObservable.add(function (mesh) {\n                        mesh.getEngine().setStencilBuffer(true);\n                    }),\n                };\n            }\n        };\n        /**\n          * Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.\n          * @param mesh The mesh to highlight\n          */\n        HighlightLayer.prototype.removeExcludedMesh = function (mesh) {\n            var meshExcluded = this._excludedMeshes[mesh.uniqueId];\n            if (meshExcluded) {\n                mesh.onBeforeRenderObservable.remove(meshExcluded.beforeRender);\n                mesh.onAfterRenderObservable.remove(meshExcluded.afterRender);\n            }\n            this._excludedMeshes[mesh.uniqueId] = undefined;\n        };\n        /**\n         * Add a mesh in the highlight layer in order to make it glow with the chosen color.\n         * @param mesh The mesh to highlight\n         * @param color The color of the highlight\n         * @param glowEmissiveOnly Extract the glow from the emissive texture\n         */\n        HighlightLayer.prototype.addMesh = function (mesh, color, glowEmissiveOnly) {\n            var _this = this;\n            if (glowEmissiveOnly === void 0) { glowEmissiveOnly = false; }\n            var meshHighlight = this._meshes[mesh.uniqueId];\n            if (meshHighlight) {\n                meshHighlight.color = color;\n            }\n            else {\n                this._meshes[mesh.uniqueId] = {\n                    mesh: mesh,\n                    color: color,\n                    // Lambda required for capture due to Observable this context\n                    observerHighlight: mesh.onBeforeRenderObservable.add(function (mesh) {\n                        if (_this._excludedMeshes[mesh.uniqueId]) {\n                            _this.defaultStencilReference(mesh);\n                        }\n                        else {\n                            mesh.getScene().getEngine().setStencilFunctionReference(_this._instanceGlowingMeshStencilReference);\n                        }\n                    }),\n                    observerDefault: mesh.onAfterRenderObservable.add(this.defaultStencilReference),\n                    glowEmissiveOnly: glowEmissiveOnly\n                };\n            }\n            this._shouldRender = true;\n        };\n        /**\n         * Remove a mesh from the highlight layer in order to make it stop glowing.\n         * @param mesh The mesh to highlight\n         */\n        HighlightLayer.prototype.removeMesh = function (mesh) {\n            var meshHighlight = this._meshes[mesh.uniqueId];\n            if (meshHighlight) {\n                mesh.onBeforeRenderObservable.remove(meshHighlight.observerHighlight);\n                mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n            }\n            this._meshes[mesh.uniqueId] = undefined;\n            this._shouldRender = false;\n            for (var meshHighlightToCheck in this._meshes) {\n                if (meshHighlightToCheck) {\n                    this._shouldRender = true;\n                    break;\n                }\n            }\n        };\n        /**\n         * Returns true if the layer contains information to display, otherwise false.\n         */\n        HighlightLayer.prototype.shouldRender = function () {\n            return this.isEnabled && this._shouldRender;\n        };\n        /**\n         * Sets the main texture desired size which is the closest power of two\n         * of the engine canvas size.\n         */\n        HighlightLayer.prototype.setMainTextureSize = function () {\n            if (this._options.mainTextureFixedSize) {\n                this._mainTextureDesiredSize.width = this._options.mainTextureFixedSize;\n                this._mainTextureDesiredSize.height = this._options.mainTextureFixedSize;\n            }\n            else {\n                this._mainTextureDesiredSize.width = this._engine.getRenderingCanvas().width * this._options.mainTextureRatio;\n                this._mainTextureDesiredSize.height = this._engine.getRenderingCanvas().height * this._options.mainTextureRatio;\n                this._mainTextureDesiredSize.width = BABYLON.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.width, this._maxSize);\n                this._mainTextureDesiredSize.height = BABYLON.Tools.GetExponentOfTwo(this._mainTextureDesiredSize.height, this._maxSize);\n            }\n        };\n        /**\n         * Force the stencil to the normal expected value for none glowing parts\n         */\n        HighlightLayer.prototype.defaultStencilReference = function (mesh) {\n            mesh.getScene().getEngine().setStencilFunctionReference(HighlightLayer.normalMeshStencilReference);\n        };\n        /**\n         * Dispose only the render target textures and post process.\n         */\n        HighlightLayer.prototype.disposeTextureAndPostProcesses = function () {\n            this._blurTexture.dispose();\n            this._mainTexture.dispose();\n            this._downSamplePostprocess.dispose();\n            this._horizontalBlurPostprocess.dispose();\n            this._verticalBlurPostprocess.dispose();\n        };\n        /**\n         * Dispose the highlight layer and free resources.\n         */\n        HighlightLayer.prototype.dispose = function () {\n            var vertexBuffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (vertexBuffer) {\n                vertexBuffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n            // Clean textures and post processes\n            this.disposeTextureAndPostProcesses();\n            // Clean mesh references \n            for (var id in this._meshes) {\n                var meshHighlight = this._meshes[id];\n                if (meshHighlight && meshHighlight.mesh) {\n                    meshHighlight.mesh.onBeforeRenderObservable.remove(meshHighlight.observerHighlight);\n                    meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.observerDefault);\n                }\n            }\n            this._meshes = null;\n            for (var id in this._excludedMeshes) {\n                var meshHighlight = this._excludedMeshes[id];\n                if (meshHighlight) {\n                    meshHighlight.mesh.onBeforeRenderObservable.remove(meshHighlight.beforeRender);\n                    meshHighlight.mesh.onAfterRenderObservable.remove(meshHighlight.afterRender);\n                }\n            }\n            this._excludedMeshes = null;\n            // Remove from scene\n            var index = this._scene.highlightLayers.indexOf(this, 0);\n            if (index > -1) {\n                this._scene.highlightLayers.splice(index, 1);\n            }\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n            this.onBeforeRenderMainTextureObservable.clear();\n            this.onBeforeBlurObservable.clear();\n            this.onBeforeComposeObservable.clear();\n            this.onAfterComposeObservable.clear();\n            this.onSizeChangedObservable.clear();\n        };\n        return HighlightLayer;\n    }());\n    /**\n     * The neutral color used during the preparation of the glow effect.\n     * This is black by default as the blend operation is a blend operation.\n     */\n    HighlightLayer.neutralColor = new BABYLON.Color4(0, 0, 0, 0);\n    /**\n     * Stencil value used for glowing meshes.\n     */\n    HighlightLayer.glowingMeshStencilReference = 0x02;\n    /**\n     * Stencil value used for the other meshes in the scene.\n     */\n    HighlightLayer.normalMeshStencilReference = 0x01;\n    BABYLON.HighlightLayer = HighlightLayer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.highlightlayer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var MeshAssetTask = (function () {\n        function MeshAssetTask(name, meshesNames, rootUrl, sceneFilename) {\n            this.name = name;\n            this.meshesNames = meshesNames;\n            this.rootUrl = rootUrl;\n            this.sceneFilename = sceneFilename;\n            this.isCompleted = false;\n        }\n        MeshAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            BABYLON.SceneLoader.ImportMesh(this.meshesNames, this.rootUrl, this.sceneFilename, scene, function (meshes, particleSystems, skeletons) {\n                _this.loadedMeshes = meshes;\n                _this.loadedParticleSystems = particleSystems;\n                _this.loadedSkeletons = skeletons;\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            }, null, function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            });\n        };\n        return MeshAssetTask;\n    }());\n    BABYLON.MeshAssetTask = MeshAssetTask;\n    var TextFileAssetTask = (function () {\n        function TextFileAssetTask(name, url) {\n            this.name = name;\n            this.url = url;\n            this.isCompleted = false;\n        }\n        TextFileAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            BABYLON.Tools.LoadFile(this.url, function (data) {\n                _this.text = data;\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            }, null, scene.database, false, function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            });\n        };\n        return TextFileAssetTask;\n    }());\n    BABYLON.TextFileAssetTask = TextFileAssetTask;\n    var BinaryFileAssetTask = (function () {\n        function BinaryFileAssetTask(name, url) {\n            this.name = name;\n            this.url = url;\n            this.isCompleted = false;\n        }\n        BinaryFileAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            BABYLON.Tools.LoadFile(this.url, function (data) {\n                _this.data = data;\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            }, null, scene.database, true, function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            });\n        };\n        return BinaryFileAssetTask;\n    }());\n    BABYLON.BinaryFileAssetTask = BinaryFileAssetTask;\n    var ImageAssetTask = (function () {\n        function ImageAssetTask(name, url) {\n            this.name = name;\n            this.url = url;\n            this.isCompleted = false;\n        }\n        ImageAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            var img = new Image();\n            BABYLON.Tools.SetCorsBehavior(this.url, img);\n            img.onload = function () {\n                _this.image = img;\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            };\n            img.onerror = function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            };\n            img.src = this.url;\n        };\n        return ImageAssetTask;\n    }());\n    BABYLON.ImageAssetTask = ImageAssetTask;\n    var TextureAssetTask = (function () {\n        function TextureAssetTask(name, url, noMipmap, invertY, samplingMode) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            this.name = name;\n            this.url = url;\n            this.noMipmap = noMipmap;\n            this.invertY = invertY;\n            this.samplingMode = samplingMode;\n            this.isCompleted = false;\n        }\n        TextureAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            var onload = function () {\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            };\n            var onerror = function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            };\n            this.texture = new BABYLON.Texture(this.url, scene, this.noMipmap, this.invertY, this.samplingMode, onload, onerror);\n        };\n        return TextureAssetTask;\n    }());\n    BABYLON.TextureAssetTask = TextureAssetTask;\n    var CubeTextureAssetTask = (function () {\n        function CubeTextureAssetTask(name, url, extensions, noMipmap, files) {\n            this.name = name;\n            this.url = url;\n            this.extensions = extensions;\n            this.noMipmap = noMipmap;\n            this.files = files;\n            this.isCompleted = false;\n        }\n        CubeTextureAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            var onload = function () {\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            };\n            var onerror = function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            };\n            this.texture = new BABYLON.CubeTexture(this.url, scene, this.extensions, this.noMipmap, this.files, onload, onerror);\n        };\n        return CubeTextureAssetTask;\n    }());\n    BABYLON.CubeTextureAssetTask = CubeTextureAssetTask;\n    var HDRCubeTextureAssetTask = (function () {\n        function HDRCubeTextureAssetTask(name, url, size, noMipmap, generateHarmonics, useInGammaSpace, usePMREMGenerator) {\n            if (noMipmap === void 0) { noMipmap = false; }\n            if (generateHarmonics === void 0) { generateHarmonics = true; }\n            if (useInGammaSpace === void 0) { useInGammaSpace = false; }\n            if (usePMREMGenerator === void 0) { usePMREMGenerator = false; }\n            this.name = name;\n            this.url = url;\n            this.size = size;\n            this.noMipmap = noMipmap;\n            this.generateHarmonics = generateHarmonics;\n            this.useInGammaSpace = useInGammaSpace;\n            this.usePMREMGenerator = usePMREMGenerator;\n            this.isCompleted = false;\n        }\n        HDRCubeTextureAssetTask.prototype.run = function (scene, onSuccess, onError) {\n            var _this = this;\n            var onload = function () {\n                _this.isCompleted = true;\n                if (_this.onSuccess) {\n                    _this.onSuccess(_this);\n                }\n                onSuccess();\n            };\n            var onerror = function () {\n                if (_this.onError) {\n                    _this.onError(_this);\n                }\n                onError();\n            };\n            this.texture = new BABYLON.HDRCubeTexture(this.url, scene, this.size, this.noMipmap, this.generateHarmonics, this.useInGammaSpace, this.usePMREMGenerator, onload, onerror);\n        };\n        return HDRCubeTextureAssetTask;\n    }());\n    BABYLON.HDRCubeTextureAssetTask = HDRCubeTextureAssetTask;\n    var AssetsManager = (function () {\n        function AssetsManager(scene) {\n            this.tasks = new Array();\n            this.waitingTasksCount = 0;\n            this.useDefaultLoadingScreen = true;\n            this._scene = scene;\n        }\n        AssetsManager.prototype.addMeshTask = function (taskName, meshesNames, rootUrl, sceneFilename) {\n            var task = new MeshAssetTask(taskName, meshesNames, rootUrl, sceneFilename);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addTextFileTask = function (taskName, url) {\n            var task = new TextFileAssetTask(taskName, url);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addBinaryFileTask = function (taskName, url) {\n            var task = new BinaryFileAssetTask(taskName, url);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addImageTask = function (taskName, url) {\n            var task = new ImageAssetTask(taskName, url);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addTextureTask = function (taskName, url, noMipmap, invertY, samplingMode) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            var task = new TextureAssetTask(taskName, url, noMipmap, invertY, samplingMode);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addCubeTextureTask = function (name, url, extensions, noMipmap, files) {\n            var task = new CubeTextureAssetTask(name, url, extensions, noMipmap, files);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype.addHDRCubeTextureTask = function (name, url, size, noMipmap, generateHarmonics, useInGammaSpace, usePMREMGenerator) {\n            if (noMipmap === void 0) { noMipmap = false; }\n            if (generateHarmonics === void 0) { generateHarmonics = true; }\n            if (useInGammaSpace === void 0) { useInGammaSpace = false; }\n            if (usePMREMGenerator === void 0) { usePMREMGenerator = false; }\n            var task = new HDRCubeTextureAssetTask(name, url, size, noMipmap, generateHarmonics, useInGammaSpace, usePMREMGenerator);\n            this.tasks.push(task);\n            return task;\n        };\n        AssetsManager.prototype._decreaseWaitingTasksCount = function () {\n            this.waitingTasksCount--;\n            if (this.waitingTasksCount === 0) {\n                if (this.onFinish) {\n                    this.onFinish(this.tasks);\n                }\n                this._scene.getEngine().hideLoadingUI();\n            }\n        };\n        AssetsManager.prototype._runTask = function (task) {\n            var _this = this;\n            task.run(this._scene, function () {\n                if (_this.onTaskSuccess) {\n                    _this.onTaskSuccess(task);\n                }\n                _this._decreaseWaitingTasksCount();\n            }, function () {\n                if (_this.onTaskError) {\n                    _this.onTaskError(task);\n                }\n                _this._decreaseWaitingTasksCount();\n            });\n        };\n        AssetsManager.prototype.reset = function () {\n            this.tasks = new Array();\n            return this;\n        };\n        AssetsManager.prototype.load = function () {\n            this.waitingTasksCount = this.tasks.length;\n            if (this.waitingTasksCount === 0) {\n                if (this.onFinish) {\n                    this.onFinish(this.tasks);\n                }\n                return this;\n            }\n            if (this.useDefaultLoadingScreen) {\n                this._scene.getEngine().displayLoadingUI();\n            }\n            for (var index = 0; index < this.tasks.length; index++) {\n                var task = this.tasks[index];\n                this._runTask(task);\n            }\n            return this;\n        };\n        return AssetsManager;\n    }());\n    BABYLON.AssetsManager = AssetsManager;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.assetsManager.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    var MapTexture = (function (_super) {\n        __extends(MapTexture, _super);\n        function MapTexture(name, scene, size, samplingMode, useMipMap, margin) {\n            if (samplingMode === void 0) { samplingMode = BABYLON.Texture.TRILINEAR_SAMPLINGMODE; }\n            if (useMipMap === void 0) { useMipMap = false; }\n            if (margin === void 0) { margin = 0; }\n            var _this = _super.call(this, null, scene, !useMipMap, false, samplingMode) || this;\n            _this.name = name;\n            _this._size = size;\n            _this.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            _this.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            // Create the rectPackMap that will allocate portion of the texture\n            _this._rectPackingMap = new BABYLON.RectPackingMap(new BABYLON.Size(size.width, size.height), margin);\n            // Create the texture that will store the content\n            _this._texture = scene.getEngine().createRenderTargetTexture(size, { generateMipMaps: !_this.noMipmap, type: BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT });\n            return _this;\n        }\n        /**\n         * Allocate a rectangle of a given size in the texture map\n         * @param size the size of the rectangle to allocation\n         * @return the PackedRect instance corresponding to the allocated rect or null is there was not enough space to allocate it.\n         */\n        MapTexture.prototype.allocateRect = function (size) {\n            return this._rectPackingMap.addRect(size);\n        };\n        /**\n         * Free a given rectangle from the texture map\n         * @param rectInfo the instance corresponding to the rect to free.\n         */\n        MapTexture.prototype.freeRect = function (rectInfo) {\n            if (rectInfo) {\n                rectInfo.freeContent();\n            }\n        };\n        Object.defineProperty(MapTexture.prototype, \"freeSpace\", {\n            /**\n             * Return the available space in the range of [O;1]. 0 being not space left at all, 1 being an empty texture map.\n             * This is the cumulated space, not the biggest available surface. Due to fragmentation you may not allocate a rect corresponding to this surface.\n             * @returns {}\n             */\n            get: function () {\n                return this._rectPackingMap.freeSpace;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Bind the texture to the rendering engine to render in the zone of a given rectangle.\n         * Use this method when you want to render into the texture map with a clipspace set to the location and size of the given rect.\n         * Don't forget to call unbindTexture when you're done rendering\n         * @param rect the zone to render to\n         * @param clear true to clear the portion's color/depth data\n         */\n        MapTexture.prototype.bindTextureForRect = function (rect, clear) {\n            return this.bindTextureForPosSize(rect.pos, rect.contentSize, clear);\n        };\n        /**\n         * Bind the texture to the rendering engine to render in the zone of the given size at the given position.\n         * Use this method when you want to render into the texture map with a clipspace set to the location and size of the given rect.\n         * Don't forget to call unbindTexture when you're done rendering\n         * @param pos the position into the texture\n         * @param size the portion to fit the clip space to\n         * @param clear true to clear the portion's color/depth data\n         */\n        MapTexture.prototype.bindTextureForPosSize = function (pos, size, clear) {\n            var engine = this.getScene().getEngine();\n            engine.bindFramebuffer(this._texture);\n            this._replacedViewport = engine.setDirectViewport(pos.x, pos.y, size.width, size.height);\n            if (clear) {\n                // We only want to clear the part of the texture we're binding to, only the scissor can help us to achieve that\n                engine.scissorClear(pos.x, pos.y, size.width, size.height, new BABYLON.Color4(0, 0, 0, 0));\n            }\n        };\n        /**\n         * Unbind the texture map from the rendering engine.\n         * Call this method when you're done rendering. A previous call to bindTextureForRect has to be made.\n         * @param dumpForDebug if set to true the content of the texture map will be dumped to a picture file that will be sent to the internet browser.\n         */\n        MapTexture.prototype.unbindTexture = function (dumpForDebug) {\n            // Dump ?\n            if (dumpForDebug) {\n                BABYLON.Tools.DumpFramebuffer(this._size.width, this._size.height, this.getScene().getEngine());\n            }\n            var engine = this.getScene().getEngine();\n            if (this._replacedViewport) {\n                engine.setViewport(this._replacedViewport);\n                this._replacedViewport = null;\n            }\n            engine.unBindFramebuffer(this._texture);\n        };\n        Object.defineProperty(MapTexture.prototype, \"canRescale\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Note, I don't know what behavior this method should have: clone the underlying texture/rectPackingMap or just reference them?\n        // Anyway, there's not much point to use this method for this kind of texture I guess\n        MapTexture.prototype.clone = function () {\n            return null;\n        };\n        return MapTexture;\n    }(BABYLON.Texture));\n    BABYLON.MapTexture = MapTexture;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.mapTexture.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This class describe a rectangle that were added to the map.\n     * You have access to its coordinates either in pixel or normalized (UV)\n     */\n    var PackedRect = (function () {\n        function PackedRect(root, parent, pos, size) {\n            this._pos = pos;\n            this._size = size;\n            this._root = root;\n            this._parent = parent;\n            this._contentSize = null;\n            this._bottomNode = null;\n            this._leftNode = null;\n            this._initialSize = null;\n            this._rightNode = null;\n        }\n        Object.defineProperty(PackedRect.prototype, \"pos\", {\n            /**\n             * @returns the position of this node into the map\n             */\n            get: function () {\n                return this._pos;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PackedRect.prototype, \"contentSize\", {\n            /**\n             * @returns the size of the rectangle this node handles\n             */\n            get: function () {\n                return this._contentSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Retrieve the inner position (considering the margin) and stores it into the res object\n         * @param res must be a valid Vector2 that will contain the inner position after this call\n         */\n        PackedRect.prototype.getInnerPosToRef = function (res) {\n            var m = this._root._margin;\n            res.x = this._pos.x + m;\n            res.y = this._pos.y + m;\n        };\n        /**\n         * Retrieve the inner size (considering the margin) and stores it into the res object\n         * @param res must be a valid Size that will contain the inner size after this call\n         */\n        PackedRect.prototype.getInnerSizeToRef = function (res) {\n            var m = this._root._margin;\n            res.width = this._contentSize.width - (m * 2);\n            res.height = this._contentSize.height - (m * 2);\n        };\n        Object.defineProperty(PackedRect.prototype, \"UVs\", {\n            /**\n             * Compute the UV of the top/left, top/right, bottom/right, bottom/left points of the rectangle this node handles into the map\n             * @returns And array of 4 Vector2, containing UV coordinates for the four corners of the Rectangle into the map\n             */\n            get: function () {\n                if (!this._contentSize) {\n                    throw new Error(\"Can't compute UVs for this object because it's nor allocated\");\n                }\n                return this.getUVsForCustomSize(this._contentSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * You may have allocated the PackedRect using over-provisioning (you allocated more than you need in order to prevent frequent deallocations/reallocations)\n         * and then using only a part of the PackRect.\n         * This method will return the UVs for this part by given the custom size of what you really use\n         * @param customSize must be less/equal to the allocated size, UV will be compute from this\n         */\n        PackedRect.prototype.getUVsForCustomSize = function (customSize) {\n            var mainWidth = this._root._size.width;\n            var mainHeight = this._root._size.height;\n            var margin = this._root._margin;\n            var topLeft = new BABYLON.Vector2((this._pos.x + margin) / mainWidth, (this._pos.y + margin) / mainHeight);\n            var rightBottom = new BABYLON.Vector2((this._pos.x + customSize.width + margin - 1) / mainWidth, (this._pos.y + customSize.height + margin - 1) / mainHeight);\n            var uvs = new Array();\n            uvs.push(topLeft);\n            uvs.push(new BABYLON.Vector2(rightBottom.x, topLeft.y));\n            uvs.push(rightBottom);\n            uvs.push(new BABYLON.Vector2(topLeft.x, rightBottom.y));\n            return uvs;\n        };\n        /**\n         * Free this rectangle from the map.\n         * Call this method when you no longer need the rectangle to be in the map.\n         */\n        PackedRect.prototype.freeContent = function () {\n            if (!this.contentSize) {\n                return;\n            }\n            this._contentSize = null;\n            // If everything below is also free, reset the whole node, and attempt to reset parents if they also become free\n            this.attemptDefrag();\n        };\n        Object.defineProperty(PackedRect.prototype, \"isUsed\", {\n            get: function () {\n                return this._contentSize != null || this._leftNode != null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PackedRect.prototype.findAndSplitNode = function (contentSize) {\n            var node = this.findNode(contentSize);\n            // Not enough space...\n            if (!node) {\n                return null;\n            }\n            node.splitNode(contentSize);\n            return node;\n        };\n        PackedRect.prototype.findNode = function (size) {\n            var resNode = null;\n            var margin = this._root._margin * 2;\n            // If this node is used, recurse to each of his subNodes to find an available one in its branch\n            if (this.isUsed) {\n                if (this._leftNode) {\n                    resNode = this._leftNode.findNode(size);\n                }\n                if (!resNode && this._rightNode) {\n                    resNode = this._rightNode.findNode(size);\n                }\n                if (!resNode && this._bottomNode) {\n                    resNode = this._bottomNode.findNode(size);\n                }\n            }\n            else if (this._initialSize) {\n                if (((size.width + margin) <= this._initialSize.width) && ((size.height + margin) <= this._initialSize.height)) {\n                    resNode = this;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (((size.width + margin) <= this._size.width) && ((size.height + margin) <= this._size.height)) {\n                resNode = this;\n            }\n            return resNode;\n        };\n        PackedRect.prototype.splitNode = function (contentSize) {\n            var cs = PackedRect.TpsSize;\n            var margin = this._root._margin * 2;\n            cs.copyFrom(contentSize);\n            cs.width += margin;\n            cs.height += margin;\n            // If there's no contentSize but an initialSize it means this node were previously allocated, but freed, we need to create a _leftNode as subNode and use to allocate the space we need (and this node will have a right/bottom subNode for the space left as this._initialSize may be greater than contentSize)\n            if (!this._contentSize && this._initialSize) {\n                this._contentSize = cs.clone();\n                this._leftNode = new PackedRect(this._root, this, new BABYLON.Vector2(this._pos.x, this._pos.y), new BABYLON.Size(this._initialSize.width, this._initialSize.height));\n                return this._leftNode.splitNode(contentSize);\n            }\n            else {\n                this._contentSize = cs.clone();\n                this._initialSize = cs.clone();\n                if (cs.width !== this._size.width) {\n                    this._rightNode = new PackedRect(this._root, this, new BABYLON.Vector2(this._pos.x + cs.width, this._pos.y), new BABYLON.Size(this._size.width - cs.width, cs.height));\n                }\n                if (cs.height !== this._size.height) {\n                    this._bottomNode = new PackedRect(this._root, this, new BABYLON.Vector2(this._pos.x, this._pos.y + cs.height), new BABYLON.Size(this._size.width, this._size.height - cs.height));\n                }\n                return this;\n            }\n        };\n        PackedRect.prototype.attemptDefrag = function () {\n            if (!this.isUsed && this.isRecursiveFree) {\n                this.clearNode();\n                if (this._parent) {\n                    this._parent.attemptDefrag();\n                }\n            }\n        };\n        PackedRect.prototype.clearNode = function () {\n            this._initialSize = null;\n            this._rightNode = null;\n            this._bottomNode = null;\n        };\n        Object.defineProperty(PackedRect.prototype, \"isRecursiveFree\", {\n            get: function () {\n                return !this.contentSize && (!this._leftNode || this._leftNode.isRecursiveFree) && (!this._rightNode || this._rightNode.isRecursiveFree) && (!this._bottomNode || this._bottomNode.isRecursiveFree);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PackedRect.prototype.evalFreeSize = function (size) {\n            var levelSize = 0;\n            if (!this.isUsed) {\n                var margin = this._root._margin;\n                var is = this._initialSize;\n                if (is) {\n                    levelSize = is.surface - (is.width * margin) - (is.height * margin);\n                }\n                else {\n                    var size_1 = this._size;\n                    levelSize = size_1.surface - (size_1.width * margin) - (size_1.height * margin);\n                }\n            }\n            if (this._rightNode) {\n                levelSize += this._rightNode.evalFreeSize(0);\n            }\n            if (this._bottomNode) {\n                levelSize += this._bottomNode.evalFreeSize(0);\n            }\n            return levelSize + size;\n        };\n        return PackedRect;\n    }());\n    PackedRect.TpsSize = BABYLON.Size.Zero();\n    BABYLON.PackedRect = PackedRect;\n    /**\n     * The purpose of this class is to pack several Rectangles into a big map, while trying to fit everything as optimally as possible.\n     * This class is typically used to build lightmaps, sprite map or to pack several little textures into a big one.\n     * Note that this class allows allocated Rectangles to be freed: that is the map is dynamically maintained so you can add/remove rectangle based on their life-cycle.\n     * In case you need a margin around the allocated rect, specify the amount in the margin argument during construction.\n     * In such case you will have to rely on innerPositionToRef and innerSizeToRef calls to get the proper size\n     */\n    var RectPackingMap = (function (_super) {\n        __extends(RectPackingMap, _super);\n        /**\n         * Create an instance of the object with a dimension using the given size\n         * @param size The dimension of the rectangle that will contain all the sub ones.\n         * @param margin The margin (empty space) created (in pixels) around the allocated Rectangles\n         */\n        function RectPackingMap(size, margin) {\n            if (margin === void 0) { margin = 0; }\n            var _this = _super.call(this, null, null, BABYLON.Vector2.Zero(), size) || this;\n            _this._margin = margin;\n            _this._root = _this;\n            return _this;\n        }\n        /**\n         * Add a rectangle, finding the best location to store it into the map\n         * @param size the dimension of the rectangle to store\n         * @return the Node containing the rectangle information, or null if we couldn't find a free spot\n         */\n        RectPackingMap.prototype.addRect = function (size) {\n            var node = this.findAndSplitNode(size);\n            return node;\n        };\n        Object.defineProperty(RectPackingMap.prototype, \"freeSpace\", {\n            /**\n             * Return the current space free normalized between [0;1]\n             * @returns {}\n             */\n            get: function () {\n                var freeSize = 0;\n                freeSize = this.evalFreeSize(freeSize);\n                return freeSize / (this._size.width * this._size.height);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return RectPackingMap;\n    }(PackedRect));\n    BABYLON.RectPackingMap = RectPackingMap;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.rectPackingMap.js.map\n\n\nvar BABYLON;\n(function (BABYLON) {\n    /**\n     * This groups together the common properties used for image processing either in direct forward pass\n     * or through post processing effect depending on the use of the image processing pipeline in your scene\n     * or not.\n     */\n    var ImageProcessingConfiguration = (function () {\n        function ImageProcessingConfiguration() {\n            /**\n             * Color curves setup used in the effect if colorCurvesEnabled is set to true\n             */\n            this.colorCurves = new BABYLON.ColorCurves();\n            this._colorCurvesEnabled = false;\n            this._colorGradingEnabled = false;\n            this._colorGradingWithGreenDepth = false;\n            this._colorGradingBGR = false;\n            this._exposure = 1.0;\n            this._toneMappingEnabled = false;\n            this._contrast = 1.0;\n            /**\n             * Vignette stretch size.\n             */\n            this.vignetteStretch = 0;\n            /**\n             * Vignette centre X Offset.\n             */\n            this.vignetteCentreX = 0;\n            /**\n             * Vignette centre Y Offset.\n             */\n            this.vignetteCentreY = 0;\n            /**\n             * Vignette weight or intensity of the vignette effect.\n             */\n            this.vignetteWeight = 1.5;\n            /**\n             * Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n             * if vignetteEnabled is set to true.\n             */\n            this.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);\n            /**\n             * Camera field of view used by the Vignette effect.\n             */\n            this.vignetteCameraFov = 0.5;\n            this._vignetteBlendMode = ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;\n            this._vignetteEnabled = false;\n            this._applyByPostProcess = false;\n            /**\n            * An event triggered when the configuration changes and requires Shader to Update some parameters.\n            * @type {BABYLON.Observable}\n            */\n            this.onUpdateParameters = new BABYLON.Observable();\n        }\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"colorCurvesEnabled\", {\n            /**\n             * Gets wether the color curves effect is enabled.\n             */\n            get: function () {\n                return this._colorCurvesEnabled;\n            },\n            /**\n             * Sets wether the color curves effect is enabled.\n             */\n            set: function (value) {\n                if (this._colorCurvesEnabled === value) {\n                    return;\n                }\n                this._colorCurvesEnabled = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"colorGradingEnabled\", {\n            /**\n             * Gets wether the color grading effect is enabled.\n             */\n            get: function () {\n                return this._colorGradingEnabled;\n            },\n            /**\n             * Sets wether the color grading effect is enabled.\n             */\n            set: function (value) {\n                if (this._colorGradingEnabled === value) {\n                    return;\n                }\n                this._colorGradingEnabled = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"colorGradingWithGreenDepth\", {\n            /**\n             * Gets wether the color grading effect is using a green depth for the 3d Texture.\n             */\n            get: function () {\n                return this._colorGradingWithGreenDepth;\n            },\n            /**\n             * Sets wether the color grading effect is using a green depth for the 3d Texture.\n             */\n            set: function (value) {\n                if (this._colorGradingWithGreenDepth === value) {\n                    return;\n                }\n                this._colorGradingWithGreenDepth = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"colorGradingBGR\", {\n            /**\n             * Gets wether the color grading texture contains BGR values.\n             */\n            get: function () {\n                return this._colorGradingBGR;\n            },\n            /**\n             * Sets wether the color grading texture contains BGR values.\n             */\n            set: function (value) {\n                if (this._colorGradingBGR === value) {\n                    return;\n                }\n                this._colorGradingBGR = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"exposure\", {\n            /**\n             * Gets the Exposure used in the effect.\n             */\n            get: function () {\n                return this._exposure;\n            },\n            /**\n             * Sets the Exposure used in the effect.\n             */\n            set: function (value) {\n                if (this._exposure === value) {\n                    return;\n                }\n                this._exposure = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"toneMappingEnabled\", {\n            /**\n             * Gets wether the tone mapping effect is enabled.\n             */\n            get: function () {\n                return this._toneMappingEnabled;\n            },\n            /**\n             * Sets wether the tone mapping effect is enabled.\n             */\n            set: function (value) {\n                if (this._toneMappingEnabled === value) {\n                    return;\n                }\n                this._toneMappingEnabled = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"contrast\", {\n            /**\n             * Gets the contrast used in the effect.\n             */\n            get: function () {\n                return this._contrast;\n            },\n            /**\n             * Sets the contrast used in the effect.\n             */\n            set: function (value) {\n                if (this._contrast === value) {\n                    return;\n                }\n                this._contrast = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"vignetteBlendMode\", {\n            /**\n             * Gets the vignette blend mode allowing different kind of effect.\n             */\n            get: function () {\n                return this._vignetteBlendMode;\n            },\n            /**\n             * Sets the vignette blend mode allowing different kind of effect.\n             */\n            set: function (value) {\n                if (this._vignetteBlendMode === value) {\n                    return;\n                }\n                this._vignetteBlendMode = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"vignetteEnabled\", {\n            /**\n             * Gets wether the vignette effect is enabled.\n             */\n            get: function () {\n                return this._vignetteEnabled;\n            },\n            /**\n             * Sets wether the vignette effect is enabled.\n             */\n            set: function (value) {\n                if (this._vignetteEnabled === value) {\n                    return;\n                }\n                this._vignetteEnabled = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration.prototype, \"applyByPostProcess\", {\n            /**\n             * Gets wether the image processing is applied through a post process or not.\n             */\n            get: function () {\n                return this._applyByPostProcess;\n            },\n            /**\n             * Sets wether the image processing is applied through a post process or not.\n             */\n            set: function (value) {\n                if (this._applyByPostProcess === value) {\n                    return;\n                }\n                this._applyByPostProcess = value;\n                this._updateParameters();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Method called each time the image processing information changes requires to recompile the effect.\n         */\n        ImageProcessingConfiguration.prototype._updateParameters = function () {\n            this.onUpdateParameters.notifyObservers(this);\n        };\n        /**\n         * Prepare the list of uniforms associated with the Image Processing effects.\n         * @param uniformsList The list of uniforms used in the effect\n         * @param defines the list of defines currently in use\n         */\n        ImageProcessingConfiguration.PrepareUniforms = function (uniforms, defines) {\n            if (defines.EXPOSURE) {\n                uniforms.push(\"exposureLinear\");\n            }\n            if (defines.CONTRAST) {\n                uniforms.push(\"contrast\");\n            }\n            if (defines.COLORGRADING) {\n                uniforms.push(\"colorTransformSettings\");\n            }\n            if (defines.VIGNETTE) {\n                uniforms.push(\"vInverseScreenSize\");\n                uniforms.push(\"vignetteSettings1\");\n                uniforms.push(\"vignetteSettings2\");\n            }\n            if (defines.COLORCURVES) {\n                BABYLON.ColorCurves.PrepareUniforms(uniforms);\n            }\n        };\n        /**\n         * Prepare the list of samplers associated with the Image Processing effects.\n         * @param uniformsList The list of uniforms used in the effect\n         * @param defines the list of defines currently in use\n         */\n        ImageProcessingConfiguration.PrepareSamplers = function (samplersList, defines) {\n            if (defines.COLORGRADING) {\n                samplersList.push(\"txColorTransform\");\n            }\n        };\n        /**\n         * Prepare the list of defines associated to the shader.\n         * @param defines the list of defines to complete\n         */\n        ImageProcessingConfiguration.prototype.prepareDefines = function (defines) {\n            defines.VIGNETTE = this.vignetteEnabled;\n            defines.VIGNETTEBLENDMODEMULTIPLY = (this.vignetteBlendMode === ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY);\n            defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;\n            defines.TONEMAPPING = this.toneMappingEnabled;\n            defines.CONTRAST = (this.contrast !== 1.0);\n            defines.EXPOSURE = (this.exposure !== 1.0);\n            defines.COLORCURVES = (this.colorCurvesEnabled && !!this.colorCurves);\n            defines.COLORGRADING = (this.colorGradingEnabled && !!this.colorGradingTexture);\n            defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;\n            defines.SAMPLER3DBGRMAP = this.colorGradingBGR;\n            defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;\n            defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING;\n        };\n        /**\n         * Returns true if all the image processing information are ready.\n         */\n        ImageProcessingConfiguration.prototype.isReady = function () {\n            // Color Grading texure can not be none blocking.\n            return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();\n        };\n        /**\n         * Binds the image processing to the shader.\n         * @param effect The effect to bind to\n         */\n        ImageProcessingConfiguration.prototype.bind = function (effect, aspectRatio) {\n            if (aspectRatio === void 0) { aspectRatio = 1; }\n            // Color Curves\n            if (this._colorCurvesEnabled) {\n                BABYLON.ColorCurves.Bind(this.colorCurves, effect);\n            }\n            // Vignette\n            if (this._vignetteEnabled) {\n                var inverseWidth = 1 / effect.getEngine().getRenderWidth();\n                var inverseHeight = 1 / effect.getEngine().getRenderHeight();\n                effect.setFloat2(\"vInverseScreenSize\", inverseWidth, inverseHeight);\n                var vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);\n                var vignetteScaleX = vignetteScaleY * aspectRatio;\n                var vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);\n                vignetteScaleX = BABYLON.Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);\n                vignetteScaleY = BABYLON.Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);\n                effect.setFloat4(\"vignetteSettings1\", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCentreX, -vignetteScaleY * this.vignetteCentreY);\n                var vignettePower = -2.0 * this.vignetteWeight;\n                effect.setFloat4(\"vignetteSettings2\", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);\n            }\n            // Exposure\n            effect.setFloat(\"exposureLinear\", this.exposure);\n            // Contrast\n            effect.setFloat(\"contrast\", this.contrast);\n            // Color transform settings\n            if (this.colorGradingTexture) {\n                effect.setTexture(\"txColorTransform\", this.colorGradingTexture);\n                var textureSize = this.colorGradingTexture.getSize().height;\n                effect.setFloat4(\"colorTransformSettings\", (textureSize - 1) / textureSize, // textureScale\n                0.5 / textureSize, // textureOffset\n                textureSize, // textureSize\n                this.colorGradingTexture.level // weight\n                );\n            }\n        };\n        /**\n         * Clones the current image processing instance.\n         * @return The cloned image processing\n         */\n        ImageProcessingConfiguration.prototype.clone = function () {\n            return BABYLON.SerializationHelper.Clone(function () { return new ImageProcessingConfiguration(); }, this);\n        };\n        /**\n         * Serializes the current image processing instance to a json representation.\n         * @return a JSON representation\n         */\n        ImageProcessingConfiguration.prototype.serialize = function () {\n            return BABYLON.SerializationHelper.Serialize(this);\n        };\n        /**\n         * Parses the image processing from a json representation.\n         * @param source the JSON source to parse\n         * @return The parsed image processing\n         */\n        ImageProcessingConfiguration.Parse = function (source) {\n            return BABYLON.SerializationHelper.Parse(function () { return new ImageProcessingConfiguration(); }, source, null, null);\n        };\n        Object.defineProperty(ImageProcessingConfiguration, \"VIGNETTEMODE_MULTIPLY\", {\n            /**\n             * Used to apply the vignette as a mix with the pixel color.\n             */\n            get: function () {\n                return this._VIGNETTEMODE_MULTIPLY;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ImageProcessingConfiguration, \"VIGNETTEMODE_OPAQUE\", {\n            /**\n             * Used to apply the vignette as a replacement of the pixel color.\n             */\n            get: function () {\n                return this._VIGNETTEMODE_OPAQUE;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ImageProcessingConfiguration;\n    }());\n    // Static constants associated to the image processing.\n    ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;\n    ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;\n    __decorate([\n        BABYLON.serializeAsColorCurves()\n    ], ImageProcessingConfiguration.prototype, \"colorCurves\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_colorCurvesEnabled\", void 0);\n    __decorate([\n        BABYLON.serializeAsTexture()\n    ], ImageProcessingConfiguration.prototype, \"colorGradingTexture\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_colorGradingEnabled\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_colorGradingWithGreenDepth\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_colorGradingBGR\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_exposure\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_toneMappingEnabled\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_contrast\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"vignetteStretch\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"vignetteCentreX\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"vignetteCentreY\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"vignetteWeight\", void 0);\n    __decorate([\n        BABYLON.serializeAsColor4()\n    ], ImageProcessingConfiguration.prototype, \"vignetteColor\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"vignetteCameraFov\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_vignetteBlendMode\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_vignetteEnabled\", void 0);\n    __decorate([\n        BABYLON.serialize()\n    ], ImageProcessingConfiguration.prototype, \"_applyByPostProcess\", void 0);\n    BABYLON.ImageProcessingConfiguration = ImageProcessingConfiguration;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.imageProcessingConfiguration.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var serializedGeometries = [];\n    var serializeGeometry = function (geometry, serializationGeometries) {\n        if (serializedGeometries[geometry.id]) {\n            return;\n        }\n        if (geometry.doNotSerialize) {\n            return;\n        }\n        if (geometry instanceof BABYLON.Geometry.Primitives.Box) {\n            serializationGeometries.boxes.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.Sphere) {\n            serializationGeometries.spheres.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.Cylinder) {\n            serializationGeometries.cylinders.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.Torus) {\n            serializationGeometries.toruses.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.Ground) {\n            serializationGeometries.grounds.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.Plane) {\n            serializationGeometries.planes.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives.TorusKnot) {\n            serializationGeometries.torusKnots.push(geometry.serialize());\n        }\n        else if (geometry instanceof BABYLON.Geometry.Primitives._Primitive) {\n            throw new Error(\"Unknown primitive type\");\n        }\n        else {\n            serializationGeometries.vertexData.push(geometry.serializeVerticeData());\n        }\n        serializedGeometries[geometry.id] = true;\n    };\n    var serializeMesh = function (mesh, serializationScene) {\n        var serializationObject = {};\n        // Geometry      \n        var geometry = mesh._geometry;\n        if (geometry) {\n            if (!mesh.getScene().getGeometryByID(geometry.id)) {\n                // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\n                serializeGeometry(geometry, serializationScene.geometries);\n            }\n        }\n        // Custom\n        if (mesh.serialize) {\n            mesh.serialize(serializationObject);\n        }\n        return serializationObject;\n    };\n    var finalizeSingleMesh = function (mesh, serializationObject) {\n        //only works if the mesh is already loaded\n        if (mesh.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADED || mesh.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_NONE) {\n            //serialize material\n            if (mesh.material) {\n                if (mesh.material instanceof BABYLON.StandardMaterial) {\n                    serializationObject.materials = serializationObject.materials || [];\n                    if (!serializationObject.materials.some(function (mat) { return (mat.id === mesh.material.id); })) {\n                        serializationObject.materials.push(mesh.material.serialize());\n                    }\n                }\n                else if (mesh.material instanceof BABYLON.MultiMaterial) {\n                    serializationObject.multiMaterials = serializationObject.multiMaterials || [];\n                    if (!serializationObject.multiMaterials.some(function (mat) { return (mat.id === mesh.material.id); })) {\n                        serializationObject.multiMaterials.push(mesh.material.serialize());\n                    }\n                }\n            }\n            //serialize geometry\n            var geometry = mesh._geometry;\n            if (geometry) {\n                if (!serializationObject.geometries) {\n                    serializationObject.geometries = {};\n                    serializationObject.geometries.boxes = [];\n                    serializationObject.geometries.spheres = [];\n                    serializationObject.geometries.cylinders = [];\n                    serializationObject.geometries.toruses = [];\n                    serializationObject.geometries.grounds = [];\n                    serializationObject.geometries.planes = [];\n                    serializationObject.geometries.torusKnots = [];\n                    serializationObject.geometries.vertexData = [];\n                }\n                serializeGeometry(geometry, serializationObject.geometries);\n            }\n            // Skeletons\n            if (mesh.skeleton) {\n                serializationObject.skeletons = serializationObject.skeletons || [];\n                serializationObject.skeletons.push(mesh.skeleton.serialize());\n            }\n            //serialize the actual mesh\n            serializationObject.meshes = serializationObject.meshes || [];\n            serializationObject.meshes.push(serializeMesh(mesh, serializationObject));\n        }\n    };\n    var SceneSerializer = (function () {\n        function SceneSerializer() {\n        }\n        SceneSerializer.ClearCache = function () {\n            serializedGeometries = [];\n        };\n        SceneSerializer.Serialize = function (scene) {\n            var serializationObject = {};\n            SceneSerializer.ClearCache();\n            // Scene\n            serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\n            serializationObject.autoClear = scene.autoClear;\n            serializationObject.clearColor = scene.clearColor.asArray();\n            serializationObject.ambientColor = scene.ambientColor.asArray();\n            serializationObject.gravity = scene.gravity.asArray();\n            serializationObject.collisionsEnabled = scene.collisionsEnabled;\n            serializationObject.workerCollisions = scene.workerCollisions;\n            // Fog\n            if (scene.fogMode && scene.fogMode !== 0) {\n                serializationObject.fogMode = scene.fogMode;\n                serializationObject.fogColor = scene.fogColor.asArray();\n                serializationObject.fogStart = scene.fogStart;\n                serializationObject.fogEnd = scene.fogEnd;\n                serializationObject.fogDensity = scene.fogDensity;\n            }\n            //Physics\n            if (scene.isPhysicsEnabled()) {\n                serializationObject.physicsEnabled = true;\n                serializationObject.physicsGravity = scene.getPhysicsEngine().gravity.asArray();\n                serializationObject.physicsEngine = scene.getPhysicsEngine().getPhysicsPluginName();\n            }\n            // Metadata\n            if (scene.metadata) {\n                serializationObject.metadata = scene.metadata;\n            }\n            // Morph targets\n            serializationObject.morphTargetManagers = [];\n            for (var _i = 0, _a = scene.meshes; _i < _a.length; _i++) {\n                var abstractMesh = _a[_i];\n                var manager = abstractMesh.morphTargetManager;\n                if (manager) {\n                    serializationObject.morphTargetManagers.push(manager.serialize());\n                }\n            }\n            // Lights\n            serializationObject.lights = [];\n            var index;\n            var light;\n            for (index = 0; index < scene.lights.length; index++) {\n                light = scene.lights[index];\n                if (!light.doNotSerialize) {\n                    serializationObject.lights.push(light.serialize());\n                }\n            }\n            // Cameras\n            serializationObject.cameras = [];\n            for (index = 0; index < scene.cameras.length; index++) {\n                var camera = scene.cameras[index];\n                if (!camera.doNotSerialize) {\n                    serializationObject.cameras.push(camera.serialize());\n                }\n            }\n            if (scene.activeCamera) {\n                serializationObject.activeCameraID = scene.activeCamera.id;\n            }\n            // Animations\n            BABYLON.Animation.AppendSerializedAnimations(scene, serializationObject);\n            // Materials\n            serializationObject.materials = [];\n            serializationObject.multiMaterials = [];\n            var material;\n            for (index = 0; index < scene.materials.length; index++) {\n                material = scene.materials[index];\n                if (!material.doNotSerialize) {\n                    serializationObject.materials.push(material.serialize());\n                }\n            }\n            // MultiMaterials\n            serializationObject.multiMaterials = [];\n            for (index = 0; index < scene.multiMaterials.length; index++) {\n                var multiMaterial = scene.multiMaterials[index];\n                serializationObject.multiMaterials.push(multiMaterial.serialize());\n            }\n            // Skeletons\n            serializationObject.skeletons = [];\n            for (index = 0; index < scene.skeletons.length; index++) {\n                serializationObject.skeletons.push(scene.skeletons[index].serialize());\n            }\n            // Geometries\n            serializationObject.geometries = {};\n            serializationObject.geometries.boxes = [];\n            serializationObject.geometries.spheres = [];\n            serializationObject.geometries.cylinders = [];\n            serializationObject.geometries.toruses = [];\n            serializationObject.geometries.grounds = [];\n            serializationObject.geometries.planes = [];\n            serializationObject.geometries.torusKnots = [];\n            serializationObject.geometries.vertexData = [];\n            serializedGeometries = [];\n            var geometries = scene.getGeometries();\n            for (index = 0; index < geometries.length; index++) {\n                var geometry = geometries[index];\n                if (geometry.isReady()) {\n                    serializeGeometry(geometry, serializationObject.geometries);\n                }\n            }\n            // Meshes\n            serializationObject.meshes = [];\n            for (index = 0; index < scene.meshes.length; index++) {\n                var abstractMesh = scene.meshes[index];\n                if (abstractMesh instanceof BABYLON.Mesh) {\n                    var mesh = abstractMesh;\n                    if (!mesh.doNotSerialize) {\n                        if (mesh.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_LOADED || mesh.delayLoadState === BABYLON.Engine.DELAYLOADSTATE_NONE) {\n                            serializationObject.meshes.push(serializeMesh(mesh, serializationObject));\n                        }\n                    }\n                }\n            }\n            // Particles Systems\n            serializationObject.particleSystems = [];\n            for (index = 0; index < scene.particleSystems.length; index++) {\n                serializationObject.particleSystems.push(scene.particleSystems[index].serialize());\n            }\n            // Lens flares\n            serializationObject.lensFlareSystems = [];\n            for (index = 0; index < scene.lensFlareSystems.length; index++) {\n                serializationObject.lensFlareSystems.push(scene.lensFlareSystems[index].serialize());\n            }\n            // Shadows\n            serializationObject.shadowGenerators = [];\n            for (index = 0; index < scene.lights.length; index++) {\n                light = scene.lights[index];\n                var shadowGenerator = light.getShadowGenerator();\n                if (shadowGenerator) {\n                    serializationObject.shadowGenerators.push(shadowGenerator.serialize());\n                }\n            }\n            // Action Manager\n            if (scene.actionManager) {\n                serializationObject.actions = scene.actionManager.serialize(\"scene\");\n            }\n            // Audio\n            serializationObject.sounds = [];\n            for (index = 0; index < scene.soundTracks.length; index++) {\n                var soundtrack = scene.soundTracks[index];\n                for (var soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\n                }\n            }\n            return serializationObject;\n        };\n        SceneSerializer.SerializeMesh = function (toSerialize /* Mesh || Mesh[] */, withParents, withChildren) {\n            if (withParents === void 0) { withParents = false; }\n            if (withChildren === void 0) { withChildren = false; }\n            var serializationObject = {};\n            SceneSerializer.ClearCache();\n            toSerialize = (toSerialize instanceof Array) ? toSerialize : [toSerialize];\n            if (withParents || withChildren) {\n                //deliberate for loop! not for each, appended should be processed as well.\n                for (var i = 0; i < toSerialize.length; ++i) {\n                    if (withChildren) {\n                        toSerialize[i].getDescendants().forEach(function (node) {\n                            if (node instanceof BABYLON.Mesh && (toSerialize.indexOf(node) < 0)) {\n                                toSerialize.push(node);\n                            }\n                        });\n                    }\n                    //make sure the array doesn't contain the object already\n                    if (withParents && toSerialize[i].parent && (toSerialize.indexOf(toSerialize[i].parent) < 0)) {\n                        toSerialize.push(toSerialize[i].parent);\n                    }\n                }\n            }\n            toSerialize.forEach(function (mesh) {\n                finalizeSingleMesh(mesh, serializationObject);\n            });\n            return serializationObject;\n        };\n        return SceneSerializer;\n    }());\n    BABYLON.SceneSerializer = SceneSerializer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.sceneSerializer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var ReflectionProbe = (function () {\n        function ReflectionProbe(name, size, scene, generateMipMaps) {\n            if (generateMipMaps === void 0) { generateMipMaps = true; }\n            var _this = this;\n            this.name = name;\n            this._viewMatrix = BABYLON.Matrix.Identity();\n            this._target = BABYLON.Vector3.Zero();\n            this._add = BABYLON.Vector3.Zero();\n            this.invertYAxis = false;\n            this.position = BABYLON.Vector3.Zero();\n            this._scene = scene;\n            this._scene.reflectionProbes.push(this);\n            this._renderTargetTexture = new BABYLON.RenderTargetTexture(name, size, scene, generateMipMaps, true, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT, true);\n            this._renderTargetTexture.onBeforeRenderObservable.add(function (faceIndex) {\n                switch (faceIndex) {\n                    case 0:\n                        _this._add.copyFromFloats(1, 0, 0);\n                        break;\n                    case 1:\n                        _this._add.copyFromFloats(-1, 0, 0);\n                        break;\n                    case 2:\n                        _this._add.copyFromFloats(0, _this.invertYAxis ? 1 : -1, 0);\n                        break;\n                    case 3:\n                        _this._add.copyFromFloats(0, _this.invertYAxis ? -1 : 1, 0);\n                        break;\n                    case 4:\n                        _this._add.copyFromFloats(0, 0, 1);\n                        break;\n                    case 5:\n                        _this._add.copyFromFloats(0, 0, -1);\n                        break;\n                }\n                if (_this._attachedMesh) {\n                    _this.position.copyFrom(_this._attachedMesh.getAbsolutePosition());\n                }\n                _this.position.addToRef(_this._add, _this._target);\n                BABYLON.Matrix.LookAtLHToRef(_this.position, _this._target, BABYLON.Vector3.Up(), _this._viewMatrix);\n                scene.setTransformMatrix(_this._viewMatrix, _this._projectionMatrix);\n            });\n            this._renderTargetTexture.onAfterUnbindObservable.add(function () {\n                scene.updateTransformMatrix(true);\n            });\n            this._projectionMatrix = BABYLON.Matrix.PerspectiveFovLH(Math.PI / 2, 1, scene.activeCamera.minZ, scene.activeCamera.maxZ);\n        }\n        Object.defineProperty(ReflectionProbe.prototype, \"samples\", {\n            get: function () {\n                return this._renderTargetTexture.samples;\n            },\n            set: function (value) {\n                this._renderTargetTexture.samples = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ReflectionProbe.prototype, \"refreshRate\", {\n            get: function () {\n                return this._renderTargetTexture.refreshRate;\n            },\n            set: function (value) {\n                this._renderTargetTexture.refreshRate = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectionProbe.prototype.getScene = function () {\n            return this._scene;\n        };\n        Object.defineProperty(ReflectionProbe.prototype, \"cubeTexture\", {\n            get: function () {\n                return this._renderTargetTexture;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ReflectionProbe.prototype, \"renderList\", {\n            get: function () {\n                return this._renderTargetTexture.renderList;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ReflectionProbe.prototype.attachToMesh = function (mesh) {\n            this._attachedMesh = mesh;\n        };\n        /**\n         * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n         *\n         * @param renderingGroupId The rendering group id corresponding to its index\n         * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n         */\n        ReflectionProbe.prototype.setRenderingAutoClearDepthStencil = function (renderingGroupId, autoClearDepthStencil) {\n            this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\n        };\n        ReflectionProbe.prototype.dispose = function () {\n            var index = this._scene.reflectionProbes.indexOf(this);\n            if (index !== -1) {\n                // Remove from the scene if found \n                this._scene.reflectionProbes.splice(index, 1);\n            }\n            if (this._renderTargetTexture) {\n                this._renderTargetTexture.dispose();\n                this._renderTargetTexture = null;\n            }\n        };\n        return ReflectionProbe;\n    }());\n    BABYLON.ReflectionProbe = ReflectionProbe;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.reflectionProbe.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var Layer = (function () {\n        function Layer(name, imgUrl, scene, isBackground, color) {\n            this.name = name;\n            this.scale = new BABYLON.Vector2(1, 1);\n            this.offset = new BABYLON.Vector2(0, 0);\n            this.alphaBlendingMode = BABYLON.Engine.ALPHA_COMBINE;\n            this.layerMask = 0x0FFFFFFF;\n            this._vertexBuffers = {};\n            // Events\n            /**\n            * An event triggered when the layer is disposed.\n            * @type {BABYLON.Observable}\n            */\n            this.onDisposeObservable = new BABYLON.Observable();\n            /**\n            * An event triggered before rendering the scene\n            * @type {BABYLON.Observable}\n            */\n            this.onBeforeRenderObservable = new BABYLON.Observable();\n            /**\n            * An event triggered after rendering the scene\n            * @type {BABYLON.Observable}\n            */\n            this.onAfterRenderObservable = new BABYLON.Observable();\n            this.texture = imgUrl ? new BABYLON.Texture(imgUrl, scene, true) : null;\n            this.isBackground = isBackground === undefined ? true : isBackground;\n            this.color = color === undefined ? new BABYLON.Color4(1, 1, 1, 1) : color;\n            this._scene = scene || BABYLON.Engine.LastCreatedScene;\n            this._scene.layers.push(this);\n            var engine = this._scene.getEngine();\n            // VBO\n            var vertices = [];\n            vertices.push(1, 1);\n            vertices.push(-1, 1);\n            vertices.push(-1, -1);\n            vertices.push(1, -1);\n            var vertexBuffer = new BABYLON.VertexBuffer(engine, vertices, BABYLON.VertexBuffer.PositionKind, false, false, 2);\n            this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = vertexBuffer;\n            // Indices\n            var indices = [];\n            indices.push(0);\n            indices.push(1);\n            indices.push(2);\n            indices.push(0);\n            indices.push(2);\n            indices.push(3);\n            this._indexBuffer = engine.createIndexBuffer(indices);\n            // Effects\n            this._effect = engine.createEffect(\"layer\", [BABYLON.VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], \"\");\n            this._alphaTestEffect = engine.createEffect(\"layer\", [BABYLON.VertexBuffer.PositionKind], [\"textureMatrix\", \"color\", \"scale\", \"offset\"], [\"textureSampler\"], \"#define ALPHATEST\");\n        }\n        Object.defineProperty(Layer.prototype, \"onDispose\", {\n            set: function (callback) {\n                if (this._onDisposeObserver) {\n                    this.onDisposeObservable.remove(this._onDisposeObserver);\n                }\n                this._onDisposeObserver = this.onDisposeObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Layer.prototype, \"onBeforeRender\", {\n            set: function (callback) {\n                if (this._onBeforeRenderObserver) {\n                    this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n                }\n                this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Layer.prototype, \"onAfterRender\", {\n            set: function (callback) {\n                if (this._onAfterRenderObserver) {\n                    this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n                }\n                this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Layer.prototype.render = function () {\n            var currentEffect = this.alphaTest ? this._alphaTestEffect : this._effect;\n            // Check\n            if (!currentEffect.isReady() || !this.texture || !this.texture.isReady())\n                return;\n            var engine = this._scene.getEngine();\n            this.onBeforeRenderObservable.notifyObservers(this);\n            // Render\n            engine.enableEffect(currentEffect);\n            engine.setState(false);\n            // Texture\n            currentEffect.setTexture(\"textureSampler\", this.texture);\n            currentEffect.setMatrix(\"textureMatrix\", this.texture.getTextureMatrix());\n            // Color\n            currentEffect.setFloat4(\"color\", this.color.r, this.color.g, this.color.b, this.color.a);\n            // Scale / offset\n            currentEffect.setVector2(\"offset\", this.offset);\n            currentEffect.setVector2(\"scale\", this.scale);\n            // VBOs\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, currentEffect);\n            // Draw order\n            if (!this.alphaTest) {\n                engine.setAlphaMode(this.alphaBlendingMode);\n                engine.draw(true, 0, 6);\n                engine.setAlphaMode(BABYLON.Engine.ALPHA_DISABLE);\n            }\n            else {\n                engine.draw(true, 0, 6);\n            }\n            this.onAfterRenderObservable.notifyObservers(this);\n        };\n        Layer.prototype.dispose = function () {\n            var vertexBuffer = this._vertexBuffers[BABYLON.VertexBuffer.PositionKind];\n            if (vertexBuffer) {\n                vertexBuffer.dispose();\n                this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] = null;\n            }\n            if (this._indexBuffer) {\n                this._scene.getEngine()._releaseBuffer(this._indexBuffer);\n                this._indexBuffer = null;\n            }\n            if (this.texture) {\n                this.texture.dispose();\n                this.texture = null;\n            }\n            // Remove from scene\n            var index = this._scene.layers.indexOf(this);\n            this._scene.layers.splice(index, 1);\n            // Callback\n            this.onDisposeObservable.notifyObservers(this);\n            this.onDisposeObservable.clear();\n            this.onAfterRenderObservable.clear();\n            this.onBeforeRenderObservable.clear();\n        };\n        return Layer;\n    }());\n    BABYLON.Layer = Layer;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.layer.js.map\n\nvar BABYLON;\n(function (BABYLON) {\n    var TextureTools = (function () {\n        function TextureTools() {\n        }\n        /**\n         * Uses the GPU to create a copy texture rescaled at a given size\n         * @param texture Texture to copy from\n         * @param width Desired width\n         * @param height Desired height\n         * @return Generated texture\n         */\n        TextureTools.CreateResizedCopy = function (texture, width, height, useBilinearMode) {\n            if (useBilinearMode === void 0) { useBilinearMode = true; }\n            var rtt = new BABYLON.RenderTargetTexture('resized' + texture.name, { width: width, height: height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture._samplingMode, false);\n            var scene = texture.getScene();\n            var engine = scene.getEngine();\n            rtt.wrapU = texture.wrapU;\n            rtt.wrapV = texture.wrapV;\n            rtt.uOffset = texture.uOffset;\n            rtt.vOffset = texture.vOffset;\n            rtt.uScale = texture.uScale;\n            rtt.vScale = texture.vScale;\n            rtt.uAng = texture.uAng;\n            rtt.vAng = texture.vAng;\n            rtt.wAng = texture.wAng;\n            rtt.coordinatesIndex = texture.coordinatesIndex;\n            rtt.level = texture.level;\n            rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\n            rtt._texture.isReady = false;\n            texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n            var passPostProcess = new BABYLON.PassPostProcess(\"pass\", 1, null, useBilinearMode ? BABYLON.Texture.BILINEAR_SAMPLINGMODE : BABYLON.Texture.NEAREST_SAMPLINGMODE, engine, false, BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT);\n            passPostProcess.getEffect().executeWhenCompiled(function () {\n                passPostProcess.onApply = function (effect) {\n                    effect.setTexture(\"textureSampler\", texture);\n                };\n                scene.postProcessManager.directRender([passPostProcess], rtt.getInternalTexture());\n                engine.unBindFramebuffer(rtt.getInternalTexture());\n                rtt.disposeFramebufferObjects();\n                passPostProcess.dispose();\n                rtt._texture.isReady = true;\n            });\n            return rtt;\n        };\n        TextureTools.GetEnvironmentBRDFTexture = function (scene) {\n            if (!scene._environmentBRDFTexture) {\n                var texture = new BABYLON.Texture(this._environmentBRDFBase64Texture, scene, true, false, BABYLON.Texture.BILINEAR_SAMPLINGMODE);\n                texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                scene._environmentBRDFTexture = texture;\n            }\n            return scene._environmentBRDFTexture;\n        };\n        return TextureTools;\n    }());\n    TextureTools._environmentBRDFBase64Texture = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR4Xu19Z7PtTHbW1g3jMMbGmGDAZAMm5xxMLDAU0WSKWOQcCoqccw6eGdtgk4yNbZxnvvAL+Af8Af6AsQl+06ako9X36dXPSi3pnPu+cz/cOntL3S1pq5+w1mrpLs/eud9fvn27rf9evPPwFz+v22S7fGZ/n7/70G79J5/Xv/qzbLP+Pnvvoc/6Tz7jX/15/c62LfeH7fofbpfP3l/ct36Wf+u4+D37+XYb++G26LPsr/zFttnPuh37bm1bt0f7MvtlnOx4uv0H4fty8UUsz77rfn/57u32cgXvDv72eQf0tl0+G38b0Nf9K4Dl704MEfA16KsE8Gw9JgD+DQE8EA0DT2b7GwK4GHnF4a8iguXZt9/vL5/dbisJbEq/uwD5vIK/fbbAv4N9U/8nJIDNCazKvBLBGwdwu62OhajxmQSAx6gqNp5HCg9wPan2nwSNjhLD8ux/3u8vP3y7vbwDAYjtR8AzFyDqLu1Q+YEINnew23rPCYiKb+q/K7o4AVT4tg0t/h4ydJZfkQASQ/d5b9fZ/Z1ENmuPn/cwYCYEELBguKC3nRkCnE0AFOwOKCOAR/sH/L4hgFMpbSWP5dn/uN9ffs7t9mJ5cAHoBLTyszBAFJ/F/xIKdASw5wgaEWDMLySxAk4svf6L+4QAGPiJCziNAPb4f3UZ2dh/m+z7BK4SAPYrxf5FB6ABPgCUAfANAZwKyscc7IEA/vv9/uLzbreXzx9cQCMACAl00m8jAlF7ov6SCMQ8gJsMFFBnCECSg5H6TxJAU3vPAbwhgFfz9AABeOEDBcIbB3AqPzwQwH+731/8sNvt5Ydut5e3B2C/fG9P+jESgGz/RgxG9r9VAwTUUh0goQDafUz+DYnAnSha5l99Z1l/yQVswAZSGIAugNd/9xBgCw9E8aECkHUB22QPHIAVDlQdQAMWAibhBgZAasAVHUAI8Cqg96Tm0bj3VBS9jwd7IIBvuN9ffMHt9vLTbreXy+32QlwAhgMIeuNzKwOqCoB2Aa00KHE+EsIeDuj4H2N+Hf/TfAC6A4nhgQCQDDwiaKDXiq9KgBEJNPArAtCk0AEd2mpAizW3/lYIoANpBPg3BPA+hjs/9eXZV+0E8Bm32wsJA9aEoBCAuAABPiEAC/yDC4gSgRgKRHkAlgsI6v7iEFqJEMgBwb4BGkEfEEDnDlReoAP/SQRgOYIB+IYDMEE/SQBbXoLNr0jhq4qOZc0PHBSf5oKW519xvz//kbfby8+83V68ABfwniIBgwgQ/HoRUMv8w5qAoQqgk4DWQiCw+63eD8k/XAPQgK5s/5a5xzAAqgR6wY9k+ZEMtCOoJABb230hEHMFWQdgAl0Ap/+uc6tKBrrP/n0AuwfiNwTwNKguHHV5/qX3+/M1B/Ddb7cXax7g2e324vaQB3hhkMAW92tHoFb96cVAbimwkgQ0Vv7R+D8iACfuxzKfLvnNlAAjAsBwwP2MwLQAD9sbYJME0AFcg5uBPSAA0x0AobhtcDKDA0j3KYDhk7Hp8uKj9/vzH3C7vfget9uLT9nDgDUZuOYCLBJA8MNKPyGGIftPrL+4gy3eh5p/lwRUYYAs9Fn7tM/E9lvJwCH2DxJ/mPTr4nyyLiDtBgTAGCrgNuPzNuETgN+suEEAFhng9lkCoICMLH7V0isCeEMCxylrefkl9/uzz90J4NNUGLDmAnYXINUBrf5dCCAuQCcCvYVAYPk3G++VAveVfkIAFRLolgbr2F9ifP33pAqAV/fHRF4HcAS7AKlAAEIYFNwITOszs/wMsB6II4BXFZ0QwBsSOEYCDwTw2TsBfPrt9uLlqzCgcwFABI0EVCiANl8Uvq0JWNsi2JPZ/0YKsOiHxftsW4v51ZqAaBWgZf91PsBL/jFHwEqBR1cCiuJ3gAfCmCEA3cf8rmz8AMZHIoA3JDBPAsuHVgL4jNvt+UoCH34ggK0asIYBGArsAB7AD+reQgCl+GwZ8LaNlP3MEEDaSg4ACMGr/+ulwV4JsAEfLH42/vdKgWElAJ4QpBl+LAlKErHwt+oGMgTA2ngE4IUIOH3dGr/hAKT/m/UBdSJYPuVL7vflU26352sScCWAD+0EsCcDVxewKjfmAzAsENVn4EfgdySgnYB81yEAgL4RA8T8mTUASAAYBgylQAkL8K/+zL6rsl8qF6ArAeS7WRGoAB8Sf7isN/VZqTs6jQ5wXlweWfyqpQ8I4I0TmCCAT/3I/b48u92ef9bt9nwNAdZE4FoOFALYXcAGegkDMByAzzQEgJh+cAIs/legH0IA5QTCPADE+7ISkD0TgA/8sBIgLQfOgF/F9kPcr+J8fIYguyCILQRKgV4DNviOzoKqeJS0u4AA3pBAjQSWT//I/b5OmC0MWB3ASgBrGLA+IryvDNxCgRXo+wKhjgwk8bcTwUACsJ09ANRVAALwCxmEoFcrAUsuAJ4M1E8BDuHABAHomJ8RgACrZfQLyT9dBWi2OOEG9NJd/TDQ8HAQuBE97ZhjGKy6o+imnU+4gDckkCeB5cMfud/v6zr9Dz84gOdCAM/3JwQhF9CAD25gBWWz/8wNgMpj3K9Lfy0foMMBVffXyT4r+cceC9bvCcDFP0311QrATPkvWgosYQFLAuoqQEcQuw3v2si25F+M1RkZXLUU+CgBmCBOEsCbvECOBJbP+Oj9fv+u2+3Zp91uz9cy4Kfebs/3ROD6iPD2b10YJCXB+0PyrgsHdtBuRACfBeTN+uM+suJPSEDbfh3/oxPoHgwiC3/06j8Eutj69sAQqj++I0CUfvIpwCEvYCT90O4Pn1XsT5Ve1/+dcp9FBh3woqXBSEJkvjHHEOUPqJPAjUUCeOMGfCJYPvOj9/t7//d2e7YmAlcS2B3A8xcPYcBm/7ULEDIQew+5gS0EIEA31R8Uf6gAoBsgKwBd9ddvBBJAs6XARgLQXQ2o7T8+IETe+9eRACg7rhCMVgCiE8D4O9wOCb2ubOht1/vYd2ubzLlgKbBHEDSnAMfL6durVm8qBPwXWz7rY/f7/X/fbsvL2+3Zqv4QAjzfw4COAMAJbEC3wC8koBJ9lAhgxZ+4hi3Oh/f8dU8EqtV/JhHgWn9cC4CJQZXZp6GAk/1nawMkrrcqAiwPIIA2FwOB2oaAF5UkcX+GADBs0I5gsNbBQqCorJcFJjqWKvhNMjky0Aek7/LZH7vf3/vO2215vruAD91uz/dSYCOAPQzYkoD7vw34sFIQw4LNymNSUKk8Wv0hCYhkoJ74Q6BboO9eDKoWAHXvBiCvAdPZf4nt3QqA924AbfXV8t8uN4Bt2We029WkoErWpSoCSm11TM8AOYA5uRS4RAITIQDDavaYHxCcm5exfM7H7vd3v2N9McDt9uxDD//WKsAG/ue32/M1DEACuO3g1jkBsf57fqCL/7UbIISAio85AAG0VQEYiIC9DJTYfy/+Dx8HlpeDRK8G90IBHQbgWgD2WT8LoOJ7NyeA5JEkAwwxmuqzur5X6y+sBEwDMggrqoBNH7c68Puk/fI9Vwfwvx4e6H724oEA1iSg5AAaAewlweeyLmAnAHQCTfU1CTAH4GyTMt+QDMRFQFEYQB71lXUAOjHYlvTqh4N2xe5yASoh2PpaJUGDBDrLr9cGIDlY1l+vDlQOAQHckYMiA68KMFsGtOy65RCGsMIDT+QqJoD3yUwCy/f+6P3+7koAt50AXrwigM0FrIuEoBrwHMMAUhmQUKAlAwHo7VmAPURo9h/r//ozLv1V7/5v6wGMV4B3rwYPXEBqIZAQwp4TYDE+LQlqtQfw6my/LgsyZaeLg7wVgmDnWQ5AA5ZWCDRx7ECzyn3udgFptFCIgTlyFRMEUCKgA+O/jl2Xz/3o/f7Otz88QvpszQOsLmAPARoBSDVgud02AthdwPZ5BSxUBVr8L3kAVHrvs076KSLQi3/M9QCJ7H/G/rf4n8X41XIgcwHecuBMDgAe+BHA6uQgqnvbF5DB5hwUQM3vQgIWkKOVftH+gAC6cz0RXZ9MjmD5fh/ZCWCd1CsB7CSwhgArAUgIIC5AQoDOCewJwab+CH79WR4C0mQAZT4hEQS9DgfEztNkoEECDfi6FAhZflb6Q1XXqwHDEECpvZX4a0qP1l7bfAS98cQfzQUo9a4mASMC0CsIm6JGK/2i/QkCuFK9PxmIYPm8nQDu795uy3K7LTvwVyJAB7ARwJoAVLkA7QIkJ9A5AQS95Ad2YmgvAJWwQFcBpB38pUuB9wVKbAWgCXwV86Mz2ICKTwUWFgOxMEBicr0eoBwCGBUADfxsDsAiA+zflNay31ZcfnAdAAXgDGkcdAcfZCJYfuCX3O9vf/vtthHAmgcQF7ATwOoAtn9IACsRSDkQ/wqIIUGoXYEQQ/sL5IDJP539776DwodVAGlr5QBgP8sDdApP3gSUXQa8/rZsRaBeHmy+HwDyCI1MUNlZzX9iJSBO9igJGJYCo4RdIqMfJQ4Ztq8C7FXjHuSnQ92XH/yvdwJ4Z68ErOXAlQRW0O9/JRG42v9GBHsuAImAqv+uzDo30C3yAfVHoHeg9xyAp/7wlp+WFCSWv1sOTBb+0EoAZP5DImBrApAUMFHolQG19c+EAkbpjyUEdQ6gm/QEsCzZFxKDlWNwprJVWfBm/1WAvWrcQ0ie7Lz80H91v7/9v263+9sPI2zrAZAEdvXvXMBKBJIIFDcgyUAEvHICg/o7wA/Bvyt35wCc2F9Cg03RvRyAA34N8hD0xsIfXP7bQgDMFSgyYO8GsF4N/hQ5ALak1yUGRQDZZJ5VWXgKEsie8yQuH63b8vn/8oEA3lsJYJ2EQgD73xX4z9bs/74gaHMBQgA7+DsXAJWBBniHCLTtNx2AUnkG/LYNiUCpvX7wp6sIOHF/lwgkNf8UGagwYMgLMBdgLQCyVgOyciCGCs5nz/Jr8EXOQOcQZEbrfjjTU8qaCBseMyx4vxPB8iP+RU8A24Kg9R8Qgaj/av8lDBgcwApQ+QdVgW0bKr3+jsk//AztzBKgtv4K+Kj08rl7JFgt9BnCAIsQcD2AsQAolQj0CAGAqhOFCK5u3cA+84dyIJLCPm6buAgoBa5qDoDF6wzUkZ13iSDKKwTamSKZSf29cuzJUwq7LV/wz18RwH2Nl9dKABLArv6bC5B/+9OBGxmsIIR1AQ3w2gk4RECTfwBulgC0rP96/FYJUOv9SzkAB/xuKTBY/qsTgZ0LILF/s/RW9v81ywEwhbeAwUIH6hRwGp+wEOhqoF49fojqQoPlR/+z+/3t77jd3n3rdru999CzEYAQAYJfXACEAqL8W5lQgA5uoJUK9zxBB3ii9ALiYT2AjvuN72wFILP+XdlP8gLKFeg6f5QM3AC+VlMMZ9ABGuN+VePHWL6tHVD23or3tQPo2iWfBRgShDp0ELcBjmIAbwTWqEzIJvLM6kEDEFcD9erxCzg3my4/9p/e7299x+323lu32+oAtjwAhgE7Cazqv7mAvRLQcgG7A9B5AAwHus87CWBYsIKFfe+eCSBgt2J+7QBQ+VsogOU/9fIPBvLhASEF8AHwlhPQ2wVYFhmo/Wby74QyYLcmQAEbbbue2FcnAb28QTmHQKBwNVCvHv8IESw//h/f7299pyIA7QIE/LsTeIbqL59hPUADvHIBG8jBIWgn0L4rsKMj2Noomz8QgZELsCoAAnh0Caj8lup7ib9tX+ZBoKgUmFkWTGJ8S/UHZa/kAHT+QGaeoeQmMUC/CoAzVYAjYDvSNwPCq8fPnINus/zEfwQE8O7tdt8dwGZjIQQQ9Y9cwAB+RQIC4I4MdvvdLL+O//E7LgLykn6q3Efjf6X8bOUfkoNYcQZ8z/KzBUBYCqT/YQgjBuOBHxPs7JHh7JoAy/IzWz+xEtBKBEYg8fIGw+SeQQQ+CzHZP+oWXWPU/8z9y0/+h/f729/5kAN4791X/6/cpl4SCsDfLRQwHEBLCmJFYH92vssNgBPo7D8qv4CekIHpAjKgx1iffGbKb5UAQwdguIAtz2KsEWj7vIQggNON91lYoIFN2mznYKj9UBmwQgXLLcDstRTdBchEFWAWcLP9MgC9cuzM8aXN8lP//v3+9v/uCUDyAM0FIBFADqAjAsgFiAvYwK3/MfAL8InSd/Yfy37Qpyv3OSTgxf8C5vZXPfF3aB2AA3hJGg5LghMOgCUBo8SgEAyC3Irvh5xAwhW0cT1iQBKYWds/QQLdeVUQcrEjeGoiWH7633sggHfWJOAaAkglYL/wLQyQf3tYsCp9CwmgFIgOgIJ/JwMdBuB3cQTDX4z9wR2whN+WE9idh67761p/F/8bpb8O/OotQCsJDhZfji0qT9p0LsCI83X9H8E9KH8iCSiTrQO29bwAAbvlCipPAw4T/oRKQAVElbaMJ472t7jnqnEjrlt+1t+539/6P4oAxLquawIkF7Bb/40M9hAAHcD2GVzABmBYKSgxfyMGAbROCipl1w6gs/8ZF0Cy/UIOOr7vHAIu9iHP/2v77yX9ROUt29+AHVUCnDJgtvSn8wXsnQGzIUAW3F27qFS4z2CrD07wCogqbR8LtGecUwR4vX/5OX/7FQFsOYC9FCiToBGAEAH83ZwA5AM06BspiPKrNQIt/kcg69iffBegNqVXb/wdQgIMC0DltUuQ+L+Bmz0OrNTdK/91+4JVf15SEPMCYRkwEfc3stBxurMS0AoTMKRocaV8cKw6jpcFsdUn2/8qRT8buGeP55HC8vP+5v3+1v99cADvvfNQBZB4dO24Kv5GAntSUOz/+n1wAis4wAnoMAC/N9svSUKsBABgmwPAbQTwWzsW/2vAI6j14h+1CEjnBYZFQWSxj+sEVFyPjgBBrhf+aOtPY39vRaBVJlQ2vyOGIATQsb6etBguDMSQyAF4IMhUAmZANNNnUNSqBDvtzzif6HSWL/wbuwN4eycA4gDEBQgRYPzfSGC3/BYBdOCHxKBHBAJoAbdWfIz1I9XXsf5g9y0yAJB7iUDPCaC6e2EA2ngMGyIHwAgBldncf4ID0EDXVp1NYmbnrclOtyfDhiPOoCO4CEXB/rOBfOZ4yy/8a7sDAALY1gKAfWMEgOovoNdk0IArKr+7gwH02gWQ2L4t/sEEoLL2IQnoFX96HYC4CIz/jcSgAJSVAtu2RPZ/SPRBHkC7AkYEqceC2fqBfdKaCcHAAeAkpKVBCANcElBVgBQRTC4HngHOTJ+rQo2jhEbP6xf/VU4AmBza7L+EAZgLgGSgxP8dGQDwmQOQbS2xp6oEWAnQn1seIEMCJO4fsv8Q2w/JQU0IJMvPiCCT/NPuQP/noJ0rAFBa23VSr1N/vQhIgxzzB9odMMIAkGvFZPF6JkyIlJeFFl6IcRYYX0ciOOOcll/6l+/3t/7fngPYy4BSCmyT0SGAlgvY4/+BAET10fZjUhAWCg2AV8nBEPQ6D6DJgSUAoQ/G+Dr+T9l/pfg0HxAs/e3WBUhbsihIgHKkHGiGCQHYO/UHomDgdd0BcRkZlYtyAFlgZNtlzqkSJcwc1xr/6FjLL/tLPQG8t+YA3tuXBKPiqISgAB//bjZdkoNE/Rs5EAIYXIAKCwYHYJADlvhalp8RgS4PogNwFN8jgo1A2LoALxRw1gA09TbCAjckQHBZlQEFwEoS0Iv1S3mAYFGPlwOIJn+0v+ocPohEsHzRX9gJYM0BvPvwTyoB2gGsP6iEAowANsBJWAAVgRYeAPCb/WdkAKEAttNJwRbzM+UPQI8K36k9Kf3RagBTe2vhj3o8uAFXLxUGxTdXBrK1AIltTZ2JzUe7Lp/Ralvxvrb5kcWP9nv2fwBzIRF4FRFkx/XcwRljHCGm5Vf++fv9re+63d4xCABVRhOAJoOtRCguQKoCmghwv7L/mBPQwB/KfMQhCEF0ym8RAUkIToUAxrP/gxOwSoDGmn9WCjTzASw3kHQA5poA7Q4g3n+MEMAChiadiopXwHZV26usvB43e/7Lr/pznADakmBdDcB8AFj+5ggcF4AhgAlwwyUM6m+pPgF8U3BS6jOdAAkJ3HUAO5C7ZKBT99/IVDsGhwyY3e8qNfhCERXDa5BrlW/ftaoqe265Ar0U+PIQQCUzqwqYBYfnSK4AcuW8sjmHaMzl1/zZnQDeud3eXRcCrfH/ngNYbyxzAKL8nQNAMiC5gI0gBNz42XIBAnAkBACwqDyWByPlp2BPWP7WD0Crs/5ewq+1JaBnWX8rEajbDiVAlbNpwHRyAJ4D6EqECQcQWfxo/0wI4E3wcPJnUbSLXqH5A26qHaD9kb7ssKaj+nV/ZiSALRG4rwhsJLBfUKt/k3yAJMGwEtCFBGD/PTIY4n6d8ANyaEk/Q/nPUv8h+WeRgXYCVgIwSwbK3osKi4PonEGUC2C2Pngc2LL73Xanlj9bBTg7BIgAFe2vuoxZS14B7wy/DCT8xX/qfn/rrYccwLtrElA7AJkgkrDSJUHJfO/Z/wZ4Kx8g4IXyYKfm0i9QfkoSJK5HghALr51Ce2Jwv0ad9BvAj1WCidKfZf1x3UDnvPQ90HYf7o1WfSQMGbOpU1D3H6oCynpjPE7VfSccpoalMEHNdAxFKkDLgDzTRo5ZaXukz1E34f1Gy2/8kzEB6MUlsjCoCwWMEAAdgOcGTECrnECn+JYTgPyABn0U82vwt7hfJft0rK9DAlHooTSolH94GxBUAnTSL/reAbz6UBADt344SDkIJBIT5E62HgnEAwgFmjq3ChFkAJUFd7Zd9fwsdZ89nnX85Tf/8Z0A1hwAOgDJAxBbuU1usboYCoiCKvWX+L/lAUDlNUG0bD8Bt7dviP9Vf0v9LbV3XQCz/3qbZf2d0h8D+JAPYDb/RAfArL1l92W7Z/OjEICpOZvkw7bES0EisET7M0RxRNkzx78qJGj37rf+MUUA+zoAnQjs1gTAhJNyFy4X7kBtkYHKB0ifDMgrLiADfJMESGa/Cwe0/a+CHsmA5QQ8N6ByAzJZh1IhEobOAegsvwaVDhEKDkCre0cielYbau4SQfIZggyIM0DMtMkc6ywnMHMsduzlt/+R+/2tt2+3d8QBiAtQSUBaEVDxPyYB22cEuiYDQgJtLUFk7539ke1vgAeAR05gC3ekbAclwuaEjEVA3XoAAnLpT6sBCuStrUrIpqsBHhkwcBOVTecFJAteCAFSyk/GzapwBOJofwV0mbEQkNX2p/X9HX9IEcB7eyLw3q8IlPgSbV/LBThEIMreQJkhAeYOIsDrsELV8VmIgHX9ITGo1L+BnxGB5wQY6IvKLzZZCKD7nsj8m+sADjoAVHk9ga19tF1CzSk5GO8T9MCUAdpZbSqEUW17lpNYfucfvN/fBgfwLlQBcEnwdkA9cdGiCjCgGrCpZhACDMSA6wL28dewgKl6GzuI963EXwtf1Nr/wQ0YMb+bCJwAPgKc5gPIPeiImeUC4B5J2zbZnGXBQjI4Mdk2HFNPYqv9MNlJCJByAzPPEezIiUAe7a8ANjPWGYpePc52Db/799/vb7/zKgQQAnhvDwH0cwFWLqBluwkRYJ7AqgoMTiHjApTqR9ZfbLxbCbCUX1wOKQGiO8ASn7XdKgMimL2SoG4nkxGVnqk+OoeBDHR4AN87EmCWnlULBGiBuiNJMFC5RJB8HsACRgYwZ7WpEEY2pNEuYOoYv/f37Q7g3dvtnT3+39YC6BBAv3IK1wVA9p8SAYC5gRDBqz53QDasvag/dQboGMCy0zBA7e/CgoTyszX/VeA35QeH1YGc2Hwr2YchGn5mJNGVd8FdoEOIHEBo9VkeQc3cqFJgEkPhxSBHwoIMCVTAlx1vlggq4y+/7/fe72+tDuDdV2XARgD7isDtd95BpZWjKRUov4Acwa6BT5OEsEjICg1aBUAl8DpwA2kgQeCYbHsjL0zygfKbll9XC5xk3zYGgM1yA0IKERGgI2PJQJ20M13CAQfgWv1kEjBj+Yc2zlqAGdWPgBPtrwI2O16FXMrn8Ad+z04AaxVgTwDiasAtBNgnrK4E6HBgSApichCBBHkBCnQNbmb1iTPoSEXlDXCfTv6x0EAA2OUDtCPA70bMT6sAXjVAlf4sIhieC8BYXy0CYk5gIPKCA8CJGzoAI5QYJqoRzx8NAZ6KCLLgzra7igSWP/i79hzA6gCAAMQFrBMNSUCrFypUm+x78k/cQRffY45AqatOGDJy0CDHkh5dDERielFhWvrTIYHO+icy/jK+qe6sCkCAH70erLsXylXMWv5GFowQrLyACISU6HZ0W+RALX0Qz2ug4NgYUWScRNQ+q6IZ8GbaVMCdHS99jX/4dwIBCAmsoNd5AHAB1sRDArByAV1YgLkBnfRDF6AtPbP4LNY32lkOgMX/tPynSKFzC466Y2JP+mT+mk8BOiVAVP2MA9COgH4nQGcgHxyCAe5uMicqARTcJ+QBIlB5+6O+V4E7c9wMCSx/9HfkCEDyAMPDJiQZ2AABqtZUVwG7s+ZWMlCDO/F9iPFZso9l/IkDaMRgxPqe4g8JQa30yg14pdaM7TddgWHxXcUPVgLqvnqyWw6AqrlT0jPV33AekYJb4IlAdfX+6LwR0BVi8Yhg+WO//X5/e68AyLMAawlwCAEwF2BkpTfgqwlu5QU6G45KrdYNsNi9qwAQMgjBnyEDI77XYGcxfjXut1wAhlfSptsGoNHJPab6XkLwTAeAk1MIidp+mJlRJYCqPxCABwizr0aUDl3I/ogEMsDMjJEZp0oYjECWP/HbSA4ACEDWAbA8gJ6MjADWbYP6i5LqvyRROBBABHgjXEAV14k963s7d0koOkm/s+J+FiaERADqbjkAHKNNrsRCoE7lmYsQ0HjlPm+dgMzKRLmQkkgyBJhR/SPWPwPyTJuriWD5U78FHMB7eyJQ5QDaYiBhXL0mgGWumRNQAO/KbieTASMOL8bvVgUSq2/lAvAaOvDiwiEjs6/BThdZ6bUBJNvfuQN0Z+pzVzI09nXqrT3UMRMAACAASURBVJcKg+J6xKAnLao7Tvruc6ZcyBS6EDpUXUIEvgyAz2oTnQuqe+aYzT386d98v69rALZ1AEIAazVgz/4zBzC8aorlAdS2rkIgC4e8v2TxkOsGMLeA45I6vgZ7ygFg4g8JQhOdl+FPZv+ZnRey0CQhE4PtH1TfCBmkXQd+S+1ZXkCTiQZq0gG4sb6qMHSAKFYQHpsIMoDMtKla/syYy5/9Tb0DWGP/7R8QgOUA2NtnzEw3LhRS6hjlA9CK6/gfS4XU5rOk427p9bg02cfATtS9CwGcSsB6/taTf9Zvx0ItvQ2JgH7WgEYyMMA+5AwmHMBMDsAjAhrPTz5M9H4mggy4M65g+XO/YSeAXf1lLYAsBca/24D7MwKdakBIYOUBxKYyJ0BDAeIOTOW2QI75AgVkXNVH7b+VBFTgDisAQda/gd5LrCrlZpa/WXJrEVBk+cGxNWAkqwDMQWiFNq2/zNKgDOi6A2NFICULRAV8rrSN7HgEzmh/NH4G2MZlDi8qXf78Fz8QgNj/thjIcADtvw9HNcgQwGxIwPIGLHTQVj8BfszWmzkAlZsQwFrlPbcCYOUCjBwKKwl6pUBRWyFhukxY7LmO7414X8f61BVY4YLY9iDBhy6BTX6LPJCoPHtcAXelbQRUD+gZEojGZyCvjrv8hV/fOwArBGBLgnFpcGdJYUJ0gNknxLDNCwm8xKEV6xtqPwt4DWpm92kIQICN7bSNF2Xv/pLfUgNd5wxoCEAA34GbqL0VAmhSuMIBuIqv8wGJRUQWmCzAfNIQwV/8tff7O+9BEhBKgEMiUIUAXjLQinMbAAAcCIruFWMVgBPFX28iLhW2Yvzu+JCo06A21wAQm69XRVJwk+RpaiEQCxeQKEDlaWhgtEWQWEqvt7vhwoQDKAFfjR+5hytdgjf20X1HLH/kIpa//GtUCLATgE4CogOQz628IwzslKx0gosuG1bWnuUGotJhyzUYYUIjBSsnoJKVXZnPCAeYo3EBH1UDDIA38CniiBR/CA1I1r5VEQBUg/1XVt8jjG7iWZUD5WEz5UIK8sRagIhYquQQgfqI/a/aeBYKZMOD5a/86r0MCGsApAqQcQDbgTQBMNuqJ70GE/nuOgMSGjDFj7ZZhNABnxBTIxon459Vfa9yYpUEEfRU5RXounEUkJEgGJlEYNb9O2IQ16hsO07y9nk2ETjzJKG4JIKUSlgQKqyDzgzQM22ic/AcxPLXflXSAew30no8eDsJvBGWyhmJsKojQOAOi3R0yRFtPcvuqxo/tf7qeryYv2T/mZqT0IARgfzmG9Eg6erP8Jvr+4Tk4Sk6IwnWfgA/IxsCPhmfKWuk3ugcqENIgLwC+hl1j4Ac7c+CPDNOd4/++q/ccwCRA1iFHkqAtBrA3ICh/J46Yp7AjM+DHIK27t1aA0YIbKGPIisrw59NAOqSH/0NEKyMCBS4qwnAtNpnk4JGnN8pfKYKoIgiA2R2DEYglW1XE8FZQI6AHu1vv8nf+BUPBNDKgFYOgDkAsHdmQhAnkhP74kNDg72OwgMP0CRuN90GW+CTdCwWoVluQKv3EAYQ1cZjuOpv9JXJNyT49KIgliMwlByVu7kJUFwvPBjcQuaxYSuUOBAGZMjGIxEP1BEQn3z/3/oi4gA0CQD4uxAACMBLCKLNjFSPJd3Q7rtJOWu1oZNcHMgmE+8H5T3P3Xj7OlCzCgEeN+sEVDs8Rpu4Ol9ggd1ScuYWkAQIsDv1lrYqB+BZ/2FfsBqQAe3sbZG6Xwn2aGzr3Ja//cuJA8CnAXfr314SajgBkwBwAs6EAwmwWWFChThY0s8iI297B3DDPYRtCLi3Psb2AdRAHrKvqb9BCEyNtaKXS4OkoqAnomXjKUEo9e/GSjqAs0HvAS8C5WzfaNwKES1/95cZDmAlAbIacPudIRcgi4H0oqBuUirgU6WDSVtJsHnJw8gtZNyGWeJLEJNn61vZzYjzo/3dQ0Ea1DgmUXMWAqTAbil9UOaLynttQj+iAzibCCLQRfstUM+ShJiqqP/y937p7gDuex5gBz5bByD23woDMA9ACeCAG8jkCLTis+8ZUhjCAisZOKvwySw/OoWONFWMrmv4ZsWAqX+wrXMGbLkwnMvgIowEIWuHTsV1CTKz978WeViA88IKDzRnA/Ts8TyCcUng7/+SngC2twFZJLBPljIB4IQ1wgA9waPM+rCfJApN9Tae1beOGZ1LO06CEKj7UbF9A7CVB7AShIa9R3Uf1gOwhF9V6S1iEEQFDqFN3my14IJEYNYRTANNERd+PZMMIsXXp7H8g198v68VgHf2uP9dBX5xAtvbgaUUqEqCg/1HKweAlx9vsLeGIlqxchWojCyqY1RCgXK5jxGHofIsD9B+V92nSAgIxCEkgLEGBU8mAaO4PgoVmEJbOQQG1CzIs+08Msg6kAwRzJBOlgiWf/SLRgewksCq8l0YAKBveQAgBGb/t4vDhJQmAwf4a9dQeZPWnJbiHMfgOYeNlAKlx3BFOxs3L6B+LySS8EUg6rzwuEgQ3luBGugDqx/lCzyCGPbtCBBi05M9Io2OFB4hEXgmGLMgzZDEjIvYruUf/0I7BGgkAJWAbY46SUArGThMyAIZVADH2ppEkiCBir2n5xmpu5ME1I5pUH+LYEnFICKEDpiFEADPSSu0JhQX/MphTBFBIYnI3MRjgLviLs48H9OR/JNf4IcAK9bxPwoV9TerAXgj4T0BOJk9MhAQDZOfACUCNgIy0zbTJpPZpyGAQwTiKug7AYkr0L+N991Vf00gpGyHINbK3yZVMQQwVT2xEMh1BEZ/Nvk1EKsKmgXyGeOeTQQdEf/TL3wggNX2b/H//jqwLRGo1gC0HMCeD9AlQPw+WDqZJEZIoCdaNY6OgOmFAVq5u7ae3Y9AHam7sd8kApUsZHaekclAvrv86eoBcwkZkFvrA1hf1wU4Cu4Btu1T/c8G/hWgrxDEmSFDc0D//OdDCEAqADoPIMnA7a8wrv6LpSEFfJlkoQtAdfKShEmAWlUDN7xgOYYE6DPuBY+Lv0W0HRXdK/cN2X6l0jqcsICubbx2AVeFAK7Sy+zV1YDiasAjgH6MvqZth+vXH6sksfyLn/eKAFaw6yoA5gEE9FYScDsZZfsR8CwhSJNb2Tq5UVLsQO0lE5Pk4bqRiBDU/oEcHFVn9X1T4dFZ6TKhYfWZcltqbm6HsZm6D07QKuGRcqQGgEUKSF5N2QySYPutbZkw4SmJwCIIJIXIYSz/8uf2BEDXAWAosN/w7gUhAHwhge7GY2wGBKFtf5oMGKgcl1Cx/wKwKKQY2hWB3oHbqver7ab6J8t/2L9VbaR6sM8auk4gArlRNbBchQnSaBw5RyV7lRCAgSYCerS/otRZwqiMmSECc7x/9XNUDkCvAyB5AAwDtrlBQgG8KegCOsvolQgrgPKcQKTQSReBhOCquBP3a8LTToXF/vpY8ls2J6AdBFH/rNJfov4YDoL6UzVP5gDc8MBJBFbBnwHrWW08EEcqrvhw+5oNBZZ//bMLBCDqb7kAcAJtUQeyOuQDcGIPnzFeJQClSbJqngBULW3xIzKpkBYe3wGxkISn/u5zASwccLbh5NHhht43ELsFcGeFXwfmA1UAdBsZ9YxU/ej+zDkwJ+RtO5Mkmhh9yc+637cKwJ79lxyAlP/kKcC1IqBzAJgL0K4AQwC0m7hgyAsBrAVEaL0HJU6SQKeiyT6dWictOwsTsqW+9ttosAax/pA3AKJBEqEhQLX+T+J2PG9GEIxEPPC6ag/SNzhOtm/fZo3JABYpfLT/KBFU+leUvxHNR37mSAAC/lYBUDkA76EgIYWOAHASKnXHm4/hwaB8pIxIV8oFFpxlziNws/0diSgF91bwuQQmE7QQ+2fUvwO+pf7KkXRA9db6W6QB1+KCHu1qMgTQE70DoTOG24/Y5qMuIEMOFYBXQ4FM++WjP2MnAFUClGTg5gCEAMhy4M4F7JNou/eZ0qBWELD7qO6D0uNkZXmEwKqb4HXI4wzAa8ejLTYSjb5mfXz8jgCvlP86YrhC/ZH4lfpSFU4SgAfMo88TZFxAlRgyY1aI4Iy2zQF87KfbBLCVAAP199YCaBJAV9AlnAxX0NqwnIBSrHSSziAPa/VeJt/ACMp0AY6l1+CNvofqb6h6NikoJMMUHN2apayZNt3YxRwAPa6Tb2iTXj4cVP2MwkdkUQFz5njsGt1tX/rTHghArwHY7P++DBhdwDanYCWgzgPIfh2TtfUB+6QcJhcBedfGUXoGwAaOyXhdKy4rC1rxPAtlymqfjP0x5h6ArVSdARJdiQa6BWC8t3h8RhQ616AnY+cEigRQdREWUZ1NDBnFz4I5Y+OroMf2y5f9VE4ACH50AS4B7OD28gDtxyEVgW6yOIQwWGlg/Uz8bQLXcBoa/AM56Dq8FcMbCTyx/o3ISF3fsvaMWPRv7JLEPht08nC4TyTDb5UNI1VnwO3coaHQFPBKxa0QwAO/G1LAucwA+2oHkDkny2Vs27/8pygCANUXF9D+h2CdC1CA334rcQf7Z7yxsp8qiFpBOKhPQAiW6jIlN9UdzllAKQBjdtxT9eF8HJLQ5xNae6Lska1nSu+pfyMjb3GOlxwEYrHANwA6sO/abdBxyRiPAf4ZoGf6WOA9y0Es/+YnAwHs4JfsP4v/JSEoTgD/is1veYFZEsB+xAp7gDEX0yRU2asQaHX2wD8QjEEsCDKt0pZqM2LpSqaiiNpteCW7mQSgukc4UTWxsH0Z8EaKT/erRGIW/E/pAo6AOdt35+Pxvwf/t0gA8BKQFfzZMiDmAYakoJ4oUB2gE4UtHDLiYQSa9bnsDEhJj4HfdBYHF/V4Vn8gvh3sh9Rfk60ot7c9Uf+Xc80AkDnCNGng+RrnzCa/RS6Z8zXBJDv0ORnf9bHY96Pbov7LV/ykMQfQrQMgVQABvP67//60BKgXA7UTU9Z/mDgk+TeAndjrBtpCBcEF9Wz23on7j1p9TW74mzaH4jgC/Vtri20uDdakzvIDbTL0y1I9Gx+V8CJHgNeTBfIMEXhjz5LDU5HB8pU/ccwByBOAXQ6AxP9sQVBL5EJGF8uByPYDCehJE1UGAuB7JKD3MadA22iFx9DCiPPpeZAFOZWyH46Jk2cDPiZFRX1IvI7XrMdg2fsOvCRsYGMM25QadgC8KAeQIg5BblAajOL26v5Z4DPrb6m95wKWf/cTxhwAPgJskQAu/aUhAIB5+22J9aelQa0uOuFFQoRBCY2Soc4PNBDBMQVAGJ50amqVI8kYOH4F3FTZsyU9EvuLMs4q/NBP3SNT1Y2FPQyQcs0RYYT7JxYTZQgiAmoE/Ki/8E80DgO+RQYe8Nvx/v2P3wng9updALgAyEoEYrY/ejS4katyBegG2OfOEqpSX7s4K0QohgVUpSft+5VgR7BFsb/nEkxScByD/s31pB2IIOMSIETRE9YLF0wiOGMtwcUu4EoyyIAe79uyEsDwIhAsBSrrT6sAuyJ0i4KU6p9CAkpl9boBNuHT7iCw9vThJBJfe8erKrt2IZZjoWSIcTkLCTwVt6oC6nojwLKYvuoWIsUf1DsZRljn7m3PAPcMBY/GqIK8YU/IHTYs/+HHKQLYAd+tBCQkMIQA7L0AQAxo8bbjI1MXPiOIqMJNOgIEly4HmvsUIaUA7oQ0tD/LuBsAzTqC7XosUnAy/MwBZADtKTl1fjhB2aT19j9RCHAGOWTGyII/Gyos//HHAgEo5c8kAbv4X6m+lRDEmy73EtViSEA5pcFOIVTSMHIEAgTLVuvVceXVeFWwO3F+ByIW5zuxv1ZRRqL6d2TK64E1Y/9dIiDWfVB3veqPEcEThAARcDNgPKtNdC6Dw/lPP+Z+fxcWAOHbgM2FQKDsQ/wP+7TSo+qzsiAqk1apLmGoVUor4kTpcCCDALzZen1EQpbNp+QEjgNdiZWxN8t4pCKQUXeLOChZOFacEoFxTmzsYRIjEZwQAnjjRwCL7Hu0PxofLnVc1IM7gzxGE96vWgkAHwUWF8AWAuGDQOyhIAQ/KwPu+9t5KmVvJwXtMHSgE9BQfU0g7oMy2g4byb9ZMFtkwUCMhNDtJ2VDDVoNLBoSEBLpQBYB18kPpElkv9HM1XRzwFB85gzw2BaArX4uoRRAFYG7up+RQYYgKm5i+aof/RACiPK39wAAEbB3ArSq3v4Bl//qpcAa8Nt3QhAM7N0FE7DTSWc4goEUAAwm8Ky1CNYCG69syWr/BJBWLkArvWflL1H/iDwE2I6dH0hKJkeyYtCRFYCThSdZYLuEwo6hCGwGlE9FBsNx//OP2gkAwwBJBBoVgK4SsE8KyQWwuJ8RAoIdCQJvpMXqVnlQA3z4TpRdjsHA1IEo6hss7JFzQQDQYwaE0AHAUmMrSWgAmJKomuRH7D8DmOVWGMAjgHb7T8oBeORR2XcFOcyMyfps2776C/ocwPr7df8rkEMC23xS/0uQLgVm3IBOAHYni1ldneHVcSMJKdbJEYYOQU7BDR+M8VMZeQZUY1tHVNYxlQJnQgJNKNbk9tzGAFovx0CWDXurDkPF1+MVcgBZhzDbbgaoVWdQsftNaIHcNwLQIYCQgCh9SwaC2jfgQ/lPg92qAnQnokIB6gCUcrlVAqNsZqqco+xMtTM2/FTwVxyBofAsvGGgNe25UxqskgxV+ETIkCaCAgFEzkLmqdXuqZ1ARBam6gMAl6/5kSoEUPYfwa/fBNSeBQBi2MZW7wRox8skBgnYTUfgKLeA11O4KDk3gJ0pWzI00BOYxuhOeU9fhwXWqdg/Io7MfuJKKNhBfRrAJisAFJgH1wF4oPYAF4HxyP6oLwN6xhls/f7Lj7jf5dHf9hdeBNoRgJH5L4UB+2TSpBDmBADsCG5U9izYq+Sg25uKqqsJhnJ64JdrcC13Mfan14tAdDL76MhM0qmOFdh2fRxGJBZQoycKI7BkQZ5tFx0v2h+BPw30BrhXH7bweCOA/eWf+kUgFvjxKcChGqAAbuYADCLQ4N5O14j9I/DjftcGe1UDpn7Ogh2LhCrHfyzw098Hwews/aVkkMzkD8qd7JciggNJQItUjoC0CuAjxMLOMzz3r/3h4ADgLcDM+ktOwKwC4HJg9ZmV/RoXWaGBUv1TiYABO8ofWLHwRDLPBd8JCn8quLMWPeMkiPozK5/dNpBCkAPIgnwWiLP9QqAqBc8of6rN1/3wh4VA8gRg9AxARwI7iFgJUCcAKwlBFg50lQIdDoCbMC1rpYKQrBygW+kUMcjkR+CsxvHus/sReCPQRvsR0A74rPCBnXtK6ZVTsdzgYwK+ovaVthE5zCi/8MnydZ+vQgC1AIiFARveINHnJQMbNlHlAbDbiTj7NBmUiYCoNqsiDBNUT+YjoHaSh3Lz3BDBcivedkaSjvqa8X2ypBe+QEQBVl9vBHrmCCi4H7EKcJban00GFcJYvv6H9UlA+i4AXAuAZT/1WWf/LdXv8G6VAQkxlMHPMsJFJ3CJylugstTaU2FPdT3wZpQ9UZ4LiYvU/TswJ1xDRsWZ88v0a0oIFjtDNt7YEQCPEEc0dnX/AwGQ2P9oDkDCAvld9XdP9dEV4I3tbpaenMZ3V2lIn0yCSlv0wyTh1Nkz9p6ppxVGoFU2VV/UOqn+6NKiMbtzdQgmcgRv1P/hJlXdw/C7/dcfajsAifeFDESU27MB+wa5jzoUaOB3LD4SA4v9NVF4LgAnd3ehgeozAHugHianEx6wCR+FG2YeA294whVQYtjvWQRUMw9BlDIkG7b6j4VmVrusOp9s/y0ncJX6R+POAD4kiI0A4L8BQ+Uf3gfg2H/2MBBTfdP+C7vAzdaPAFfIwLSERHVoIoqUBjNKm3EDGVIwx8kAOFLuaL86hkkkxcU/jDgrSh8CUhG9B6iMzc+0iUB7xO6H4EWszLqBb/ghJARgTwKytwI7OYAhBHBcQDYckOtlTmFYABIA3XILbCEJ3QaE1ampsRItHTbsF+mqqpUryCzZzYA/QzJJN+ICPLFqLwPCI/F/aXy5N4YjiRT6akB7BGmd2/INP/ghBGjJPwL+1QnIfGf2X8CuQ4GGEZXoO9UFEOdwhAxYDiCtXE79ngKh2t7LFWTAHwAbSTEKEby2kaqznEHUJ6XmCUJJjaPUdFbFK4CvtI2IprJ/+caVAHQSkD0ObL0MxCgJbnNNqb7+XlX+KATYLlwdky4NZVaRxY/ZcMGLZwNHkCaXCPwZ1bbOBZXNyS0wkJruSKmll1w9CsrHdACzZOBdYwWwYj7CcAhcijf+8o0/KHYAkgzs/u4Trqm+/g7gKYUDRNG7F4jKhTlAbz+SbgNjdz+g0S5yA0wFO5AQAnHVzwOoZ/vPAn8yMeclKSMlPwOspm1nhO2oeRZEM+0qgH8q9d/O8ZtWAig4AMGQuRDIWQ48JAUBkO3eRcDWuQSi+pETQOBSdpxQ/kjJI7IYljkrVXaBlajpZxbqeGrOQEDzGqA8OoywfvdqHP5+IICznEKFSDJOYhjvm35g0QEkFwIh2Bm4w3AgcAJ6MrV5R+y9BpcmCFQl+oOz8MByE0qNu/EK4UDkJBihWHF7Bvz4m5jAJct+I8Wn+6+I1a8YE0k4+OwBtaLwlbYZwIfjrQQwrP4jK/82+6+2y8q/IQmolR2SiNvvqFUc3x/A9jOwESfAgB6BnxGJFR6E9tWbhJ499ey9FUbIhDT6ejadAjwKMbSVtkgxY7kvAOuZjwFn1fvq0CACeAhucGPycejzzT9gdABYERheCLqDUQhh+0qeC2iYNcBvWf4wMWgQhE7+CdHoC04TAlFy0zkY6+41udAJkyANar8JKVIHEBFEspYfOZLIxofkmSEOr82B+H9WvWcIoALaStuILNj+bdtKAF4JUKu+uQpQx/5AFKj6NBwQeiLOYCCxKEegCELb++GHcCoCA2taYHXU0IrtXTJhjsd5kKcDpziDBEEgQZkkg+MBWVigiYjA/T3gZofjGI4kC+azwTszXgTaqwlgHX/5ls97tRRYVL2tADRCgUH1yYKgDofE4nc4VqDG/EGbE0ZiziMIF/yGYlCHYJEKKzviJLaOEWTbQ5CQpN9AAhcoP5JWGaBA8lmyKYHZI+FgldwMeLNhgncNlX0RWczufyAAWQqcjP2tCgACV+Z+t0RYAUmIpAOxEdtHTmDbTybBsHaAnIMmiuHmatcBk9m8iexcEgrqVgP2c6cxvFL+LMii2HkYJ5Er8H6TaeL4ANj/CKSPofiIowcH8P23COBGnwHQhOBVALxHg1l4kCED0mbIEVjqTIhk+4GT26dJIXAF0yGBQR4U6MR5ZNsNTkIRS0mVsa8ir+o4LnF4ZKvPYXKV3xWK/1o4gG/9/ioJKC8E9dyAAXaM75sDANDp+N8LA7p3CyjF1Y5B3xxKEsZ6AVo5SIDYZHMvGRUlqqLseLCSbzunpBVGMsy6hTA0icAWXf9sIjC45irZyPzKuJUjIH4KxR8cwLd+v50A1PMAmOzTnwXTYvkld7Bth5uM+9uBo3yAodKR8uP4HUEQ5dFtGYEM25QCDwQQqVAEzAgcQdx/JvipC4jICX50Cpxk/wzoorCkAsrM8WbHM0WCEGXU9qr9y0oAWwiglH8LCYz1/w3wqvznqr5BDhqsUwuEqg5BkUwHdgOI2yGsx02tHIHcaGd/pMQIbArMRF7hCGAwFMqAxWwTEdys+sO9zJzfjBuoKPVVba8lgGISsFsApElivyE45wdXADdNhwUdlkm8nnYCCeWXY+l439tecgvG5OxuZqSMjnPoJnwWYJETYUoenWOkaBP9M2C2yDML8my72fg/Am2FLKKxZvZvfb7t+77KAWxOwEj8NXUHp7DNb3QBCvwSAnSCq0MAQhiitugOcCzcbsX71qrAri9OXEY21nMGHUu9GnG4oQVncMg2Z8FPSDEFNMcVHemf6ssIidw3a6wsyM9oVwXhUQLwznkQMVIKbQRAV/45RKDJoAHcIQMhiwjUQwjQscer3hYh0BWBxhhCNCzej/ZZx9FuIsolHLbMFUWfAXIUviAY2ecKOUVjMTIoXH8EmAwhRSA/Cuoj/c255pHot33uQw6A5QFku5cLQGAjMSDmLCcw4BImixUaCDCZkntuwGtPCcABCx6nHBJkVDg7qSuvwEoAcQDIBPi9MTIAKyt59rcKyGWWHCr9IvJ4kv2NAII8gIC1Wwqs1wUAoi0yEABrx82UP+sGziCFDsgkHLDyBN1N80gjqCLg+CkQJOPqdn4BUOhEniENVJtE/2x8TduRa/IAmT1WBMSzxomO8yj7P/65r1YCotIPn0m8j28BFpVvwGdkoCRf2/gOd1k3MNgImIEEyBZZYEKJugVrHYEoi3EsTSzu5HEIZCCFyuQPnMIl4If7kgVMtt0hUkOCMj5XgVex7VM2XU3IlEAQxyPDdP0//n3GlYAh+FWs370OXBbbqWSfblNxAlbbsuUPyMLLBeA9YLafTZruB8+AO2vps+32650Flqem4b4T1d881oyreWICqJLL1e2XjQDkjUDkmX+d5WffEVeWE0CBNJU/qfq6f0eQBdVv/Qw1tdyCBWzGsDJGqBIZgiCAzjqK0kQ6A1hnjOGBNUEwIUmd5AAqxyndB0PFw7nkOAY9R5ePf+9XSUBGBAJudAVt234Ttn37xi4ESGyTE0rnAIBtBqwfAD/+Zl68r8nGdA3RykEsy2TtfJYkKsfWk+wM4GavJwnA2fj/CDCPgqzSPwoLov1HSOUVAeBKwGgtgJH80+AfbL8OC9A66Od0gFy0UiuCa+Sjt0cKboYQRGmHsR0w4vmGE0GRltk+AapuIlTbG9dcDh8mxpkCauL6wt/eUcojfY8AUiv0Wd+tc3ogAA/8xsKfDuykTVP2/YO1GlCLNnUCiii0Cpu7LUfgjUf2WTG/JgXLORwFtbkE2VLQRNKPTgiHjNKASBw7PZZ2J0Vnc+Q4ugsk6gAAG0BJREFUVVKKQH/muZxKCp/4Xv3DQGLn0fI3sEerAPVTghAaaFyllgcDi1Asq43t6yzwI2IIKgHiOFKWjZyjZ3XZBMuAOJqYbTJVwwuDfIb/l8FR2cy5VX6Ts0HmZdunz90i7eClJZnjZdoMv1EjAMcFbLiYAT+x8TpX0DCeAHPXxAA5XTug7YiW7on9NPYPwgLtEEKiSNjcTg2y4YSehCeBv+xUZid98ne5khCmwHaQDGeOGfVZVgKwqgAiiBH4U2XAfTCco1qxNcAZxiOAm+J/kSvwEoYU4Anl325ath0hr5BYNPDYq9Sr4LzY+reJfBZZVa/vhPYRGGf2Z/p4bZZPfM++CmCFAF4YIETR/upnApw3AqUJAQ4ShQPD/ovA3wjdANDwwxvKZbVjN45uSwI427eqnIywpsbIKOT7iAAy4Ix+p5kxMn2kzSsCCKoA+AiwJoOOAJTtF8vPSAK3NSFLhAJdPwLuTKiwHc8jhsx+1YaGBSRxJdeadQgWETBVTJNG0mVEE3TbXww9yg6lmPzL/gapawNSitpXgIdcF40783tlzmUd94EAEiVAuc8m+HWOoCH61fxAy19R/mplAElHicqrryeD3wM1fVkpm1gBkOgxHEV0gZA4VnpiFlQ5MzHNNoXjpM+9APBozKuI59BvpgAwJgE/B0KA6CWgrP7vZP4bWcBJZJYEI1FYQuzlAtw8gTFg2jXs12I+diz7gQA9tu/2GaRkOQvrfYapiZgNR6znyMn1zQCkpG7GOZfG0PenQAAZIM6cS2bcq9osnxAC0C6AgH14+Ie9EIQQwoY5FRo0HAbbKY5In3Yf2QtHEGVWiGEAVhHow1cHPHgeJnAZqAIll3GrSUdKBkdyBmQF41WTsxv3LMK6mAAe5bdwSKt6/AcCMEIAmevrbz88A7Dv1CofVQQ66w9ftAJrMdSuAHD46ucIiEGDeRDcKCwgB43KgZYa47l4biIav0QyybjfOufhWGcRiQHK7nivKQFUATcQ+Ylgnhl7+cT3sEOARgDO038dATjZ/w74AKTM9q05AScjBY8YEHRVy4/Kr4mEKZXbRnaSa/IAvR3HISk3CZkkr3AMOPeM3c2SiTtWAfyzgDyz3+xYZ/6e6XPoCMBZ9tuAboB8cALKIbT5x54H2CeVBrkGOHUFHjFQNlBJ6wnVZ+AWgogA3Fg6cVymuJ1zME/kYQdT0CwgXTUpEFdmUodtCgQQjrVf2NXtMuNn2lTu18x4rxyACgO8sp+n+ts+A+Rs+a+0Z1jFfXS/ASLLGQxjJEAYlgpn1FwdN0UazloDD6wR4aQVH4GTPP+ZCUkn/MmhxtWgsu7H7O9x5fkun/hsFQKw5B+AGsGfjfc9UrDIYjukmmjatlv4taoAFduvyccFWYJIvOSdFvIo7s8Avps0ScBaE606VoVUdFvL9byO4Inc2PvhnEcC2CfL+mf7p+P//ar1dgTsEA7AmJ1gFrZ36k36tXEjV8CshFwT3tEsqBPt2rDQNqX68GNl2kfEUQGmpcQR+VSOkQJIQf2vUMorxkxdd1R+hbl6aLzmAMhCnuEZAKPmrxW+EYAFcGtpsLM9dATgUrSiMvLQbSruYArQCaKIAJxyCjgxnGN6hGLuyy55npicFuEcJZSjAD7aPwvOK46TGfPBAej4nz3959T8B8VXYMR5aK4HIACOLD8DLZvzlp2nZiAB1G1+J9pVbD8jrdR6Awts5PymQL+Pf6j6EBCCNVHN/7iV/lgq6XkWCcn1k2NmwX2UxLLHyQBeLkPGXD7x3cccQGbdP1P9UPmt5CAAqiMLOVvD8re2XkjggHXASALUWfAzl4BzKLT0wblk+kdt0vuNc6lMbBPkhtU9tMpRgfUogGaApfmi8lsdPd9S/44ASLyPQEelZwlATQqIPU/56ctB1MtEGI61slP1NybvU4LfELBXmxMZfzZGxnGkQY8HgB9rxkVM9XkK0imqfYUYqgRYAnHBEelxXzkAJwcg4EOFz9p+5hSasBPlZuGCMgIPIkwmiN50RjWg+22zDsFxHRnwR21cEKtzjADvTUx0OzMgjsY2VbEI/iq4ps+L3JiKslfPszJ2pS2exwMBZHMA+8Re709HAGxxELTtnACgWZNIa5ew/APY9c0xngno+qlBXHxfDP7tBlaOwSZjsn+GFLZJciAMOUQYRQI4dKxHBvWVJDAz9vKJz4rXAYjidiHA/sPRtQDWE4LGOwIt1e+2KxvgEsD7DPyotNPqXwQNO84ApIkxI3IJwXryMcPjnUAAVeCd1f6MaxsJgNX9WXjgKbzlCIwyX7vn3jJhpZCUAGBjRBCKTzjukoraOlfbp04iooTk04mFic4I6QiwvQkvp+XlL44cewYkZwF0uDZ1D2Ztu76VR8ZZPv5ZDxpOwwDr+X9P4ZV9b66B2HodRmgXnHEGrc8Tgz98B4GF4wJp0Bud7B+BqDu9fcxMn6hNaT+5llL/IsnNkMNMn9eZUDYC0M/5I2jXzxqowzaw9l1bZzsCl1p9I1zQJCHkhffeVH+HJBgA9HwysZYE4TA/Z/sZziECi+clPAXOKg62y5xLFHJMjZFU2ciVnA30GRJ4jD7Lxz/zVQ5AwFVa/rt3osAv5gIQ3A+25OFuenbefV6AlBLZeBb4U/hMNSLQC8gonPyzx7Xq7gapyObwfKJx4SfIOJmzjveYQM78VlW7PktU2eseCSCI9wegW5Y/SQwakDpksPYLM1juofVTQHFxE71NKGkJQmyGDTyt9qsFGeCYo8N5ZcfJtnMnsvo9smNm2mWBUHU50bFnjvvYY67H6wiAvvLLyQPgk3xWqKCFRZSdAbdti5KBilws8YrcAd70cgxfJYtAYQPI97uPEog62DbxCmNGE7UKJjx2duwz2kVjXLl/hiAihzEz5isCCFYByhzRCj0A37H92xjE1neuwtmP/V1nQBYKWfMbQ40MCKvtD5EMO6ErgBqMGQGBnWa6z37sdPujoUYUipy4f9a+R0A/c9zl277bXgXYRQABjsDUIK0Anym7DiW0m2CCaS0ZHsggafuzYO6GSwCQNkn0CwnojDESYUwFjDjcTL9osVHZTTwigCMgvu77txCAEkCy7s9IAcHI3IIGNoJwIAV0ppmwYD+4xgn9HoCpAuIQl0aDsF9nH0J6KDWo2v5DKk86zxy/QjCZtq9Tm+hcrtq/EUCn9M4LQIYwYL+x5mpABUgK8H0jgmH47IC/U38Sl1fBnwV+GryzuYILwd+GTl5ENPmyzNONkzx2xg7PklP2ujLtHqtNdJxov3YljQBEibW1t7Y34CVW/Wngt3vv9MXxB4sPd5w5CBY+6PESTvihCUzU7JzF68uCwzrnSnKudCx1MZmJUxo/itWTP+bMeWX7PEW7s46ZGSdq00IA+uYfou4DkEG9vX2W7Weqz8gBccjcAQNPRfnNuUjcCQPB6a7BZIMqBI32SfBVjhZNtm6sxPFL48HglX5XtM2OeWa7zFhWm+VbP6NPAgrYXOX3VH8fwFT9qEqg+rvq76izRxQZfEVlQXcOJ4nDBdgZY6TZKoZ6ZpLFo4iq8JZHj1Htf1X7K8bNjDnTZiCAyPLPxvs4LnUEiaW/HaifCPyReEXEkSGfM22/nO82OaKTTyP4QMOLQo/M5NdnfXWf6viZ9pk263Vm2m0hwOoAUK3NxUCBsrvEkFH9YI1AN3+zFYHki0M6UBog8bCDYcth0SUHOgW3pwxyAPiJ9wvMjp6Z7Gzsx+pXPU62/RntGgFYyt/IQVnS9au3DwHL6vc6RIjWASDIBntvOMvsSkAPwBZuuu0HQBuNUwUFPd+LwZ+diFc4kPSxyQ/52H2rx6u0z7bV7ZZvkRyAEddr694BP3IFmXyAE/NHlt8iAv2fjXju1wJ/Cvhq4AzOzDZO58y4mXxClUxObX/4IvqzyU547xqOjnGkf7VvpX2p7bd8eCIJKIpLXAFTfq322jl0feCOee00qC2HYIHfUt408GFgb26n5v0JawVmiOVUgHuDpX6E+GwqEzseLRcnXz3OzDVV+3jtl5UAEKAIOhO40WO+mZifOA5KBEG7DuCJhUADIcDkZPPUJIQDil21/dP4KXYsNs9g46HNgYGrkz1/UucRwHrMo+c527/abwwBdgLoSIAou1bjSNU98jD/81Ct/t7/IyAuRPocAH9F9be2pEM0x+l+tTEag03u11H55Zy2yTZzURUUH2xbBVDmcEfGfOy+yzfrEMBaCrzfTAbsiBwyYcGg/oSEAOu9sKi2oe2fUP3WJQnacN4XbH84lp6VB9xJZoKn25RPPD3yaQ2PAC5zEkfHP9I/03cjAAbgAegHFv9YBMEsPyqsPgcNbNaWgb+bh4QsNLHgjWV9Q4IxZoZFIubxghmWcRWZSVrgj/xwb8Df/VYZMEY/7hVjPBAAgIIqvKHGkfJ3Y0UEsl99+L4AaQcoxLmm593Z4Gfz2pvrw76kg5giBXIiV+EwHDdsEE336/efAaiZszzzuEfHWr7508k7ARXIEMjMGZhKnnkpKGnDxhu2ESWfAX8K0Jn/ZwBmgjn3E7Y/i5uIWDITM3uszFgdYV01cPVEgvZHwXP0dK46fmXc5Zs+nZcBN8BFqn10v7H8V5NMZ7kTVYHBoicBTMkgqaqhC3AaRHiJ9m8TccJZeBM4dUw2wIHrjABVmdjkJ2nDV8eJzuus/VeelzX2RgCDwnuLghxV74CbedQ3Uy5MvBQkUn53P7odreIJUFnzvdueGKdq+b3xLwF2NqE/zRxnweiDNc6VpLD+Uo0AGnjBWg92f6dVur2yNFhA59h4nEfb5+T6fw2MCPxU9ZV8mG3UXKNzn1yjnqIRZtz9RXIpinaIplkiCgd+08D9Bc4ihuUbMQRQkzXrDBAv4UNBcllR+IDK/Ejgb5MZZnVEIJ7V9J4M9EAdEUI7ZqZhVrkzZJawFslTegPvR/gFMiSxEYBW2PX7oPIROWTe+JsIHzoygS/6fDTwjiq/Bv8s8BmJAOfR2x6BxnMW1dDBIyxrTkbnt/VzGqX6PwIgjhxCX0MGXEeO9xh912t4IIAo5nfAj2o0kAaqeDLb341hHNcDf/QEoAvsI8lCA4nW5D/iAE5558ABxR/O/SDCD3a/DCuZ83q/E8HyDZ/mVAF2pCEoKcizdj5DJEIaVfAnlgJXwT/lApxS3wzoM2DLTNSK8mfHE+UvtS/A9apxM6fwlMeW81vJ5WrnsREAA/W2LQHsVMyfGKez/gr8Q1ignEXm8V8PzFXXYIHJUmY2mWbIwPq/EvWEzkzeTJuQNMgg2XEzIJwJb6rjHgp7zjrYI43D3MryX8EBWHZ+VvUtEmGAbseAGUSPWwT/2apvglntOAv0bRwDWRnAXdYmM/BkEvKpgZm8tEeC7nWH6QhgRvVdkColt9rKcT1ioC4gsP0V8LttjUnMwFkBvjXJhu2EFGcBEk3saL8cN5uHmD3PaMpnzzMax9v/GMc4cn5n9N0IANXXBWnmPQCi0Enwb8AO2mbAXwFw1fJXiKQBxLg7FYJAR8aGiyboZfvVwNFxMhN1ZoyZPplzie5hZYzXve3y9RICEBAOZJAEdQnQxpiuG3DWBWA//RnJhu5TdyskFTIDKwBPtU2qfwQGb3/Ut/utEo0TTUxczPSd6ZMF5pVjZ88hanfkHDcCiAC7HSAqFQJthi4icAlU8YMyImPtAcAOmLBtCHzCHikwR6GEvtMnVxQY6ZFD2vMt8TDTjFN5yj5Xgisa29t/BNSV4y5f/6nj04ADABNZfI8kqJor5XcVPwF+D7RybimSgF/PHDNQ5YhAPCC2vkl3EYF6VvlpP7VxZpJW+lTasntbAYLVduYcKse9evzoXJav+9RX6wBkMnUKfgH4U+VFDcTkcmANCAR/SBIF8M+CPOUUCDnijZwB9UyfDlSJmZpo0s3HTPtMm7McRMkNRcgK9s9e18HDDt03AugArx7qMfftQ0XKP+MmvD4U4HguhDi8PpV9mfUGTJFToJdrMGaGNWHO2u46iYCQjgAwC4RsuyxRZoA0c8xo3CvGjI7p3dvla4kD2Dqom06JIOsOEs8A4A9jOZCzwV9yBKpxBtSZNt01JY5h3cwzicA7p84VZGZech1AFhjZdjPneYTIop+iet7ReGed60YAFuBc9T8R/IPiF2N+Rh6RWtM+xEmIw/EmlEckacA6KnsGuL0JaO5LJv2ykztqF+2fBXV23LNApcc5cnyPCM4Yd/kv6ACyoM62q7wSTD+BaDiQlAuYLBNSIBeAGRGBSQbkTlZAf0bb4dySbqQ62TOTNtPGDVkIarJjnkkCR45Z/V1nHMPa5xUBwEQ/TfnhF3DHJC8TYa7gKPhLqg8Hi4Bd3W9ZbDZhzgB3ZYx2bs7szUzsqM3R/Y/pBqJzPZM0HgP4eD0bAaTi/WxeoBDvD6SQIAzG/K1bslJgEUF3o48+XUhi32EiFev8WYKYAjzOPBCDSFkicHj7o75Zlc+MQy4vurS2vzp+9ryvtveZ81i+5lPGMiBT3zRJ7J3Tig9UHvVxHYC6SxmQm22csVwC2q8lcgTbGGRWHQF4tq83KbYxjNkegWAW6NG4mUk84wYyx50Zt3K+FgFUzu2o+9gIIALeVeBHuxmdQxb8VeAP48IAEZCn9zvHsCZQFuDZdvQ4CeWPJudTE0F0fjNOoDLmEQKoHmfmWjRhLF8dOQA1KVygFpKDrwP4B7IwgDkNdOYIDJBlgXt2O7wPenJEE3IG7DN9qhM9Ou8rx5slgMo5zzoT5hY2AjBBfTL48cfZhs6+OhzOvANtArBpR5AA5mEiIHc5GjPrCLLEcIXyW5O3uj07sTNgybTJgjU7Vna8KtEebe/1X/6z5QAmwT+AnL1g9CD4hTzcsMAiDba9mPCLQEv3G2RlTfoMoDNtvEnZ+quBZlR6Buwzx7lCvTMAz7SZIYDsuFlyZCrvnddGAIMDCMDfgbxCFIkKgUcg2q6m1X3/VWj7yTUD7Ec1iSHhLrJEcAT0dLIVKxHRRKwSQQSAq/dH15PdX2030z76LRj4oz7LV2kHQJRqIAgB1GOD31DRChF0bR3lM8GcKO91fYvuwmJr73y8yeQSRlL5zwL1rOJHk/jo/oxyR8e4GtDZ41fPoyeAQhKvVBk4Q/kD8FdIYLvhCTLxQozIAWzDBwCLQB3tj87BnQwTyl8hgkrbzKSNAHD1/gxJZNtkrhfVPLo2rfyV9hsBlMH8RMpfBjn8MpbyZ8asEEEbT/1GFZWOgB/tD13EBcpfBfwVbiCa+FfvrwA7OpfKWLNksZ7D8p8+lFwI9AS2H1U0A1Rp47YlwLTaTwF/7xSB9Oj+I+pfeX15SCYGyWYm5etGAhlQPmabqxwFjrsRgAaO+f0k5ccTcI+dBGuaHJLjReByCSNQ16PAj/qHgIUBKqrN2h7tH6ncFQQRgSoCeLQ/Gj+65gxxasufPSZrt/zHrAN4jcCfBjyG4RPPCZQdgAOuCLgeqUSEFIIeZt0VQD46pjeBryCBCMRX788CNjqPCplYx9wIIHQAB8GfVvwT3gNAgTQBflflme0l7qJCIDMgzwCvtQmcSZpECi82rTiECBTVsWbHi/pl9kdtzgT20bGW/xA5gNcc/K4bOAh8D8DdD3/kPygplhVLoL9Q+TPnESlUFdTV9rPOIgLw0f1HQRv9rjpE8I63EYDpAF5D8LuAP2j5o7GpSkMn/UNXvlfaZtxCa3Oh8lcAWWk7C9yzjpEFmAes2X3ZY2dIKNNm+feWA3hC8FeASNuS9QxZNbeOTfur38i6edkxI2BnVFc7kyPWPnO8yvhntI0m9WOSwBGQRy7g6P4skWwEMDiASfDjzTFdxX5m3f4CYCNyyCzwicZIkQUBv6fiFYWvtDVB9cjKnyWLqrqfBehZsM4CcbZfFrjR+BFRynGWf6cdwCT4GahSJBCAPwJrtx++6GOnQK3icVO5T3p+oAL0qG13fYScvImVAW/p+CoIzYxfPb8qkUSAuIIgZseMzjWzP9NmPb+NABpYXgPwlwAPE02vZjwT8BHJsMn7ZG6AzLoMAM9qU7H5Z6j7GWNkVLd6nCwAFVe2r5HCn7V/+crVAVSeAUALbyjhrPJ7LsIC9NaHKN4lDsBQVtMpOI7CIyg2ebxjzKr/DOgzfSok8NhtI2CeCfQjID3SN7pG3L985cvEOgAE/ZFXfSceCio7AMO1uIShriflFhySqQL2DMKgx0yofwbAnnupALYCpsx5PUaY8H4ILSoAjxzG8hUvi88C7Ee3VB5PjrZJuA02BgVp4EBSwM7E/cn1BBVV90A2tQ86RQCOCCuz/ygRZAF/lETOBLSnypXz9Igssy8igIp7WP7tTgAhcCfVuyOBE8DfLq4A/shVuERhAGsKpBeFBNH/gmRNqogoov2PRQJHj/MYJDBDDkeAPHs8fcxGAJaiVwHMwLZtS4Df7Kst+8HKgQX44fj7hizYz24XKbH8rmjzItAe3R+dU9WmZ53AB5UEZoE8228ggH+TdQAFADMgpQhGAZ0SAlHkSOGj/VZ4MRNCZPvMtuv6JQgqA9gqKWTBmAV3tl32uGcpvgWy6vZZpT8L5CgQlAA85a2qtwZ6RflDB5AEfwT4aL+21Fb7LIhn+kfAzfzHIhVgR22j8zmq/BVQZc61SgKV41fH9n6bWXI4q9/y5SoJiAMfBb9Xm7ccwXB8cQVE7QayIW8groI0s5KwOmYEHm9Cm/suUP+MEp/V5oiaV8B6VdsZEphR9Jk+FXLYCMAE0oTtb2OpCZoBq+kAjLFMsgDP4x33TOsfugohMnJuEUEM56lmRaSIV+/PnP8RwGfHrxzjyrZnksPlBPBlRhlwxrpnwW8CnWXJC0RymBCS5b4zwV5Wf+hwBNhH+lqW9rHdwVF1P9r/dQZ6ljiWlQC0SjIbPLRRilYFv0cC7Yc9WOrLAFWf94y9n+ljnZurdie8YnzquMS9PAUJHAVshqCs63oMsFeuzzvPaB8eZ/lS7QCU4jJVNckgUGurH1XuiVJfilSYFTdUtUIgR0nA67/tU7OjouBll2GEKVnQZ4EWXUPFps8es3KM15EEskoPt3T7KP02AojUO0UCk+CnoCWAzII7Au2w3yG8o6COzoUBioKCnKPrFBjJqRlQcQLVY2WJIjNuBaCvIwlUVX0G0NVjdATwMXEAAYBdEnhC8Ecgc/efGPNH5xFNdhOQRdt/ptpHCh3tj675CFE8JTFUjv2UriFz7GUlgOp/DNKRwUHwdxPfUeMjDoCCq5BfOOoEZvpr2x+BLavolXEyAM6obnTMzHEqoMuc09HxKv2rbTPAVYZO/ydUbXfkKP4/BnecprBuissAAAAASUVORK5CYII=\";\n    BABYLON.TextureTools = TextureTools;\n})(BABYLON || (BABYLON = {}));\n\n//# sourceMappingURL=babylon.textureTools.js.map\n\nBABYLON.Effect.ShadersStore={\"defaultVertexShader\":\"#include<__decl__defaultVertex>\\n\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nvarying vec2 vDiffuseUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nvarying vec2 vSpecularUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\nvoid main(void) {\\nvec3 positionUpdated=position;\\n#ifdef NORMAL \\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif \\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nvNormalW=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif\\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif\\n#if defined(DIFFUSE) && DIFFUSEDIRECTUV == 0\\nif (vDiffuseInfos.x == 0.)\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvDiffuseUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM) && SPECULARDIRECTUV == 0\\nif (vSpecularInfos.x == 0.)\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvSpecularUV=vec2(specularMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#include<bumpVertex>\\n#include<clipPlaneVertex>\\n#include<fogVertex>\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n#include<pointCloudVertex>\\n#include<logDepthVertex>\\n}\",\"defaultPixelShader\":\"#include<__decl__defaultFragment>\\n#ifdef BUMP\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\n\\n#define RECIPROCAL_PI2 0.15915494\\nuniform vec3 vEyePosition;\\nuniform vec3 vAmbientColor;\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2;\\n#endif\\n\\n#include<helperFunctions>\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<lightsFragmentFunctions>\\n#include<shadowsFragmentFunctions>\\n\\n#ifdef DIFFUSE\\n#if DIFFUSEDIRECTUV == 1\\n#define vDiffuseUV vMainUV1\\n#elif DIFFUSEDIRECTUV == 2\\n#define vDiffuseUV vMainUV2\\n#else\\nvarying vec2 vDiffuseUV;\\n#endif\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY \\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\nuniform samplerCube refractionCubeSampler;\\n#else\\nuniform sampler2D refraction2DSampler;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\n#if SPECULARDIRECTUV == 1\\n#define vSpecularUV vMainUV1\\n#elif SPECULARDIRECTUV == 2\\n#define vSpecularUV vMainUV2\\n#else\\nvarying vec2 vSpecularUV;\\n#endif\\nuniform sampler2D specularSampler;\\n#endif\\n\\n#include<fresnelFunction>\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\nuniform samplerCube reflectionCubeSampler;\\n#else\\nuniform sampler2D reflection2DSampler;\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<imageProcessingFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n#include<fogFragmentDeclaration>\\nvoid main(void) {\\n#include<clipPlaneFragment>\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n\\nvec4 baseColor=vec4(1.,1.,1.,1.);\\nvec3 diffuseColor=vDiffuseColor.rgb;\\n\\nfloat alpha=vDiffuseColor.a;\\n\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=vec3(1.0,1.0,1.0);\\n#endif\\n#include<bumpFragment>\\n#ifdef TWOSIDEDLIGHTING\\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#endif\\n#ifdef DIFFUSE\\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\\n#ifdef ALPHATEST\\nif (baseColor.a<0.4)\\ndiscard;\\n#endif\\n#ifdef ALPHAFROMDIFFUSE\\nalpha*=baseColor.a;\\n#endif\\nbaseColor.rgb*=vDiffuseInfos.y;\\n#endif\\n#ifdef VERTEXCOLOR\\nbaseColor.rgb*=vColor.rgb;\\n#endif\\n\\nvec3 baseAmbientColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#endif\\n\\n#ifdef SPECULARTERM\\nfloat glossiness=vSpecularColor.a;\\nvec3 specularColor=vSpecularColor.rgb;\\n#ifdef SPECULAR\\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);\\nspecularColor=specularMapColor.rgb;\\n#ifdef GLOSSINESS\\nglossiness=glossiness*specularMapColor.a;\\n#endif\\n#endif\\n#else\\nfloat glossiness=0.;\\n#endif\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\nlightingInfo info;\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\nfloat shadow=1.;\\n#ifdef LIGHTMAP\\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb*vLightmapInfos.y;\\n#endif\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\nvec3 refractionColor=vec3(0.,0.,0.);\\n#ifdef REFRACTION\\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nif (dot(refractionVector,viewDirectionW)<1.0)\\n{\\nrefractionColor=textureCube(refractionCubeSampler,refractionVector).rgb*vRefractionInfos.x;\\n}\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\nrefractionColor=texture2D(refraction2DSampler,refractionCoords).rgb*vRefractionInfos.x;\\n#endif\\n#endif\\n\\nvec3 reflectionColor=vec3(0.,0.,0.);\\n#ifdef REFLECTION\\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_3D\\n#ifdef ROUGHNESS\\nfloat bias=vReflectionInfos.y;\\n#ifdef SPECULARTERM\\n#ifdef SPECULAR\\n#ifdef GLOSSINESS\\nbias*=(1.0-specularMapColor.a);\\n#endif\\n#endif\\n#endif\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias).rgb*vReflectionInfos.x;\\n#else\\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW).rgb*vReflectionInfos.x;\\n#endif\\n#else\\nvec2 coords=vReflectionUVW.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\ncoords/=vReflectionUVW.z;\\n#endif\\ncoords.y=1.0-coords.y;\\nreflectionColor=texture2D(reflection2DSampler,coords).rgb*vReflectionInfos.x;\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\\n#ifdef REFLECTIONFRESNELFROMSPECULAR\\n#ifdef SPECULARTERM\\nreflectionColor*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#else\\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#else\\nreflectionColor*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\\n#endif\\n#endif\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);\\nrefractionColor*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\\n#endif\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);\\nalpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\\n#else\\nalpha*=opacityMap.a*vOpacityInfos.y;\\n#endif\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#ifdef OPACITYFRESNEL\\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);\\nalpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\\n#endif\\n\\nvec3 emissiveColor=vEmissiveColor;\\n#ifdef EMISSIVE\\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);\\nemissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\\n#endif\\n\\n#ifdef DIFFUSEFRESNEL\\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);\\ndiffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\n#ifdef LINKEMISSIVEWITHDIFFUSE\\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#else\\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\\n#endif\\n#endif\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase*specularColor;\\n#ifdef SPECULAROVERALPHA\\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n#else\\nvec3 finalSpecular=vec3(0.0);\\n#endif\\n#ifdef REFLECTIONOVERALPHA\\nalpha=clamp(alpha+dot(reflectionColor,vec3(0.3,0.59,0.11)),0.,1.);\\n#endif\\n\\n#ifdef EMISSIVEASILLUMINATION\\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+emissiveColor+refractionColor,0.0,1.0),alpha);\\n#else\\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor+refractionColor,alpha);\\n#endif\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\ncolor.rgb*=lightmapColor;\\n#else\\ncolor.rgb+=lightmapColor;\\n#endif\\n#endif\\n#endif\\n#include<logDepthFragment>\\n#include<fogFragment>\\n\\n\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\ncolor.rgb=toLinearSpace(color.rgb);\\n#else\\n#ifdef IMAGEPROCESSING\\ncolor.rgb=toLinearSpace(color.rgb);\\ncolor=applyImageProcessing(color);\\n#endif\\n#endif\\ngl_FragColor=color;\\n}\",\"pbrVertexShader\":\"precision highp float;\\n#include<__decl__pbrVertex>\\n\\nattribute vec3 position;\\n#ifdef NORMAL\\nattribute vec3 normal;\\n#endif\\n#ifdef TANGENT\\nattribute vec4 tangent;\\n#endif\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif\\n#ifdef MAINUV2\\nvarying vec2 vMainUV2; \\n#endif \\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0\\nvarying vec2 vAlbedoUV;\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0\\nvarying vec2 vAmbientUV;\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0\\nvarying vec2 vOpacityUV;\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0\\nvarying vec2 vEmissiveUV;\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0\\nvarying vec2 vLightmapUV;\\n#endif\\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0\\nvarying vec2 vReflectivityUV;\\n#endif\\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0\\nvarying vec2 vMicroSurfaceSamplerUV;\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0\\nvarying vec2 vBumpUV;\\n#endif\\n\\nvarying vec3 vPositionW;\\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && !defined(USESPHERICALINFRAGMENT)\\nvarying vec3 vEnvironmentIrradiance;\\n#include<harmonicsFunctions>\\n#endif\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n#include<bumpVertexDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n#include<fogVertexDeclaration>\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n#include<morphTargetsVertexGlobalDeclaration>\\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#include<logDepthDeclaration>\\nvoid main(void) {\\nvec3 positionUpdated=position;\\n#ifdef NORMAL\\nvec3 normalUpdated=normal;\\n#endif\\n#ifdef TANGENT\\nvec4 tangentUpdated=tangent;\\n#endif\\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\\n#ifdef REFLECTIONMAP_SKYBOX\\nvPositionUVW=positionUpdated;\\n#endif \\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(positionUpdated,1.0);\\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\\nvPositionW=vec3(worldPos);\\n#ifdef NORMAL\\nvNormalW=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && !defined(USESPHERICALINFRAGMENT)\\nvec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\nvEnvironmentIrradiance=environmentIrradianceJones(reflectionVector);\\n#endif\\n#endif\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\\n#endif\\n\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\n#ifdef MAINUV1\\nvMainUV1=uv;\\n#endif \\n#ifdef MAINUV2\\nvMainUV2=uv2;\\n#endif \\n#if defined(ALBEDO) && ALBEDODIRECTUV == 0 \\nif (vAlbedoInfos.x == 0.)\\n{\\nvAlbedoUV=vec2(albedoMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAlbedoUV=vec2(albedoMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(AMBIENT) && AMBIENTDIRECTUV == 0 \\nif (vAmbientInfos.x == 0.)\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvAmbientUV=vec2(ambientMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(OPACITY) && OPACITYDIRECTUV == 0 \\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(EMISSIVE) && EMISSIVEDIRECTUV == 0 \\nif (vEmissiveInfos.x == 0.)\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvEmissiveUV=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(LIGHTMAP) && LIGHTMAPDIRECTUV == 0 \\nif (vLightmapInfos.x == 0.)\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvLightmapUV=vec2(lightmapMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(REFLECTIVITY) && REFLECTIVITYDIRECTUV == 0 \\nif (vReflectivityInfos.x == 0.)\\n{\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvReflectivityUV=vec2(reflectivityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(MICROSURFACEMAP) && MICROSURFACEMAPDIRECTUV == 0 \\nif (vMicroSurfaceSamplerInfos.x == 0.)\\n{\\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvMicroSurfaceSamplerUV=vec2(microSurfaceSamplerMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n#if defined(BUMP) && BUMPDIRECTUV == 0 \\nif (vBumpInfos.x == 0.)\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvBumpUV=vec2(bumpMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\n\\n#include<bumpVertex>\\n\\n#include<clipPlaneVertex>\\n\\n#include<fogVertex>\\n\\n#include<shadowsVertex>[0..maxSimultaneousLights]\\n\\n#ifdef VERTEXCOLOR\\nvColor=color;\\n#endif\\n\\n#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\\n\\n#include<logDepthVertex>\\n}\",\"pbrPixelShader\":\"#if defined(BUMP)|| !defined(NORMAL)\\n#extension GL_OES_standard_derivatives : enable\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n#extension GL_EXT_shader_texture_lod : enable\\n#endif\\n#ifdef LOGARITHMICDEPTH\\n#extension GL_EXT_frag_depth : enable\\n#endif\\nprecision highp float;\\n#include<__decl__pbrFragment>\\nuniform vec3 vEyePosition;\\nuniform vec3 vAmbientColor;\\nuniform vec4 vCameraInfos;\\n\\nvarying vec3 vPositionW;\\n#ifdef MAINUV1\\nvarying vec2 vMainUV1;\\n#endif \\n#ifdef MAINUV2 \\nvarying vec2 vMainUV2; \\n#endif \\n#ifdef NORMAL\\nvarying vec3 vNormalW;\\n#if defined(USESPHERICALFROMREFLECTIONMAP) && !defined(USESPHERICALINFRAGMENT)\\nvarying vec3 vEnvironmentIrradiance;\\n#endif\\n#endif\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\n\\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\\n\\n#ifdef ALBEDO\\n#if ALBEDODIRECTUV == 1\\n#define vAlbedoUV vMainUV1\\n#elif ALBEDODIRECTUV == 2\\n#define vAlbedoUV vMainUV2\\n#else\\nvarying vec2 vAlbedoUV;\\n#endif\\nuniform sampler2D albedoSampler;\\n#endif\\n#ifdef AMBIENT\\n#if AMBIENTDIRECTUV == 1\\n#define vAmbientUV vMainUV1\\n#elif AMBIENTDIRECTUV == 2\\n#define vAmbientUV vMainUV2\\n#else\\nvarying vec2 vAmbientUV;\\n#endif\\nuniform sampler2D ambientSampler;\\n#endif\\n#ifdef OPACITY\\n#if OPACITYDIRECTUV == 1\\n#define vOpacityUV vMainUV1\\n#elif OPACITYDIRECTUV == 2\\n#define vOpacityUV vMainUV2\\n#else\\nvarying vec2 vOpacityUV;\\n#endif\\nuniform sampler2D opacitySampler;\\n#endif\\n#ifdef EMISSIVE\\n#if EMISSIVEDIRECTUV == 1\\n#define vEmissiveUV vMainUV1\\n#elif EMISSIVEDIRECTUV == 2\\n#define vEmissiveUV vMainUV2\\n#else\\nvarying vec2 vEmissiveUV;\\n#endif\\nuniform sampler2D emissiveSampler;\\n#endif\\n#ifdef LIGHTMAP\\n#if LIGHTMAPDIRECTUV == 1\\n#define vLightmapUV vMainUV1\\n#elif LIGHTMAPDIRECTUV == 2\\n#define vLightmapUV vMainUV2\\n#else\\nvarying vec2 vLightmapUV;\\n#endif\\nuniform sampler2D lightmapSampler;\\n#endif\\n#ifdef REFLECTIVITY\\n#if REFLECTIVITYDIRECTUV == 1\\n#define vReflectivityUV vMainUV1\\n#elif REFLECTIVITYDIRECTUV == 2\\n#define vReflectivityUV vMainUV2\\n#else\\nvarying vec2 vReflectivityUV;\\n#endif\\nuniform sampler2D reflectivitySampler;\\n#endif\\n#ifdef MICROSURFACEMAP\\n#if MICROSURFACEMAPDIRECTUV == 1\\n#define vMicroSurfaceSamplerUV vMainUV1\\n#elif MICROSURFACEMAPDIRECTUV == 2\\n#define vMicroSurfaceSamplerUV vMainUV2\\n#else\\nvarying vec2 vMicroSurfaceSamplerUV;\\n#endif\\nuniform sampler2D microSurfaceSampler;\\n#endif\\n\\n#ifdef REFRACTION\\n#ifdef REFRACTIONMAP_3D\\n#define sampleRefraction(s,c) textureCube(s,c)\\nuniform samplerCube refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube refractionSamplerLow;\\nuniform samplerCube refractionSamplerHigh;\\n#endif\\n#else\\n#define sampleRefraction(s,c) texture2D(s,c)\\nuniform sampler2D refractionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube refractionSamplerLow;\\nuniform samplerCube refractionSamplerHigh;\\n#endif\\n#endif\\n#endif\\n\\n#ifdef REFLECTION\\n#ifdef REFLECTIONMAP_3D\\n#define sampleReflection(s,c) textureCube(s,c)\\nuniform samplerCube reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#else\\n#define sampleReflection(s,c) texture2D(s,c)\\nuniform sampler2D reflectionSampler;\\n#ifdef LODBASEDMICROSFURACE\\n#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)\\n#else\\nuniform samplerCube reflectionSamplerLow;\\nuniform samplerCube reflectionSamplerHigh;\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nvarying vec3 vPositionUVW;\\n#else\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvarying vec3 vDirectionW;\\n#endif\\n#endif\\n#include<reflectionFunction>\\n#endif\\n#ifdef ENVIRONMENTBRDF\\nuniform sampler2D environmentBrdfSampler;\\n#endif\\n\\n#ifndef FROMLINEARSPACE\\n#define FROMLINEARSPACE;\\n#endif\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\n\\n#include<shadowsFragmentFunctions>\\n#include<pbrFunctions>\\n#include<harmonicsFunctions>\\n#include<pbrLightFunctions>\\n#include<bumpFragmentFunctions>\\n#include<clipPlaneFragmentDeclaration>\\n#include<logDepthDeclaration>\\n\\n#include<fogFragmentDeclaration>\\nvoid main(void) {\\n#include<clipPlaneFragment>\\n\\n\\nvec3 viewDirectionW=normalize(vEyePosition-vPositionW);\\n#ifdef NORMAL\\nvec3 normalW=normalize(vNormalW);\\n#else\\nvec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)));\\n#endif\\n#ifdef BUMP\\nvec3 originalNormalW=normalW;\\n#endif\\n#include<bumpFragment>\\n#if defined(TWOSIDEDLIGHTING) && defined(NORMAL) \\nnormalW=gl_FrontFacing ? normalW : -normalW;\\n#ifdef BUMP\\noriginalNormalW=gl_FrontFacing ? originalNormalW : -originalNormalW;;\\n#endif\\n#endif\\n\\n\\nvec3 surfaceAlbedo=vAlbedoColor.rgb;\\n\\nfloat alpha=vAlbedoColor.a;\\n#ifdef ALBEDO\\nvec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);\\n#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)\\nalpha*=albedoTexture.a;\\n#endif\\nsurfaceAlbedo*=toLinearSpace(albedoTexture.rgb);\\nsurfaceAlbedo*=vAlbedoInfos.y;\\n#endif\\n\\n#ifdef OPACITY\\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\\n#ifdef OPACITYRGB\\nalpha=getLuminance(opacityMap.rgb);\\n#else\\nalpha*=opacityMap.a;\\n#endif\\nalpha*=vOpacityInfos.y;\\n#endif\\n#ifdef VERTEXALPHA\\nalpha*=vColor.a;\\n#endif\\n#if !defined(LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)\\n#ifdef ALPHATEST\\nif (alpha<=ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n#endif\\n#ifdef VERTEXCOLOR\\nsurfaceAlbedo*=vColor.rgb;\\n#endif\\n\\nvec3 ambientOcclusionColor=vec3(1.,1.,1.);\\n#ifdef AMBIENT\\nvec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\\n#ifdef AMBIENTINGRAYSCALE\\nambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);\\n#endif\\nambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);\\n#endif\\n\\nfloat microSurface=vReflectivityColor.a;\\nvec3 surfaceReflectivityColor=vReflectivityColor.rgb;\\n#ifdef METALLICWORKFLOW\\nvec2 metallicRoughness=surfaceReflectivityColor.rg;\\n#ifdef REFLECTIVITY\\nvec4 surfaceMetallicColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\\n#ifdef AOSTOREINMETALMAPRED\\nvec3 aoStoreInMetalMap=vec3(surfaceMetallicColorMap.r,surfaceMetallicColorMap.r,surfaceMetallicColorMap.r);\\nambientOcclusionColor=mix(ambientOcclusionColor,aoStoreInMetalMap,vReflectivityInfos.z);\\n#endif\\n#ifdef METALLNESSSTOREINMETALMAPBLUE\\nmetallicRoughness.r*=surfaceMetallicColorMap.b;\\n#else\\nmetallicRoughness.r*=surfaceMetallicColorMap.r;\\n#endif\\n#ifdef ROUGHNESSSTOREINMETALMAPALPHA\\nmetallicRoughness.g*=surfaceMetallicColorMap.a;\\n#else\\n#ifdef ROUGHNESSSTOREINMETALMAPGREEN\\nmetallicRoughness.g*=surfaceMetallicColorMap.g;\\n#endif\\n#endif\\n#endif\\n#ifdef MICROSURFACEMAP\\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\\nmetallicRoughness.g*=microSurfaceTexel.r;\\n#endif\\n\\nmicroSurface=1.0-metallicRoughness.g;\\n\\nvec3 baseColor=surfaceAlbedo;\\n\\n\\nconst vec3 DefaultSpecularReflectanceDielectric=vec3(0.04,0.04,0.04);\\n\\nsurfaceAlbedo=mix(baseColor.rgb*(1.0-DefaultSpecularReflectanceDielectric.r),vec3(0.,0.,0.),metallicRoughness.r);\\n\\nsurfaceReflectivityColor=mix(DefaultSpecularReflectanceDielectric,baseColor,metallicRoughness.r);\\n#else\\n#ifdef REFLECTIVITY\\nvec4 surfaceReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);\\nsurfaceReflectivityColor*=toLinearSpace(surfaceReflectivityColorMap.rgb);\\nsurfaceReflectivityColor*=vReflectivityInfos.y;\\n#ifdef MICROSURFACEFROMREFLECTIVITYMAP\\nmicroSurface*=surfaceReflectivityColorMap.a;\\nmicroSurface*=vReflectivityInfos.z;\\n#else\\n#ifdef MICROSURFACEAUTOMATIC\\nmicroSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);\\n#endif\\n#ifdef MICROSURFACEMAP\\nvec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;\\nmicroSurface*=microSurfaceTexel.r;\\n#endif\\n#endif\\n#endif\\n#endif\\n\\nmicroSurface=clamp(microSurface,0.,1.);\\n\\nfloat roughness=1.-microSurface;\\n\\n#ifdef ALPHAFRESNEL\\n\\n\\n\\nfloat opacityPerceptual=alpha;\\nfloat opacity0=opacityPerceptual*opacityPerceptual;\\nfloat opacity90=fresnelGrazingReflectance(opacity0);\\nvec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);\\n\\nalpha=fresnelSchlickEnvironmentGGX(clamp(dot(V,normalForward),0.0,1.0),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;\\n#ifdef ALPHATEST\\nif (alpha<=ALPHATESTVALUE)\\ndiscard;\\n#ifndef ALPHABLEND\\n\\nalpha=1.0;\\n#endif\\n#endif\\n#endif\\n\\n\\nfloat NdotVUnclamped=dot(normalW,viewDirectionW);\\nfloat NdotV=clamp(NdotVUnclamped,0.,1.)+0.00001;\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\n\\n#ifdef REFRACTION\\nvec3 environmentRefraction=vec3(0.,0.,0.);\\nvec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);\\n#ifdef REFRACTIONMAP_OPPOSITEZ\\nrefractionVector.z*=-1.0;\\n#endif\\n\\n#ifdef REFRACTIONMAP_3D\\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;\\nvec3 refractionCoords=refractionVector;\\nrefractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));\\n#else\\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));\\nvec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;\\nrefractionCoords.y=1.0-refractionCoords.y;\\n#endif\\n#ifdef LODINREFRACTIONALPHA\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\\n#else\\nfloat refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,alphaG,1.0);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n\\nrefractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;\\n#ifdef LODINREFRACTIONALPHA\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);\\nfloat requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);\\n#else\\nfloat requestedRefractionLOD=refractionLOD;\\n#endif\\nenvironmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD).rgb;\\n#else\\nfloat lodRefractionNormalized=clamp(refractionLOD/log2(vRefractionMicrosurfaceInfos.x),0.,1.);\\nfloat lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;\\nvec3 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords).rgb;\\nif(lodRefractionNormalizedDoubled<1.0){\\nenvironmentRefraction=mix(\\nsampleRefraction(refractionSamplerHigh,refractionCoords).rgb,\\nenvironmentRefractionMid,\\nlodRefractionNormalizedDoubled\\n);\\n}else{\\nenvironmentRefraction=mix(\\nenvironmentRefractionMid,\\nsampleRefraction(refractionSamplerLow,refractionCoords).rgb,\\nlodRefractionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef GAMMAREFRACTION\\nenvironmentRefraction=toLinearSpace(environmentRefraction.rgb);\\n#endif\\n\\nenvironmentRefraction*=vRefractionInfos.x;\\n#endif\\n\\n#ifdef REFLECTION\\nvec3 environmentRadiance=vec3(0.,0.,0.);\\nvec3 environmentIrradiance=vec3(0.,0.,0.);\\nvec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\\n#ifdef REFLECTIONMAP_OPPOSITEZ\\nreflectionVector.z*=-1.0;\\n#endif\\n\\n#ifdef REFLECTIONMAP_3D\\nvec3 reflectionCoords=reflectionVector;\\n#else\\nvec2 reflectionCoords=reflectionVector.xy;\\n#ifdef REFLECTIONMAP_PROJECTION\\nreflectionCoords/=reflectionVector.z;\\n#endif\\nreflectionCoords.y=1.0-reflectionCoords.y;\\n#endif\\n#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);\\n#else\\nfloat reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,1.);\\n#endif\\n#ifdef LODBASEDMICROSFURACE\\n\\nreflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;\\n#ifdef LODINREFLECTIONALPHA\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);\\nfloat requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);\\n#else\\nfloat requestedReflectionLOD=reflectionLOD;\\n#endif\\nenvironmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,requestedReflectionLOD).rgb;\\n#else\\nfloat lodReflectionNormalized=clamp(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x),0.,1.);\\nfloat lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;\\nvec3 environmentSpecularMid=sampleReflection(reflectionSampler,reflectionCoords).rgb;\\nif(lodReflectionNormalizedDoubled<1.0){\\nenvironmentRadiance=mix(\\nsampleReflection(reflectionSamplerHigh,reflectionCoords).rgb,\\nenvironmentSpecularMid,\\nlodReflectionNormalizedDoubled\\n);\\n}else{\\nenvironmentRadiance=mix(\\nenvironmentSpecularMid,\\nsampleReflection(reflectionSamplerLow,reflectionCoords).rgb,\\nlodReflectionNormalizedDoubled-1.0\\n);\\n}\\n#endif\\n#ifdef GAMMAREFLECTION\\nenvironmentRadiance=toLinearSpace(environmentRadiance.rgb);\\n#endif\\n\\n#ifdef USESPHERICALFROMREFLECTIONMAP\\n#if defined(NORMAL) && !defined(USESPHERICALINFRAGMENT)\\nenvironmentIrradiance=vEnvironmentIrradiance;\\n#else\\nenvironmentIrradiance=environmentIrradianceJones(reflectionVector);\\n#endif\\n#endif\\n\\nenvironmentRadiance*=vReflectionInfos.x;\\nenvironmentRadiance*=vReflectionColor.rgb;\\nenvironmentIrradiance*=vReflectionColor.rgb;\\n#endif\\n\\n\\n\\nfloat reflectance=max(max(surfaceReflectivityColor.r,surfaceReflectivityColor.g),surfaceReflectivityColor.b);\\nfloat reflectance90=fresnelGrazingReflectance(reflectance);\\nvec3 specularEnvironmentR0=surfaceReflectivityColor.rgb;\\nvec3 specularEnvironmentR90=vec3(1.0,1.0,1.0)*reflectance90;\\n\\nvec3 diffuseBase=vec3(0.,0.,0.);\\n#ifdef SPECULARTERM\\nvec3 specularBase=vec3(0.,0.,0.);\\n#endif\\n#ifdef LIGHTMAP\\nvec3 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset).rgb*vLightmapInfos.y;\\n#endif\\nlightingInfo info;\\nfloat shadow=1.; \\nfloat NdotL=-1.;\\n#include<lightFragment>[0..maxSimultaneousLights]\\n\\n#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)\\n\\nvec2 brdfSamplerUV=vec2(NdotV,roughness);\\n\\nvec4 environmentBrdf=texture2D(environmentBrdfSampler,brdfSamplerUV);\\nvec3 specularEnvironmentReflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;\\n#ifdef AMBIENTINGRAYSCALE\\nfloat ambientMonochrome=ambientOcclusionColor.r;\\n#else\\nfloat ambientMonochrome=getLuminance(ambientOcclusionColor);\\n#endif\\nfloat seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);\\nspecularEnvironmentReflectance*=seo;\\n#ifdef BUMP\\n#ifdef REFLECTIONMAP_3D\\nfloat eho=environmentHorizonOcclusion(reflectionCoords,normalW);\\nspecularEnvironmentReflectance*=eho;\\n#endif\\n#endif\\n#else\\n\\nvec3 specularEnvironmentReflectance=fresnelSchlickEnvironmentGGX(NdotV,specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));\\n#endif\\n\\n#ifdef REFRACTION\\nvec3 refractance=vec3(0.0,0.0,0.0);\\nvec3 transmission=vec3(1.0,1.0,1.0);\\n#ifdef LINKREFRACTIONTOTRANSPARENCY\\n\\ntransmission*=(1.0-alpha);\\n\\n\\nvec3 mixedAlbedo=surfaceAlbedo;\\nfloat maxChannel=max(max(mixedAlbedo.r,mixedAlbedo.g),mixedAlbedo.b);\\nvec3 tint=clamp(maxChannel*mixedAlbedo,0.0,1.0);\\n\\nsurfaceAlbedo*=alpha;\\n\\nenvironmentIrradiance*=alpha;\\n\\nenvironmentRefraction*=tint;\\n\\nalpha=1.0;\\n#endif\\n\\nvec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);\\nspecularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,alpha);\\n\\ntransmission*=1.0-specularEnvironmentReflectance;\\n\\nrefractance=transmission;\\n#endif\\n\\n\\n\\n\\nsurfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;\\n\\nvec3 finalDiffuse=diffuseBase;\\nfinalDiffuse.rgb+=vAmbientColor;\\nfinalDiffuse*=surfaceAlbedo.rgb;\\nfinalDiffuse=max(finalDiffuse,0.0);\\n\\n#ifdef REFLECTION\\nvec3 finalIrradiance=environmentIrradiance;\\nfinalIrradiance*=surfaceAlbedo.rgb;\\n#endif\\n\\n#ifdef SPECULARTERM\\nvec3 finalSpecular=specularBase;\\nfinalSpecular*=surfaceReflectivityColor;\\nfinalSpecular=max(finalSpecular,0.0);\\n\\nvec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;\\n#endif\\n\\n#ifdef REFLECTION\\nvec3 finalRadiance=environmentRadiance;\\nfinalRadiance*=specularEnvironmentReflectance;\\n\\nvec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;\\n#endif\\n\\n#ifdef REFRACTION\\nvec3 finalRefraction=environmentRefraction;\\nfinalRefraction*=refractance;\\n#endif\\n\\nvec3 finalEmissive=vEmissiveColor;\\n#ifdef EMISSIVE\\nvec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;\\nfinalEmissive*=toLinearSpace(emissiveColorTex.rgb);\\nfinalEmissive*=vEmissiveInfos.y;\\n#endif\\n\\n#ifdef ALPHABLEND\\nfloat luminanceOverAlpha=0.0;\\n#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalRadianceScaled);\\n#endif\\n#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)\\nluminanceOverAlpha+=getLuminance(finalSpecularScaled);\\n#endif\\n#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA)\\nalpha=clamp(alpha+luminanceOverAlpha*luminanceOverAlpha,0.,1.);\\n#endif\\n#endif\\n\\n\\n\\nvec4 finalColor=vec4(finalDiffuse*ambientOcclusionColor*vLightingIntensity.x +\\n#ifdef REFLECTION\\nfinalIrradiance*ambientOcclusionColor*vLightingIntensity.z +\\n#endif\\n#ifdef SPECULARTERM\\n\\n\\nfinalSpecularScaled +\\n#endif\\n#ifdef REFLECTION\\n\\n\\nfinalRadianceScaled +\\n#endif\\n#ifdef REFRACTION\\nfinalRefraction*vLightingIntensity.z +\\n#endif\\nfinalEmissive*vLightingIntensity.y,\\nalpha);\\n\\n#ifdef LIGHTMAP\\n#ifndef LIGHTMAPEXCLUDED\\n#ifdef USELIGHTMAPASSHADOWMAP\\nfinalColor.rgb*=lightmapColor;\\n#else\\nfinalColor.rgb+=lightmapColor;\\n#endif\\n#endif\\n#endif\\n\\nfinalColor=max(finalColor,0.0);\\n#include<logDepthFragment>\\n#include<fogFragment>(color,finalColor)\\n#ifdef IMAGEPROCESSINGPOSTPROCESS\\n\\n\\nfinalColor.rgb=clamp(finalColor.rgb,0.,30.0);\\n#else\\n\\nfinalColor=applyImageProcessing(finalColor);\\n#endif\\n#ifdef PREMULTIPLYALPHA\\n\\nfinalColor.rgb*=finalColor.a;\\n#endif\\ngl_FragColor=finalColor;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n}\",\"spritesVertexShader\":\"\\nattribute vec4 position;\\nattribute vec4 options;\\nattribute vec4 cellInfo;\\nattribute vec4 color;\\n\\nuniform vec2 textureInfos;\\nuniform mat4 view;\\nuniform mat4 projection;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#include<fogVertexDeclaration>\\nvoid main(void) { \\nvec3 viewPos=(view*vec4(position.xyz,1.0)).xyz; \\nvec2 cornerPos;\\nfloat angle=position.w;\\nvec2 size=vec2(options.x,options.y);\\nvec2 offset=options.zw;\\nvec2 uvScale=textureInfos.xy;\\ncornerPos=vec2(offset.x-0.5,offset.y-0.5)*size;\\n\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\n\\nviewPos+=rotatedCorner;\\ngl_Position=projection*vec4(viewPos,1.0); \\n\\nvColor=color;\\n\\nvec2 uvOffset=vec2(abs(offset.x-cellInfo.x),1.0-abs(offset.y-cellInfo.y));\\nvUV=(uvOffset+cellInfo.zw)*uvScale;\\n\\n#ifdef FOG\\nvFogDistance=viewPos;\\n#endif\\n}\",\"spritesPixelShader\":\"uniform bool alphaTest;\\nvarying vec4 vColor;\\n\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n\\n#include<fogFragmentDeclaration>\\nvoid main(void) {\\nvec4 color=texture2D(diffuseSampler,vUV);\\nif (alphaTest) \\n{\\nif (color.a<0.95)\\ndiscard;\\n}\\ncolor*=vColor;\\n#include<fogFragment>\\ngl_FragColor=color;\\n}\",\"particlesVertexShader\":\"\\nattribute vec3 position;\\nattribute vec4 color;\\nattribute vec4 options;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\n\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\n#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nuniform mat4 invView;\\nvarying float fClipDistance;\\n#endif\\nvoid main(void) { \\nvec3 viewPos=(view*vec4(position,1.0)).xyz; \\nvec3 cornerPos;\\nfloat size=options.y;\\nfloat angle=options.x;\\nvec2 offset=options.zw;\\ncornerPos=vec3(offset.x-0.5,offset.y-0.5,0.)*size;\\n\\nvec3 rotatedCorner;\\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\\nrotatedCorner.z=0.;\\n\\nviewPos+=rotatedCorner;\\ngl_Position=projection*vec4(viewPos,1.0); \\nvColor=color;\\nvUV=offset;\\n\\n#ifdef CLIPPLANE\\nvec4 worldPos=invView*vec4(viewPos,1.0);\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\\n}\",\"particlesPixelShader\":\"\\nvarying vec2 vUV;\\nvarying vec4 vColor;\\nuniform vec4 textureMask;\\nuniform sampler2D diffuseSampler;\\n#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\\nvoid main(void) {\\n#ifdef CLIPPLANE\\nif (fClipDistance>0.0)\\ndiscard;\\n#endif\\nvec4 baseColor=texture2D(diffuseSampler,vUV);\\ngl_FragColor=(baseColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\\n}\",\"colorVertexShader\":\"\\nattribute vec3 position;\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n\\nuniform mat4 viewProjection;\\nuniform mat4 world;\\n\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\nvoid main(void) {\\nmat4 finalWorld=world;\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n}\",\"colorPixelShader\":\"#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#else\\nuniform vec4 color;\\n#endif\\nvoid main(void) {\\n#ifdef VERTEXCOLOR\\ngl_FragColor=vColor;\\n#else\\ngl_FragColor=color;\\n#endif\\n}\",\"postprocessVertexShader\":\"\\nattribute vec2 position;\\nuniform vec2 scale;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=(position*madd+madd)*scale;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\"passPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nvoid main(void) \\n{\\ngl_FragColor=texture2D(textureSampler,vUV);\\n}\",\"shadowMapVertexShader\":\"\\nattribute vec3 position;\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nuniform vec2 biasAndScale;\\nuniform vec2 depthValues;\\nvarying float vDepthMetric;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\ngl_Position=viewProjection*worldPos;\\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y))+biasAndScale.x;\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\"shadowMapPixelShader\":\"#ifndef FLOAT\\nvec4 pack(float depth)\\n{\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(depth*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\n#endif\\nvarying float vDepthMetric;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nuniform vec2 biasAndScale;\\nuniform vec2 depthValues;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\nfloat depth=vDepthMetric;\\n#ifdef ESM\\ndepth=clamp(exp(-min(87.,biasAndScale.y*depth)),0.,1.);\\n#endif\\n#ifdef FLOAT\\ngl_FragColor=vec4(depth,1.0,1.0,1.0);\\n#else\\ngl_FragColor=pack(depth);\\n#endif\\n}\",\"depthBoxBlurPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec2 screenSize;\\nvoid main(void)\\n{\\nvec4 colorDepth=vec4(0.0);\\nfor (int x=-OFFSET; x<=OFFSET; x++)\\nfor (int y=-OFFSET; y<=OFFSET; y++)\\ncolorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);\\ngl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));\\n}\",\"proceduralVertexShader\":\"\\nattribute vec2 position;\\n\\nvarying vec2 vPosition;\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvPosition=position;\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\"depthVertexShader\":\"\\nattribute vec3 position;\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nuniform vec2 depthValues;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvarying float vDepthMetric;\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\"depthPixelShader\":\"#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nvarying float vDepthMetric;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=vec4(vDepthMetric,vDepthMetric*vDepthMetric,0.0,1.0);\\n}\",\"ssaoPixelShader\":\"\\nuniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float radius;\\nuniform float area;\\nuniform float fallOff;\\nuniform float base;\\nvec3 normalFromDepth(float depth,vec2 coords)\\n{\\nvec2 offset1=vec2(0.0,radius);\\nvec2 offset2=vec2(radius,0.0);\\nfloat depth1=texture2D(textureSampler,coords+offset1).r;\\nfloat depth2=texture2D(textureSampler,coords+offset2).r;\\nvec3 p1=vec3(offset1,depth1-depth);\\nvec3 p2=vec3(offset2,depth2-depth);\\nvec3 normal=cross(p1,p2);\\nnormal.z=-normal.z;\\nreturn normalize(normal);\\n}\\nvoid main()\\n{\\nvec3 random=normalize(texture2D(randomSampler,vUV*randTextureTiles).rgb);\\nfloat depth=texture2D(textureSampler,vUV).r;\\nvec3 position=vec3(vUV,depth);\\nvec3 normal=normalFromDepth(depth,vUV);\\nfloat radiusDepth=radius/depth;\\nfloat occlusion=0.0;\\nvec3 ray;\\nvec3 hemiRay;\\nfloat occlusionDepth;\\nfloat difference;\\nfor (int i=0; i<SAMPLES; i++)\\n{\\nray=radiusDepth*reflect(sampleSphere[i],random);\\nhemiRay=position+sign(dot(ray,normal))*ray;\\nocclusionDepth=texture2D(textureSampler,clamp(hemiRay.xy,vec2(0.001,0.001),vec2(0.999,0.999))).r;\\ndifference=depth-occlusionDepth;\\nocclusion+=step(fallOff,difference)*(1.0-smoothstep(fallOff,area,difference));\\n}\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor.r=result;\\ngl_FragColor.g=result;\\ngl_FragColor.b=result;\\ngl_FragColor.a=1.0;\\n}\\n#endif\\n#ifdef BILATERAL_BLUR\\nuniform sampler2D depthSampler;\\nuniform float outSize;\\nuniform float samplerOffsets[SAMPLES];\\nvoid main()\\n{\\nfloat texelsize=1.0/outSize;\\nfloat compareDepth=texture2D(depthSampler,vUV).r;\\nfloat result=0.0;\\nfloat weightSum=0.0;\\nfor (int i=0; i<SAMPLES; ++i)\\n{\\n#ifdef BILATERAL_BLUR_H\\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\\n#else\\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\\n#endif\\nvec2 samplePos=vUV+sampleOffset;\\nfloat sampleDepth=texture2D(depthSampler,samplePos).r;\\nfloat weight=(1.0/(0.0001+abs(compareDepth-sampleDepth)));\\nresult+=texture2D(textureSampler,samplePos).r*weight;\\nweightSum+=weight;\\n}\\nresult/=weightSum;\\ngl_FragColor.rgb=vec3(result);\\ngl_FragColor.a=1.0;\\n}\\n#endif\\n\",\"ssao2PixelShader\":\"\\nprecision highp float;\\nuniform sampler2D textureSampler;\\nuniform float near;\\nuniform float far;\\nuniform float radius;\\nvarying vec2 vUV;\\nfloat perspectiveDepthToViewZ( const in float invClipZ,const in float near,const in float far ) {\\nreturn ( near*far )/( ( far-near )*invClipZ-far );\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( near*far/viewZ+far)/( far-near );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ,const in float near,const in float far ) {\\nreturn ( viewZ+near )/( near-far );\\n}\\n#ifdef SSAO\\nuniform sampler2D randomSampler;\\nuniform sampler2D normalSampler;\\nuniform float randTextureTiles;\\nuniform float samplesFactor;\\nuniform vec3 sampleSphere[SAMPLES];\\nuniform float totalStrength;\\nuniform float base;\\nuniform float xViewport;\\nuniform float yViewport;\\nuniform float maxZ;\\nuniform float minZAspect;\\nuniform vec2 texelSize;\\nuniform mat4 projection;\\nvoid main()\\n{\\nvec3 random=texture2D(randomSampler,vUV*randTextureTiles).rgb;\\nfloat depth=abs(texture(textureSampler,vUV).r);\\nvec3 normal=texture2D(normalSampler,vUV).rgb; \\nfloat occlusion=0.0;\\nfloat correctedRadius=min(radius,minZAspect*depth/near);\\nvec3 vViewRay=vec3((vUV.x*2.0-1.0)*xViewport,(vUV.y*2.0-1.0)*yViewport,1.0);\\nvec3 origin=vViewRay*depth;\\nvec3 rvec=random*2.0-1.0;\\nrvec.z=0.0;\\nvec3 tangent=normalize(rvec-normal*dot(rvec,normal));\\nvec3 bitangent=cross(normal,tangent);\\nmat3 tbn=mat3(tangent,bitangent,normal);\\nfloat difference;\\nif (depth>maxZ) {\\ngl_FragColor=vec4(1.0,1.0,1.0,1.0);\\nreturn;\\n}\\nfor (int i=0; i<SAMPLES; ++i) {\\n\\nvec3 samplePosition=tbn*sampleSphere[i];\\nsamplePosition=samplePosition*correctedRadius+origin;\\n\\nvec4 offset=vec4(samplePosition,1.0);\\noffset=projection*offset;\\noffset.xyz/=offset.w;\\noffset.xy=offset.xy*0.5+0.5;\\nif (offset.x<0.0 || offset.y<0.0 || offset.x>1.0 || offset.y>1.0) {\\ncontinue;\\n}\\n\\nfloat sampleDepth=abs(texture(textureSampler,offset.xy).r);\\n\\nfloat rangeCheck=abs(depth-sampleDepth)<correctedRadius ? 1.0 : 0.0;\\ndifference=samplePosition.z-sampleDepth;\\n\\nocclusion+=(difference>=1e-5 ? 1.0 : 0.0)*rangeCheck;\\n}\\n\\nfloat ao=1.0-totalStrength*occlusion*samplesFactor;\\nfloat result=clamp(ao+base,0.0,1.0);\\ngl_FragColor=vec4(vec3(result),1.0);\\n}\\n#endif\\n#ifdef BILATERAL_BLUR\\nuniform sampler2D depthSampler;\\nuniform float outSize;\\nuniform float samplerOffsets[SAMPLES];\\nvec4 blur9(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.3846153846)*direction;\\nvec2 off2=vec2(3.2307692308)*direction;\\ncolor+=texture2D(image,uv)*0.2270270270;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.3162162162;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.0702702703;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.0702702703;\\nreturn color;\\n}\\nvec4 blur13(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\ncolor+=texture2D(image,uv)*0.1964825501511404;\\ncolor+=texture2D(image,uv+(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv-(off1/resolution))*0.2969069646728344;\\ncolor+=texture2D(image,uv+(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv-(off2/resolution))*0.09447039785044732;\\ncolor+=texture2D(image,uv+(off3/resolution))*0.010381362401148057;\\ncolor+=texture2D(image,uv-(off3/resolution))*0.010381362401148057;\\nreturn color;\\n}\\nvec4 blur13Bilateral(sampler2D image,vec2 uv,float resolution,vec2 direction) {\\nvec4 color=vec4(0.0);\\nvec2 off1=vec2(1.411764705882353)*direction;\\nvec2 off2=vec2(3.2941176470588234)*direction;\\nvec2 off3=vec2(5.176470588235294)*direction;\\nfloat compareDepth=abs(texture2D(depthSampler,uv).r);\\nfloat sampleDepth;\\nfloat weight;\\nfloat weightSum=30.0;\\ncolor+=texture2D(image,uv)*30.0;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off1/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off1/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off2/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off2/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv+(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv+(off3/resolution))*weight;\\nsampleDepth=abs(texture2D(depthSampler,uv-(off3/resolution)).r);\\nweight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30.0);\\nweightSum+=weight;\\ncolor+=texture2D(image,uv-(off3/resolution))*weight;\\nreturn color/weightSum;\\n}\\nvoid main()\\n{\\n#if EXPENSIVE\\nfloat compareDepth=abs(texture2D(depthSampler,vUV).r);\\nfloat texelsize=1.0/outSize;\\nfloat result=0.0;\\nfloat weightSum=0.0;\\nfor (int i=0; i<SAMPLES; ++i)\\n{\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\nvec2 sampleOffset=vec2(texelsize*samplerOffsets[i],0.0);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\nvec2 sampleOffset=vec2(0.0,texelsize*samplerOffsets[i]);\\n#endif\\nvec2 samplePos=vUV+sampleOffset;\\nfloat sampleDepth=abs(texture2D(depthSampler,samplePos).r);\\nfloat weight=clamp(1.0/( 0.003+abs(compareDepth-sampleDepth)),0.0,30000.0);\\nresult+=texture2D(textureSampler,samplePos).r*weight;\\nweightSum+=weight;\\n}\\nresult/=weightSum;\\ngl_FragColor.rgb=vec3(result);\\ngl_FragColor.a=1.0;\\n#else\\nvec4 color;\\n#ifdef BILATERAL_BLUR_H\\nvec2 direction=vec2(1.0,0.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#else\\nvec2 direction=vec2(0.0,1.0);\\ncolor=blur13Bilateral(textureSampler,vUV,outSize,direction);\\n#endif\\ngl_FragColor.rgb=vec3(color.r);\\ngl_FragColor.a=1.0;\\n#endif\\n}\\n#endif\\n\",\"ssaoCombinePixelShader\":\"uniform sampler2D textureSampler;\\nuniform sampler2D originalColor;\\nvarying vec2 vUV;\\nvoid main(void) {\\nvec4 ssaoColor=texture2D(textureSampler,vUV);\\nvec4 sceneColor=texture2D(originalColor,vUV);\\ngl_FragColor=sceneColor*ssaoColor;\\n}\\n\",\"chromaticAberrationPixelShader\":\"\\nuniform sampler2D textureSampler; \\n\\nuniform float chromatic_aberration;\\nuniform float screen_width;\\nuniform float screen_height;\\n\\nvarying vec2 vUV;\\nvoid main(void)\\n{\\nvec2 centered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\\nfloat radius2=centered_screen_pos.x*centered_screen_pos.x\\n+centered_screen_pos.y*centered_screen_pos.y;\\nfloat radius=sqrt(radius2);\\nvec4 original=texture2D(textureSampler,vUV);\\nif (chromatic_aberration>0.0) {\\n\\nvec3 ref_indices=vec3(-0.3,0.0,0.3);\\nfloat ref_shiftX=chromatic_aberration*radius*17.0/screen_width;\\nfloat ref_shiftY=chromatic_aberration*radius*17.0/screen_height;\\n\\nvec2 ref_coords_r=vec2(vUV.x+ref_indices.r*ref_shiftX,vUV.y+ref_indices.r*ref_shiftY*0.5);\\nvec2 ref_coords_g=vec2(vUV.x+ref_indices.g*ref_shiftX,vUV.y+ref_indices.g*ref_shiftY*0.5);\\nvec2 ref_coords_b=vec2(vUV.x+ref_indices.b*ref_shiftX,vUV.y+ref_indices.b*ref_shiftY*0.5);\\noriginal.r=texture2D(textureSampler,ref_coords_r).r;\\noriginal.g=texture2D(textureSampler,ref_coords_g).g;\\noriginal.b=texture2D(textureSampler,ref_coords_b).b;\\n}\\ngl_FragColor=original;\\n}\",\"lensHighlightsPixelShader\":\"\\nuniform sampler2D textureSampler; \\n\\nuniform float gain;\\nuniform float threshold;\\nuniform float screen_width;\\nuniform float screen_height;\\n\\nvarying vec2 vUV;\\n\\nvec4 highlightColor(vec4 color) {\\nvec4 highlight=color;\\nfloat luminance=dot(highlight.rgb,vec3(0.2125,0.7154,0.0721));\\nfloat lum_threshold;\\nif (threshold>1.0) { lum_threshold=0.94+0.01*threshold; }\\nelse { lum_threshold=0.5+0.44*threshold; }\\nluminance=clamp((luminance-lum_threshold)*(1.0/(1.0-lum_threshold)),0.0,1.0);\\nhighlight*=luminance*gain;\\nhighlight.a=1.0;\\nreturn highlight;\\n}\\nvoid main(void)\\n{\\nvec4 original=texture2D(textureSampler,vUV);\\n\\nif (gain == -1.0) {\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\nreturn;\\n}\\nfloat w=2.0/screen_width;\\nfloat h=2.0/screen_height;\\nfloat weight=1.0;\\n\\nvec4 blurred=vec4(0.0,0.0,0.0,0.0);\\n#ifdef PENTAGON\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.84*w,0.43*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.48*w,-1.29*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.61*w,1.51*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.55*w,-0.74*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.71*w,-0.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.94*w,1.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.40*w,-1.87*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.62*w,1.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.09*w,0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.46*w,-1.71*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.08*w,2.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.85*w,-1.89*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.89*w,0.16*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.29*w,1.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.40*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.54*w,2.26*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.60*w,-0.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.31*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.83*w,2.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.12*w,-2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.60*w,1.11*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.99*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.50*w,-2.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.85*w,3.33*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.94*w,-1.92*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.27*w,-0.53*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.95*w,2.48*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.23*w,-3.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.17*w,2.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.97*w,-0.04*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.25*w,-2.00*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.31*w,3.08*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.94*w,-2.59*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.37*w,0.64*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.13*w,1.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.03*w,-3.65*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.60*w,3.17*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.14*w,-1.19*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.00*w,-1.19*h)));\\n#else\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.85*w,0.36*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.52*w,-1.14*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.46*w,1.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.46*w,-0.83*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.79*w,-0.42*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.11*w,1.62*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.29*w,-2.07*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.69*w,1.39*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.28*w,0.12*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.65*w,-1.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.08*w,2.44*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.63*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.55*w,0.31*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.13*w,1.52*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.56*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.38*w,2.34*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.64*w,-0.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.53*w,-1.21*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.06*w,2.63*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.00*w,-2.69*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.59*w,1.32*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.82*w,0.78*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.57*w,-2.50*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(0.54*w,2.93*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.39*w,-1.81*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,-0.28*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.04*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.02*w,-3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.09*w,2.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-3.07*w,-0.25*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.44*w,-1.90*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-0.52*w,3.05*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-1.68*w,-2.61*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(3.01*w,0.79*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.76*w,1.46*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.05*w,-2.94*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(1.21*w,2.88*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(-2.84*w,-1.30*h)));\\nblurred+=highlightColor(texture2D(textureSampler,vUV+vec2(2.98*w,-0.96*h)));\\n#endif\\nblurred/=39.0;\\ngl_FragColor=blurred;\\n\\n}\",\"depthOfFieldPixelShader\":\"\\n\\n\\n\\n\\nuniform sampler2D textureSampler;\\nuniform sampler2D highlightsSampler;\\nuniform sampler2D depthSampler;\\nuniform sampler2D grainSampler;\\n\\nuniform float grain_amount;\\nuniform bool blur_noise;\\nuniform float screen_width;\\nuniform float screen_height;\\nuniform float distortion;\\nuniform bool dof_enabled;\\n\\nuniform float screen_distance; \\nuniform float aperture;\\nuniform float darken;\\nuniform float edge_blur;\\nuniform bool highlights;\\n\\nuniform float near;\\nuniform float far;\\n\\nvarying vec2 vUV;\\n\\n#define PI 3.14159265\\n#define TWOPI 6.28318530\\n#define inverse_focal_length 0.1 \\n\\nvec2 centered_screen_pos;\\nvec2 distorted_coords;\\nfloat radius2;\\nfloat radius;\\n\\nvec2 rand(vec2 co)\\n{\\nfloat noise1=(fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453));\\nfloat noise2=(fract(sin(dot(co,vec2(12.9898,78.233)*2.0))*43758.5453));\\nreturn clamp(vec2(noise1,noise2),0.0,1.0);\\n}\\n\\nvec2 getDistortedCoords(vec2 coords) {\\nif (distortion == 0.0) { return coords; }\\nvec2 direction=1.0*normalize(centered_screen_pos);\\nvec2 dist_coords=vec2(0.5,0.5);\\ndist_coords.x=0.5+direction.x*radius2*1.0;\\ndist_coords.y=0.5+direction.y*radius2*1.0;\\nfloat dist_amount=clamp(distortion*0.23,0.0,1.0);\\ndist_coords=mix(coords,dist_coords,dist_amount);\\nreturn dist_coords;\\n}\\n\\nfloat sampleScreen(inout vec4 color,const in vec2 offset,const in float weight) {\\n\\nvec2 coords=distorted_coords;\\nfloat angle=rand(coords*100.0).x*TWOPI;\\ncoords+=vec2(offset.x*cos(angle)-offset.y*sin(angle),offset.x*sin(angle)+offset.y*cos(angle));\\ncolor+=texture2D(textureSampler,coords)*weight;\\nreturn weight;\\n}\\n\\nfloat getBlurLevel(float size) {\\nreturn min(3.0,ceil(size/1.0));\\n}\\n\\nvec4 getBlurColor(float size) {\\nvec4 col=texture2D(textureSampler,distorted_coords);\\nif (size == 0.0) { return col; }\\n\\n\\nfloat blur_level=getBlurLevel(size);\\nfloat w=(size/screen_width);\\nfloat h=(size/screen_height);\\nfloat total_weight=1.0;\\nvec2 sample_coords;\\ntotal_weight+=sampleScreen(col,vec2(-0.50*w,0.24*h),0.93);\\ntotal_weight+=sampleScreen(col,vec2(0.30*w,-0.75*h),0.90);\\ntotal_weight+=sampleScreen(col,vec2(0.36*w,0.96*h),0.87);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,-0.55*h),0.85);\\ntotal_weight+=sampleScreen(col,vec2(1.33*w,-0.37*h),0.83);\\ntotal_weight+=sampleScreen(col,vec2(-0.82*w,1.31*h),0.80);\\ntotal_weight+=sampleScreen(col,vec2(-0.31*w,-1.67*h),0.78);\\ntotal_weight+=sampleScreen(col,vec2(1.47*w,1.11*h),0.76);\\ntotal_weight+=sampleScreen(col,vec2(-1.97*w,0.19*h),0.74);\\ntotal_weight+=sampleScreen(col,vec2(1.42*w,-1.57*h),0.72);\\nif (blur_level>1.0) {\\ntotal_weight+=sampleScreen(col,vec2(0.01*w,2.25*h),0.70);\\ntotal_weight+=sampleScreen(col,vec2(-1.62*w,-1.74*h),0.67);\\ntotal_weight+=sampleScreen(col,vec2(2.49*w,0.20*h),0.65);\\ntotal_weight+=sampleScreen(col,vec2(-2.07*w,1.61*h),0.63);\\ntotal_weight+=sampleScreen(col,vec2(0.46*w,-2.70*h),0.61);\\ntotal_weight+=sampleScreen(col,vec2(1.55*w,2.40*h),0.59);\\ntotal_weight+=sampleScreen(col,vec2(-2.88*w,-0.75*h),0.56);\\ntotal_weight+=sampleScreen(col,vec2(2.73*w,-1.44*h),0.54);\\ntotal_weight+=sampleScreen(col,vec2(-1.08*w,3.02*h),0.52);\\ntotal_weight+=sampleScreen(col,vec2(-1.28*w,-3.05*h),0.49);\\n}\\nif (blur_level>2.0) {\\ntotal_weight+=sampleScreen(col,vec2(3.11*w,1.43*h),0.46);\\ntotal_weight+=sampleScreen(col,vec2(-3.36*w,1.08*h),0.44);\\ntotal_weight+=sampleScreen(col,vec2(1.80*w,-3.16*h),0.41);\\ntotal_weight+=sampleScreen(col,vec2(0.83*w,3.65*h),0.38);\\ntotal_weight+=sampleScreen(col,vec2(-3.16*w,-2.19*h),0.34);\\ntotal_weight+=sampleScreen(col,vec2(3.92*w,-0.53*h),0.31);\\ntotal_weight+=sampleScreen(col,vec2(-2.59*w,3.12*h),0.26);\\ntotal_weight+=sampleScreen(col,vec2(-0.20*w,-4.15*h),0.22);\\ntotal_weight+=sampleScreen(col,vec2(3.02*w,3.00*h),0.15);\\n}\\ncol/=total_weight; \\n\\nif (darken>0.0) {\\ncol.rgb*=clamp(0.3,1.0,1.05-size*0.5*darken);\\n}\\n\\n\\n\\n\\nreturn col;\\n}\\nvoid main(void)\\n{\\n\\ncentered_screen_pos=vec2(vUV.x-0.5,vUV.y-0.5);\\nradius2=centered_screen_pos.x*centered_screen_pos.x+centered_screen_pos.y*centered_screen_pos.y;\\nradius=sqrt(radius2);\\ndistorted_coords=getDistortedCoords(vUV); \\nvec2 texels_coords=vec2(vUV.x*screen_width,vUV.y*screen_height); \\nfloat depth=texture2D(depthSampler,distorted_coords).r; \\nfloat distance=near+(far-near)*depth; \\nvec4 color=texture2D(textureSampler,vUV); \\n\\n\\nfloat coc=abs(aperture*(screen_distance*(inverse_focal_length-1.0/distance)-1.0));\\n\\nif (dof_enabled == false || coc<0.07) { coc=0.0; }\\n\\nfloat edge_blur_amount=0.0;\\nif (edge_blur>0.0) {\\nedge_blur_amount=clamp((radius*2.0-1.0+0.15*edge_blur)*1.5,0.0,1.0)*1.3;\\n}\\n\\nfloat blur_amount=max(edge_blur_amount,coc);\\n\\nif (blur_amount == 0.0) {\\ngl_FragColor=texture2D(textureSampler,distorted_coords);\\n}\\nelse {\\n\\ngl_FragColor=getBlurColor(blur_amount*1.7);\\n\\nif (highlights) {\\ngl_FragColor.rgb+=clamp(coc,0.0,1.0)*texture2D(highlightsSampler,distorted_coords).rgb;\\n}\\nif (blur_noise) {\\n\\nvec2 noise=rand(distorted_coords)*0.01*blur_amount;\\nvec2 blurred_coord=vec2(distorted_coords.x+noise.x,distorted_coords.y+noise.y);\\ngl_FragColor=0.04*texture2D(textureSampler,blurred_coord)+0.96*gl_FragColor;\\n}\\n}\\n\\nif (grain_amount>0.0) {\\nvec4 grain_color=texture2D(grainSampler,texels_coords*0.003);\\ngl_FragColor.rgb+=(-0.5+grain_color.rgb)*0.30*grain_amount;\\n}\\n}\\n\",\"standardPixelShader\":\"uniform sampler2D textureSampler;\\nvarying vec2 vUV;\\n#if defined(PASS_POST_PROCESS)\\nvoid main(void)\\n{\\nvec4 color=texture2D(textureSampler,vUV);\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(DOWN_SAMPLE_X4)\\nuniform vec2 dsOffsets[16];\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+dsOffsets[0]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[1]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[2]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[3]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[4]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[5]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[6]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[7]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[8]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[9]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[10]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[11]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[12]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[13]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[14]);\\naverage+=texture2D(textureSampler,vUV+dsOffsets[15]);\\naverage/=16.0;\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(BRIGHT_PASS)\\nuniform vec2 dsOffsets[4];\\nuniform float brightThreshold;\\nvoid main(void)\\n{\\nvec4 average=vec4(0.0,0.0,0.0,0.0);\\naverage=texture2D(textureSampler,vUV+vec2(dsOffsets[0].x,dsOffsets[0].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[1].x,dsOffsets[1].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[2].x,dsOffsets[2].y));\\naverage+=texture2D(textureSampler,vUV+vec2(dsOffsets[3].x,dsOffsets[3].y));\\naverage*=0.25;\\nfloat luminance=length(average.rgb);\\nif (luminance<brightThreshold) {\\naverage=vec4(0.0,0.0,0.0,1.0);\\n}\\ngl_FragColor=average;\\n}\\n#endif\\n#if defined(TEXTURE_ADDER)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensSampler;\\nuniform float exposure;\\nvoid main(void)\\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\ncolour*=exposure;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\ncolour+=colour*texture2D(lensSampler,vUV).rgb;\\nvec4 finalColor=vec4(colour.rgb,1.0)+texture2D(otherSampler,vUV);\\ngl_FragColor=finalColor;\\n}\\n#endif\\n#if defined(VLS)\\n#define PI 3.1415926535897932384626433832795\\nuniform mat4 shadowViewProjection;\\nuniform mat4 lightWorld;\\nuniform vec3 cameraPosition;\\nuniform vec3 sunDirection;\\nuniform vec3 sunColor;\\nuniform vec2 depthValues;\\nuniform float scatteringCoefficient;\\nuniform float scatteringPower;\\nuniform sampler2D shadowMapSampler;\\nuniform sampler2D positionSampler;\\nfloat computeScattering(float lightDotView)\\n{\\nfloat result=1.0-scatteringCoefficient*scatteringCoefficient;\\nresult/=(4.0*PI*pow(1.0+scatteringCoefficient*scatteringCoefficient-(2.0*scatteringCoefficient)*lightDotView,1.5));\\nreturn result;\\n}\\nvoid main(void)\\n{\\n\\nvec3 worldPos=texture2D(positionSampler,vUV).rgb;\\nvec3 startPosition=cameraPosition;\\nvec3 rayVector=worldPos-startPosition;\\nfloat rayLength=length(rayVector);\\nvec3 rayDirection=rayVector/rayLength;\\nfloat stepLength=rayLength/NB_STEPS;\\nvec3 stepL=rayDirection*stepLength;\\nvec3 currentPosition=startPosition;\\nvec3 accumFog=vec3(0.0);\\nfor (int i=0; i<int(NB_STEPS); i++)\\n{\\nvec4 worldInShadowCameraSpace=shadowViewProjection*vec4(currentPosition,1.0);\\nfloat depthMetric=(worldInShadowCameraSpace.z+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depthMetric,0.0,1.0);\\nworldInShadowCameraSpace.xyz/=worldInShadowCameraSpace.w;\\nworldInShadowCameraSpace.xyz=0.5*worldInShadowCameraSpace.xyz+vec3(0.5);\\nfloat shadowMapValue=texture2D(shadowMapSampler,worldInShadowCameraSpace.xy).r;\\nif (shadowMapValue>shadowPixelDepth)\\naccumFog+=sunColor*computeScattering(dot(rayDirection,sunDirection));\\ncurrentPosition+=stepL;\\n}\\naccumFog/=NB_STEPS;\\nvec3 color=accumFog*scatteringPower;\\ngl_FragColor=vec4(color*exp(color) ,1.0);\\n}\\n#endif\\n#if defined(VLSMERGE)\\nuniform sampler2D originalSampler;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(originalSampler,vUV)+texture2D(textureSampler,vUV);\\n}\\n#endif\\n#if defined(LUMINANCE)\\nuniform vec2 lumOffsets[4];\\nvoid main()\\n{\\nfloat average=0.0;\\nvec4 color=vec4(0.0);\\nfloat maximum=-1e20;\\nvec3 weight=vec3(0.299,0.587,0.114);\\nfor (int i=0; i<4; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+ lumOffsets[i]);\\n\\nfloat GreyValue=dot(color.rgb,vec3(0.33,0.33,0.33));\\n\\n#ifdef WEIGHTED_AVERAGE\\nfloat GreyValue=dot(color.rgb,weight);\\n#endif\\n#ifdef BRIGHTNESS\\nfloat GreyValue=max(color.r,max(color.g,color.b));\\n#endif\\n#ifdef HSL_COMPONENT\\nfloat GreyValue=0.5*(max(color.r,max(color.g,color.b))+min(color.r,min(color.g,color.b)));\\n#endif\\n#ifdef MAGNITUDE\\nfloat GreyValue=length(color.rgb);\\n#endif\\nmaximum=max(maximum,GreyValue);\\naverage+=(0.25*log(1e-5+GreyValue));\\n}\\naverage=exp(average);\\ngl_FragColor=vec4(average,maximum,0.0,1.0);\\n}\\n#endif\\n#if defined(LUMINANCE_DOWN_SAMPLE)\\nuniform vec2 dsOffsets[9];\\nuniform float halfDestPixelSize;\\n#ifdef FINAL_DOWN_SAMPLER\\nvec4 pack(float value) {\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(value*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\n#endif\\nvoid main()\\n{\\nvec4 color=vec4(0.0);\\nfloat average=0.0;\\nfor (int i=0; i<9; i++)\\n{\\ncolor=texture2D(textureSampler,vUV+vec2(halfDestPixelSize,halfDestPixelSize)+dsOffsets[i]);\\naverage+=color.r;\\n}\\naverage/=9.0;\\n#ifdef FINAL_DOWN_SAMPLER\\ngl_FragColor=pack(average);\\n#else\\ngl_FragColor=vec4(average,average,0.0,1.0);\\n#endif\\n}\\n#endif\\n#if defined(HDR)\\nuniform sampler2D textureAdderSampler;\\nuniform float averageLuminance;\\nvoid main()\\n{\\nvec4 color=texture2D(textureAdderSampler,vUV);\\nvec4 adjustedColor=color/averageLuminance;\\ncolor=adjustedColor;\\ncolor.a=1.0;\\ngl_FragColor=color;\\n}\\n#endif\\n#if defined(LENS_FLARE)\\n#define GHOSTS 3\\nuniform sampler2D lensColorSampler;\\nuniform float strength;\\nuniform float ghostDispersal;\\nuniform float haloWidth;\\nuniform vec2 resolution;\\nuniform float distortionStrength;\\nfloat hash(vec2 p)\\n{\\nfloat h=dot(p,vec2(127.1,311.7));\\nreturn -1.0+2.0*fract(sin(h)*43758.5453123);\\n}\\nfloat noise(in vec2 p)\\n{\\nvec2 i=floor(p);\\nvec2 f=fract(p);\\nvec2 u=f*f*(3.0-2.0*f);\\nreturn mix(mix(hash(i+vec2(0.0,0.0)),\\nhash(i+vec2(1.0,0.0)),u.x),\\nmix(hash(i+vec2(0.0,1.0)),\\nhash(i+vec2(1.0,1.0)),u.x),u.y);\\n}\\nfloat fbm(vec2 p)\\n{\\nfloat f=0.0;\\nf+=0.5000*noise(p); p*=2.02;\\nf+=0.2500*noise(p); p*=2.03;\\nf+=0.1250*noise(p); p*=2.01;\\nf+=0.0625*noise(p); p*=2.04;\\nf/=0.9375;\\nreturn f;\\n}\\nvec3 pattern(vec2 uv)\\n{\\nvec2 p=-1.0+2.0*uv;\\nfloat p2=dot(p,p);\\nfloat f=fbm(vec2(15.0*p2))/2.0;\\nfloat r=0.2+0.6*sin(12.5*length(uv-vec2(0.5)));\\nfloat g=0.2+0.6*sin(20.5*length(uv-vec2(0.5)));\\nfloat b=0.2+0.6*sin(17.2*length(uv-vec2(0.5)));\\nreturn (1.0-f)*vec3(r,g,b);\\n}\\nfloat luminance(vec3 color)\\n{\\nreturn dot(color.rgb,vec3(0.2126,0.7152,0.0722));\\n}\\nvec4 textureDistorted(sampler2D tex,vec2 texcoord,vec2 direction,vec3 distortion)\\n{\\nreturn vec4(\\ntexture2D(tex,texcoord+direction*distortion.r).r,\\ntexture2D(tex,texcoord+direction*distortion.g).g,\\ntexture2D(tex,texcoord+direction*distortion.b).b,\\n1.0\\n);\\n}\\nvoid main(void)\\n{\\nvec2 uv=-vUV+vec2(1.0);\\nvec2 ghostDir=(vec2(0.5)-uv)*ghostDispersal;\\nvec2 texelSize=1.0/resolution;\\nvec3 distortion=vec3(-texelSize.x*distortionStrength,0.0,texelSize.x*distortionStrength);\\nvec4 result=vec4(0.0);\\nfloat ghostIndice=1.0;\\nfor (int i=0; i<GHOSTS; ++i)\\n{\\nvec2 offset=fract(uv+ghostDir*ghostIndice);\\nfloat weight=length(vec2(0.5)-offset)/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,offset,normalize(ghostDir),distortion)*weight*strength;\\nghostIndice+=1.0;\\n}\\nvec2 haloVec=normalize(ghostDir)*haloWidth;\\nfloat weight=length(vec2(0.5)-fract(uv+haloVec))/length(vec2(0.5));\\nweight=pow(1.0-weight,10.0);\\nresult+=textureDistorted(textureSampler,fract(uv+haloVec),normalize(ghostDir),distortion)*weight*strength;\\nresult*=texture2D(lensColorSampler,vec2(length(vec2(0.5)-uv)/length(vec2(0.5))));\\ngl_FragColor=result;\\n}\\n#endif\\n#if defined(LENS_FLARE_COMPOSE)\\nuniform sampler2D otherSampler;\\nuniform sampler2D lensDirtSampler;\\nuniform sampler2D lensStarSampler;\\nuniform mat4 lensStarMatrix;\\nvoid main(void)\\n{\\nvec2 lensFlareCoords=(lensStarMatrix*vec4(vUV,1.0,1.0)).xy;\\nvec4 lensMod=texture2D(lensDirtSampler,vUV);\\nlensMod+=texture2D(lensStarSampler,vUV);\\nvec4 result=texture2D(textureSampler,vUV)*lensMod;\\ngl_FragColor=texture2D(otherSampler,vUV)+result;\\n}\\n#endif\\n#if defined(DEPTH_OF_FIELD)\\nuniform sampler2D otherSampler;\\nuniform sampler2D depthSampler;\\nuniform float distance;\\nvoid main(void)\\n{\\nvec4 sharp=texture2D(otherSampler,vUV);\\nvec4 blur=texture2D(textureSampler,vUV);\\nfloat dist=clamp(texture2D(depthSampler,vUV).r*distance,0.0,1.0);\\nfloat factor=0.0;\\nif (dist<0.05)\\nfactor=1.0;\\nelse if (dist<0.1)\\nfactor=20.0*(0.1-dist);\\nelse if (dist<0.5)\\nfactor=0.0;\\nelse\\nfactor=2.0*(dist-0.5);\\nfactor=clamp(factor,0.0,0.90);\\ngl_FragColor=mix(sharp,blur,factor);\\n}\\n#endif\\n#if defined(MOTION_BLUR)\\nuniform mat4 inverseViewProjection;\\nuniform mat4 prevViewProjection;\\nuniform vec2 screenSize;\\nuniform float motionScale;\\nuniform float motionStrength;\\nuniform sampler2D depthSampler;\\nvoid main(void)\\n{\\nvec2 texelSize=1.0/screenSize;\\nfloat depth=texture2D(depthSampler,vUV).r;\\nvec4 cpos=vec4(vUV*2.0-1.0,depth,1.0);\\ncpos=cpos*inverseViewProjection;\\nvec4 ppos=cpos*prevViewProjection;\\nppos.xyz/=ppos.w;\\nppos.xy=ppos.xy*0.5+0.5;\\nvec2 velocity=(ppos.xy-vUV)*motionScale*motionStrength;\\nfloat speed=length(velocity/texelSize);\\nint nSamples=int(clamp(speed,1.0,MAX_MOTION_SAMPLES));\\nvec4 result=texture2D(textureSampler,vUV);\\nfor (int i=1; i<int(MAX_MOTION_SAMPLES); ++i) {\\nif (i>=nSamples)\\nbreak;\\nvec2 offset1=vUV+velocity*(float(i)/float(nSamples-1)-0.5);\\nresult+=texture2D(textureSampler,offset1);\\n}\\ngl_FragColor=result/float(nSamples);\\n}\\n#endif\\n\",\"fxaaVertexShader\":\"\\nattribute vec2 position;\\nuniform vec2 texelSize;\\n\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=(position*madd+madd);\\nsampleCoordS=vUV+vec2( 0.0,1.0)*texelSize;\\nsampleCoordE=vUV+vec2( 1.0,0.0)*texelSize;\\nsampleCoordN=vUV+vec2( 0.0,-1.0)*texelSize;\\nsampleCoordW=vUV+vec2(-1.0,0.0)*texelSize;\\nsampleCoordNW=vUV+vec2(-1.0,-1.0)*texelSize;\\nsampleCoordSE=vUV+vec2( 1.0,1.0)*texelSize;\\nsampleCoordNE=vUV+vec2( 1.0,-1.0)*texelSize;\\nsampleCoordSW=vUV+vec2(-1.0,1.0)*texelSize;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\"fxaaPixelShader\":\"uniform sampler2D textureSampler;\\nuniform vec2 texelSize;\\nvarying vec2 vUV;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\nvarying vec2 sampleCoordNW;\\nvarying vec2 sampleCoordSE;\\nvarying vec2 sampleCoordNE;\\nvarying vec2 sampleCoordSW;\\nconst float fxaaQualitySubpix=1.0;\\nconst float fxaaQualityEdgeThreshold=0.166;\\nconst float fxaaQualityEdgeThresholdMin=0.0833;\\nconst vec3 kLumaCoefficients=vec3(0.2126,0.7152,0.0722);\\n#define FxaaLuma(rgba) dot(rgba.rgb,kLumaCoefficients)\\nvoid main(){\\nvec2 posM;\\nposM.x=vUV.x;\\nposM.y=vUV.y;\\nvec4 rgbyM=texture2D(textureSampler,vUV,0.0);\\nfloat lumaM=FxaaLuma(rgbyM);\\nfloat lumaS=FxaaLuma(texture2D(textureSampler,sampleCoordS,0.0));\\nfloat lumaE=FxaaLuma(texture2D(textureSampler,sampleCoordE,0.0));\\nfloat lumaN=FxaaLuma(texture2D(textureSampler,sampleCoordN,0.0));\\nfloat lumaW=FxaaLuma(texture2D(textureSampler,sampleCoordW,0.0));\\nfloat maxSM=max(lumaS,lumaM);\\nfloat minSM=min(lumaS,lumaM);\\nfloat maxESM=max(lumaE,maxSM);\\nfloat minESM=min(lumaE,minSM);\\nfloat maxWN=max(lumaN,lumaW);\\nfloat minWN=min(lumaN,lumaW);\\nfloat rangeMax=max(maxWN,maxESM);\\nfloat rangeMin=min(minWN,minESM);\\nfloat rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;\\nfloat range=rangeMax-rangeMin;\\nfloat rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);\\nif(range<rangeMaxClamped) \\n{\\ngl_FragColor=rgbyM;\\nreturn;\\n}\\nfloat lumaNW=FxaaLuma(texture2D(textureSampler,sampleCoordNW,0.0));\\nfloat lumaSE=FxaaLuma(texture2D(textureSampler,sampleCoordSE,0.0));\\nfloat lumaNE=FxaaLuma(texture2D(textureSampler,sampleCoordNE,0.0));\\nfloat lumaSW=FxaaLuma(texture2D(textureSampler,sampleCoordSW,0.0));\\nfloat lumaNS=lumaN+lumaS;\\nfloat lumaWE=lumaW+lumaE;\\nfloat subpixRcpRange=1.0/range;\\nfloat subpixNSWE=lumaNS+lumaWE;\\nfloat edgeHorz1=(-2.0*lumaM)+lumaNS;\\nfloat edgeVert1=(-2.0*lumaM)+lumaWE;\\nfloat lumaNESE=lumaNE+lumaSE;\\nfloat lumaNWNE=lumaNW+lumaNE;\\nfloat edgeHorz2=(-2.0*lumaE)+lumaNESE;\\nfloat edgeVert2=(-2.0*lumaN)+lumaNWNE;\\nfloat lumaNWSW=lumaNW+lumaSW;\\nfloat lumaSWSE=lumaSW+lumaSE;\\nfloat edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);\\nfloat edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);\\nfloat edgeHorz3=(-2.0*lumaW)+lumaNWSW;\\nfloat edgeVert3=(-2.0*lumaS)+lumaSWSE;\\nfloat edgeHorz=abs(edgeHorz3)+edgeHorz4;\\nfloat edgeVert=abs(edgeVert3)+edgeVert4;\\nfloat subpixNWSWNESE=lumaNWSW+lumaNESE;\\nfloat lengthSign=texelSize.x;\\nbool horzSpan=edgeHorz>=edgeVert;\\nfloat subpixA=subpixNSWE*2.0+subpixNWSWNESE;\\nif (!horzSpan)\\n{\\nlumaN=lumaW;\\n}\\nif (!horzSpan) \\n{\\nlumaS=lumaE;\\n}\\nif (horzSpan) \\n{\\nlengthSign=texelSize.y;\\n}\\nfloat subpixB=(subpixA*(1.0/12.0))-lumaM;\\nfloat gradientN=lumaN-lumaM;\\nfloat gradientS=lumaS-lumaM;\\nfloat lumaNN=lumaN+lumaM;\\nfloat lumaSS=lumaS+lumaM;\\nbool pairN=abs(gradientN)>=abs(gradientS);\\nfloat gradient=max(abs(gradientN),abs(gradientS));\\nif (pairN)\\n{\\nlengthSign=-lengthSign;\\n}\\nfloat subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);\\nvec2 posB;\\nposB.x=posM.x;\\nposB.y=posM.y;\\nvec2 offNP;\\noffNP.x=(!horzSpan) ? 0.0 : texelSize.x;\\noffNP.y=(horzSpan) ? 0.0 : texelSize.y;\\nif (!horzSpan) \\n{\\nposB.x+=lengthSign*0.5;\\n}\\nif (horzSpan)\\n{\\nposB.y+=lengthSign*0.5;\\n}\\nvec2 posN;\\nposN.x=posB.x-offNP.x*1.5;\\nposN.y=posB.y-offNP.y*1.5;\\nvec2 posP;\\nposP.x=posB.x+offNP.x*1.5;\\nposP.y=posB.y+offNP.y*1.5;\\nfloat subpixD=((-2.0)*subpixC)+3.0;\\nfloat lumaEndN=FxaaLuma(texture2D(textureSampler,posN,0.0));\\nfloat subpixE=subpixC*subpixC;\\nfloat lumaEndP=FxaaLuma(texture2D(textureSampler,posP,0.0));\\nif (!pairN) \\n{\\nlumaNN=lumaSS;\\n}\\nfloat gradientScaled=gradient*1.0/4.0;\\nfloat lumaMM=lumaM-lumaNN*0.5;\\nfloat subpixF=subpixD*subpixE;\\nbool lumaMLTZero=lumaMM<0.0;\\nlumaEndN-=lumaNN*0.5;\\nlumaEndP-=lumaNN*0.5;\\nbool doneN=abs(lumaEndN)>=gradientScaled;\\nbool doneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) \\n{\\nposN.x-=offNP.x*3.0;\\n}\\nif (!doneN) \\n{\\nposN.y-=offNP.y*3.0;\\n}\\nbool doneNP=(!doneN) || (!doneP);\\nif (!doneP) \\n{\\nposP.x+=offNP.x*3.0;\\n}\\nif (!doneP)\\n{\\nposP.y+=offNP.y*3.0;\\n}\\nif (doneNP)\\n{\\nif (!doneN) lumaEndN=FxaaLuma(texture2D(textureSampler,posN.xy,0.0));\\nif (!doneP) lumaEndP=FxaaLuma(texture2D(textureSampler,posP.xy,0.0));\\nif (!doneN) lumaEndN=lumaEndN-lumaNN*0.5;\\nif (!doneP) lumaEndP=lumaEndP-lumaNN*0.5;\\ndoneN=abs(lumaEndN)>=gradientScaled;\\ndoneP=abs(lumaEndP)>=gradientScaled;\\nif (!doneN) posN.x-=offNP.x*12.0;\\nif (!doneN) posN.y-=offNP.y*12.0;\\ndoneNP=(!doneN) || (!doneP);\\nif (!doneP) posP.x+=offNP.x*12.0;\\nif (!doneP) posP.y+=offNP.y*12.0;\\n}\\nfloat dstN=posM.x-posN.x;\\nfloat dstP=posP.x-posM.x;\\nif (!horzSpan)\\n{\\ndstN=posM.y-posN.y;\\n}\\nif (!horzSpan) \\n{\\ndstP=posP.y-posM.y;\\n}\\nbool goodSpanN=(lumaEndN<0.0) != lumaMLTZero;\\nfloat spanLength=(dstP+dstN);\\nbool goodSpanP=(lumaEndP<0.0) != lumaMLTZero;\\nfloat spanLengthRcp=1.0/spanLength;\\nbool directionN=dstN<dstP;\\nfloat dst=min(dstN,dstP);\\nbool goodSpan=directionN ? goodSpanN : goodSpanP;\\nfloat subpixG=subpixF*subpixF;\\nfloat pixelOffset=(dst*(-spanLengthRcp))+0.5;\\nfloat subpixH=subpixG*fxaaQualitySubpix;\\nfloat pixelOffsetGood=goodSpan ? pixelOffset : 0.0;\\nfloat pixelOffsetSubpix=max(pixelOffsetGood,subpixH);\\nif (!horzSpan)\\n{\\nposM.x+=pixelOffsetSubpix*lengthSign;\\n}\\nif (horzSpan)\\n{\\nposM.y+=pixelOffsetSubpix*lengthSign;\\n}\\ngl_FragColor=texture2D(textureSampler,posM,0.0);\\n}\",\"geometryVertexShader\":\"#version 300 es\\nprecision highp float;\\nprecision highp int;\\n#include<bones300Declaration>\\n#include<instances300Declaration>\\nin vec3 position;\\nin vec3 normal;\\n#if defined(ALPHATEST) || defined(NEED_UV)\\nout vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nin vec2 uv;\\n#endif\\n#ifdef UV2\\nin vec2 uv2;\\n#endif\\n#endif\\n\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\nout vec3 vNormalV;\\nout vec4 vViewPos;\\n#ifdef POSITION\\nout vec3 vPosition;\\n#endif\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\nvec4 pos=vec4(finalWorld*vec4(position,1.0));\\nvNormalV=normalize(vec3((view*finalWorld)*vec4(normal,0.0)));\\nvViewPos=view*pos;\\n#ifdef POSITION\\nvPosition=pos.xyz/pos.w;\\n#endif\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\"geometryPixelShader\":\"#version 300 es\\nprecision highp float;\\nprecision highp int;\\nin vec3 vNormalV;\\nin vec4 vViewPos;\\n#ifdef POSITION\\nin vec3 vPosition;\\n#endif\\n#ifdef ALPHATEST\\nin vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nlayout(location=0) out vec4 color0;\\nlayout(location=1) out vec4 color1;\\n#ifdef POSITION\\nlayout(location=2) out vec4 color2;\\n#endif\\nvoid main() {\\n#ifdef ALPHATEST\\nif (texture(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\ncolor0=vec4(vViewPos.z/vViewPos.w,0.0,0.0,1.0);\\ncolor1=vec4(normalize(vNormalV),1.0);\\n\\n#ifdef POSITION\\ncolor2=vec4(vPosition,1.0);\\n#endif\\n}\",\"refractionPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D refractionSampler;\\n\\nuniform vec3 baseColor;\\nuniform float depth;\\nuniform float colorLevel;\\nvoid main() {\\nfloat ref=1.0-texture2D(refractionSampler,vUV).r;\\nvec2 uv=vUV-vec2(0.5);\\nvec2 offset=uv*depth*ref;\\nvec3 sourceColor=texture2D(textureSampler,vUV-offset).rgb;\\ngl_FragColor=vec4(sourceColor+sourceColor*ref*colorLevel,1.0);\\n}\",\"blackAndWhitePixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform float degree;\\nvoid main(void) \\n{\\nvec3 color=texture2D(textureSampler,vUV).rgb;\\nfloat luminance=dot(color,vec3(0.3,0.59,0.11)); \\nvec3 blackAndWhite=vec3(luminance,luminance,luminance);\\ngl_FragColor=vec4(color-((color-blackAndWhite)*degree),1.0);\\n}\",\"convolutionPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 screenSize;\\nuniform float kernel[9];\\nvoid main(void)\\n{\\nvec2 onePixel=vec2(1.0,1.0)/screenSize;\\nvec4 colorSum =\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,-1))*kernel[0] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,-1))*kernel[1] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,-1))*kernel[2] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,0))*kernel[3] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,0))*kernel[4] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,0))*kernel[5] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(-1,1))*kernel[6] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(0,1))*kernel[7] +\\ntexture2D(textureSampler,vUV+onePixel*vec2(1,1))*kernel[8];\\nfloat kernelWeight =\\nkernel[0] +\\nkernel[1] +\\nkernel[2] +\\nkernel[3] +\\nkernel[4] +\\nkernel[5] +\\nkernel[6] +\\nkernel[7] +\\nkernel[8];\\nif (kernelWeight<=0.0) {\\nkernelWeight=1.0;\\n}\\ngl_FragColor=vec4((colorSum/kernelWeight).rgb,1);\\n}\",\"filterPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform mat4 kernelMatrix;\\nvoid main(void)\\n{\\nvec3 baseColor=texture2D(textureSampler,vUV).rgb;\\nvec3 updatedColor=(kernelMatrix*vec4(baseColor,1.0)).rgb;\\ngl_FragColor=vec4(updatedColor,1.0);\\n}\",\"volumetricLightScatteringPixelShader\":\"uniform sampler2D textureSampler;\\nuniform sampler2D lightScatteringSampler;\\nuniform float decay;\\nuniform float exposure;\\nuniform float weight;\\nuniform float density;\\nuniform vec2 meshPositionOnScreen;\\nvarying vec2 vUV;\\nvoid main(void) {\\nvec2 tc=vUV;\\nvec2 deltaTexCoord=(tc-meshPositionOnScreen.xy);\\ndeltaTexCoord*=1.0/float(NUM_SAMPLES)*density;\\nfloat illuminationDecay=1.0;\\nvec4 color=texture2D(lightScatteringSampler,tc)*0.4;\\nfor(int i=0; i<NUM_SAMPLES; i++) {\\ntc-=deltaTexCoord;\\nvec4 dataSample=texture2D(lightScatteringSampler,tc)*0.4;\\ndataSample*=illuminationDecay*weight;\\ncolor+=dataSample;\\nilluminationDecay*=decay;\\n}\\nvec4 realColor=texture2D(textureSampler,vUV);\\ngl_FragColor=((vec4((vec3(color.r,color.g,color.b)*exposure),1))+(realColor*(1.5-0.4)));\\n}\\n\",\"volumetricLightScatteringPassPixelShader\":\"#if defined(ALPHATEST) || defined(NEED_UV)\\nvarying vec2 vUV;\\n#endif\\n#if defined(ALPHATEST)\\nuniform sampler2D diffuseSampler;\\n#endif\\nvoid main(void)\\n{\\n#if defined(ALPHATEST)\\nvec4 diffuseColor=texture2D(diffuseSampler,vUV);\\nif (diffuseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=vec4(0.0,0.0,0.0,1.0);\\n}\\n\",\"colorCorrectionPixelShader\":\"\\nuniform sampler2D textureSampler; \\nuniform sampler2D colorTable; \\n\\nvarying vec2 vUV;\\n\\nconst float SLICE_COUNT=16.0; \\n\\nvec4 sampleAs3DTexture(sampler2D texture,vec3 uv,float width) {\\nfloat sliceSize=1.0/width; \\nfloat slicePixelSize=sliceSize/width; \\nfloat sliceInnerSize=slicePixelSize*(width-1.0); \\nfloat zSlice0=min(floor(uv.z*width),width-1.0);\\nfloat zSlice1=min(zSlice0+1.0,width-1.0);\\nfloat xOffset=slicePixelSize*0.5+uv.x*sliceInnerSize;\\nfloat s0=xOffset+(zSlice0*sliceSize);\\nfloat s1=xOffset+(zSlice1*sliceSize);\\nvec4 slice0Color=texture2D(texture,vec2(s0,uv.y));\\nvec4 slice1Color=texture2D(texture,vec2(s1,uv.y));\\nfloat zOffset=mod(uv.z*width,1.0);\\nvec4 result=mix(slice0Color,slice1Color,zOffset);\\nreturn result;\\n}\\nvoid main(void)\\n{\\nvec4 screen_color=texture2D(textureSampler,vUV);\\ngl_FragColor=sampleAs3DTexture(colorTable,screen_color.rgb,SLICE_COUNT);\\n}\",\"tonemapPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform float _ExposureAdjustment;\\n#if defined(HABLE_TONEMAPPING)\\nconst float A=0.15;\\nconst float B=0.50;\\nconst float C=0.10;\\nconst float D=0.20;\\nconst float E=0.02;\\nconst float F=0.30;\\nconst float W=11.2;\\n#endif\\nfloat Luminance(vec3 c)\\n{\\nreturn dot(c,vec3(0.22,0.707,0.071));\\n}\\nvoid main(void) \\n{\\nvec3 colour=texture2D(textureSampler,vUV).rgb;\\n#if defined(REINHARD_TONEMAPPING)\\nfloat lum=Luminance(colour.rgb); \\nfloat lumTm=lum*_ExposureAdjustment;\\nfloat scale=lumTm/(1.0+lumTm); \\ncolour*=scale/lum;\\n#elif defined(HABLE_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nconst float ExposureBias=2.0;\\nvec3 x=ExposureBias*colour;\\nvec3 curr=((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\\nx=vec3(W,W,W);\\nvec3 whiteScale=1.0/(((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F);\\ncolour=curr*whiteScale;\\n#elif defined(OPTIMIZED_HEJIDAWSON_TONEMAPPING)\\ncolour*=_ExposureAdjustment;\\nvec3 X=max(vec3(0.0,0.0,0.0),colour-0.004);\\nvec3 retColor=(X*(6.2*X+0.5))/(X*(6.2*X+1.7)+0.06);\\ncolour=retColor*retColor;\\n#elif defined(PHOTOGRAPHIC_TONEMAPPING)\\ncolour=vec3(1.0,1.0,1.0)-exp2(-_ExposureAdjustment*colour);\\n#endif\\ngl_FragColor=vec4(colour.rgb,1.0);\\n}\",\"displayPassPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D passSampler;\\nvoid main(void)\\n{\\ngl_FragColor=texture2D(passSampler,vUV);\\n}\",\"highlightsPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nconst vec3 RGBLuminanceCoefficients=vec3(0.2126,0.7152,0.0722);\\nvoid main(void) \\n{\\nvec4 tex=texture2D(textureSampler,vUV);\\nvec3 c=tex.rgb;\\nfloat luma=dot(c.rgb,RGBLuminanceCoefficients);\\n\\n\\ngl_FragColor=vec4(pow(c,vec3(25.0-luma*15.0)),tex.a); \\n}\",\"imageProcessingPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n#include<imageProcessingDeclaration>\\n#include<helperFunctions>\\n#include<imageProcessingFunctions>\\nvoid main(void)\\n{\\nvec4 result=texture2D(textureSampler,vUV);\\n#ifdef IMAGEPROCESSING\\n#ifndef FROMLINEARSPACE\\n\\nresult.rgb=toLinearSpace(result.rgb);\\n#endif\\nresult=applyImageProcessing(result);\\n#else\\n\\n#ifdef FROMLINEARSPACE\\nresult=applyImageProcessing(result);\\n#endif\\n#endif\\ngl_FragColor=result;\\n}\",\"kernelBlurVertexShader\":\"\\nattribute vec2 position;\\n\\nuniform vec2 delta;\\n\\nvarying vec2 sampleCenter;\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nsampleCenter=(position*madd+madd);\\n#include<kernelBlurVertex>[0..varyingCount]\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\"kernelBlurPixelShader\":\"\\nuniform sampler2D textureSampler;\\nuniform vec2 delta;\\n\\nvarying vec2 sampleCenter;\\n#include<kernelBlurVaryingDeclaration>[0..varyingCount]\\n#ifdef PACKEDFLOAT\\nvec4 pack(float depth)\\n{\\nconst vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);\\nconst vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);\\nvec4 res=fract(depth*bit_shift);\\nres-=res.xxyz*bit_mask;\\nreturn res;\\n}\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nvoid main(void)\\n{\\n#ifdef PACKEDFLOAT \\nfloat blend=0.;\\n#else\\nvec4 blend=vec4(0.);\\n#endif\\n#include<kernelBlurFragment>[0..varyingCount]\\n#include<kernelBlurFragment2>[0..depCount]\\n#ifdef PACKEDFLOAT\\ngl_FragColor=pack(blend);\\n#else\\ngl_FragColor=blend;\\n#endif\\n}\",\"lensFlareVertexShader\":\"\\nattribute vec2 position;\\n\\nuniform mat4 viewportMatrix;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvUV=position*madd+madd;\\ngl_Position=viewportMatrix*vec4(position,0.0,1.0);\\n}\",\"lensFlarePixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec4 color;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\ngl_FragColor=baseColor*color;\\n}\",\"anaglyphPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform sampler2D leftSampler;\\nvoid main(void)\\n{\\nvec4 leftFrag=texture2D(leftSampler,vUV);\\nleftFrag=vec4(1.0,leftFrag.g,leftFrag.b,1.0);\\nvec4 rightFrag=texture2D(textureSampler,vUV);\\nrightFrag=vec4(rightFrag.r,1.0,1.0,1.0);\\ngl_FragColor=vec4(rightFrag.rgb*leftFrag.rgb,1.0);\\n}\",\"stereoscopicInterlacePixelShader\":\"const vec3 TWO=vec3(2.0,2.0,2.0);\\nvarying vec2 vUV;\\nuniform sampler2D camASampler;\\nuniform sampler2D textureSampler;\\nuniform vec2 stepSize;\\nvoid main(void)\\n{\\nbool useCamB;\\nvec2 texCoord1;\\nvec2 texCoord2;\\nvec3 frag1;\\nvec3 frag2;\\n#ifdef IS_STEREOSCOPIC_HORIZ\\nuseCamB=vUV.x>0.5;\\ntexCoord1=vec2(useCamB ? (vUV.x-0.5)*2.0 : vUV.x*2.0,vUV.y);\\ntexCoord2=vec2(texCoord1.x+stepSize.x,vUV.y);\\n#else\\nuseCamB=vUV.y>0.5;\\ntexCoord1=vec2(vUV.x,useCamB ? (vUV.y-0.5)*2.0 : vUV.y*2.0);\\ntexCoord2=vec2(vUV.x,texCoord1.y+stepSize.y);\\n#endif\\n\\nif (useCamB){\\nfrag1=texture2D(textureSampler,texCoord1).rgb;\\nfrag2=texture2D(textureSampler,texCoord2).rgb;\\n}else{\\nfrag1=texture2D(camASampler ,texCoord1).rgb;\\nfrag2=texture2D(camASampler ,texCoord2).rgb;\\n}\\ngl_FragColor=vec4((frag1+frag2)/TWO,1.0);\\n}\",\"vrDistortionCorrectionPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\nuniform vec2 LensCenter;\\nuniform vec2 Scale;\\nuniform vec2 ScaleIn;\\nuniform vec4 HmdWarpParam;\\nvec2 HmdWarp(vec2 in01) {\\nvec2 theta=(in01-LensCenter)*ScaleIn; \\nfloat rSq=theta.x*theta.x+theta.y*theta.y;\\nvec2 rvector=theta*(HmdWarpParam.x+HmdWarpParam.y*rSq+HmdWarpParam.z*rSq*rSq+HmdWarpParam.w*rSq*rSq*rSq);\\nreturn LensCenter+Scale*rvector;\\n}\\nvoid main(void)\\n{\\nvec2 tc=HmdWarp(vUV);\\nif (tc.x <0.0 || tc.x>1.0 || tc.y<0.0 || tc.y>1.0)\\ngl_FragColor=vec4(0.0,0.0,0.0,0.0);\\nelse{\\ngl_FragColor=texture2D(textureSampler,tc);\\n}\\n}\",\"glowBlurPostProcessPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec2 screenSize;\\nuniform vec2 direction;\\nuniform float blurWidth;\\n\\nfloat getLuminance(vec3 color)\\n{\\nreturn dot(color,vec3(0.2126,0.7152,0.0722));\\n}\\nvoid main(void)\\n{\\nfloat weights[7];\\nweights[0]=0.05;\\nweights[1]=0.1;\\nweights[2]=0.2;\\nweights[3]=0.3;\\nweights[4]=0.2;\\nweights[5]=0.1;\\nweights[6]=0.05;\\nvec2 texelSize=vec2(1.0/screenSize.x,1.0/screenSize.y);\\nvec2 texelStep=texelSize*direction*blurWidth;\\nvec2 start=vUV-3.0*texelStep;\\nvec4 baseColor=vec4(0.,0.,0.,0.);\\nvec2 texelOffset=vec2(0.,0.);\\nfor (int i=0; i<7; i++)\\n{\\n\\nvec4 texel=texture2D(textureSampler,start+texelOffset);\\nbaseColor.a+=texel.a*weights[i];\\n\\nfloat luminance=getLuminance(baseColor.rgb);\\nfloat luminanceTexel=getLuminance(texel.rgb);\\nfloat choice=step(luminanceTexel,luminance);\\nbaseColor.rgb=choice*baseColor.rgb+(1.0-choice)*texel.rgb;\\ntexelOffset+=texelStep;\\n}\\ngl_FragColor=baseColor;\\n}\",\"glowMapGenerationPixelShader\":\"#ifdef ALPHATEST\\nvarying vec2 vUVDiffuse;\\nuniform sampler2D diffuseSampler;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform sampler2D emissiveSampler;\\n#endif\\nuniform vec4 color;\\nvoid main(void)\\n{\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUVDiffuse).a<0.4)\\ndiscard;\\n#endif\\n#ifdef EMISSIVE\\ngl_FragColor=texture2D(emissiveSampler,vUVEmissive);\\n#else\\ngl_FragColor=color;\\n#endif\\n}\",\"glowMapGenerationVertexShader\":\"\\nattribute vec3 position;\\n#include<bonesDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\nvarying vec4 vPosition;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#ifdef ALPHATEST\\nvarying vec2 vUVDiffuse;\\nuniform mat4 diffuseMatrix;\\n#endif\\n#ifdef EMISSIVE\\nvarying vec2 vUVEmissive;\\nuniform mat4 emissiveMatrix;\\n#endif\\nvoid main(void)\\n{\\n#include<instancesVertex>\\n#include<bonesVertex>\\n#ifdef CUBEMAP\\nvPosition=finalWorld*vec4(position,1.0);\\ngl_Position=viewProjection*finalWorld*vec4(position,1.0);\\n#else\\nvPosition=viewProjection*finalWorld*vec4(position,1.0);\\ngl_Position=vPosition;\\n#endif\\n#ifdef ALPHATEST\\n#ifdef DIFFUSEUV1\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef DIFFUSEUV2\\nvUVDiffuse=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n#ifdef EMISSIVE\\n#ifdef EMISSIVEUV1\\nvUVEmissive=vec2(emissiveMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef EMISSIVEUV2\\nvUVEmissive=vec2(emissiveMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\",\"glowMapMergePixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform float offset;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\nbaseColor.a=abs(offset-baseColor.a);\\ngl_FragColor=baseColor;\\n}\",\"glowMapMergeVertexShader\":\"\\nattribute vec2 position;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) {\\nvUV=position*madd+madd;\\ngl_Position=vec4(position,0.0,1.0);\\n}\",\"lineVertexShader\":\"\\nattribute vec3 position;\\nattribute vec4 normal;\\n\\nuniform mat4 worldViewProjection;\\nuniform float width;\\nuniform float aspectRatio;\\nvoid main(void) {\\nvec4 viewPosition=worldViewProjection*vec4(position,1.0);\\nvec4 viewPositionNext=worldViewProjection*vec4(normal.xyz,1.0);\\nvec2 currentScreen=viewPosition.xy/viewPosition.w;\\nvec2 nextScreen=viewPositionNext.xy/viewPositionNext.w;\\ncurrentScreen.x*=aspectRatio;\\nnextScreen.x*=aspectRatio;\\nvec2 dir=normalize(nextScreen-currentScreen);\\nvec2 normalDir=vec2(-dir.y,dir.x);\\nnormalDir*=width/2.0;\\nnormalDir.x/=aspectRatio;\\nvec4 offset=vec4(normalDir*normal.w,0.0,0.0);\\ngl_Position=viewPosition+offset;\\n}\",\"linePixelShader\":\"uniform vec4 color;\\nvoid main(void) {\\ngl_FragColor=color;\\n}\",\"outlineVertexShader\":\"\\nattribute vec3 position;\\nattribute vec3 normal;\\n#include<bonesDeclaration>\\n\\nuniform float offset;\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform mat4 diffuseMatrix;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n#endif\\nvoid main(void)\\n{\\nvec3 offsetPosition=position+normal*offset;\\n#include<instancesVertex>\\n#include<bonesVertex>\\ngl_Position=viewProjection*finalWorld*vec4(offsetPosition,1.0);\\n#ifdef ALPHATEST\\n#ifdef UV1\\nvUV=vec2(diffuseMatrix*vec4(uv,1.0,0.0));\\n#endif\\n#ifdef UV2\\nvUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));\\n#endif\\n#endif\\n}\\n\",\"outlinePixelShader\":\"uniform vec4 color;\\n#ifdef ALPHATEST\\nvarying vec2 vUV;\\nuniform sampler2D diffuseSampler;\\n#endif\\nvoid main(void) {\\n#ifdef ALPHATEST\\nif (texture2D(diffuseSampler,vUV).a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=color;\\n}\",\"layerVertexShader\":\"\\nattribute vec2 position;\\n\\nuniform vec2 scale;\\nuniform vec2 offset;\\nuniform mat4 textureMatrix;\\n\\nvarying vec2 vUV;\\nconst vec2 madd=vec2(0.5,0.5);\\nvoid main(void) { \\nvec2 shiftedPosition=position*scale+offset;\\nvUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));\\ngl_Position=vec4(shiftedPosition,0.0,1.0);\\n}\",\"layerPixelShader\":\"\\nvarying vec2 vUV;\\nuniform sampler2D textureSampler;\\n\\nuniform vec4 color;\\nvoid main(void) {\\nvec4 baseColor=texture2D(textureSampler,vUV);\\n#ifdef ALPHATEST\\nif (baseColor.a<0.4)\\ndiscard;\\n#endif\\ngl_FragColor=baseColor*color;\\n}\"};\nBABYLON.Effect.IncludesShadersStore={\"bonesDeclaration\":\"#if NUM_BONE_INFLUENCERS>0\\nuniform mat4 mBones[BonesPerMesh];\\nattribute vec4 matricesIndices;\\nattribute vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nattribute vec4 matricesIndicesExtra;\\nattribute vec4 matricesWeightsExtra;\\n#endif\\n#endif\",\"instancesDeclaration\":\"#ifdef INSTANCES\\nattribute vec4 world0;\\nattribute vec4 world1;\\nattribute vec4 world2;\\nattribute vec4 world3;\\n#else\\nuniform mat4 world;\\n#endif\",\"pointCloudVertexDeclaration\":\"#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\",\"bumpVertexDeclaration\":\"#if defined(BUMP) || defined(PARALLAX)\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n#endif\\n\",\"clipPlaneVertexDeclaration\":\"#ifdef CLIPPLANE\\nuniform vec4 vClipPlane;\\nvarying float fClipDistance;\\n#endif\",\"fogVertexDeclaration\":\"#ifdef FOG\\nvarying vec3 vFogDistance;\\n#endif\",\"morphTargetsVertexGlobalDeclaration\":\"#ifdef MORPHTARGETS\\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\\n#endif\",\"morphTargetsVertexDeclaration\":\"#ifdef MORPHTARGETS\\nattribute vec3 position{X};\\n#ifdef MORPHTARGETS_NORMAL\\nattribute vec3 normal{X};\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\nattribute vec3 tangent{X};\\n#endif\\n#endif\",\"logDepthDeclaration\":\"#ifdef LOGARITHMICDEPTH\\nuniform float logarithmicDepthConstant;\\nvarying float vFragmentDepth;\\n#endif\",\"morphTargetsVertex\":\"#ifdef MORPHTARGETS\\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\\n#ifdef MORPHTARGETS_NORMAL\\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\\n#endif\\n#ifdef MORPHTARGETS_TANGENT\\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\\n#endif\\n#endif\",\"instancesVertex\":\"#ifdef INSTANCES\\nmat4 finalWorld=mat4(world0,world1,world2,world3);\\n#else\\nmat4 finalWorld=world;\\n#endif\",\"bonesVertex\":\"#if NUM_BONE_INFLUENCERS>0\\nmat4 influence;\\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\\n#if NUM_BONE_INFLUENCERS>1\\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>2\\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>3\\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\\n#endif \\n#if NUM_BONE_INFLUENCERS>4\\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\\n#endif \\n#if NUM_BONE_INFLUENCERS>5\\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\\n#endif \\n#if NUM_BONE_INFLUENCERS>6\\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\\n#endif \\n#if NUM_BONE_INFLUENCERS>7\\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\\n#endif \\nfinalWorld=finalWorld*influence;\\n#endif\",\"bumpVertex\":\"#if defined(BUMP) || defined(PARALLAX)\\n#if defined(TANGENT) && defined(NORMAL)\\nvec3 normalW=normalize(vec3(finalWorld*vec4(normalUpdated,0.0)));\\nvec3 tangentW=normalize(vec3(finalWorld*vec4(tangentUpdated.xyz,0.0)));\\nvec3 bitangentW=cross(normalW,tangentW)*tangentUpdated.w;\\nvTBN=mat3(tangentW,bitangentW,normalW);\\n#endif\\n#endif\",\"clipPlaneVertex\":\"#ifdef CLIPPLANE\\nfClipDistance=dot(worldPos,vClipPlane);\\n#endif\",\"fogVertex\":\"#ifdef FOG\\nvFogDistance=(view*worldPos).xyz;\\n#endif\",\"shadowsVertex\":\"#ifdef SHADOWS\\n#if defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\\nvDepthMetric{X}=((vPositionFromLight{X}.z+light{X}.depthValues.x)/(light{X}.depthValues.y));\\n#endif\\n#endif\",\"pointCloudVertex\":\"#ifdef POINTSIZE\\ngl_PointSize=pointSize;\\n#endif\",\"logDepthVertex\":\"#ifdef LOGARITHMICDEPTH\\nvFragmentDepth=1.0+gl_Position.w;\\ngl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\\n#endif\",\"helperFunctions\":\"const float PI=3.1415926535897932384626433832795;\\nconst float LinearEncodePowerApprox=2.2;\\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\\nmat3 transposeMat3(mat3 inMatrix) {\\nvec3 i0=inMatrix[0];\\nvec3 i1=inMatrix[1];\\nvec3 i2=inMatrix[2];\\nmat3 outMatrix=mat3(\\nvec3(i0.x,i1.x,i2.x),\\nvec3(i0.y,i1.y,i2.y),\\nvec3(i0.z,i1.z,i2.z)\\n);\\nreturn outMatrix;\\n}\\nvec3 applyEaseInOut(vec3 x){\\nreturn x*x*(3.0-2.0*x);\\n}\\nvec3 toLinearSpace(vec3 color)\\n{\\nreturn pow(color,vec3(LinearEncodePowerApprox));\\n}\\nvec3 toGammaSpace(vec3 color)\\n{\\nreturn pow(color,vec3(GammaEncodePowerApprox));\\n}\\nfloat square(float value)\\n{\\nreturn value*value;\\n}\\nfloat getLuminance(vec3 color)\\n{\\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\\n}\",\"lightFragmentDeclaration\":\"#ifdef LIGHT{X}\\nuniform vec4 vLightData{X};\\nuniform vec4 vLightDiffuse{X};\\n#ifdef SPECULARTERM\\nuniform vec3 vLightSpecular{X};\\n#else\\nvec3 vLightSpecular{X}=vec3(0.);\\n#endif\\n#ifdef SHADOW{X}\\n#if defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\nuniform sampler2D shadowSampler{X};\\nuniform mat4 lightMatrix{X};\\n#endif\\nuniform vec3 shadowsInfo{X};\\nuniform vec2 depthValues{X};\\n#endif\\n#ifdef SPOTLIGHT{X}\\nuniform vec4 vLightDirection{X};\\n#endif\\n#ifdef HEMILIGHT{X}\\nuniform vec3 vLightGround{X};\\n#endif\\n#endif\",\"lightsFragmentFunctions\":\"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n#ifdef NDOTL\\nfloat ndl;\\n#endif\\n};\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 lightVectorW;\\nfloat attenuation=1.0;\\nif (lightData.w == 0.)\\n{\\nvec3 direction=lightData.xyz-vPositionW;\\nattenuation=max(0.,1.0-length(direction)/range);\\nlightVectorW=normalize(direction);\\n}\\nelse\\n{\\nlightVectorW=normalize(-lightData.xyz);\\n}\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {\\nlightingInfo result;\\nvec3 direction=lightData.xyz-vPositionW;\\nvec3 lightVectorW=normalize(direction);\\nfloat attenuation=max(0.,1.0-length(direction)/range);\\n\\nfloat cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));\\nif (cosAngle>=lightDirection.w)\\n{\\ncosAngle=max(0.,pow(cosAngle,lightData.w));\\nattenuation*=cosAngle;\\n\\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=ndl*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightVectorW);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor*attenuation;\\n#endif\\nreturn result;\\n}\\nresult.diffuse=vec3(0.);\\n#ifdef SPECULARTERM\\nresult.specular=vec3(0.);\\n#endif\\n#ifdef NDOTL\\nresult.ndl=0.;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {\\nlightingInfo result;\\n\\nfloat ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\\n#ifdef NDOTL\\nresult.ndl=ndl;\\n#endif\\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\\n#ifdef SPECULARTERM\\n\\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);\\nfloat specComp=max(0.,dot(vNormal,angleW));\\nspecComp=pow(specComp,max(1.,glossiness));\\nresult.specular=specComp*specularColor;\\n#endif\\nreturn result;\\n}\\n\",\"lightUboDeclaration\":\"#ifdef LIGHT{X}\\nuniform Light{X}\\n{\\nvec4 vLightData;\\nvec4 vLightDiffuse;\\nvec3 vLightSpecular;\\n#ifdef SPOTLIGHT{X}\\nvec4 vLightDirection;\\n#endif\\n#ifdef HEMILIGHT{X}\\nvec3 vLightGround;\\n#endif\\nvec3 shadowsInfo;\\nvec2 depthValues;\\n} light{X};\\n#ifdef SHADOW{X}\\n#if defined(SHADOWCUBE{X})\\nuniform samplerCube shadowSampler{X};\\n#else\\nvarying vec4 vPositionFromLight{X};\\nvarying float vDepthMetric{X};\\nuniform sampler2D shadowSampler{X};\\nuniform mat4 lightMatrix{X};\\n#endif\\n#endif\\n#endif\",\"defaultVertexDeclaration\":\"\\nuniform mat4 viewProjection;\\nuniform mat4 view;\\n#ifdef DIFFUSE\\nuniform mat4 diffuseMatrix;\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\nuniform mat4 specularMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\",\"defaultFragmentDeclaration\":\"uniform vec4 vDiffuseColor;\\n#ifdef SPECULARTERM\\nuniform vec4 vSpecularColor;\\n#endif\\nuniform vec3 vEmissiveColor;\\n\\n#ifdef DIFFUSE\\nuniform vec2 vDiffuseInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec2 vAmbientInfos;\\n#endif\\n#ifdef OPACITY \\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\n#endif\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\n#ifndef REFRACTIONMAP_3D\\nuniform mat4 refractionMatrix;\\n#endif\\n#ifdef REFRACTIONFRESNEL\\nuniform vec4 refractionLeftColor;\\nuniform vec4 refractionRightColor;\\n#endif\\n#endif\\n#if defined(SPECULAR) && defined(SPECULARTERM)\\nuniform vec2 vSpecularInfos;\\n#endif\\n#ifdef DIFFUSEFRESNEL\\nuniform vec4 diffuseLeftColor;\\nuniform vec4 diffuseRightColor;\\n#endif\\n#ifdef OPACITYFRESNEL\\nuniform vec4 opacityParts;\\n#endif\\n#ifdef EMISSIVEFRESNEL\\nuniform vec4 emissiveLeftColor;\\nuniform vec4 emissiveRightColor;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\n#ifdef REFLECTIONMAP_SKYBOX\\n#else\\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION)\\nuniform mat4 reflectionMatrix;\\n#endif\\n#endif\\n#ifdef REFLECTIONFRESNEL\\nuniform vec4 reflectionLeftColor;\\nuniform vec4 reflectionRightColor;\\n#endif\\n#endif\",\"defaultUboDeclaration\":\"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nvec4 diffuseLeftColor;\\nvec4 diffuseRightColor;\\nvec4 opacityParts;\\nvec4 reflectionLeftColor;\\nvec4 reflectionRightColor;\\nvec4 refractionLeftColor;\\nvec4 refractionRightColor;\\nvec4 emissiveLeftColor; \\nvec4 emissiveRightColor;\\nvec2 vDiffuseInfos;\\nvec2 vAmbientInfos;\\nvec2 vOpacityInfos;\\nvec2 vReflectionInfos;\\nvec2 vEmissiveInfos;\\nvec2 vLightmapInfos;\\nvec2 vSpecularInfos;\\nvec3 vBumpInfos;\\nmat4 diffuseMatrix;\\nmat4 ambientMatrix;\\nmat4 opacityMatrix;\\nmat4 reflectionMatrix;\\nmat4 emissiveMatrix;\\nmat4 lightmapMatrix;\\nmat4 specularMatrix;\\nmat4 bumpMatrix; \\nmat4 refractionMatrix;\\nvec4 vRefractionInfos;\\nvec4 vSpecularColor;\\nvec3 vEmissiveColor;\\nvec4 vDiffuseColor;\\nfloat pointSize; \\n};\\nuniform Scene {\\nmat4 viewProjection;\\nmat4 view;\\n};\",\"shadowsFragmentFunctions\":\"#ifdef SHADOWS\\n#ifndef SHADOWFLOAT\\nfloat unpack(vec4 color)\\n{\\nconst vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);\\nreturn dot(color,bit_shift);\\n}\\n#endif\\nfloat computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nif (depth>shadow)\\n{\\nreturn darkness;\\n}\\nreturn 1.0;\\n}\\nfloat computeShadowWithPCFCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\ndepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\nfloat visibility=1.;\\nvec3 poissonDisk[4];\\npoissonDisk[0]=vec3(-1.0,1.0,-1.0);\\npoissonDisk[1]=vec3(1.0,-1.0,-1.0);\\npoissonDisk[2]=vec3(-1.0,-1.0,-1.0);\\npoissonDisk[3]=vec3(1.0,-1.0,1.0);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;\\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\\n#else\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;\\nif (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\nfloat computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); \\nreturn esm;\\n}\\nfloat computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\\n{\\nvec3 directionToLight=vPositionW-lightPosition;\\nfloat depth=length(directionToLight);\\ndepth=(depth+depthValues.x)/(depthValues.y);\\nfloat shadowPixelDepth=clamp(depth,0.,1.0);\\ndirectionToLight=normalize(directionToLight);\\ndirectionToLight.y=-directionToLight.y;\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\\n#else\\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\nreturn esm;\\n}\\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nclipSpace=0.5*clipSpace+vec3(0.5);\\nvec2 uv=clipSpace.xy;\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadow=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadow=texture2D(shadowSampler,uv).x;\\n#endif\\nif (shadowPixelDepth>shadow)\\n{\\nreturn darkness;\\n}\\nreturn 1.;\\n}\\nfloat computeShadowWithPCF(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nclipSpace=0.5*clipSpace+vec3(0.5);\\nvec2 uv=clipSpace.xy;\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\nfloat visibility=1.;\\nvec2 poissonDisk[4];\\npoissonDisk[0]=vec2(-0.94201624,-0.39906216);\\npoissonDisk[1]=vec2(0.94558609,-0.76890725);\\npoissonDisk[2]=vec2(-0.094184101,-0.92938870);\\npoissonDisk[3]=vec2(0.34495938,0.29387760);\\n\\n#ifndef SHADOWFLOAT\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[0]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[1]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[2]*mapSize))<shadowPixelDepth) visibility-=0.25;\\nif (unpack(texture2D(shadowSampler,uv+poissonDisk[3]*mapSize))<shadowPixelDepth) visibility-=0.25;\\n#else\\nif (texture2D(shadowSampler,uv+poissonDisk[0]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[1]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[2]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\nif (texture2D(shadowSampler,uv+poissonDisk[3]*mapSize).x<shadowPixelDepth) visibility-=0.25;\\n#endif\\nreturn min(1.0,visibility+darkness);\\n}\\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nclipSpace=0.5*clipSpace+vec3(0.5);\\nvec2 uv=clipSpace.xy;\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0);\\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);\\n\\n\\n\\n\\n\\nreturn esm;\\n}\\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale)\\n{\\nvec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;\\nclipSpace=0.5*clipSpace+vec3(0.5);\\nvec2 uv=clipSpace.xy;\\nif (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\\n{\\nreturn 1.0;\\n}\\nfloat shadowPixelDepth=clamp(depthMetric,0.,1.0); \\n#ifndef SHADOWFLOAT\\nfloat shadowMapSample=unpack(texture2D(shadowSampler,uv));\\n#else\\nfloat shadowMapSample=texture2D(shadowSampler,uv).x;\\n#endif\\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);\\n\\n\\n\\n\\n\\nreturn esm;\\n}\\n#endif\\n\",\"fresnelFunction\":\"#ifdef FRESNEL\\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\\n{\\nfloat fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);\\nreturn clamp(fresnelTerm,0.,1.);\\n}\\n#endif\",\"reflectionFunction\":\"vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\\n{\\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\\nvec3 direction=normalize(vDirectionW);\\nfloat t=clamp(direction.y*-0.5+0.5,0.,1.0);\\nfloat s=atan(direction.z,direction.x)*RECIPROCAL_PI2+0.5;\\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\\nreturn vec3(1.0-s,t,0);\\n#else\\nreturn vec3(s,t,0);\\n#endif\\n#endif\\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\\nvec3 cameraToVertex=normalize(worldPos.xyz-vEyePosition);\\nvec3 r=reflect(cameraToVertex,worldNormal);\\nfloat t=clamp(r.y*-0.5+0.5,0.,1.0);\\nfloat s=atan(r.z,r.x)*RECIPROCAL_PI2+0.5;\\nreturn vec3(s,t,0);\\n#endif\\n#ifdef REFLECTIONMAP_SPHERICAL\\nvec3 viewDir=normalize(vec3(view*worldPos));\\nvec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));\\nvec3 r=reflect(viewDir,viewNormal);\\nr.z=r.z-1.0;\\nfloat m=2.0*length(r);\\nreturn vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);\\n#endif\\n#ifdef REFLECTIONMAP_PLANAR\\nvec3 viewDir=worldPos.xyz-vEyePosition;\\nvec3 coords=normalize(reflect(viewDir,worldNormal));\\nreturn vec3(reflectionMatrix*vec4(coords,1));\\n#endif\\n#ifdef REFLECTIONMAP_CUBIC\\nvec3 viewDir=worldPos.xyz-vEyePosition;\\nvec3 coords=reflect(viewDir,worldNormal);\\n#ifdef INVERTCUBICMAP\\ncoords.y=1.0-coords.y;\\n#endif\\nreturn vec3(reflectionMatrix*vec4(coords,0));\\n#endif\\n#ifdef REFLECTIONMAP_PROJECTION\\nreturn vec3(reflectionMatrix*(view*worldPos));\\n#endif\\n#ifdef REFLECTIONMAP_SKYBOX\\nreturn vPositionUVW;\\n#endif\\n#ifdef REFLECTIONMAP_EXPLICIT\\nreturn vec3(0,0,0);\\n#endif\\n}\",\"imageProcessingDeclaration\":\"#ifdef EXPOSURE\\nuniform float exposureLinear;\\n#endif\\n#ifdef CONTRAST\\nuniform float contrast;\\n#endif\\n#ifdef VIGNETTE\\nuniform vec2 vInverseScreenSize;\\nuniform vec4 vignetteSettings1;\\nuniform vec4 vignetteSettings2;\\n#endif\\n#ifdef COLORCURVES\\nuniform vec4 vCameraColorCurveNegative;\\nuniform vec4 vCameraColorCurveNeutral;\\nuniform vec4 vCameraColorCurvePositive;\\n#endif\\n#ifdef COLORGRADING\\nuniform sampler2D txColorTransform;\\nuniform vec4 colorTransformSettings;\\n#endif\",\"imageProcessingFunctions\":\"#ifdef COLORGRADING\\n\\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\\n{\\nfloat sliceSize=2.0*sampler3dSetting.x; \\n#ifdef SAMPLER3DGREENDEPTH\\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\\n#else\\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\\n#endif\\nfloat sliceInteger=floor(sliceContinuous);\\n\\n\\nfloat sliceFraction=sliceContinuous-sliceInteger;\\n#ifdef SAMPLER3DGREENDEPTH\\nvec2 sliceUV=color.rb;\\n#else\\nvec2 sliceUV=color.rg;\\n#endif\\nsliceUV.x*=sliceSize;\\nsliceUV.x+=sliceInteger*sliceSize;\\nsliceUV=clamp(sliceUV,0.,1.);\\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\\nsliceUV.x+=sliceSize;\\nsliceUV=clamp(sliceUV,0.,1.);\\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\\n#ifdef SAMPLER3DBGRMAP\\ncolor.rgb=result.rgb;\\n#else\\ncolor.rgb=result.bgr;\\n#endif\\nreturn color;\\n}\\n#endif\\nvec4 applyImageProcessing(vec4 result) {\\n#ifdef EXPOSURE\\nresult.rgb*=exposureLinear;\\n#endif\\n#ifdef VIGNETTE\\n\\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\\nviewportXY=viewportXY*2.0-1.0;\\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\\n\\nvec3 vignetteColor=vignetteSettings2.rgb;\\n#ifdef VIGNETTEBLENDMODEMULTIPLY\\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\\nresult.rgb*=vignetteColorMultiplier;\\n#endif\\n#ifdef VIGNETTEBLENDMODEOPAQUE\\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\\n#endif\\n#endif\\n#ifdef TONEMAPPING\\nconst float tonemappingCalibration=1.590579;\\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\\n#endif\\n\\nresult.rgb=toGammaSpace(result.rgb);\\nresult.rgb=clamp(result.rgb,0.0,1.0);\\n#ifdef CONTRAST\\n\\nvec3 resultHighContrast=applyEaseInOut(result.rgb);\\nif (contrast<1.0) {\\n\\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\\n} else {\\n\\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\\n}\\n#endif\\n\\n#ifdef COLORGRADING\\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\\n#endif\\n#ifdef COLORCURVES\\n\\nfloat luma=getLuminance(result.rgb);\\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\\nresult.rgb*=colorCurve.rgb;\\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\\n#endif\\nreturn result;\\n}\",\"bumpFragmentFunctions\":\"#ifdef BUMP\\n#if BUMPDIRECTUV == 1\\n#define vBumpUV vMainUV1\\n#elif BUMPDIRECTUV == 2\\n#define vBumpUV vMainUV2\\n#else\\nvarying vec2 vBumpUV;\\n#endif\\nuniform sampler2D bumpSampler;\\n#if defined(TANGENT) && defined(NORMAL) \\nvarying mat3 vTBN;\\n#endif\\n\\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv)\\n{\\n\\nuv=gl_FrontFacing ? uv : -uv;\\n\\nvec3 dp1=dFdx(p);\\nvec3 dp2=dFdy(p);\\nvec2 duv1=dFdx(uv);\\nvec2 duv2=dFdy(uv);\\n\\nvec3 dp2perp=cross(dp2,normal);\\nvec3 dp1perp=cross(normal,dp1);\\nvec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;\\nvec3 binormal=dp2perp*duv1.y+dp1perp*duv2.y;\\n#ifdef USERIGHTHANDEDSYSTEM\\nbinormal=-binormal;\\n#endif\\n\\nfloat invmax=inversesqrt(max(dot(tangent,tangent),dot(binormal,binormal)));\\nreturn mat3(tangent*invmax,binormal*invmax,normal);\\n}\\nvec3 perturbNormal(mat3 cotangentFrame,vec2 uv)\\n{\\nvec3 map=texture2D(bumpSampler,uv).xyz;\\n#ifdef INVERTNORMALMAPX\\nmap.x=1.0-map.x;\\n#endif\\n#ifdef INVERTNORMALMAPY\\nmap.y=1.0-map.y;\\n#endif\\nmap=map*255./127.-128./127.;\\nreturn normalize(cotangentFrame*map);\\n}\\n#ifdef PARALLAX\\nconst float minSamples=4.;\\nconst float maxSamples=15.;\\nconst int iMaxSamples=15;\\n\\nvec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {\\nfloat parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;\\nparallaxLimit*=parallaxScale;\\nvec2 vOffsetDir=normalize(vViewDirCoT.xy);\\nvec2 vMaxOffset=vOffsetDir*parallaxLimit;\\nfloat numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));\\nfloat stepSize=1.0/numSamples;\\n\\nfloat currRayHeight=1.0;\\nvec2 vCurrOffset=vec2(0,0);\\nvec2 vLastOffset=vec2(0,0);\\nfloat lastSampledHeight=1.0;\\nfloat currSampledHeight=1.0;\\nfor (int i=0; i<iMaxSamples; i++)\\n{\\ncurrSampledHeight=texture2D(bumpSampler,vBumpUV+vCurrOffset).w;\\n\\nif (currSampledHeight>currRayHeight)\\n{\\nfloat delta1=currSampledHeight-currRayHeight;\\nfloat delta2=(currRayHeight+stepSize)-lastSampledHeight;\\nfloat ratio=delta1/(delta1+delta2);\\nvCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;\\n\\nbreak;\\n}\\nelse\\n{\\ncurrRayHeight-=stepSize;\\nvLastOffset=vCurrOffset;\\nvCurrOffset+=stepSize*vMaxOffset;\\nlastSampledHeight=currSampledHeight;\\n}\\n}\\nreturn vCurrOffset;\\n}\\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\\n{\\n\\nfloat height=texture2D(bumpSampler,vBumpUV).w;\\nvec2 texCoordOffset=heightScale*viewDir.xy*height;\\nreturn -texCoordOffset;\\n}\\n#endif\\n#endif\",\"clipPlaneFragmentDeclaration\":\"#ifdef CLIPPLANE\\nvarying float fClipDistance;\\n#endif\",\"fogFragmentDeclaration\":\"#ifdef FOG\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying vec3 vFogDistance;\\nfloat CalcFogFactor()\\n{\\nfloat fogCoeff=1.0;\\nfloat fogStart=vFogInfos.y;\\nfloat fogEnd=vFogInfos.z;\\nfloat fogDensity=vFogInfos.w;\\nfloat fogDistance=length(vFogDistance);\\nif (FOGMODE_LINEAR == vFogInfos.x)\\n{\\nfogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);\\n}\\nelse if (FOGMODE_EXP == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDensity);\\n}\\nelse if (FOGMODE_EXP2 == vFogInfos.x)\\n{\\nfogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);\\n}\\nreturn clamp(fogCoeff,0.0,1.0);\\n}\\n#endif\",\"clipPlaneFragment\":\"#ifdef CLIPPLANE\\nif (fClipDistance>0.0)\\n{\\ndiscard;\\n}\\n#endif\",\"bumpFragment\":\"vec2 uvOffset=vec2(0.0,0.0);\\n#if defined(BUMP) || defined(PARALLAX)\\n#ifdef NORMALXYSCALE\\nnormalW=normalize(normalW*vec3(vBumpInfos.y,vBumpInfos.y,1.0));\\nfloat normalScale=1.0;\\n#else \\nfloat normalScale=vBumpInfos.y;\\n#endif\\n#if defined(TANGENT) && defined(NORMAL)\\nmat3 TBN=vTBN;\\n#else\\nmat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,vBumpUV);\\n#endif\\n#endif\\n#ifdef PARALLAX\\nmat3 invTBN=transposeMat3(TBN);\\n#ifdef PARALLAXOCCLUSION\\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\\n#else\\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\\n#endif\\n#endif\\n#ifdef BUMP\\nnormalW=perturbNormal(TBN,vBumpUV+uvOffset);\\n#endif\",\"lightFragment\":\"#ifdef LIGHT{X}\\n#if defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\\n\\n#else\\n#ifdef PBR\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,NdotL);\\n#endif\\n#ifdef HEMILIGHT{X}\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightGround,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,NdotL);\\n#endif\\n#if defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,roughness,NdotV,specularEnvironmentR0,specularEnvironmentR90,NdotL);\\n#endif\\n#else\\n#ifdef SPOTLIGHT{X}\\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#ifdef HEMILIGHT{X}\\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightGround,glossiness);\\n#endif\\n#if defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular,light{X}.vLightDiffuse.a,glossiness);\\n#endif\\n#endif\\n#endif\\n#ifdef SHADOW{X}\\n#ifdef SHADOWCLOSEESM{X}\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z);\\n#endif\\n#else\\n#ifdef SHADOWESM{X}\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z);\\n#endif\\n#else \\n#ifdef SHADOWPCF{X}\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowWithPCFCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadowWithPCF(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x);\\n#endif\\n#else\\n#if defined(SHADOWCUBE{X})\\nshadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\\n#else\\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x);\\n#endif\\n#endif\\n#endif\\n#endif\\n#else\\nshadow=1.;\\n#endif\\n#ifdef CUSTOMUSERLIGHTING\\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\\n#ifdef SPECULARTERM\\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\\n#endif\\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\\ndiffuseBase+=lightmapColor*shadow;\\n#ifdef SPECULARTERM\\n#ifndef LIGHTMAPNOSPECULAR{X}\\nspecularBase+=info.specular*shadow*lightmapColor;\\n#endif\\n#endif\\n#else\\ndiffuseBase+=info.diffuse*shadow;\\n#ifdef SPECULARTERM\\nspecularBase+=info.specular*shadow;\\n#endif\\n#endif\\n#endif\",\"logDepthFragment\":\"#ifdef LOGARITHMICDEPTH\\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\\n#endif\",\"fogFragment\":\"#ifdef FOG\\nfloat fog=CalcFogFactor();\\ncolor.rgb=fog*color.rgb+(1.0-fog)*vFogColor;\\n#endif\",\"pbrVertexDeclaration\":\"uniform mat4 view;\\nuniform mat4 viewProjection;\\n#ifdef ALBEDO\\nuniform mat4 albedoMatrix;\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform mat4 ambientMatrix;\\nuniform vec3 vAmbientInfos;\\n#endif\\n#ifdef OPACITY\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\nuniform mat4 emissiveMatrix;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\nuniform mat4 lightmapMatrix;\\n#endif\\n#ifdef REFLECTIVITY \\nuniform vec3 vReflectivityInfos;\\nuniform mat4 reflectivityMatrix;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\nuniform mat4 microSurfaceSamplerMatrix;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\nuniform mat4 bumpMatrix;\\n#endif\\n#ifdef POINTSIZE\\nuniform float pointSize;\\n#endif\\n\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#endif\\n\",\"pbrFragmentDeclaration\":\"uniform vec3 vReflectionColor;\\nuniform vec4 vAlbedoColor;\\n\\nuniform vec4 vLightingIntensity;\\nuniform vec4 vReflectivityColor;\\nuniform vec3 vEmissiveColor;\\n\\n#ifdef ALBEDO\\nuniform vec2 vAlbedoInfos;\\n#endif\\n#ifdef AMBIENT\\nuniform vec3 vAmbientInfos;\\n#endif\\n#ifdef BUMP\\nuniform vec3 vBumpInfos;\\n#endif\\n#ifdef OPACITY \\nuniform vec2 vOpacityInfos;\\n#endif\\n#ifdef EMISSIVE\\nuniform vec2 vEmissiveInfos;\\n#endif\\n#ifdef LIGHTMAP\\nuniform vec2 vLightmapInfos;\\n#endif\\n#ifdef REFLECTIVITY\\nuniform vec3 vReflectivityInfos;\\n#endif\\n#ifdef MICROSURFACEMAP\\nuniform vec2 vMicroSurfaceSamplerInfos;\\n#endif\\n\\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION)\\nuniform mat4 view;\\n#endif\\n\\n#ifdef REFRACTION\\nuniform vec4 vRefractionInfos;\\nuniform mat4 refractionMatrix;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\n#endif\\n\\n#ifdef REFLECTION\\nuniform vec2 vReflectionInfos;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\n#endif\",\"pbrUboDeclaration\":\"layout(std140,column_major) uniform;\\nuniform Material\\n{\\nuniform vec2 vAlbedoInfos;\\nuniform vec3 vAmbientInfos;\\nuniform vec2 vOpacityInfos;\\nuniform vec2 vEmissiveInfos;\\nuniform vec2 vLightmapInfos;\\nuniform vec3 vReflectivityInfos;\\nuniform vec2 vMicroSurfaceSamplerInfos;\\nuniform vec4 vRefractionInfos;\\nuniform vec2 vReflectionInfos;\\nuniform vec3 vBumpInfos;\\nuniform mat4 albedoMatrix;\\nuniform mat4 ambientMatrix;\\nuniform mat4 opacityMatrix;\\nuniform mat4 emissiveMatrix;\\nuniform mat4 lightmapMatrix;\\nuniform mat4 reflectivityMatrix;\\nuniform mat4 microSurfaceSamplerMatrix;\\nuniform mat4 bumpMatrix;\\nuniform mat4 refractionMatrix;\\nuniform mat4 reflectionMatrix;\\nuniform vec3 vReflectionColor;\\nuniform vec4 vAlbedoColor;\\nuniform vec4 vLightingIntensity;\\nuniform vec3 vRefractionMicrosurfaceInfos;\\nuniform vec3 vReflectionMicrosurfaceInfos;\\nuniform vec4 vReflectivityColor;\\nuniform vec3 vEmissiveColor;\\nuniform float pointSize;\\n};\\nuniform Scene {\\nmat4 viewProjection;\\nmat4 view;\\n};\",\"pbrFunctions\":\"\\n#define RECIPROCAL_PI2 0.15915494\\n#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\\n\\nconst float kRougnhessToAlphaScale=0.1;\\nconst float kRougnhessToAlphaOffset=0.29248125;\\nfloat convertRoughnessToAverageSlope(float roughness)\\n{\\n\\nconst float kMinimumVariance=0.0005;\\nfloat alphaG=square(roughness)+kMinimumVariance;\\nreturn alphaG;\\n}\\n\\nfloat smithVisibilityG1_TrowbridgeReitzGGX(float dot,float alphaG)\\n{\\nfloat tanSquared=(1.0-dot*dot)/(dot*dot);\\nreturn 2.0/(1.0+sqrt(1.0+alphaG*alphaG*tanSquared));\\n}\\nfloat smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL,float NdotV,float alphaG)\\n{\\nreturn smithVisibilityG1_TrowbridgeReitzGGX(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGX(NdotV,alphaG);\\n}\\n\\n\\nfloat normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)\\n{\\n\\n\\n\\nfloat a2=square(alphaG);\\nfloat d=NdotH*NdotH*(a2-1.0)+1.0;\\nreturn a2/(PI*d*d);\\n}\\nvec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)\\n{\\nreturn reflectance0+(reflectance90-reflectance0)*pow(clamp(1.0-VdotH,0.,1.),5.0);\\n}\\nvec3 fresnelSchlickEnvironmentGGX(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)\\n{\\n\\nfloat weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);\\nreturn reflectance0+weight*(reflectance90-reflectance0)*pow(clamp(1.0-VdotN,0.,1.),5.0);\\n}\\n\\nvec3 computeSpecularTerm(float NdotH,float NdotL,float NdotV,float VdotH,float roughness,vec3 reflectance0,vec3 reflectance90)\\n{\\nfloat alphaG=convertRoughnessToAverageSlope(roughness);\\nfloat distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);\\nfloat visibility=smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL,NdotV,alphaG);\\nvisibility/=(4.0*NdotL*NdotV); \\nfloat specTerm=max(0.,visibility*distribution)*NdotL;\\nvec3 fresnel=fresnelSchlickGGX(VdotH,reflectance0,reflectance90);\\nreturn fresnel*specTerm;\\n}\\nfloat computeDiffuseTerm(float NdotL,float NdotV,float VdotH,float roughness)\\n{\\n\\n\\nfloat diffuseFresnelNV=pow(clamp(1.0-NdotL,0.000001,1.),5.0);\\nfloat diffuseFresnelNL=pow(clamp(1.0-NdotV,0.000001,1.),5.0);\\nfloat diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;\\nfloat fresnel =\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *\\n(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);\\nreturn fresnel*NdotL/PI;\\n}\\nfloat adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance)\\n{\\n#ifdef USEPHYSICALLIGHTFALLOFF\\n\\nfloat lightRoughness=lightRadius/lightDistance;\\n\\nfloat totalRoughness=clamp(lightRoughness+roughness,0.,1.);\\nreturn totalRoughness;\\n#else\\nreturn roughness;\\n#endif\\n}\\nfloat computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)\\n{\\nconst float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;\\nfloat reflectivityLuminance=getLuminance(reflectivityColor);\\nfloat reflectivityLuma=sqrt(reflectivityLuminance);\\nmicroSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;\\nreturn microSurface;\\n}\\n\\n\\nfloat fresnelGrazingReflectance(float reflectance0) {\\nfloat reflectance90=clamp(reflectance0*25.0,0.0,1.0);\\nreturn reflectance90;\\n}\\n\\n\\n#define UNPACK_LOD(x) (1.0-x)*255.0\\nfloat getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {\\nfloat microsurfaceAverageSlope=alphaG;\\n\\n\\n\\n\\n\\n\\nmicrosurfaceAverageSlope*=sqrt(abs(NdotV));\\nfloat microsurfaceAverageSlopeTexels=microsurfaceAverageSlope*cubeMapDimensionPixels;\\nfloat lod=log2(microsurfaceAverageSlopeTexels);\\nreturn lod;\\n}\\nfloat environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {\\n\\n\\nfloat temp=NdotVUnclamped+ambientOcclusion;\\nreturn clamp(square(temp)-1.0+ambientOcclusion,0.0,1.0);\\n}\\nfloat environmentHorizonOcclusion(vec3 reflection,vec3 normal) {\\n\\nfloat temp=clamp( 1.0+1.1*dot(reflection,normal),0.0,1.0);\\nreturn square(temp);\\n}\",\"harmonicsFunctions\":\"#ifdef USESPHERICALFROMREFLECTIONMAP\\nuniform vec3 vSphericalX;\\nuniform vec3 vSphericalY;\\nuniform vec3 vSphericalZ;\\nuniform vec3 vSphericalXX_ZZ;\\nuniform vec3 vSphericalYY_ZZ;\\nuniform vec3 vSphericalZZ;\\nuniform vec3 vSphericalXY;\\nuniform vec3 vSphericalYZ;\\nuniform vec3 vSphericalZX;\\nvec3 quaternionVectorRotation_ScaledSqrtTwo(vec4 Q,vec3 V){\\nvec3 T=cross(Q.xyz,V);\\nT+=Q.www*V;\\nreturn cross(Q.xyz,T)+V;\\n}\\nvec3 environmentIrradianceJones(vec3 normal)\\n{\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfloat Nx=normal.x;\\nfloat Ny=normal.y;\\nfloat Nz=normal.z;\\nvec3 C1=vSphericalZZ.rgb;\\nvec3 Cx=vSphericalX.rgb;\\nvec3 Cy=vSphericalY.rgb;\\nvec3 Cz=vSphericalZ.rgb;\\nvec3 Cxx_zz=vSphericalXX_ZZ.rgb;\\nvec3 Cyy_zz=vSphericalYY_ZZ.rgb;\\nvec3 Cxy=vSphericalXY.rgb;\\nvec3 Cyz=vSphericalYZ.rgb;\\nvec3 Czx=vSphericalZX.rgb;\\nvec3 a1=Cyy_zz*Ny+Cy;\\nvec3 a2=Cyz*Nz+a1;\\nvec3 b1=Czx*Nz+Cx;\\nvec3 b2=Cxy*Ny+b1;\\nvec3 b3=Cxx_zz*Nx+b2;\\nvec3 t1=Cz*Nz+C1;\\nvec3 t2=a2*Ny+t1;\\nvec3 t3=b3*Nx+t2;\\nreturn t3;\\n}\\n#endif\",\"pbrLightFunctions\":\"\\nstruct lightingInfo\\n{\\nvec3 diffuse;\\n#ifdef SPECULARTERM\\nvec3 specular;\\n#endif\\n};\\nfloat computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range)\\n{ \\n#ifdef USEPHYSICALLIGHTFALLOFF\\nfloat lightDistanceFalloff=1.0/((lightDistanceSquared+0.001));\\n#else\\nfloat lightDistanceFalloff=max(0.,1.0-length(lightOffset)/range);\\n#endif\\nreturn lightDistanceFalloff;\\n}\\nfloat computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngle,float exponent)\\n{\\nfloat falloff=0.0;\\n#ifdef USEPHYSICALLIGHTFALLOFF\\nfloat cosHalfAngle=cos(lightAngle*0.5);\\nconst float kMinusLog2ConeAngleIntensityRatio=6.64385618977; \\n\\n\\n\\n\\n\\nfloat concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);\\n\\n\\nvec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);\\nfalloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));\\n#else\\nfloat cosAngle=max(0.000000000000001,dot(-lightDirection,directionToLightCenterW));\\nif (cosAngle>=lightAngle)\\n{\\nfalloff=max(0.,pow(cosAngle,exponent));\\n}\\n#endif\\nreturn falloff;\\n}\\nlightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float rangeRadius,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,out float NdotL) {\\nlightingInfo result;\\nvec3 lightDirection;\\nfloat attenuation=1.0;\\nfloat lightDistance;\\n\\nif (lightData.w == 0.)\\n{\\nvec3 lightOffset=lightData.xyz-vPositionW;\\nfloat lightDistanceSquared=dot(lightOffset,lightOffset);\\nattenuation=computeDistanceLightFalloff(lightOffset,lightDistanceSquared,rangeRadius);\\nlightDistance=sqrt(lightDistanceSquared);\\nlightDirection=normalize(lightOffset);\\n}\\n\\nelse\\n{\\nlightDistance=length(-lightData.xyz);\\nlightDirection=normalize(-lightData.xyz);\\n}\\n\\nroughness=adjustRoughnessFromLightProperties(roughness,rangeRadius,lightDistance);\\n\\nvec3 H=normalize(viewDirectionW+lightDirection);\\nNdotL=clamp(dot(vNormal,lightDirection),0.00000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\\nresult.diffuse=diffuseTerm*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90);\\nresult.specular=specTerm*diffuseColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float rangeRadius,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,out float NdotL) {\\nlightingInfo result;\\nvec3 lightOffset=lightData.xyz-vPositionW;\\nvec3 directionToLightCenterW=normalize(lightOffset);\\n\\nfloat lightDistanceSquared=dot(lightOffset,lightOffset);\\nfloat attenuation=computeDistanceLightFalloff(lightOffset,lightDistanceSquared,rangeRadius);\\n\\nfloat directionalAttenuation=computeDirectionalLightFalloff(lightDirection.xyz,directionToLightCenterW,lightDirection.w,lightData.w);\\nattenuation*=directionalAttenuation;\\n\\nfloat lightDistance=sqrt(lightDistanceSquared);\\nroughness=adjustRoughnessFromLightProperties(roughness,rangeRadius,lightDistance);\\n\\nvec3 H=normalize(viewDirectionW+directionToLightCenterW);\\nNdotL=clamp(dot(vNormal,directionToLightCenterW),0.000000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nfloat diffuseTerm=computeDiffuseTerm(NdotL,NdotV,VdotH,roughness);\\nresult.diffuse=diffuseTerm*diffuseColor*attenuation;\\n#ifdef SPECULARTERM\\n\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90);\\nresult.specular=specTerm*diffuseColor*attenuation;\\n#endif\\nreturn result;\\n}\\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float roughness,float NdotV,vec3 reflectance0,vec3 reflectance90,out float NdotL) {\\nlightingInfo result;\\n\\n\\n\\nNdotL=dot(vNormal,lightData.xyz)*0.5+0.5;\\nresult.diffuse=mix(groundColor,diffuseColor,NdotL);\\n#ifdef SPECULARTERM\\n\\nvec3 lightVectorW=normalize(lightData.xyz);\\nvec3 H=normalize(viewDirectionW+lightVectorW);\\nfloat NdotH=clamp(dot(vNormal,H),0.000000000001,1.0);\\nNdotL=clamp(NdotL,0.000000000001,1.0);\\nfloat VdotH=clamp(dot(viewDirectionW,H),0.0,1.0);\\nvec3 specTerm=computeSpecularTerm(NdotH,NdotL,NdotV,VdotH,roughness,reflectance0,reflectance90);\\nresult.specular=specTerm*diffuseColor;\\n#endif\\nreturn result;\\n}\",\"bones300Declaration\":\"#if NUM_BONE_INFLUENCERS>0\\nuniform mat4 mBones[BonesPerMesh];\\nin vec4 matricesIndices;\\nin vec4 matricesWeights;\\n#if NUM_BONE_INFLUENCERS>4\\nin vec4 matricesIndicesExtra;\\nin vec4 matricesWeightsExtra;\\n#endif\\n#endif\",\"instances300Declaration\":\"#ifdef INSTANCES\\nin vec4 world0;\\nin vec4 world1;\\nin vec4 world2;\\nin vec4 world3;\\n#else\\nuniform mat4 world;\\n#endif\",\"kernelBlurFragment\":\"#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCoord{X}))*KERNEL_WEIGHT{X};\\n#else\\nblend+=texture2D(textureSampler,sampleCoord{X})*KERNEL_WEIGHT{X};\\n#endif\",\"kernelBlurFragment2\":\"#ifdef PACKEDFLOAT\\nblend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*KERNEL_DEP_WEIGHT{X};\\n#else\\nblend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*KERNEL_DEP_WEIGHT{X};\\n#endif\",\"kernelBlurVaryingDeclaration\":\"varying vec2 sampleCoord{X};\",\"kernelBlurVertex\":\"sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};\"};\nif (((typeof window != \"undefined\" && window.module) || (typeof module != \"undefined\")) && typeof module.exports != \"undefined\") {\n    module.exports = BABYLON;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babylonjs/dist/preview release/babylon.max.js\n// module id = 0\n// module chunks = 0","(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tconst Building_1 = __webpack_require__(1);\n\texports.Building = Building_1.default;\n\t//import ExtendedMaze from './src/classes/Maze/ExtendedMaze';\n\tconst Grid3_1 = __webpack_require__(4);\n\texports.Grid3 = Grid3_1.default;\n\tconst Wall_1 = __webpack_require__(5);\n\texports.Wall = Wall_1.default;\n\tconst Vector2_1 = __webpack_require__(8);\n\texports.Vector2 = Vector2_1.default;\n\tconst Vector3_1 = __webpack_require__(3);\n\texports.Vector3 = Vector3_1.default;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tconst config_1 = __webpack_require__(2);\n\tconst Vector3_1 = __webpack_require__(3);\n\tconst Grid3_1 = __webpack_require__(4);\n\tconst Wall_1 = __webpack_require__(5);\n\tconst Brick_1 = __webpack_require__(6);\n\tconst fromFloorStrings_1 = __webpack_require__(7);\n\tclass Building extends Grid3_1.default {\n\t    constructor(grid, size, center) {\n\t        super(grid);\n\t        this.size = size;\n\t        this.center = center;\n\t    }\n\t    getWalls() {\n\t        let wallsMixed = [];\n\t        config_1.CHARS\n\t            .filter((charConfig) => charConfig.id !== 'NONE')\n\t            .forEach((charConfig) => {\n\t            const walls = [];\n\t            this.getBooleanGrid(charConfig.id).iterate((val, pos) => {\n\t                if (val) {\n\t                    walls.push(new Wall_1.default(pos, pos));\n\t                }\n\t            });\n\t            const joinedWalls = Wall_1.default.joinWalls(walls);\n\t            wallsMixed = wallsMixed.concat(joinedWalls);\n\t        });\n\t        return wallsMixed;\n\t    }\n\t    positionOnGrid(axis, gridCellPosition) {\n\t        let position = Math.floor(gridCellPosition / 2) * (this.size[axis][0] + this.size[axis][1]);\n\t        if (gridCellPosition % 2 === 1) {\n\t            position += this.size[axis][0];\n\t        }\n\t        if (axis === 'y') {\n\t            position = -position; //todo max position\n\t        }\n\t        return position;\n\t    }\n\t    getBricks() {\n\t        const center = new Vector3_1.default(\n\t        //todo maybe between\n\t        this.positionOnGrid('x', this.center.x), this.positionOnGrid('y', this.center.y), 0);\n\t        const bricks = [];\n\t        this.getWalls().forEach((wall) => {\n\t            bricks.push(new Brick_1.default(new Vector3_1.default(this.positionOnGrid('x', wall.from.x), this.positionOnGrid('y', wall.from.y), this.positionOnGrid('z', wall.from.z)).subtract(center), new Vector3_1.default(this.positionOnGrid('x', wall.to.x + 1), this.positionOnGrid('y', wall.to.y + 1), this.positionOnGrid('z', wall.to.z + 1)).subtract(center)));\n\t        });\n\t        return bricks;\n\t    }\n\t    toString() {\n\t        let output = '';\n\t        this.iterate((val, pos) => {\n\t            const charConfig = config_1.CHARS.find((charConfig) => charConfig.id === val) || config_1.CHARS[0];\n\t            //console.log(charConfig,y,x);\n\t            output += charConfig.chars[pos.x % 2];\n\t        }, () => {\n\t            output += '\\n';\n\t        }, () => {\n\t            output += '\\n\\n\\n';\n\t        });\n\t        return output;\n\t    }\n\t    //todo maybe better\n\t    static fromFloorStrings(buildingString) {\n\t        return fromFloorStrings_1.default(buildingString);\n\t    }\n\t}\n\texports.default = Building;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t//todo remove\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.CHARS = [\n\t    {\n\t        id: 'NONE',\n\t        chars: [' ', '   ', ':', ':::']\n\t    },\n\t    {\n\t        id: 'PILLAR',\n\t        chars: ['+']\n\t    },\n\t    {\n\t        id: 'VERTICAL',\n\t        chars: ['|']\n\t    },\n\t    {\n\t        id: 'HORIZONTAL',\n\t        chars: ['-', '---']\n\t    },\n\t    {\n\t        id: 'PLATE',\n\t        chars: ['#', '###']\n\t    }\n\t];\n\t/*export const CHARS = [\n\t    {\n\t        id: 'NONE',\n\t        chars: [\n\t            [[' '], ['   ']],\n\t            [[' '], ['   ']]\n\t        ]\n\t    },\n\t    {\n\t        id: 'PLATE',\n\t        chars: [\n\t            [[], []],\n\t            [[], [':::']]\n\t        ]\n\t    },\n\t    {\n\t        id: 'PILLAR',\n\t        chars: [\n\t            [['+'], []],\n\t            [[], []]\n\t        ]\n\t    },\n\t    {\n\t        id: 'VERTICAL',\n\t        chars: [\n\t            [['|'], []],\n\t            [['|'], []]\n\t        ]\n\t    },\n\t    {\n\t        id: 'HORIZONTAL',\n\t        chars: [\n\t            [['-'], ['---']],\n\t            [[], []]\n\t        ]\n\t    }\n\t];*/ \n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass Vector3 {\n\t    constructor(x, y, z) {\n\t        this.x = x;\n\t        this.y = y;\n\t        this.z = z;\n\t    }\n\t    add(vector3) {\n\t        return new Vector3(this.x + vector3.x, this.y + vector3.y, this.z + vector3.z);\n\t    }\n\t    subtract(vector3) {\n\t        return new Vector3(this.x - vector3.x, this.y - vector3.y, this.z - vector3.z);\n\t    }\n\t    scale(scale) {\n\t        return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n\t    }\n\t    toArray() {\n\t        return [this.x, this.y, this.z];\n\t    }\n\t}\n\texports.default = Vector3;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tconst Vector3_1 = __webpack_require__(3);\n\tclass Grid3 {\n\t    constructor(_grid) {\n\t        this._grid = _grid;\n\t    }\n\t    get array() {\n\t        return this._grid;\n\t    }\n\t    get length() {\n\t        return new Vector3_1.default(this.lengthX, this.lengthY, this.lengthZ);\n\t    }\n\t    get lengthY() {\n\t        return this._grid.length;\n\t    }\n\t    get lengthX() {\n\t        return this._grid[0].length; //todo better\n\t    }\n\t    get lengthZ() {\n\t        return this._grid[0][0].length; //todo better\n\t    }\n\t    setCell(position, value) {\n\t        this._grid[position.z] = this._grid[position.z] || [];\n\t        this._grid[position.z][position.y] = this._grid[position.z][position.y] || [];\n\t        this._grid[position.z][position.y][position.x] = value;\n\t    }\n\t    /*getCell(position: IVector3): T | undefined {\n\t        const grid2d = this._grid[position.z] || [];\n\t        const grid1d = grid2d[position.y] || [];\n\t        return grid1d[position.x];\n\t    }*/\n\t    iterate(callback, rowCallback, floorCallback) {\n\t        for (let z = 0; z < this._grid.length; z++) {\n\t            for (let y = 0; y < this._grid[z].length; y++) {\n\t                for (let x = 0; x < this._grid[z][y].length; x++) {\n\t                    callback(this._grid[z][y][x], new Vector3_1.default(x, y, z));\n\t                }\n\t                if (typeof rowCallback !== 'undefined')\n\t                    rowCallback(y);\n\t            }\n\t            if (typeof floorCallback !== 'undefined')\n\t                floorCallback(z);\n\t        }\n\t    }\n\t    getBooleanGrid(testValue) {\n\t        const booleanGrid = new Grid3([]);\n\t        this.iterate((val, pos) => {\n\t            booleanGrid.setCell(pos, val === testValue);\n\t        });\n\t        return booleanGrid;\n\t    }\n\t    toString() {\n\t        let output = '';\n\t        this.iterate((val, pos) => {\n\t            output += val ? '' : '  ';\n\t        }, () => {\n\t            output += '\\n';\n\t        }, () => {\n\t            output += '\\n\\n\\n';\n\t        });\n\t        return output;\n\t    }\n\t}\n\texports.default = Grid3;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tconst Vector3_1 = __webpack_require__(3);\n\t//todo name Wall vs Grid3Brick ?????????????\n\tclass Wall {\n\t    constructor(from, to) {\n\t        this.from = from;\n\t        this.to = to;\n\t    }\n\t    isJoinable(wall2) {\n\t        const wall1 = this;\n\t        return ([\n\t            {\n\t                axis1: 'x',\n\t                axis2: 'y',\n\t                axis3: 'z'\n\t            },\n\t            {\n\t                axis1: 'y',\n\t                axis2: 'z',\n\t                axis3: 'x'\n\t            },\n\t            {\n\t                axis1: 'z',\n\t                axis2: 'x',\n\t                axis3: 'y'\n\t            }\n\t        ].some(({ axis1, axis2, axis3 }) => (((wall1.from[axis1] === wall2.from[axis1] && wall1.to[axis1] === wall2.to[axis1])\n\t            &&\n\t                (wall1.from[axis2] === wall2.from[axis2] && wall1.to[axis2] === wall2.to[axis2])) &&\n\t            (wall1.to[axis3] + 1 === wall2.from[axis3] || wall2.to[axis3] + 1 === wall1.from[axis3]))));\n\t    }\n\t    /*joinWithInPlace(wall2: Wall): void {\n\t        const wall1 = this;\n\t        this.from = {\n\t            x: Math.min(wall1.from.x, wall2.from.x),\n\t            y: Math.min(wall1.from.y, wall2.from.y),\n\t            z: Math.min(wall1.from.z, wall2.from.z),\n\t        };\n\t        this.to = {\n\t            x: Math.max(wall1.to.x, wall2.to.x),\n\t            y: Math.max(wall1.to.y, wall2.to.y),\n\t            z: Math.max(wall1.to.z, wall2.to.z),\n\t        };\n\t    }*/\n\t    joinWith(wall2) {\n\t        const wall1 = this;\n\t        return new Wall(new Vector3_1.default(Math.min(wall1.from.x, wall2.from.x), Math.min(wall1.from.y, wall2.from.y), Math.min(wall1.from.z, wall2.from.z)), new Vector3_1.default(Math.max(wall1.to.x, wall2.to.x), Math.max(wall1.to.y, wall2.to.y), Math.max(wall1.to.z, wall2.to.z)));\n\t    }\n\t    static joinWalls(originalWalls) {\n\t        function joinWallToWalls(oldWalls, newWall) {\n\t            let joinedWall = newWall;\n\t            const newWalls = [];\n\t            for (const oldWall of oldWalls) {\n\t                if (joinedWall.isJoinable(oldWall)) {\n\t                    joinedWall = newWall.joinWith(oldWall);\n\t                }\n\t                else {\n\t                    newWalls.push(oldWall);\n\t                }\n\t            }\n\t            if (joinedWall !== newWall) {\n\t                return joinWallToWalls(newWalls, joinedWall);\n\t            }\n\t            else {\n\t                newWalls.push(newWall);\n\t                return newWalls;\n\t            }\n\t        }\n\t        let newWalls = [];\n\t        for (const wall of originalWalls) {\n\t            newWalls = joinWallToWalls(newWalls, wall);\n\t        }\n\t        return newWalls;\n\t    }\n\t}\n\texports.default = Wall;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass Brick {\n\t    constructor(from, to) {\n\t        this.from = from;\n\t        this.to = to;\n\t    }\n\t    get size() {\n\t        return this.to.subtract(this.from);\n\t    }\n\t    get center() {\n\t        return this.from.add(this.to).scale(.5);\n\t    }\n\t}\n\texports.default = Brick;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tconst Vector2_1 = __webpack_require__(8);\n\tconst index_1 = __webpack_require__(1);\n\tconst config_1 = __webpack_require__(2);\n\tfunction createPlateString(floorString) {\n\t    let deskString = '';\n\t    for (let i = 0; i < floorString.length; i++) {\n\t        if (floorString[i] === ' ') {\n\t            deskString += floorString[i];\n\t        }\n\t        else if (floorString[i] === '\\n') {\n\t            deskString += floorString[i];\n\t        }\n\t        else {\n\t            deskString += '#';\n\t        }\n\t    }\n\t    return deskString;\n\t}\n\tfunction fromFroorString(floorString) {\n\t    floorString = floorString.trim();\n\t    const array = [];\n\t    let y = 0;\n\t    for (let rowString of floorString.split('\\n')) {\n\t        array[y] = [];\n\t        let x = 0;\n\t        for (let i = 0; i < rowString.length; i += x % 2 === 0 ? 3 : 1) {\n\t            const substring = rowString.substring(i, i + (x % 2 === 0 ? 1 : 3));\n\t            const charConfig = config_1.CHARS.find((charConfig) => charConfig.chars.indexOf(substring) !== -1);\n\t            if (typeof charConfig === 'undefined') {\n\t                throw new Error(`String \"${substring}\" has no meaning in building ASCII config.\"`);\n\t            }\n\t            else {\n\t                array[y][x] = charConfig.id;\n\t            }\n\t            x++;\n\t        }\n\t        y++;\n\t    }\n\t    return array;\n\t}\n\tfunction default_1(buildingString) {\n\t    const grid = [];\n\t    buildingString.forEach((floorString, i) => {\n\t        const plate = fromFroorString(createPlateString(floorString));\n\t        //if(i===0)grid.push(plate);\n\t        grid.push(fromFroorString(floorString));\n\t        grid.push(plate);\n\t    });\n\t    return new index_1.default(grid, {\n\t        x: [3, 10],\n\t        y: [3, 10],\n\t        z: [10, 0.5],\n\t    }, new Vector2_1.default(5, 5));\n\t}\n\texports.default = default_1;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\tclass Vector2 {\n\t    constructor(x, y) {\n\t        this.x = x;\n\t        this.y = y;\n\t    }\n\t    static Zero() {\n\t        return new Vector2(0, 0);\n\t    }\n\t    add(vector3) {\n\t        return new Vector2(this.x + vector3.x, this.y + vector3.y);\n\t    }\n\t    subtract(vector3) {\n\t        return new Vector2(this.x - vector3.x, this.y - vector3.y);\n\t    }\n\t    scale(scale) {\n\t        return new Vector2(this.x * scale, this.y * scale);\n\t    }\n\t    length(vector2 = Vector2.Zero()) {\n\t        return Math.sqrt(Math.pow(this.x - vector2.x, 2) +\n\t            Math.pow(this.y - vector2.y, 2));\n\t    }\n\t    toArray() {\n\t        return [this.x, this.y];\n\t    }\n\t}\n\texports.default = Vector2;\n\n\n/***/ }\n/******/ ])));\n//# sourceMappingURL=gridbuilding.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/gridbuilding/dist/gridbuilding.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/core.js\n// module id = 2\n// module chunks = 0","import * as BABYLON from 'babylonjs';\nimport World from './World';\n\n\nexport default class Brick{\n    public mesh:BABYLON.AbstractMesh;\n\n    constructor(\n        private _world:World,\n        private _materialName:string,\n        private _physicalProperties:{mass:number,restitution:number},\n        private _size:BABYLON.Vector3,\n        private _position:BABYLON.Vector3,\n        private _rotation:BABYLON.Vector3 = BABYLON.Vector3.Zero(),\n        private _linearVelocity:BABYLON.Vector3 = BABYLON.Vector3.Zero(),\n        private _angularVelocity:BABYLON.Vector3 = BABYLON.Vector3.Zero(),\n\n    ){\n        this.createBabylonMesh();\n        this._world.bricks.push(this);\n        this.mesh.position = this._position;\n        this.mesh.rotation = this._rotation;\n        this.mesh.physicsImpostor.setLinearVelocity(this._linearVelocity);\n        this.mesh.physicsImpostor.setAngularVelocity(this._angularVelocity);\n    }\n\n\n    get position():BABYLON.Vector3{\n        return this._position;\n    }\n\n    get rotation():BABYLON.Vector3{\n        return this.mesh.rotationQuaternion.toEulerAngles();\n    }\n\n    get linearVelocity():BABYLON.Vector3{\n        return this.mesh.physicsImpostor.getLinearVelocity();\n    }\n\n    get angularVelocity():BABYLON.Vector3{\n        return this.mesh.physicsImpostor.getAngularVelocity();\n    }\n\n    set linearVelocity(linearVelocity:BABYLON.Vector3){\n        this.mesh.physicsImpostor.setLinearVelocity(linearVelocity);\n    }\n\n    set angularVelocity(angularVelocity:BABYLON.Vector3){\n        this.mesh.physicsImpostor.setAngularVelocity(angularVelocity);\n    }\n\n    createBabylonMesh(){\n        const globalScale = 10;\n        const width = this._size.x;\n        const height = this._size.y;\n        const depth = this._size.z;\n        const faceUV = [\n            new BABYLON.Vector4(0, 0, width / globalScale, height / globalScale),\n            new BABYLON.Vector4(0, 0, width / globalScale, height / globalScale),\n\n            new BABYLON.Vector4(0, 0, height / globalScale, depth / globalScale),\n            new BABYLON.Vector4(0, 0, height / globalScale, depth / globalScale),\n\n            new BABYLON.Vector4(0, 0, depth / globalScale, width / globalScale),\n            new BABYLON.Vector4(0, 0, depth / globalScale, width / globalScale),\n        ];\n        const meshOptions = {width, height, depth, faceUV};\n        this.mesh = BABYLON.MeshBuilder.CreateBox('BoxBrick', meshOptions, this._world.scene);\n\n        this.mesh.material = this._world.materialFactory.getMaterial(this._materialName);\n        this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(\n            this.mesh,\n            BABYLON.PhysicsImpostor.BoxImpostor,\n            this._physicalProperties,\n            this._world.scene\n        );\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/Brick.ts","// @remove-on-eject-begin\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n// @remove-on-eject-end\n'use strict';\n\nif (typeof Promise === 'undefined') {\n  // Rejection tracking prevents a common issue where React gets into an\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\n  // and the user has no idea what causes React's erratic future behavior.\n  require('promise/lib/rejection-tracking').enable();\n  window.Promise = require('promise/lib/es6-extensions.js');\n}\n\n// fetch() polyfill for making API calls.\nrequire('whatwg-fetch');\n\n// Object.assign() is commonly used with React.\n// It will use the native implementation if it's present and isn't buggy.\nObject.assign = require('object-assign');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/react-scripts-ts/config/polyfills.js\n// module id = 4\n// module chunks = 0","import World from './world/World';\nimport './index.css';\n\nconst canvasElement = document.getElementById(\"scene\") as HTMLCanvasElement;\n\nconst world = new World(canvasElement);\nworld.run();\nconsole.log(world);\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/index.tsx","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` or `self` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\n/* globals self */\nvar scope = typeof global !== \"undefined\" ? global : self;\nvar BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/asap/browser-raw.js\n// module id = 6\n// module chunks = 0","// removed by extract-text-webpack-plugin\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.css\n// module id = 7\n// module chunks = 0","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/object-assign/index.js\n// module id = 8\n// module chunks = 0","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/es6-extensions.js\n// module id = 9\n// module chunks = 0","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/promise/lib/rejection-tracking.js\n// module id = 10\n// module chunks = 0","export const KEYMAP = {\n    'FORWARD': [38, 87],\n    'BACKWARD': [40, 83],\n    'LEFT': [37, 65],\n    'RIGHT': [39, 68],\n    'JUMP': [32],\n};\n\nexport const PLAYER = {\n  SPEED: {\n      TERMINAL:35,\n      FORWARD:15,\n      BACKWARD:5,\n      SIDE:5,\n      FLY:2,\n      JUMP:25\n  }\n};\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/config.ts","import * as BABYLON from 'babylonjs';\nimport * as GridBuilding from 'gridbuilding';\nimport World from '../world/World';\nimport Brick from '../world/Brick';\n\nexport default class WorldGenerator{\n    constructor(\n        private world:World\n    ){}\n\n    generateWorld() {\n\n\n\n        const center = new BABYLON.Vector3(\n            0,\n            0,\n            50\n        );\n\n        const FLOOR = `       \n+:::+:::+\n:::::::::\n+:::+:::+\n::::::::|\n+:::+---+\n`;\n\n        const building = GridBuilding.Building.fromFloorStrings([\n            FLOOR,\n            FLOOR,\n            FLOOR,\n            FLOOR,\n            FLOOR,\n            FLOOR,\n            FLOOR\n        ]);\n\n        building.getBricks().forEach((brick) => {\n\n            new Brick(\n                this.world,\n                'stone-plain',\n                {mass:200, restitution: 0.01},\n                new BABYLON.Vector3(brick.size.x, brick.size.z, brick.size.y),\n                new BABYLON.Vector3(brick.center.x, brick.center.z, brick.center.y).add(center)\n            );\n        });\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/generator/index.ts","import * as BABYLON from 'babylonjs';\n\nexport default class MaterialFactory{\n\n    private _materialsCache:BABYLON.StandardMaterial[];\n\n    constructor(\n        private _scene:BABYLON.Scene\n    ){\n        this._materialsCache = [];\n    }\n\n    getMaterial(\n        materialName:string\n    ){\n\n        const cashedMaterial = this._materialsCache.find((material)=>material.name === materialName)||null;\n\n        if(cashedMaterial){\n            return cashedMaterial;\n        }else {\n\n            let textureScale=1;\n            if(materialName==='grass'){\n                textureScale=100;\n            }\n\n            const material = new BABYLON.StandardMaterial(materialName, this._scene);\n            material.backFaceCulling = false;\n            const texture = new BABYLON.Texture(process.env.PUBLIC_URL +`/assets/textures/${materialName}.jpg`, this._scene);\n            texture.uScale = textureScale;\n            texture.vScale = textureScale;\n            material.diffuseTexture = texture;\n            material.specularColor = BABYLON.Color3.FromHexString('#ffeacb');\n            material.emissiveTexture = texture;\n            this._materialsCache.push(material);\n            return material;\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/MaterialFactory.ts","import * as BABYLON from 'babylonjs';\n\nexport default function createCamera(scene:BABYLON.Scene):BABYLON.FreeCamera{\n    const camera = new BABYLON.FreeCamera(\"FreeCamera\", BABYLON.Vector3.Zero(),  scene);\n    camera.fov = 1.2;\n    return camera;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/Player/createCamera.ts","import * as BABYLON from 'babylonjs';\nimport World from '../World';\nimport createCamera from './createCamera';\n//import setPlayerMouseLock from './setPlayerMouseLock';\n//import setPlayerMovement from './setPlayerMovement';\nimport setPlayerAction from './setPlayerAction';\nimport {PLAYER} from '../../config';\n\nexport default class Player {\n\n    public mesh: BABYLON.AbstractMesh;\n    public camera: BABYLON.FreeCamera;\n\n    constructor(public world: World) {\n\n        this.camera = createCamera(world.scene);\n        this.mesh = BABYLON.Mesh.CreateSphere(\"player\", 16, 1, world.scene);\n        this.mesh.isVisible = false;\n        this.mesh.position = new BABYLON.Vector3(0, 2, 0);\n        this.mesh.rotation = new BABYLON.Vector3(0, 0, 0);\n        this.mesh.scaling = new BABYLON.Vector3(1, 4, 1);\n        this.mesh.physicsImpostor = new BABYLON.PhysicsImpostor(\n            this.mesh,\n            BABYLON.PhysicsImpostor.SphereImpostor,\n            {\n                mass: 1,\n                restitution: 0.01,\n                friction: 100\n            },\n            world.scene\n        );\n\n\n        this.mesh.physicsImpostor.registerAfterPhysicsStep(() => {\n            this.camera.position = this.mesh.position;\n            this.mesh.physicsImpostor.setAngularVelocity(BABYLON.Vector3.Zero());\n        });\n\n\n        //setPlayerMouseLock(this.world.canvasElement, this.camera);\n        //setPlayerMovement(this);\n        setPlayerAction(this);\n    }\n\n    get direction(): BABYLON.Vector3 {\n        const point1 = this.mesh.position;\n        const point2 = this.world.scene.pick(this.world.canvasElement.width / 2, this.world.canvasElement.height / 2, (mesh) => mesh === this.world.skyboxMesh).pickedPoint;\n\n        return point2.subtract(point1);\n    }\n\n    get direction1(): BABYLON.Vector3 {\n        const playerDirection = this.direction;\n        return playerDirection.scale(1 / playerDirection.length());\n    }\n\n    get rotationY(): number {\n        const playerDirection = this.direction;\n        return Math.atan2(playerDirection.z, playerDirection.x);\n    }\n\n    addMovement(vector: BABYLON.Vector3) {\n\n        const currentVelocity = this.mesh.physicsImpostor.getLinearVelocity();\n        const onGround = true;\n\n        const distance = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.z, 2));\n        const rotation = Math.atan2(vector.z, vector.x) + this.rotationY;\n\n\n        const rotatedVector = new BABYLON.Vector3(\n            Math.cos(rotation) * distance,\n            onGround ? vector.y : 0,\n            Math.sin(rotation) * distance\n        );\n\n        const composedVelocity = currentVelocity.add(rotatedVector);\n        const jumpVelocity = new BABYLON.Vector3(0, composedVelocity.y, 0);\n        const surfaceVelocity = new BABYLON.Vector3(composedVelocity.x, 0, composedVelocity.z);\n\n        const surfaceVelocityLength = surfaceVelocity.length();\n        if (surfaceVelocityLength > PLAYER.SPEED.TERMINAL) {\n            surfaceVelocity.scaleInPlace(PLAYER.SPEED.TERMINAL / surfaceVelocityLength);\n        }\n\n        const composedVelocityTerminated = surfaceVelocity.add(jumpVelocity);\n\n        this.mesh.physicsImpostor.setLinearVelocity(composedVelocityTerminated);\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/Player/index.ts","import * as BABYLON from 'babylonjs';\nimport {Vector2} from 'gridbuilding';\nimport Player from './index';\nimport Brick from '../../world/Brick';\n\n\nfunction groupArray<T>(array: T[], inGroup: number): T[][] {\n\n    //todo test inGroup\n\n    const l = array.length - inGroup + 1;\n    //if(l<1)return [];\n\n    const result = []\n    for (let i = 0; i < l; i++) {\n        const group = []\n        for (let j = 0; j < inGroup; j++) {\n            group.push(array[i + j]);\n        }\n        result.push(group);\n    }\n\n    return result;\n\n}\n\n\nexport default function setPlayerAction(player: Player) {\n\n\n    let pointerDown: boolean = false;\n    let path: Vector2[];\n\n\n    player.world.canvasElement.addEventListener(\n        \"pointerdown\",\n        (event) => {\n\n            pointerDown = true;\n            path = [];\n            //todo duplicite\n            path.push(new Vector2(\n                event.clientX / document.documentElement.clientWidth,\n                event.clientY / document.documentElement.clientHeight\n            ));\n\n\n        });\n\n\n    player.world.canvasElement.addEventListener(\n        \"pointermove\",\n        (event) => {\n            if (pointerDown) {\n                path.push(new Vector2(\n                    event.clientX / document.documentElement.clientWidth,\n                    event.clientY / document.documentElement.clientHeight\n                ));\n            }\n        });\n\n\n    player.world.canvasElement.addEventListener(\n        \"pointerup\",\n        (event) => {\n\n\n            //const x = (event.clientX / document.documentElement.clientWidth)-.5;\n            //const y = (event.clientY / document.documentElement.clientHeight)-.5;\n\n\n            const length = groupArray(path, 2).reduce((sum, currentValue) => sum + currentValue[0].length(currentValue[1]), 0);\n            const delta = path[path.length - 1].subtract(path[0]);\n\n            //console.log(length);\n\n\n            new Brick(\n                player.world,\n                'clay-bricks',\n                {mass: 5000, restitution: 0.5},\n                new BABYLON.Vector3(2, 2, 2),\n                player.mesh.position.add(player.direction1),\n                BABYLON.Vector3.Zero(),\n                player.direction1.scale(length*100).add(new BABYLON.Vector3(\n                    100 * delta.x,\n                    100 * -delta.y,\n                    0\n                )),\n                new BABYLON.Vector3(\n                    (Math.random() - .5) * Math.PI * 10,\n                    (Math.random() - .5) * Math.PI * 10,\n                    (Math.random() - .5) * Math.PI * 10\n                )\n            );\n\n\n        });\n\n\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/Player/setPlayerAction.ts","import * as BABYLON from 'babylonjs';\nimport MaterialFactory from '../MaterialFactory';\n\nexport default function createGroundMesh(\n    scene:BABYLON.Scene,\n    materialFactory:MaterialFactory\n):BABYLON.AbstractMesh{\n\n    const groundMesh = BABYLON.Mesh.CreateGround(\"ground\", 1000, 1000, 2, scene);\n    groundMesh.material = materialFactory.getMaterial('grass');\n    groundMesh.physicsImpostor = new BABYLON.PhysicsImpostor(\n        groundMesh,\n        BABYLON.PhysicsImpostor.BoxImpostor,\n        { mass: 0, restitution: 0.1},\n        scene\n    );\n    return groundMesh;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/World/createGround.ts","import * as BABYLON from 'babylonjs';\n\nexport default function createLights(scene:BABYLON.Scene):BABYLON.Light[]{\n    const light1 = new BABYLON.DirectionalLight(\"dir01\", new BABYLON.Vector3(1, -2, 1), scene);\n    light1.position = new BABYLON.Vector3(20, 3, 20);\n    light1.intensity = 0.7;\n    return [light1]\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/World/createLights.ts","import * as BABYLON from 'babylonjs';\n\nexport default function createScene(engine:BABYLON.Engine):BABYLON.Scene{\n    const scene = new BABYLON.Scene(engine);\n    scene.clearColor = new BABYLON.Color4(1, 0, 0, 0);\n    const gravityVector = new BABYLON.Vector3(0,-100, 0);\n    const physicsPlugin = new BABYLON.OimoJSPlugin();\n    scene.enablePhysics(gravityVector, physicsPlugin);\n    return scene;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/World/createScene.ts","import * as BABYLON from 'babylonjs';\n\nexport default function createSkyboxMesh(scene:BABYLON.Scene):BABYLON.AbstractMesh{\n    const skyboxMesh = BABYLON.Mesh.CreateBox(\"skyBox\", 1000, scene);\n    const skyboxMaterial = new BABYLON.StandardMaterial(\"skyBox\", scene);\n    skyboxMaterial.backFaceCulling = false;\n    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(process.env.PUBLIC_URL +\"/assets/skyboxes/TropicalSunnyDay/TropicalSunnyDay\", scene, [\"_ft.jpg\", \"_up.jpg\", \"_rt.jpg\", \"_bk.jpg\", \"_dn.jpg\", \"_lf.jpg\"]);\n    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;\n    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);\n    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);\n    skyboxMaterial.disableLighting = true;\n    skyboxMesh.material = skyboxMaterial;\n    return skyboxMesh;\n}\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/World/createSkyboxMesh.ts","import * as BABYLON from 'babylonjs';\nimport MaterialFactory from \"../MaterialFactory\";\nimport WorldGenerator from \"../../generator\";\nimport Player from '../Player';\nimport Brick from '../Brick';\nimport createScene from './createScene';\nimport createLights from './createLights';\nimport createGroundMesh from './createGround';\nimport createSkyboxMesh from './createSkyboxMesh';\n\nexport default class World{\n    public engine:BABYLON.Engine;\n    public scene:BABYLON.Scene;\n    public materialFactory:MaterialFactory;\n    public worldGenerator:WorldGenerator;\n    public lights:BABYLON.Light[];\n    public player:Player;\n    public bricks:Brick[];\n    public groundMesh:BABYLON.AbstractMesh;\n    public skyboxMesh:BABYLON.AbstractMesh;\n\n    constructor(\n        public canvasElement: HTMLCanvasElement,\n    ){\n    }\n\n    run(){\n        this.bricks=[];\n        this.engine = new BABYLON.Engine(this.canvasElement, true);\n\n        this.engine.runRenderLoop(()=>{\n            this.scene.render();\n        });\n\n        window.addEventListener(\"resize\", ()=>{\n            this.engine.resize();\n        });\n\n        this.scene = createScene(this.engine);\n        this.lights = createLights(this.scene);\n        this.materialFactory = new MaterialFactory(this.scene);\n        this.player = new Player(this);\n        this.skyboxMesh = createSkyboxMesh(this.scene);\n        this.groundMesh = createGroundMesh(this.scene,this.materialFactory);\n\n        this.worldGenerator = new WorldGenerator(this);\n        this.worldGenerator.generateWorld();\n    }\n\n    pick(left:number=.5,top:number=.5):BABYLON.PickingInfo {\n        return this.scene.pick(this.canvasElement.width * left, this.canvasElement.height * top, (mesh) => {\n            return mesh !== this.player.mesh && 'physicsImpostor' in mesh;\n        });\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader!./src/world/World/index.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 22\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 23\n// module chunks = 0"],"sourceRoot":""}